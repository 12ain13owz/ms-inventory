import {
  _typeof
} from "./chunk-BP5JJWGC.js";
import {
  ErrorFieldComponent,
  LoadingDataComponent,
  SharedModule,
  SweetAlertComponent,
  ThaiYearPipe,
  ThemeService,
  ValidationService
} from "./chunk-6UWJ54NM.js";
import {
  ActivatedRoute,
  AsyncPipe,
  AuthApiService,
  BehaviorSubject,
  BreakpointObserver,
  Breakpoints,
  ChangeDetectionStrategy,
  Component,
  CoreModule,
  DatePipe,
  DecimalPipe,
  DefaultValueAccessor,
  DomSanitizer,
  EventEmitter,
  FormBuilder,
  FormControl,
  FormControlDirective,
  FormControlName,
  FormGroupDirective,
  FormsModule,
  HttpClient,
  HttpParams,
  Input,
  InputFlags,
  LazyLoadImageDirective,
  LoadingScreenService,
  MAT_DIALOG_DATA,
  MatAccordion,
  MatAnchor,
  MatAutocomplete,
  MatAutocompleteTrigger,
  MatBadge,
  MatButton,
  MatCard,
  MatCardActions,
  MatCardContent,
  MatCardFooter,
  MatCardHeader,
  MatCardTitle,
  MatCell,
  MatCellDef,
  MatCheckbox,
  MatChipListbox,
  MatChipOption,
  MatColumnDef,
  MatDateRangeInput,
  MatDateRangePicker,
  MatDatepicker,
  MatDatepickerInput,
  MatDatepickerToggle,
  MatDialog,
  MatDialogActions,
  MatDialogContent,
  MatDialogRef,
  MatDialogTitle,
  MatDivider,
  MatEndDate,
  MatError,
  MatExpansionPanel,
  MatExpansionPanelHeader,
  MatFabAnchor,
  MatFabButton,
  MatFormField,
  MatHeaderCell,
  MatHeaderCellDef,
  MatHeaderRow,
  MatHeaderRowDef,
  MatHint,
  MatIcon,
  MatIconButton,
  MatInput,
  MatLabel,
  MatList,
  MatListItem,
  MatListItemLine,
  MatListItemTitle,
  MatListSubheaderCssMatStyler,
  MatMenu,
  MatMenuItem,
  MatMenuTrigger,
  MatNavList,
  MatOption,
  MatPaginator,
  MatProgressBar,
  MatRadioButton,
  MatRadioGroup,
  MatRow,
  MatRowDef,
  MatSelect,
  MatSelectTrigger,
  MatSidenav,
  MatSidenavContainer,
  MatSidenavContent,
  MatSlideToggle,
  MatSnackBar,
  MatSort,
  MatSortHeader,
  MatStartDate,
  MatSuffix,
  MatTab,
  MatTabGroup,
  MatTable,
  MatTableDataSource,
  MatToolbar,
  NavigationEnd,
  NgClass,
  NgControlStatus,
  NgControlStatusGroup,
  NgForOf,
  NgForm,
  NgIf,
  NgModel,
  NgModule,
  NgxDropzoneComponent,
  NgxDropzoneImagePreviewComponent,
  NgxDropzoneLabelDirective,
  NgxMaskDirective,
  Output,
  Platform,
  ProfileService,
  Renderer2,
  Router,
  RouterLink,
  RouterLinkActive,
  RouterModule,
  RouterOutlet,
  SelectionModel,
  Subject,
  Subscription,
  ToastNotificationService,
  TokenService,
  Validators,
  ViewChild,
  catchError,
  concatMap,
  debounceTime,
  defer,
  delay,
  distinctUntilChanged,
  environment,
  filter,
  finalize,
  forkJoin,
  from,
  inject,
  interval,
  map,
  merge,
  of,
  setClassMetadata,
  shareReplay,
  startWith,
  switchMap,
  take,
  takeWhile,
  tap,
  throwError,
  timer,
  withLatestFrom,
  ɵNgNoValidate,
  ɵsetClassDebugInfo,
  ɵɵNgOnChangesFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵdefer,
  ɵɵdeferEnableTimerScheduling,
  ɵɵdeferWhen,
  ɵɵdefineComponent,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-5XPFCMCB.js";
import "./chunk-LBFFV6FE.js";
import {
  __async,
  __commonJS,
  __export,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-CPNXOV62.js";

// node_modules/html5-qrcode/third_party/zxing-js.umd.js
var require_zxing_js_umd = __commonJS({
  "node_modules/html5-qrcode/third_party/zxing-js.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.ZXing = {}));
    })(exports, function(exports2) {
      "use strict";
      function isNullOrUndefined2(obj) {
        return obj === null || obj === void 0;
      }
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      function __extends3(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      }
      function fixProto(target, prototype) {
        var setPrototypeOf = Object.setPrototypeOf;
        setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
      }
      function fixStack(target, fn) {
        if (fn === void 0) {
          fn = target.constructor;
        }
        var captureStackTrace = Error.captureStackTrace;
        captureStackTrace && captureStackTrace(target, fn);
      }
      var CustomError = function(_super) {
        __extends3(CustomError2, _super);
        function CustomError2(message) {
          var _newTarget = this.constructor;
          var _this = _super.call(this, message) || this;
          Object.defineProperty(_this, "name", {
            value: _newTarget.name,
            enumerable: false
          });
          fixProto(_this, _newTarget.prototype);
          fixStack(_this);
          return _this;
        }
        return CustomError2;
      }(Error);
      class Exception extends CustomError {
        /**
         * Allows Exception to be constructed directly
         * with some message and prototype definition.
         */
        constructor(message = void 0) {
          super(message);
          this.message = message;
        }
        getKind() {
          const ex = this.constructor;
          return ex.kind;
        }
      }
      Exception.kind = "Exception";
      class ArgumentException extends Exception {
      }
      ArgumentException.kind = "ArgumentException";
      class IllegalArgumentException extends Exception {
      }
      IllegalArgumentException.kind = "IllegalArgumentException";
      class BinaryBitmap2 {
        constructor(binarizer) {
          this.binarizer = binarizer;
          if (binarizer === null) {
            throw new IllegalArgumentException("Binarizer must be non-null.");
          }
        }
        /**
         * @return The width of the bitmap.
         */
        getWidth() {
          return this.binarizer.getWidth();
        }
        /**
         * @return The height of the bitmap.
         */
        getHeight() {
          return this.binarizer.getHeight();
        }
        /**
         * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
         * cached data. Callers should assume this method is expensive and call it as seldom as possible.
         * This method is intended for decoding 1D barcodes and may choose to apply sharpening.
         *
         * @param y The row to fetch, which must be in [0, bitmap height)
         * @param row An optional preallocated array. If null or too small, it will be ignored.
         *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
         * @return The array of bits for this row (true means black).
         * @throws NotFoundException if row can't be binarized
         */
        getBlackRow(y2, row) {
          return this.binarizer.getBlackRow(y2, row);
        }
        /**
         * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
         * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
         * may not apply sharpening. Therefore, a row from this matrix may not be identical to one
         * fetched using getBlackRow(), so don't mix and match between them.
         *
         * @return The 2D array of bits for the image (true means black).
         * @throws NotFoundException if image can't be binarized to make a matrix
         */
        getBlackMatrix() {
          if (this.matrix === null || this.matrix === void 0) {
            this.matrix = this.binarizer.getBlackMatrix();
          }
          return this.matrix;
        }
        /**
         * @return Whether this bitmap can be cropped.
         */
        isCropSupported() {
          return this.binarizer.getLuminanceSource().isCropSupported();
        }
        /**
         * Returns a new object with cropped image data. Implementations may keep a reference to the
         * original data rather than a copy. Only callable if isCropSupported() is true.
         *
         * @param left The left coordinate, which must be in [0,getWidth())
         * @param top The top coordinate, which must be in [0,getHeight())
         * @param width The width of the rectangle to crop.
         * @param height The height of the rectangle to crop.
         * @return A cropped version of this object.
         */
        crop(left, top, width, height) {
          const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
          return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
        }
        /**
         * @return Whether this bitmap supports counter-clockwise rotation.
         */
        isRotateSupported() {
          return this.binarizer.getLuminanceSource().isRotateSupported();
        }
        /**
         * Returns a new object with rotated image data by 90 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise() {
          const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
          return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
        }
        /**
         * Returns a new object with rotated image data by 45 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise45() {
          const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
          return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
        }
        /*@Override*/
        toString() {
          try {
            return this.getBlackMatrix().toString();
          } catch (e) {
            return "";
          }
        }
      }
      class ChecksumException extends Exception {
        static getChecksumInstance() {
          return new ChecksumException();
        }
      }
      ChecksumException.kind = "ChecksumException";
      class Binarizer {
        constructor(source) {
          this.source = source;
        }
        getLuminanceSource() {
          return this.source;
        }
        getWidth() {
          return this.source.getWidth();
        }
        getHeight() {
          return this.source.getHeight();
        }
      }
      class System {
        // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
        /**
         * Makes a copy of a array.
         */
        static arraycopy(src, srcPos, dest, destPos, length2) {
          while (length2--) {
            dest[destPos++] = src[srcPos++];
          }
        }
        /**
         * Returns the current time in milliseconds.
         */
        static currentTimeMillis() {
          return Date.now();
        }
      }
      class IndexOutOfBoundsException extends Exception {
      }
      IndexOutOfBoundsException.kind = "IndexOutOfBoundsException";
      class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {
        constructor(index = void 0, message = void 0) {
          super(message);
          this.index = index;
          this.message = message;
        }
      }
      ArrayIndexOutOfBoundsException.kind = "ArrayIndexOutOfBoundsException";
      class Arrays {
        /**
         * Assigns the specified int value to each element of the specified array
         * of ints.
         *
         * @param a the array to be filled
         * @param val the value to be stored in all elements of the array
         */
        static fill(a2, val) {
          for (let i3 = 0, len = a2.length; i3 < len; i3++)
            a2[i3] = val;
        }
        /**
         * Assigns the specified int value to each element of the specified
         * range of the specified array of ints.  The range to be filled
         * extends from index {@code fromIndex}, inclusive, to index
         * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
         * range to be filled is empty.)
         *
         * @param a the array to be filled
         * @param fromIndex the index of the first element (inclusive) to be
         *        filled with the specified value
         * @param toIndex the index of the last element (exclusive) to be
         *        filled with the specified value
         * @param val the value to be stored in all elements of the array
         * @throws IllegalArgumentException if {@code fromIndex > toIndex}
         * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or
         *         {@code toIndex > a.length}
         */
        static fillWithin(a2, fromIndex, toIndex, val) {
          Arrays.rangeCheck(a2.length, fromIndex, toIndex);
          for (let i3 = fromIndex; i3 < toIndex; i3++)
            a2[i3] = val;
        }
        /**
         * Checks that {@code fromIndex} and {@code toIndex} are in
         * the range and throws an exception if they aren't.
         */
        static rangeCheck(arrayLength, fromIndex, toIndex) {
          if (fromIndex > toIndex) {
            throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
          }
          if (fromIndex < 0) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
          }
          if (toIndex > arrayLength) {
            throw new ArrayIndexOutOfBoundsException(toIndex);
          }
        }
        static asList(...args) {
          return args;
        }
        static create(rows, cols, value2) {
          let arr = Array.from({ length: rows });
          return arr.map((x2) => Array.from({ length: cols }).fill(value2));
        }
        static createInt32Array(rows, cols, value2) {
          let arr = Array.from({ length: rows });
          return arr.map((x2) => Int32Array.from({ length: cols }).fill(value2));
        }
        static equals(first, second) {
          if (!first) {
            return false;
          }
          if (!second) {
            return false;
          }
          if (!first.length) {
            return false;
          }
          if (!second.length) {
            return false;
          }
          if (first.length !== second.length) {
            return false;
          }
          for (let i3 = 0, length2 = first.length; i3 < length2; i3++) {
            if (first[i3] !== second[i3]) {
              return false;
            }
          }
          return true;
        }
        static hashCode(a2) {
          if (a2 === null) {
            return 0;
          }
          let result = 1;
          for (const element of a2) {
            result = 31 * result + element;
          }
          return result;
        }
        static fillUint8Array(a2, value2) {
          for (let i3 = 0; i3 !== a2.length; i3++) {
            a2[i3] = value2;
          }
        }
        static copyOf(original, newLength) {
          return original.slice(0, newLength);
        }
        static copyOfUint8Array(original, newLength) {
          if (original.length <= newLength) {
            const newArray = new Uint8Array(newLength);
            newArray.set(original);
            return newArray;
          }
          return original.slice(0, newLength);
        }
        static copyOfRange(original, from2, to) {
          const newLength = to - from2;
          const copy = new Int32Array(newLength);
          System.arraycopy(original, from2, copy, 0, newLength);
          return copy;
        }
        /*
        * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point
        * for the new element.
        * Parameters:
        *     ar - A sorted array
        *     el - An element to search for
        *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:
        *        a negative number  if a is less than b;
        *        0 if a is equal to b;
        *        a positive number of a is greater than b.
        * The array may contain duplicate elements. If there are more than one equal elements in the array,
        * the returned value can be the index of any one of the equal elements.
        *
        * http://jsfiddle.net/aryzhov/pkfst550/
        */
        static binarySearch(ar, el, comparator) {
          if (void 0 === comparator) {
            comparator = Arrays.numberComparator;
          }
          let m2 = 0;
          let n2 = ar.length - 1;
          while (m2 <= n2) {
            const k2 = n2 + m2 >> 1;
            const cmp = comparator(el, ar[k2]);
            if (cmp > 0) {
              m2 = k2 + 1;
            } else if (cmp < 0) {
              n2 = k2 - 1;
            } else {
              return k2;
            }
          }
          return -m2 - 1;
        }
        static numberComparator(a2, b2) {
          return a2 - b2;
        }
      }
      class Integer {
        static numberOfTrailingZeros(i3) {
          let y2;
          if (i3 === 0)
            return 32;
          let n2 = 31;
          y2 = i3 << 16;
          if (y2 !== 0) {
            n2 -= 16;
            i3 = y2;
          }
          y2 = i3 << 8;
          if (y2 !== 0) {
            n2 -= 8;
            i3 = y2;
          }
          y2 = i3 << 4;
          if (y2 !== 0) {
            n2 -= 4;
            i3 = y2;
          }
          y2 = i3 << 2;
          if (y2 !== 0) {
            n2 -= 2;
            i3 = y2;
          }
          return n2 - (i3 << 1 >>> 31);
        }
        static numberOfLeadingZeros(i3) {
          if (i3 === 0) {
            return 32;
          }
          let n2 = 1;
          if (i3 >>> 16 === 0) {
            n2 += 16;
            i3 <<= 16;
          }
          if (i3 >>> 24 === 0) {
            n2 += 8;
            i3 <<= 8;
          }
          if (i3 >>> 28 === 0) {
            n2 += 4;
            i3 <<= 4;
          }
          if (i3 >>> 30 === 0) {
            n2 += 2;
            i3 <<= 2;
          }
          n2 -= i3 >>> 31;
          return n2;
        }
        static toHexString(i3) {
          return i3.toString(16);
        }
        static toBinaryString(intNumber) {
          return String(parseInt(String(intNumber), 2));
        }
        // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.
        // Returns:
        // the number of one-bits in the two's complement binary representation of the specified int value.
        static bitCount(i3) {
          i3 = i3 - (i3 >>> 1 & 1431655765);
          i3 = (i3 & 858993459) + (i3 >>> 2 & 858993459);
          i3 = i3 + (i3 >>> 4) & 252645135;
          i3 = i3 + (i3 >>> 8);
          i3 = i3 + (i3 >>> 16);
          return i3 & 63;
        }
        static truncDivision(dividend, divisor) {
          return Math.trunc(dividend / divisor);
        }
        /**
         * Converts A string to an integer.
         * @param s A string to convert into a number.
         * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.
         */
        static parseInt(num, radix = void 0) {
          return parseInt(num, radix);
        }
      }
      Integer.MIN_VALUE_32_BITS = -2147483648;
      Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
      class BitArray {
        // For testing only
        constructor(size, bits2) {
          if (void 0 === size) {
            this.size = 0;
            this.bits = new Int32Array(1);
          } else {
            this.size = size;
            if (void 0 === bits2 || null === bits2) {
              this.bits = BitArray.makeArray(size);
            } else {
              this.bits = bits2;
            }
          }
        }
        getSize() {
          return this.size;
        }
        getSizeInBytes() {
          return Math.floor((this.size + 7) / 8);
        }
        ensureCapacity(size) {
          if (size > this.bits.length * 32) {
            const newBits = BitArray.makeArray(size);
            System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
            this.bits = newBits;
          }
        }
        /**
         * @param i bit to get
         * @return true iff bit i is set
         */
        get(i3) {
          return (this.bits[Math.floor(i3 / 32)] & 1 << (i3 & 31)) !== 0;
        }
        /**
         * Sets bit i.
         *
         * @param i bit to set
         */
        set(i3) {
          this.bits[Math.floor(i3 / 32)] |= 1 << (i3 & 31);
        }
        /**
         * Flips bit i.
         *
         * @param i bit to set
         */
        flip(i3) {
          this.bits[Math.floor(i3 / 32)] ^= 1 << (i3 & 31);
        }
        /**
         * @param from first bit to check
         * @return index of first bit that is set, starting from the given index, or size if none are set
         *  at or beyond this given index
         * @see #getNextUnset(int)
         */
        getNextSet(from2) {
          const size = this.size;
          if (from2 >= size) {
            return size;
          }
          const bits2 = this.bits;
          let bitsOffset = Math.floor(from2 / 32);
          let currentBits = bits2[bitsOffset];
          currentBits &= ~((1 << (from2 & 31)) - 1);
          const length2 = bits2.length;
          while (currentBits === 0) {
            if (++bitsOffset === length2) {
              return size;
            }
            currentBits = bits2[bitsOffset];
          }
          const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
          return result > size ? size : result;
        }
        /**
         * @param from index to start looking for unset bit
         * @return index of next unset bit, or {@code size} if none are unset until the end
         * @see #getNextSet(int)
         */
        getNextUnset(from2) {
          const size = this.size;
          if (from2 >= size) {
            return size;
          }
          const bits2 = this.bits;
          let bitsOffset = Math.floor(from2 / 32);
          let currentBits = ~bits2[bitsOffset];
          currentBits &= ~((1 << (from2 & 31)) - 1);
          const length2 = bits2.length;
          while (currentBits === 0) {
            if (++bitsOffset === length2) {
              return size;
            }
            currentBits = ~bits2[bitsOffset];
          }
          const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
          return result > size ? size : result;
        }
        /**
         * Sets a block of 32 bits, starting at bit i.
         *
         * @param i first bit to set
         * @param newBits the new value of the next 32 bits. Note again that the least-significant bit
         * corresponds to bit i, the next-least-significant to i+1, and so on.
         */
        setBulk(i3, newBits) {
          this.bits[Math.floor(i3 / 32)] = newBits;
        }
        /**
         * Sets a range of bits.
         *
         * @param start start of range, inclusive.
         * @param end end of range, exclusive
         */
        setRange(start, end) {
          if (end < start || start < 0 || end > this.size) {
            throw new IllegalArgumentException();
          }
          if (end === start) {
            return;
          }
          end--;
          const firstInt = Math.floor(start / 32);
          const lastInt = Math.floor(end / 32);
          const bits2 = this.bits;
          for (let i3 = firstInt; i3 <= lastInt; i3++) {
            const firstBit = i3 > firstInt ? 0 : start & 31;
            const lastBit = i3 < lastInt ? 31 : end & 31;
            const mask = (2 << lastBit) - (1 << firstBit);
            bits2[i3] |= mask;
          }
        }
        /**
         * Clears all bits (sets to false).
         */
        clear() {
          const max2 = this.bits.length;
          const bits2 = this.bits;
          for (let i3 = 0; i3 < max2; i3++) {
            bits2[i3] = 0;
          }
        }
        /**
         * Efficient method to check if a range of bits is set, or not set.
         *
         * @param start start of range, inclusive.
         * @param end end of range, exclusive
         * @param value if true, checks that bits in range are set, otherwise checks that they are not set
         * 
         * @return true iff all bits are set or not set in range, according to value argument
         * @throws IllegalArgumentException if end is less than start or the range is not contained in the array
         */
        isRange(start, end, value2) {
          if (end < start || start < 0 || end > this.size) {
            throw new IllegalArgumentException();
          }
          if (end === start) {
            return true;
          }
          end--;
          const firstInt = Math.floor(start / 32);
          const lastInt = Math.floor(end / 32);
          const bits2 = this.bits;
          for (let i3 = firstInt; i3 <= lastInt; i3++) {
            const firstBit = i3 > firstInt ? 0 : start & 31;
            const lastBit = i3 < lastInt ? 31 : end & 31;
            const mask = (2 << lastBit) - (1 << firstBit) & 4294967295;
            if ((bits2[i3] & mask) !== (value2 ? mask : 0)) {
              return false;
            }
          }
          return true;
        }
        appendBit(bit) {
          this.ensureCapacity(this.size + 1);
          if (bit) {
            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
          }
          this.size++;
        }
        /**
         * Appends the least-significant bits, from value, in order from most-significant to
         * least-significant. For example, appending 6 bits from 0x000001E will append the bits
         * 0, 1, 1, 1, 1, 0 in that order.
         *
         * @param value {@code int} containing bits to append
         * @param numBits bits from value to append
         */
        appendBits(value2, numBits) {
          if (numBits < 0 || numBits > 32) {
            throw new IllegalArgumentException("Num bits must be between 0 and 32");
          }
          this.ensureCapacity(this.size + numBits);
          for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
            this.appendBit((value2 >> numBitsLeft - 1 & 1) === 1);
          }
        }
        appendBitArray(other) {
          const otherSize = other.size;
          this.ensureCapacity(this.size + otherSize);
          for (let i3 = 0; i3 < otherSize; i3++) {
            this.appendBit(other.get(i3));
          }
        }
        xor(other) {
          if (this.size !== other.size) {
            throw new IllegalArgumentException("Sizes don't match");
          }
          const bits2 = this.bits;
          for (let i3 = 0, length2 = bits2.length; i3 < length2; i3++) {
            bits2[i3] ^= other.bits[i3];
          }
        }
        /**
         *
         * @param bitOffset first bit to start writing
         * @param array array to write into. Bytes are written most-significant byte first. This is the opposite
         *  of the internal representation, which is exposed by {@link #getBitArray()}
         * @param offset position in array to start writing
         * @param numBytes how many bytes to write
         */
        toBytes(bitOffset, array, offset, numBytes) {
          for (let i3 = 0; i3 < numBytes; i3++) {
            let theByte = 0;
            for (let j2 = 0; j2 < 8; j2++) {
              if (this.get(bitOffset)) {
                theByte |= 1 << 7 - j2;
              }
              bitOffset++;
            }
            array[offset + i3] = /*(byte)*/
            theByte;
          }
        }
        /**
         * @return underlying array of ints. The first element holds the first 32 bits, and the least
         *         significant bit is bit 0.
         */
        getBitArray() {
          return this.bits;
        }
        /**
         * Reverses all bits in the array.
         */
        reverse() {
          const newBits = new Int32Array(this.bits.length);
          const len = Math.floor((this.size - 1) / 32);
          const oldBitsLen = len + 1;
          const bits2 = this.bits;
          for (let i3 = 0; i3 < oldBitsLen; i3++) {
            let x2 = bits2[i3];
            x2 = x2 >> 1 & 1431655765 | (x2 & 1431655765) << 1;
            x2 = x2 >> 2 & 858993459 | (x2 & 858993459) << 2;
            x2 = x2 >> 4 & 252645135 | (x2 & 252645135) << 4;
            x2 = x2 >> 8 & 16711935 | (x2 & 16711935) << 8;
            x2 = x2 >> 16 & 65535 | (x2 & 65535) << 16;
            newBits[len - i3] = /*(int)*/
            x2;
          }
          if (this.size !== oldBitsLen * 32) {
            const leftOffset = oldBitsLen * 32 - this.size;
            let currentInt = newBits[0] >>> leftOffset;
            for (let i3 = 1; i3 < oldBitsLen; i3++) {
              const nextInt = newBits[i3];
              currentInt |= nextInt << 32 - leftOffset;
              newBits[i3 - 1] = currentInt;
              currentInt = nextInt >>> leftOffset;
            }
            newBits[oldBitsLen - 1] = currentInt;
          }
          this.bits = newBits;
        }
        static makeArray(size) {
          return new Int32Array(Math.floor((size + 31) / 32));
        }
        /*@Override*/
        equals(o2) {
          if (!(o2 instanceof BitArray)) {
            return false;
          }
          const other = o2;
          return this.size === other.size && Arrays.equals(this.bits, other.bits);
        }
        /*@Override*/
        hashCode() {
          return 31 * this.size + Arrays.hashCode(this.bits);
        }
        /*@Override*/
        toString() {
          let result = "";
          for (let i3 = 0, size = this.size; i3 < size; i3++) {
            if ((i3 & 7) === 0) {
              result += " ";
            }
            result += this.get(i3) ? "X" : ".";
          }
          return result;
        }
        /*@Override*/
        clone() {
          return new BitArray(this.size, this.bits.slice());
        }
      }
      var DecodeHintType2;
      (function(DecodeHintType3) {
        DecodeHintType3[DecodeHintType3["OTHER"] = 0] = "OTHER";
        DecodeHintType3[DecodeHintType3["PURE_BARCODE"] = 1] = "PURE_BARCODE";
        DecodeHintType3[DecodeHintType3["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
        DecodeHintType3[DecodeHintType3["TRY_HARDER"] = 3] = "TRY_HARDER";
        DecodeHintType3[DecodeHintType3["CHARACTER_SET"] = 4] = "CHARACTER_SET";
        DecodeHintType3[DecodeHintType3["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
        DecodeHintType3[DecodeHintType3["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
        DecodeHintType3[DecodeHintType3["ASSUME_GS1"] = 7] = "ASSUME_GS1";
        DecodeHintType3[DecodeHintType3["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END";
        DecodeHintType3[DecodeHintType3["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK";
        DecodeHintType3[DecodeHintType3["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS";
      })(DecodeHintType2 || (DecodeHintType2 = {}));
      var DecodeHintType$1 = DecodeHintType2;
      class FormatException extends Exception {
        static getFormatInstance() {
          return new FormatException();
        }
      }
      FormatException.kind = "FormatException";
      var CharacterSetValueIdentifiers;
      (function(CharacterSetValueIdentifiers2) {
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
        CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
      })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
      class CharacterSetECI {
        constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {
          this.valueIdentifier = valueIdentifier;
          this.name = name;
          if (typeof valuesParam === "number") {
            this.values = Int32Array.from([valuesParam]);
          } else {
            this.values = valuesParam;
          }
          this.otherEncodingNames = otherEncodingNames;
          CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
          CharacterSetECI.NAME_TO_ECI.set(name, this);
          const values = this.values;
          for (let i3 = 0, length2 = values.length; i3 !== length2; i3++) {
            const v2 = values[i3];
            CharacterSetECI.VALUES_TO_ECI.set(v2, this);
          }
          for (const otherName of otherEncodingNames) {
            CharacterSetECI.NAME_TO_ECI.set(otherName, this);
          }
        }
        // CharacterSetECI(value: number /*int*/) {
        //   this(new Int32Array {value})
        // }
        // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {
        //   this.values = new Int32Array {value}
        //   this.otherEncodingNames = otherEncodingNames
        // }
        // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {
        //   this.values = values
        //   this.otherEncodingNames = otherEncodingNames
        // }
        getValueIdentifier() {
          return this.valueIdentifier;
        }
        getName() {
          return this.name;
        }
        getValue() {
          return this.values[0];
        }
        /**
         * @param value character set ECI value
         * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but
         *   unsupported
         * @throws FormatException if ECI value is invalid
         */
        static getCharacterSetECIByValue(value2) {
          if (value2 < 0 || value2 >= 900) {
            throw new FormatException("incorect value");
          }
          const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value2);
          if (void 0 === characterSet) {
            throw new FormatException("incorect value");
          }
          return characterSet;
        }
        /**
         * @param name character set ECI encoding name
         * @return CharacterSetECI representing ECI for character encoding, or null if it is legal
         *   but unsupported
         */
        static getCharacterSetECIByName(name) {
          const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
          if (void 0 === characterSet) {
            throw new FormatException("incorect value");
          }
          return characterSet;
        }
        equals(o2) {
          if (!(o2 instanceof CharacterSetECI)) {
            return false;
          }
          const other = o2;
          return this.getName() === other.getName();
        }
      }
      CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map();
      CharacterSetECI.VALUES_TO_ECI = /* @__PURE__ */ new Map();
      CharacterSetECI.NAME_TO_ECI = /* @__PURE__ */ new Map();
      CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
      CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
      CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
      CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
      CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
      CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
      CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
      CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
      CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
      CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
      CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
      CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
      CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
      CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
      CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
      CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
      CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
      CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
      CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
      CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
      CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
      CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
      CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
      CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
      CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, "Big5");
      CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
      CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
      class UnsupportedOperationException extends Exception {
      }
      UnsupportedOperationException.kind = "UnsupportedOperationException";
      class StringEncoding {
        /**
         * Decodes some Uint8Array to a string format.
         */
        static decode(bytes, encoding) {
          const encodingName = this.encodingName(encoding);
          if (this.customDecoder) {
            return this.customDecoder(bytes, encodingName);
          }
          if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
            return this.decodeFallback(bytes, encodingName);
          }
          return new TextDecoder(encodingName).decode(bytes);
        }
        /**
         * Checks if the decoding method should use the fallback for decoding
         * once Node TextDecoder doesn't support all encoding formats.
         *
         * @param encodingName
         */
        static shouldDecodeOnFallback(encodingName) {
          return !StringEncoding.isBrowser() && encodingName === "ISO-8859-1";
        }
        /**
         * Encodes some string into a Uint8Array.
         */
        static encode(s2, encoding) {
          const encodingName = this.encodingName(encoding);
          if (this.customEncoder) {
            return this.customEncoder(s2, encodingName);
          }
          if (typeof TextEncoder === "undefined") {
            return this.encodeFallback(s2);
          }
          return new TextEncoder().encode(s2);
        }
        static isBrowser() {
          return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
        }
        /**
         * Returns the string value from some encoding character set.
         */
        static encodingName(encoding) {
          return typeof encoding === "string" ? encoding : encoding.getName();
        }
        /**
         * Returns character set from some encoding character set.
         */
        static encodingCharacterSet(encoding) {
          if (encoding instanceof CharacterSetECI) {
            return encoding;
          }
          return CharacterSetECI.getCharacterSetECIByName(encoding);
        }
        /**
         * Runs a fallback for the native decoding funcion.
         */
        static decodeFallback(bytes, encoding) {
          const characterSet = this.encodingCharacterSet(encoding);
          if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
            let s2 = "";
            for (let i3 = 0, length2 = bytes.length; i3 < length2; i3++) {
              let h2 = bytes[i3].toString(16);
              if (h2.length < 2) {
                h2 = "0" + h2;
              }
              s2 += "%" + h2;
            }
            return decodeURIComponent(s2);
          }
          if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {
            return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
          }
          throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);
        }
        static isDecodeFallbackSupported(characterSet) {
          return characterSet.equals(CharacterSetECI.UTF8) || characterSet.equals(CharacterSetECI.ISO8859_1) || characterSet.equals(CharacterSetECI.ASCII);
        }
        /**
         * Runs a fallback for the native encoding funcion.
         *
         * @see https://stackoverflow.com/a/17192845/4367683
         */
        static encodeFallback(s2) {
          const encodedURIstring = btoa(unescape(encodeURIComponent(s2)));
          const charList = encodedURIstring.split("");
          const uintArray = [];
          for (let i3 = 0; i3 < charList.length; i3++) {
            uintArray.push(charList[i3].charCodeAt(0));
          }
          return new Uint8Array(uintArray);
        }
      }
      class StringUtils {
        // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
        // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
        static castAsNonUtf8Char(code, encoding = null) {
          const e = encoding ? encoding.getName() : this.ISO88591;
          return StringEncoding.decode(new Uint8Array([code]), e);
        }
        /**
         * @param bytes bytes encoding a string, whose encoding should be guessed
         * @param hints decode hints if applicable
         * @return name of guessed encoding; at the moment will only guess one of:
         *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
         *  default encoding if none of these can possibly be correct
         */
        static guessEncoding(bytes, hints) {
          if (hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.CHARACTER_SET)) {
            return hints.get(DecodeHintType$1.CHARACTER_SET).toString();
          }
          const length2 = bytes.length;
          let canBeISO88591 = true;
          let canBeShiftJIS = true;
          let canBeUTF8 = true;
          let utf8BytesLeft = 0;
          let utf2BytesChars = 0;
          let utf3BytesChars = 0;
          let utf4BytesChars = 0;
          let sjisBytesLeft = 0;
          let sjisKatakanaChars = 0;
          let sjisCurKatakanaWordLength = 0;
          let sjisCurDoubleBytesWordLength = 0;
          let sjisMaxKatakanaWordLength = 0;
          let sjisMaxDoubleBytesWordLength = 0;
          let isoHighOther = 0;
          const utf8bom = bytes.length > 3 && bytes[0] === /*(byte) */
          239 && bytes[1] === /*(byte) */
          187 && bytes[2] === /*(byte) */
          191;
          for (let i3 = 0; i3 < length2 && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i3++) {
            const value2 = bytes[i3] & 255;
            if (canBeUTF8) {
              if (utf8BytesLeft > 0) {
                if ((value2 & 128) === 0) {
                  canBeUTF8 = false;
                } else {
                  utf8BytesLeft--;
                }
              } else if ((value2 & 128) !== 0) {
                if ((value2 & 64) === 0) {
                  canBeUTF8 = false;
                } else {
                  utf8BytesLeft++;
                  if ((value2 & 32) === 0) {
                    utf2BytesChars++;
                  } else {
                    utf8BytesLeft++;
                    if ((value2 & 16) === 0) {
                      utf3BytesChars++;
                    } else {
                      utf8BytesLeft++;
                      if ((value2 & 8) === 0) {
                        utf4BytesChars++;
                      } else {
                        canBeUTF8 = false;
                      }
                    }
                  }
                }
              }
            }
            if (canBeISO88591) {
              if (value2 > 127 && value2 < 160) {
                canBeISO88591 = false;
              } else if (value2 > 159) {
                if (value2 < 192 || value2 === 215 || value2 === 247) {
                  isoHighOther++;
                }
              }
            }
            if (canBeShiftJIS) {
              if (sjisBytesLeft > 0) {
                if (value2 < 64 || value2 === 127 || value2 > 252) {
                  canBeShiftJIS = false;
                } else {
                  sjisBytesLeft--;
                }
              } else if (value2 === 128 || value2 === 160 || value2 > 239) {
                canBeShiftJIS = false;
              } else if (value2 > 160 && value2 < 224) {
                sjisKatakanaChars++;
                sjisCurDoubleBytesWordLength = 0;
                sjisCurKatakanaWordLength++;
                if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                  sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
                }
              } else if (value2 > 127) {
                sjisBytesLeft++;
                sjisCurKatakanaWordLength = 0;
                sjisCurDoubleBytesWordLength++;
                if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                  sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
                }
              } else {
                sjisCurKatakanaWordLength = 0;
                sjisCurDoubleBytesWordLength = 0;
              }
            }
          }
          if (canBeUTF8 && utf8BytesLeft > 0) {
            canBeUTF8 = false;
          }
          if (canBeShiftJIS && sjisBytesLeft > 0) {
            canBeShiftJIS = false;
          }
          if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
            return StringUtils.UTF8;
          }
          if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
            return StringUtils.SHIFT_JIS;
          }
          if (canBeISO88591 && canBeShiftJIS) {
            return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length2 ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
          }
          if (canBeISO88591) {
            return StringUtils.ISO88591;
          }
          if (canBeShiftJIS) {
            return StringUtils.SHIFT_JIS;
          }
          if (canBeUTF8) {
            return StringUtils.UTF8;
          }
          return StringUtils.PLATFORM_DEFAULT_ENCODING;
        }
        /**
         *
         * @see https://stackoverflow.com/a/13439711/4367683
         *
         * @param append The new string to append.
         * @param args Argumets values to be formated.
         */
        static format(append, ...args) {
          let i3 = -1;
          function callback(exp, p0, p1, p2, p3, p4) {
            if (exp === "%%")
              return "%";
            if (args[++i3] === void 0)
              return void 0;
            exp = p2 ? parseInt(p2.substr(1)) : void 0;
            let base = p3 ? parseInt(p3.substr(1)) : void 0;
            let val;
            switch (p4) {
              case "s":
                val = args[i3];
                break;
              case "c":
                val = args[i3][0];
                break;
              case "f":
                val = parseFloat(args[i3]).toFixed(exp);
                break;
              case "p":
                val = parseFloat(args[i3]).toPrecision(exp);
                break;
              case "e":
                val = parseFloat(args[i3]).toExponential(exp);
                break;
              case "x":
                val = parseInt(args[i3]).toString(base ? base : 16);
                break;
              case "d":
                val = parseFloat(parseInt(args[i3], base ? base : 10).toPrecision(exp)).toFixed(0);
                break;
            }
            val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
            let size = parseInt(p1);
            let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
            while (val.length < size)
              val = p0 !== void 0 ? val + ch : ch + val;
            return val;
          }
          let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
          return append.replace(regex, callback);
        }
        /**
         *
         */
        static getBytes(str, encoding) {
          return StringEncoding.encode(str, encoding);
        }
        /**
         * Returns the charcode at the specified index or at index zero.
         */
        static getCharCode(str, index = 0) {
          return str.charCodeAt(index);
        }
        /**
         * Returns char for given charcode
         */
        static getCharAt(charCode) {
          return String.fromCharCode(charCode);
        }
      }
      StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName();
      StringUtils.GB2312 = "GB2312";
      StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName();
      StringUtils.EUC_JP = "EUC_JP";
      StringUtils.UTF8 = CharacterSetECI.UTF8.getName();
      StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8;
      StringUtils.ASSUME_SHIFT_JIS = false;
      class StringBuilder {
        constructor(value2 = "") {
          this.value = value2;
        }
        enableDecoding(encoding) {
          this.encoding = encoding;
          return this;
        }
        append(s2) {
          if (typeof s2 === "string") {
            this.value += s2.toString();
          } else if (this.encoding) {
            this.value += StringUtils.castAsNonUtf8Char(s2, this.encoding);
          } else {
            this.value += String.fromCharCode(s2);
          }
          return this;
        }
        appendChars(str, offset, len) {
          for (let i3 = offset; offset < offset + len; i3++) {
            this.append(str[i3]);
          }
          return this;
        }
        length() {
          return this.value.length;
        }
        charAt(n2) {
          return this.value.charAt(n2);
        }
        deleteCharAt(n2) {
          this.value = this.value.substr(0, n2) + this.value.substring(n2 + 1);
        }
        setCharAt(n2, c2) {
          this.value = this.value.substr(0, n2) + c2 + this.value.substr(n2 + 1);
        }
        substring(start, end) {
          return this.value.substring(start, end);
        }
        /**
         * @note helper method for RSS Expanded
         */
        setLengthToZero() {
          this.value = "";
        }
        toString() {
          return this.value;
        }
        insert(n2, c2) {
          this.value = this.value.substr(0, n2) + c2 + this.value.substr(n2 + c2.length);
        }
      }
      class BitMatrix {
        /**
         * Creates an empty square {@link BitMatrix}.
         *
         * @param dimension height and width
         */
        // public constructor(dimension: number /*int*/) {
        //   this(dimension, dimension)
        // }
        /**
         * Creates an empty {@link BitMatrix}.
         *
         * @param width bit matrix width
         * @param height bit matrix height
         */
        // public constructor(width: number /*int*/, height: number /*int*/) {
        //   if (width < 1 || height < 1) {
        //     throw new IllegalArgumentException("Both dimensions must be greater than 0")
        //   }
        //   this.width = width
        //   this.height = height
        //   this.rowSize = (width + 31) / 32
        //   bits = new int[rowSize * height];
        // }
        constructor(width, height, rowSize, bits2) {
          this.width = width;
          this.height = height;
          this.rowSize = rowSize;
          this.bits = bits2;
          if (void 0 === height || null === height) {
            height = width;
          }
          this.height = height;
          if (width < 1 || height < 1) {
            throw new IllegalArgumentException("Both dimensions must be greater than 0");
          }
          if (void 0 === rowSize || null === rowSize) {
            rowSize = Math.floor((width + 31) / 32);
          }
          this.rowSize = rowSize;
          if (void 0 === bits2 || null === bits2) {
            this.bits = new Int32Array(this.rowSize * this.height);
          }
        }
        /**
         * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.
         *
         * @function parse
         * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
         * @return {@link BitMatrix} representation of image
         */
        static parseFromBooleanArray(image) {
          const height = image.length;
          const width = image[0].length;
          const bits2 = new BitMatrix(width, height);
          for (let i3 = 0; i3 < height; i3++) {
            const imageI = image[i3];
            for (let j2 = 0; j2 < width; j2++) {
              if (imageI[j2]) {
                bits2.set(j2, i3);
              }
            }
          }
          return bits2;
        }
        /**
         *
         * @function parse
         * @param stringRepresentation
         * @param setString
         * @param unsetString
         */
        static parseFromString(stringRepresentation, setString, unsetString) {
          if (stringRepresentation === null) {
            throw new IllegalArgumentException("stringRepresentation cannot be null");
          }
          const bits2 = new Array(stringRepresentation.length);
          let bitsPos = 0;
          let rowStartPos = 0;
          let rowLength = -1;
          let nRows = 0;
          let pos = 0;
          while (pos < stringRepresentation.length) {
            if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
              if (bitsPos > rowStartPos) {
                if (rowLength === -1) {
                  rowLength = bitsPos - rowStartPos;
                } else if (bitsPos - rowStartPos !== rowLength) {
                  throw new IllegalArgumentException("row lengths do not match");
                }
                rowStartPos = bitsPos;
                nRows++;
              }
              pos++;
            } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
              pos += setString.length;
              bits2[bitsPos] = true;
              bitsPos++;
            } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
              pos += unsetString.length;
              bits2[bitsPos] = false;
              bitsPos++;
            } else {
              throw new IllegalArgumentException("illegal character encountered: " + stringRepresentation.substring(pos));
            }
          }
          if (bitsPos > rowStartPos) {
            if (rowLength === -1) {
              rowLength = bitsPos - rowStartPos;
            } else if (bitsPos - rowStartPos !== rowLength) {
              throw new IllegalArgumentException("row lengths do not match");
            }
            nRows++;
          }
          const matrix = new BitMatrix(rowLength, nRows);
          for (let i3 = 0; i3 < bitsPos; i3++) {
            if (bits2[i3]) {
              matrix.set(Math.floor(i3 % rowLength), Math.floor(i3 / rowLength));
            }
          }
          return matrix;
        }
        /**
         * <p>Gets the requested bit, where true means black.</p>
         *
         * @param x The horizontal component (i.e. which column)
         * @param y The vertical component (i.e. which row)
         * @return value of given bit in matrix
         */
        get(x2, y2) {
          const offset = y2 * this.rowSize + Math.floor(x2 / 32);
          return (this.bits[offset] >>> (x2 & 31) & 1) !== 0;
        }
        /**
         * <p>Sets the given bit to true.</p>
         *
         * @param x The horizontal component (i.e. which column)
         * @param y The vertical component (i.e. which row)
         */
        set(x2, y2) {
          const offset = y2 * this.rowSize + Math.floor(x2 / 32);
          this.bits[offset] |= 1 << (x2 & 31) & 4294967295;
        }
        unset(x2, y2) {
          const offset = y2 * this.rowSize + Math.floor(x2 / 32);
          this.bits[offset] &= ~(1 << (x2 & 31) & 4294967295);
        }
        /**
         * <p>Flips the given bit.</p>
         *
         * @param x The horizontal component (i.e. which column)
         * @param y The vertical component (i.e. which row)
         */
        flip(x2, y2) {
          const offset = y2 * this.rowSize + Math.floor(x2 / 32);
          this.bits[offset] ^= 1 << (x2 & 31) & 4294967295;
        }
        /**
         * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
         * mask bit is set.
         *
         * @param mask XOR mask
         */
        xor(mask) {
          if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {
            throw new IllegalArgumentException("input matrix dimensions do not match");
          }
          const rowArray = new BitArray(Math.floor(this.width / 32) + 1);
          const rowSize = this.rowSize;
          const bits2 = this.bits;
          for (let y2 = 0, height = this.height; y2 < height; y2++) {
            const offset = y2 * rowSize;
            const row = mask.getRow(y2, rowArray).getBitArray();
            for (let x2 = 0; x2 < rowSize; x2++) {
              bits2[offset + x2] ^= row[x2];
            }
          }
        }
        /**
         * Clears all bits (sets to false).
         */
        clear() {
          const bits2 = this.bits;
          const max2 = bits2.length;
          for (let i3 = 0; i3 < max2; i3++) {
            bits2[i3] = 0;
          }
        }
        /**
         * <p>Sets a square region of the bit matrix to true.</p>
         *
         * @param left The horizontal position to begin at (inclusive)
         * @param top The vertical position to begin at (inclusive)
         * @param width The width of the region
         * @param height The height of the region
         */
        setRegion(left, top, width, height) {
          if (top < 0 || left < 0) {
            throw new IllegalArgumentException("Left and top must be nonnegative");
          }
          if (height < 1 || width < 1) {
            throw new IllegalArgumentException("Height and width must be at least 1");
          }
          const right = left + width;
          const bottom = top + height;
          if (bottom > this.height || right > this.width) {
            throw new IllegalArgumentException("The region must fit inside the matrix");
          }
          const rowSize = this.rowSize;
          const bits2 = this.bits;
          for (let y2 = top; y2 < bottom; y2++) {
            const offset = y2 * rowSize;
            for (let x2 = left; x2 < right; x2++) {
              bits2[offset + Math.floor(x2 / 32)] |= 1 << (x2 & 31) & 4294967295;
            }
          }
        }
        /**
         * A fast method to retrieve one row of data from the matrix as a BitArray.
         *
         * @param y The row to retrieve
         * @param row An optional caller-allocated BitArray, will be allocated if null or too small
         * @return The resulting BitArray - this reference should always be used even when passing
         *         your own row
         */
        getRow(y2, row) {
          if (row === null || row === void 0 || row.getSize() < this.width) {
            row = new BitArray(this.width);
          } else {
            row.clear();
          }
          const rowSize = this.rowSize;
          const bits2 = this.bits;
          const offset = y2 * rowSize;
          for (let x2 = 0; x2 < rowSize; x2++) {
            row.setBulk(x2 * 32, bits2[offset + x2]);
          }
          return row;
        }
        /**
         * @param y row to set
         * @param row {@link BitArray} to copy from
         */
        setRow(y2, row) {
          System.arraycopy(row.getBitArray(), 0, this.bits, y2 * this.rowSize, this.rowSize);
        }
        /**
         * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
         */
        rotate180() {
          const width = this.getWidth();
          const height = this.getHeight();
          let topRow = new BitArray(width);
          let bottomRow = new BitArray(width);
          for (let i3 = 0, length2 = Math.floor((height + 1) / 2); i3 < length2; i3++) {
            topRow = this.getRow(i3, topRow);
            bottomRow = this.getRow(height - 1 - i3, bottomRow);
            topRow.reverse();
            bottomRow.reverse();
            this.setRow(i3, bottomRow);
            this.setRow(height - 1 - i3, topRow);
          }
        }
        /**
         * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
         *
         * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
         */
        getEnclosingRectangle() {
          const width = this.width;
          const height = this.height;
          const rowSize = this.rowSize;
          const bits2 = this.bits;
          let left = width;
          let top = height;
          let right = -1;
          let bottom = -1;
          for (let y2 = 0; y2 < height; y2++) {
            for (let x32 = 0; x32 < rowSize; x32++) {
              const theBits = bits2[y2 * rowSize + x32];
              if (theBits !== 0) {
                if (y2 < top) {
                  top = y2;
                }
                if (y2 > bottom) {
                  bottom = y2;
                }
                if (x32 * 32 < left) {
                  let bit = 0;
                  while ((theBits << 31 - bit & 4294967295) === 0) {
                    bit++;
                  }
                  if (x32 * 32 + bit < left) {
                    left = x32 * 32 + bit;
                  }
                }
                if (x32 * 32 + 31 > right) {
                  let bit = 31;
                  while (theBits >>> bit === 0) {
                    bit--;
                  }
                  if (x32 * 32 + bit > right) {
                    right = x32 * 32 + bit;
                  }
                }
              }
            }
          }
          if (right < left || bottom < top) {
            return null;
          }
          return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
        }
        /**
         * This is useful in detecting a corner of a 'pure' barcode.
         *
         * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
         */
        getTopLeftOnBit() {
          const rowSize = this.rowSize;
          const bits2 = this.bits;
          let bitsOffset = 0;
          while (bitsOffset < bits2.length && bits2[bitsOffset] === 0) {
            bitsOffset++;
          }
          if (bitsOffset === bits2.length) {
            return null;
          }
          const y2 = bitsOffset / rowSize;
          let x2 = bitsOffset % rowSize * 32;
          const theBits = bits2[bitsOffset];
          let bit = 0;
          while ((theBits << 31 - bit & 4294967295) === 0) {
            bit++;
          }
          x2 += bit;
          return Int32Array.from([x2, y2]);
        }
        getBottomRightOnBit() {
          const rowSize = this.rowSize;
          const bits2 = this.bits;
          let bitsOffset = bits2.length - 1;
          while (bitsOffset >= 0 && bits2[bitsOffset] === 0) {
            bitsOffset--;
          }
          if (bitsOffset < 0) {
            return null;
          }
          const y2 = Math.floor(bitsOffset / rowSize);
          let x2 = Math.floor(bitsOffset % rowSize) * 32;
          const theBits = bits2[bitsOffset];
          let bit = 31;
          while (theBits >>> bit === 0) {
            bit--;
          }
          x2 += bit;
          return Int32Array.from([x2, y2]);
        }
        /**
         * @return The width of the matrix
         */
        getWidth() {
          return this.width;
        }
        /**
         * @return The height of the matrix
         */
        getHeight() {
          return this.height;
        }
        /**
         * @return The row size of the matrix
         */
        getRowSize() {
          return this.rowSize;
        }
        /*@Override*/
        equals(o2) {
          if (!(o2 instanceof BitMatrix)) {
            return false;
          }
          const other = o2;
          return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays.equals(this.bits, other.bits);
        }
        /*@Override*/
        hashCode() {
          let hash = this.width;
          hash = 31 * hash + this.width;
          hash = 31 * hash + this.height;
          hash = 31 * hash + this.rowSize;
          hash = 31 * hash + Arrays.hashCode(this.bits);
          return hash;
        }
        /**
         * @return string representation using "X" for set and " " for unset bits
         */
        /*@Override*/
        // public toString(): string {
        //   return toString(": "X, "  ")
        // }
        /**
         * @param setString representation of a set bit
         * @param unsetString representation of an unset bit
         * @return string representation of entire matrix utilizing given strings
         */
        // public toString(setString: string = "X ", unsetString: string = "  "): string {
        //   return this.buildToString(setString, unsetString, "\n")
        // }
        /**
         * @param setString representation of a set bit
         * @param unsetString representation of an unset bit
         * @param lineSeparator newline character in string representation
         * @return string representation of entire matrix utilizing given strings and line separator
         * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always
         */
        // @Deprecated
        toString(setString = "X ", unsetString = "  ", lineSeparator = "\n") {
          return this.buildToString(setString, unsetString, lineSeparator);
        }
        buildToString(setString, unsetString, lineSeparator) {
          let result = new StringBuilder();
          for (let y2 = 0, height = this.height; y2 < height; y2++) {
            for (let x2 = 0, width = this.width; x2 < width; x2++) {
              result.append(this.get(x2, y2) ? setString : unsetString);
            }
            result.append(lineSeparator);
          }
          return result.toString();
        }
        /*@Override*/
        clone() {
          return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
        }
      }
      class NotFoundException extends Exception {
        static getNotFoundInstance() {
          return new NotFoundException();
        }
      }
      NotFoundException.kind = "NotFoundException";
      class GlobalHistogramBinarizer extends Binarizer {
        constructor(source) {
          super(source);
          this.luminances = GlobalHistogramBinarizer.EMPTY;
          this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
        }
        // Applies simple sharpening to the row data to improve performance of the 1D Readers.
        /*@Override*/
        getBlackRow(y2, row) {
          const source = this.getLuminanceSource();
          const width = source.getWidth();
          if (row === void 0 || row === null || row.getSize() < width) {
            row = new BitArray(width);
          } else {
            row.clear();
          }
          this.initArrays(width);
          const localLuminances = source.getRow(y2, this.luminances);
          const localBuckets = this.buckets;
          for (let x2 = 0; x2 < width; x2++) {
            localBuckets[(localLuminances[x2] & 255) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
          }
          const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
          if (width < 3) {
            for (let x2 = 0; x2 < width; x2++) {
              if ((localLuminances[x2] & 255) < blackPoint) {
                row.set(x2);
              }
            }
          } else {
            let left = localLuminances[0] & 255;
            let center = localLuminances[1] & 255;
            for (let x2 = 1; x2 < width - 1; x2++) {
              const right = localLuminances[x2 + 1] & 255;
              if ((center * 4 - left - right) / 2 < blackPoint) {
                row.set(x2);
              }
              left = center;
              center = right;
            }
          }
          return row;
        }
        // Does not sharpen the data, as this call is intended to only be used by 2D Readers.
        /*@Override*/
        getBlackMatrix() {
          const source = this.getLuminanceSource();
          const width = source.getWidth();
          const height = source.getHeight();
          const matrix = new BitMatrix(width, height);
          this.initArrays(width);
          const localBuckets = this.buckets;
          for (let y2 = 1; y2 < 5; y2++) {
            const row = Math.floor(height * y2 / 5);
            const localLuminances2 = source.getRow(row, this.luminances);
            const right = Math.floor(width * 4 / 5);
            for (let x2 = Math.floor(width / 5); x2 < right; x2++) {
              const pixel = localLuminances2[x2] & 255;
              localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
            }
          }
          const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
          const localLuminances = source.getMatrix();
          for (let y2 = 0; y2 < height; y2++) {
            const offset = y2 * width;
            for (let x2 = 0; x2 < width; x2++) {
              const pixel = localLuminances[offset + x2] & 255;
              if (pixel < blackPoint) {
                matrix.set(x2, y2);
              }
            }
          }
          return matrix;
        }
        /*@Override*/
        createBinarizer(source) {
          return new GlobalHistogramBinarizer(source);
        }
        initArrays(luminanceSize) {
          if (this.luminances.length < luminanceSize) {
            this.luminances = new Uint8ClampedArray(luminanceSize);
          }
          const buckets = this.buckets;
          for (let x2 = 0; x2 < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x2++) {
            buckets[x2] = 0;
          }
        }
        static estimateBlackPoint(buckets) {
          const numBuckets = buckets.length;
          let maxBucketCount = 0;
          let firstPeak = 0;
          let firstPeakSize = 0;
          for (let x2 = 0; x2 < numBuckets; x2++) {
            if (buckets[x2] > firstPeakSize) {
              firstPeak = x2;
              firstPeakSize = buckets[x2];
            }
            if (buckets[x2] > maxBucketCount) {
              maxBucketCount = buckets[x2];
            }
          }
          let secondPeak = 0;
          let secondPeakScore = 0;
          for (let x2 = 0; x2 < numBuckets; x2++) {
            const distanceToBiggest = x2 - firstPeak;
            const score = buckets[x2] * distanceToBiggest * distanceToBiggest;
            if (score > secondPeakScore) {
              secondPeak = x2;
              secondPeakScore = score;
            }
          }
          if (firstPeak > secondPeak) {
            const temp = firstPeak;
            firstPeak = secondPeak;
            secondPeak = temp;
          }
          if (secondPeak - firstPeak <= numBuckets / 16) {
            throw new NotFoundException();
          }
          let bestValley = secondPeak - 1;
          let bestValleyScore = -1;
          for (let x2 = secondPeak - 1; x2 > firstPeak; x2--) {
            const fromFirst = x2 - firstPeak;
            const score = fromFirst * fromFirst * (secondPeak - x2) * (maxBucketCount - buckets[x2]);
            if (score > bestValleyScore) {
              bestValley = x2;
              bestValleyScore = score;
            }
          }
          return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
        }
      }
      GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
      GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
      GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
      GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
      class HybridBinarizer2 extends GlobalHistogramBinarizer {
        constructor(source) {
          super(source);
          this.matrix = null;
        }
        /**
         * Calculates the final BitMatrix once for all requests. This could be called once from the
         * constructor instead, but there are some advantages to doing it lazily, such as making
         * profiling easier, and not doing heavy lifting when callers don't expect it.
         */
        /*@Override*/
        getBlackMatrix() {
          if (this.matrix !== null) {
            return this.matrix;
          }
          const source = this.getLuminanceSource();
          const width = source.getWidth();
          const height = source.getHeight();
          if (width >= HybridBinarizer2.MINIMUM_DIMENSION && height >= HybridBinarizer2.MINIMUM_DIMENSION) {
            const luminances = source.getMatrix();
            let subWidth = width >> HybridBinarizer2.BLOCK_SIZE_POWER;
            if ((width & HybridBinarizer2.BLOCK_SIZE_MASK) !== 0) {
              subWidth++;
            }
            let subHeight = height >> HybridBinarizer2.BLOCK_SIZE_POWER;
            if ((height & HybridBinarizer2.BLOCK_SIZE_MASK) !== 0) {
              subHeight++;
            }
            const blackPoints = HybridBinarizer2.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
            const newMatrix = new BitMatrix(width, height);
            HybridBinarizer2.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
            this.matrix = newMatrix;
          } else {
            this.matrix = super.getBlackMatrix();
          }
          return this.matrix;
        }
        /*@Override*/
        createBinarizer(source) {
          return new HybridBinarizer2(source);
        }
        /**
         * For each block in the image, calculate the average black point using a 5x5 grid
         * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
         * on the last pixels in the row/column which are also used in the previous block).
         */
        static calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
          const maxYOffset = height - HybridBinarizer2.BLOCK_SIZE;
          const maxXOffset = width - HybridBinarizer2.BLOCK_SIZE;
          for (let y2 = 0; y2 < subHeight; y2++) {
            let yoffset = y2 << HybridBinarizer2.BLOCK_SIZE_POWER;
            if (yoffset > maxYOffset) {
              yoffset = maxYOffset;
            }
            const top = HybridBinarizer2.cap(y2, 2, subHeight - 3);
            for (let x2 = 0; x2 < subWidth; x2++) {
              let xoffset = x2 << HybridBinarizer2.BLOCK_SIZE_POWER;
              if (xoffset > maxXOffset) {
                xoffset = maxXOffset;
              }
              const left = HybridBinarizer2.cap(x2, 2, subWidth - 3);
              let sum = 0;
              for (let z2 = -2; z2 <= 2; z2++) {
                const blackRow = blackPoints[top + z2];
                sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
              }
              const average = sum / 25;
              HybridBinarizer2.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
            }
          }
        }
        static cap(value2, min, max2) {
          return value2 < min ? min : value2 > max2 ? max2 : value2;
        }
        /**
         * Applies a single threshold to a block of pixels.
         */
        static thresholdBlock(luminances, xoffset, yoffset, threshold, stride, matrix) {
          for (let y2 = 0, offset = yoffset * stride + xoffset; y2 < HybridBinarizer2.BLOCK_SIZE; y2++, offset += stride) {
            for (let x2 = 0; x2 < HybridBinarizer2.BLOCK_SIZE; x2++) {
              if ((luminances[offset + x2] & 255) <= threshold) {
                matrix.set(xoffset + x2, yoffset + y2);
              }
            }
          }
        }
        /**
         * Calculates a single black point for each block of pixels and saves it away.
         * See the following thread for a discussion of this algorithm:
         *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
         */
        static calculateBlackPoints(luminances, subWidth, subHeight, width, height) {
          const maxYOffset = height - HybridBinarizer2.BLOCK_SIZE;
          const maxXOffset = width - HybridBinarizer2.BLOCK_SIZE;
          const blackPoints = new Array(subHeight);
          for (let y2 = 0; y2 < subHeight; y2++) {
            blackPoints[y2] = new Int32Array(subWidth);
            let yoffset = y2 << HybridBinarizer2.BLOCK_SIZE_POWER;
            if (yoffset > maxYOffset) {
              yoffset = maxYOffset;
            }
            for (let x2 = 0; x2 < subWidth; x2++) {
              let xoffset = x2 << HybridBinarizer2.BLOCK_SIZE_POWER;
              if (xoffset > maxXOffset) {
                xoffset = maxXOffset;
              }
              let sum = 0;
              let min = 255;
              let max2 = 0;
              for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer2.BLOCK_SIZE; yy++, offset += width) {
                for (let xx = 0; xx < HybridBinarizer2.BLOCK_SIZE; xx++) {
                  const pixel = luminances[offset + xx] & 255;
                  sum += pixel;
                  if (pixel < min) {
                    min = pixel;
                  }
                  if (pixel > max2) {
                    max2 = pixel;
                  }
                }
                if (max2 - min > HybridBinarizer2.MIN_DYNAMIC_RANGE) {
                  for (yy++, offset += width; yy < HybridBinarizer2.BLOCK_SIZE; yy++, offset += width) {
                    for (let xx = 0; xx < HybridBinarizer2.BLOCK_SIZE; xx++) {
                      sum += luminances[offset + xx] & 255;
                    }
                  }
                }
              }
              let average = sum >> HybridBinarizer2.BLOCK_SIZE_POWER * 2;
              if (max2 - min <= HybridBinarizer2.MIN_DYNAMIC_RANGE) {
                average = min / 2;
                if (y2 > 0 && x2 > 0) {
                  const averageNeighborBlackPoint = (blackPoints[y2 - 1][x2] + 2 * blackPoints[y2][x2 - 1] + blackPoints[y2 - 1][x2 - 1]) / 4;
                  if (min < averageNeighborBlackPoint) {
                    average = averageNeighborBlackPoint;
                  }
                }
              }
              blackPoints[y2][x2] = average;
            }
          }
          return blackPoints;
        }
      }
      HybridBinarizer2.BLOCK_SIZE_POWER = 3;
      HybridBinarizer2.BLOCK_SIZE = 1 << HybridBinarizer2.BLOCK_SIZE_POWER;
      HybridBinarizer2.BLOCK_SIZE_MASK = HybridBinarizer2.BLOCK_SIZE - 1;
      HybridBinarizer2.MINIMUM_DIMENSION = HybridBinarizer2.BLOCK_SIZE * 5;
      HybridBinarizer2.MIN_DYNAMIC_RANGE = 24;
      class LuminanceSource {
        constructor(width, height) {
          this.width = width;
          this.height = height;
        }
        /**
         * @return The width of the bitmap.
         */
        getWidth() {
          return this.width;
        }
        /**
         * @return The height of the bitmap.
         */
        getHeight() {
          return this.height;
        }
        /**
         * @return Whether this subclass supports cropping.
         */
        isCropSupported() {
          return false;
        }
        /**
         * Returns a new object with cropped image data. Implementations may keep a reference to the
         * original data rather than a copy. Only callable if isCropSupported() is true.
         *
         * @param left The left coordinate, which must be in [0,getWidth())
         * @param top The top coordinate, which must be in [0,getHeight())
         * @param width The width of the rectangle to crop.
         * @param height The height of the rectangle to crop.
         * @return A cropped version of this object.
         */
        crop(left, top, width, height) {
          throw new UnsupportedOperationException("This luminance source does not support cropping.");
        }
        /**
         * @return Whether this subclass supports counter-clockwise rotation.
         */
        isRotateSupported() {
          return false;
        }
        /**
         * Returns a new object with rotated image data by 90 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise() {
          throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");
        }
        /**
         * Returns a new object with rotated image data by 45 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise45() {
          throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");
        }
        /*@Override*/
        toString() {
          const row = new Uint8ClampedArray(this.width);
          let result = new StringBuilder();
          for (let y2 = 0; y2 < this.height; y2++) {
            const sourceRow = this.getRow(y2, row);
            for (let x2 = 0; x2 < this.width; x2++) {
              const luminance = sourceRow[x2] & 255;
              let c2;
              if (luminance < 64) {
                c2 = "#";
              } else if (luminance < 128) {
                c2 = "+";
              } else if (luminance < 192) {
                c2 = ".";
              } else {
                c2 = " ";
              }
              result.append(c2);
            }
            result.append("\n");
          }
          return result.toString();
        }
      }
      class InvertedLuminanceSource extends LuminanceSource {
        constructor(delegate) {
          super(delegate.getWidth(), delegate.getHeight());
          this.delegate = delegate;
        }
        /*@Override*/
        getRow(y2, row) {
          const sourceRow = this.delegate.getRow(y2, row);
          const width = this.getWidth();
          for (let i3 = 0; i3 < width; i3++) {
            sourceRow[i3] = /*(byte)*/
            255 - (sourceRow[i3] & 255);
          }
          return sourceRow;
        }
        /*@Override*/
        getMatrix() {
          const matrix = this.delegate.getMatrix();
          const length2 = this.getWidth() * this.getHeight();
          const invertedMatrix = new Uint8ClampedArray(length2);
          for (let i3 = 0; i3 < length2; i3++) {
            invertedMatrix[i3] = /*(byte)*/
            255 - (matrix[i3] & 255);
          }
          return invertedMatrix;
        }
        /*@Override*/
        isCropSupported() {
          return this.delegate.isCropSupported();
        }
        /*@Override*/
        crop(left, top, width, height) {
          return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
        }
        /*@Override*/
        isRotateSupported() {
          return this.delegate.isRotateSupported();
        }
        /**
         * @return original delegate {@link LuminanceSource} since invert undoes itself
         */
        /*@Override*/
        invert() {
          return this.delegate;
        }
        /*@Override*/
        rotateCounterClockwise() {
          return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
        }
        /*@Override*/
        rotateCounterClockwise45() {
          return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
        }
      }
      class HTMLCanvasElementLuminanceSource2 extends LuminanceSource {
        constructor(canvas) {
          super(canvas.width, canvas.height);
          this.canvas = canvas;
          this.tempCanvasElement = null;
          this.buffer = HTMLCanvasElementLuminanceSource2.makeBufferFromCanvasImageData(canvas);
        }
        static makeBufferFromCanvasImageData(canvas) {
          const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
          return HTMLCanvasElementLuminanceSource2.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
        }
        static toGrayscaleBuffer(imageBuffer, width, height) {
          const grayscaleBuffer = new Uint8ClampedArray(width * height);
          for (let i3 = 0, j2 = 0, length2 = imageBuffer.length; i3 < length2; i3 += 4, j2++) {
            let gray;
            const alpha = imageBuffer[i3 + 3];
            if (alpha === 0) {
              gray = 255;
            } else {
              const pixelR = imageBuffer[i3];
              const pixelG = imageBuffer[i3 + 1];
              const pixelB = imageBuffer[i3 + 2];
              gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
            }
            grayscaleBuffer[j2] = gray;
          }
          return grayscaleBuffer;
        }
        getRow(y2, row) {
          if (y2 < 0 || y2 >= this.getHeight()) {
            throw new IllegalArgumentException("Requested row is outside the image: " + y2);
          }
          const width = this.getWidth();
          const start = y2 * width;
          if (row === null) {
            row = this.buffer.slice(start, start + width);
          } else {
            if (row.length < width) {
              row = new Uint8ClampedArray(width);
            }
            row.set(this.buffer.slice(start, start + width));
          }
          return row;
        }
        getMatrix() {
          return this.buffer;
        }
        isCropSupported() {
          return true;
        }
        crop(left, top, width, height) {
          super.crop(left, top, width, height);
          return this;
        }
        /**
         * This is always true, since the image is a gray-scale image.
         *
         * @return true
         */
        isRotateSupported() {
          return true;
        }
        rotateCounterClockwise() {
          this.rotate(-90);
          return this;
        }
        rotateCounterClockwise45() {
          this.rotate(-45);
          return this;
        }
        getTempCanvasElement() {
          if (null === this.tempCanvasElement) {
            const tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
            tempCanvasElement.width = this.canvas.width;
            tempCanvasElement.height = this.canvas.height;
            this.tempCanvasElement = tempCanvasElement;
          }
          return this.tempCanvasElement;
        }
        rotate(angle) {
          const tempCanvasElement = this.getTempCanvasElement();
          const tempContext = tempCanvasElement.getContext("2d");
          const angleRadians = angle * HTMLCanvasElementLuminanceSource2.DEGREE_TO_RADIANS;
          const width = this.canvas.width;
          const height = this.canvas.height;
          const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
          const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
          tempCanvasElement.width = newWidth;
          tempCanvasElement.height = newHeight;
          tempContext.translate(newWidth / 2, newHeight / 2);
          tempContext.rotate(angleRadians);
          tempContext.drawImage(this.canvas, width / -2, height / -2);
          this.buffer = HTMLCanvasElementLuminanceSource2.makeBufferFromCanvasImageData(tempCanvasElement);
          return this;
        }
        invert() {
          return new InvertedLuminanceSource(this);
        }
      }
      HTMLCanvasElementLuminanceSource2.DEGREE_TO_RADIANS = Math.PI / 180;
      class VideoInputDevice {
        /**
         * Creates an instance of VideoInputDevice.
         *
         * @param {string} deviceId the video input device id
         * @param {string} label the label of the device if available
         */
        constructor(deviceId, label, groupId) {
          this.deviceId = deviceId;
          this.label = label;
          this.kind = "videoinput";
          this.groupId = groupId || void 0;
        }
        /** @inheritdoc */
        toJSON() {
          return {
            kind: this.kind,
            groupId: this.groupId,
            deviceId: this.deviceId,
            label: this.label
          };
        }
      }
      var __awaiter8 = (globalThis || global || self || window || void 0) && (globalThis || global || self || window || void 0).__awaiter || function(thisArg, _arguments, P2, generator) {
        function adopt(value2) {
          return value2 instanceof P2 ? value2 : new P2(function(resolve) {
            resolve(value2);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value2) {
            try {
              step(generator.next(value2));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value2) {
            try {
              step(generator["throw"](value2));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      class BrowserCodeReader {
        /**
         * Creates an instance of BrowserCodeReader.
         * @param {Reader} reader The reader instance to decode the barcode
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries
         *
         * @memberOf BrowserCodeReader
         */
        constructor(reader, timeBetweenScansMillis = 500, _hints) {
          this.reader = reader;
          this.timeBetweenScansMillis = timeBetweenScansMillis;
          this._hints = _hints;
          this._stopContinuousDecode = false;
          this._stopAsyncDecode = false;
          this._timeBetweenDecodingAttempts = 0;
        }
        /**
         * If navigator is present.
         */
        get hasNavigator() {
          return typeof navigator !== "undefined";
        }
        /**
         * If mediaDevices under navigator is supported.
         */
        get isMediaDevicesSuported() {
          return this.hasNavigator && !!navigator.mediaDevices;
        }
        /**
         * If enumerateDevices under navigator is supported.
         */
        get canEnumerateDevices() {
          return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
        }
        /** Time between two decoding tries in milli seconds. */
        get timeBetweenDecodingAttempts() {
          return this._timeBetweenDecodingAttempts;
        }
        /**
         * Change the time span the decoder waits between two decoding tries.
         *
         * @param {number} millis Time between two decoding tries in milli seconds.
         */
        set timeBetweenDecodingAttempts(millis) {
          this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
        }
        /**
         * Sets the hints.
         */
        set hints(hints) {
          this._hints = hints || null;
        }
        /**
         * Sets the hints.
         */
        get hints() {
          return this._hints;
        }
        /**
         * Lists all the available video input devices.
         */
        listVideoInputDevices() {
          return __awaiter8(this, void 0, void 0, function* () {
            if (!this.hasNavigator) {
              throw new Error("Can't enumerate devices, navigator is not present.");
            }
            if (!this.canEnumerateDevices) {
              throw new Error("Can't enumerate devices, method not supported.");
            }
            const devices = yield navigator.mediaDevices.enumerateDevices();
            const videoDevices = [];
            for (const device of devices) {
              const kind = device.kind === "video" ? "videoinput" : device.kind;
              if (kind !== "videoinput") {
                continue;
              }
              const deviceId = device.deviceId || device.id;
              const label = device.label || `Video device ${videoDevices.length + 1}`;
              const groupId = device.groupId;
              const videoDevice = { deviceId, label, kind, groupId };
              videoDevices.push(videoDevice);
            }
            return videoDevices;
          });
        }
        /**
         * Obtain the list of available devices with type 'videoinput'.
         *
         * @returns {Promise<VideoInputDevice[]>} an array of available video input devices
         *
         * @memberOf BrowserCodeReader
         *
         * @deprecated Use `listVideoInputDevices` instead.
         */
        getVideoInputDevices() {
          return __awaiter8(this, void 0, void 0, function* () {
            const devices = yield this.listVideoInputDevices();
            return devices.map((d2) => new VideoInputDevice(d2.deviceId, d2.label));
          });
        }
        /**
         * Let's you find a device using it's Id.
         */
        findDeviceById(deviceId) {
          return __awaiter8(this, void 0, void 0, function* () {
            const devices = yield this.listVideoInputDevices();
            if (!devices) {
              return null;
            }
            return devices.find((x2) => x2.deviceId === deviceId);
          });
        }
        /**
         * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.
         *
         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns The decoding result.
         *
         * @memberOf BrowserCodeReader
         *
         * @deprecated Use `decodeOnceFromVideoDevice` instead.
         */
        decodeFromInputVideoDevice(deviceId, videoSource) {
          return __awaiter8(this, void 0, void 0, function* () {
            return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);
          });
        }
        /**
         * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.
         *
         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeOnceFromVideoDevice(deviceId, videoSource) {
          return __awaiter8(this, void 0, void 0, function* () {
            this.reset();
            let videoConstraints;
            if (!deviceId) {
              videoConstraints = { facingMode: "environment" };
            } else {
              videoConstraints = { deviceId: { exact: deviceId } };
            }
            const constraints = { video: videoConstraints };
            return yield this.decodeOnceFromConstraints(constraints, videoSource);
          });
        }
        /**
         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param constraints the media stream constraints to get s valid media stream to decode from
         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeOnceFromConstraints(constraints, videoSource) {
          return __awaiter8(this, void 0, void 0, function* () {
            const stream = yield navigator.mediaDevices.getUserMedia(constraints);
            return yield this.decodeOnceFromStream(stream, videoSource);
          });
        }
        /**
         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeOnceFromStream(stream, videoSource) {
          return __awaiter8(this, void 0, void 0, function* () {
            this.reset();
            const video = yield this.attachStreamToVideo(stream, videoSource);
            const result = yield this.decodeOnce(video);
            return result;
          });
        }
        /**
         * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.
         *
         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<void>}
         *
         * @memberOf BrowserCodeReader
         *
         * @deprecated Use `decodeFromVideoDevice` instead.
         */
        decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {
          return __awaiter8(this, void 0, void 0, function* () {
            return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);
          });
        }
        /**
         * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.
         *
         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<void>}
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromVideoDevice(deviceId, videoSource, callbackFn) {
          return __awaiter8(this, void 0, void 0, function* () {
            let videoConstraints;
            if (!deviceId) {
              videoConstraints = { facingMode: "environment" };
            } else {
              videoConstraints = { deviceId: { exact: deviceId } };
            }
            const constraints = { video: videoConstraints };
            return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);
          });
        }
        /**
         * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromConstraints(constraints, videoSource, callbackFn) {
          return __awaiter8(this, void 0, void 0, function* () {
            const stream = yield navigator.mediaDevices.getUserMedia(constraints);
            return yield this.decodeFromStream(stream, videoSource, callbackFn);
          });
        }
        /**
         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromStream(stream, videoSource, callbackFn) {
          return __awaiter8(this, void 0, void 0, function* () {
            this.reset();
            const video = yield this.attachStreamToVideo(stream, videoSource);
            return yield this.decodeContinuously(video, callbackFn);
          });
        }
        /**
         * Breaks the decoding loop.
         */
        stopAsyncDecode() {
          this._stopAsyncDecode = true;
        }
        /**
         * Breaks the decoding loop.
         */
        stopContinuousDecode() {
          this._stopContinuousDecode = true;
        }
        /**
         * Sets the new stream and request a new decoding-with-delay.
         *
         * @param stream The stream to be shown in the video element.
         * @param decodeFn A callback for the decode method.
         */
        attachStreamToVideo(stream, videoSource) {
          return __awaiter8(this, void 0, void 0, function* () {
            const videoElement = this.prepareVideoElement(videoSource);
            this.addVideoSource(videoElement, stream);
            this.videoElement = videoElement;
            this.stream = stream;
            yield this.playVideoOnLoadAsync(videoElement);
            return videoElement;
          });
        }
        /**
         *
         * @param videoElement
         */
        playVideoOnLoadAsync(videoElement) {
          return new Promise((resolve, reject) => this.playVideoOnLoad(videoElement, () => resolve()));
        }
        /**
         * Binds listeners and callbacks to the videoElement.
         *
         * @param element
         * @param callbackFn
         */
        playVideoOnLoad(element, callbackFn) {
          this.videoEndedListener = () => this.stopStreams();
          this.videoCanPlayListener = () => this.tryPlayVideo(element);
          element.addEventListener("ended", this.videoEndedListener);
          element.addEventListener("canplay", this.videoCanPlayListener);
          element.addEventListener("playing", callbackFn);
          this.tryPlayVideo(element);
        }
        /**
         * Checks if the given video element is currently playing.
         */
        isVideoPlaying(video) {
          return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
        }
        /**
         * Just tries to play the video and logs any errors.
         * The play call is only made is the video is not already playing.
         */
        tryPlayVideo(videoElement) {
          return __awaiter8(this, void 0, void 0, function* () {
            if (this.isVideoPlaying(videoElement)) {
              console.warn("Trying to play video that is already playing.");
              return;
            }
            try {
              yield videoElement.play();
            } catch (_a2) {
              console.warn("It was not possible to play the video.");
            }
          });
        }
        /**
         * Searches and validates a media element.
         */
        getMediaElement(mediaElementId, type) {
          const mediaElement = document.getElementById(mediaElementId);
          if (!mediaElement) {
            throw new ArgumentException(`element with id '${mediaElementId}' not found`);
          }
          if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
            throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
          }
          return mediaElement;
        }
        /**
         * Decodes the barcode from an image.
         *
         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
         * @param {string} [url]
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromImage(source, url2) {
          if (!source && !url2) {
            throw new ArgumentException("either imageElement with a src set or an url must be provided");
          }
          if (url2 && !source) {
            return this.decodeFromImageUrl(url2);
          }
          return this.decodeFromImageElement(source);
        }
        /**
         * Decodes the barcode from a video.
         *
         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
         * @param {string} [url]
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromVideo(source, url2) {
          if (!source && !url2) {
            throw new ArgumentException("Either an element with a src set or an URL must be provided");
          }
          if (url2 && !source) {
            return this.decodeFromVideoUrl(url2);
          }
          return this.decodeFromVideoElement(source);
        }
        /**
         * Decodes continuously the barcode from a video.
         *
         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
         * @param {string} [url]
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         *
         * @experimental
         */
        decodeFromVideoContinuously(source, url2, callbackFn) {
          if (void 0 === source && void 0 === url2) {
            throw new ArgumentException("Either an element with a src set or an URL must be provided");
          }
          if (url2 && !source) {
            return this.decodeFromVideoUrlContinuously(url2, callbackFn);
          }
          return this.decodeFromVideoElementContinuously(source, callbackFn);
        }
        /**
         * Decodes something from an image HTML element.
         */
        decodeFromImageElement(source) {
          if (!source) {
            throw new ArgumentException("An image element must be provided.");
          }
          this.reset();
          const element = this.prepareImageElement(source);
          this.imageElement = element;
          let task;
          if (this.isImageLoaded(element)) {
            task = this.decodeOnce(element, false, true);
          } else {
            task = this._decodeOnLoadImage(element);
          }
          return task;
        }
        /**
         * Decodes something from an image HTML element.
         */
        decodeFromVideoElement(source) {
          const element = this._decodeFromVideoElementSetup(source);
          return this._decodeOnLoadVideo(element);
        }
        /**
         * Decodes something from an image HTML element.
         */
        decodeFromVideoElementContinuously(source, callbackFn) {
          const element = this._decodeFromVideoElementSetup(source);
          return this._decodeOnLoadVideoContinuously(element, callbackFn);
        }
        /**
         * Sets up the video source so it can be decoded when loaded.
         *
         * @param source The video source element.
         */
        _decodeFromVideoElementSetup(source) {
          if (!source) {
            throw new ArgumentException("A video element must be provided.");
          }
          this.reset();
          const element = this.prepareVideoElement(source);
          this.videoElement = element;
          return element;
        }
        /**
         * Decodes an image from a URL.
         */
        decodeFromImageUrl(url2) {
          if (!url2) {
            throw new ArgumentException("An URL must be provided.");
          }
          this.reset();
          const element = this.prepareImageElement();
          this.imageElement = element;
          const decodeTask = this._decodeOnLoadImage(element);
          element.src = url2;
          return decodeTask;
        }
        /**
         * Decodes an image from a URL.
         */
        decodeFromVideoUrl(url2) {
          if (!url2) {
            throw new ArgumentException("An URL must be provided.");
          }
          this.reset();
          const element = this.prepareVideoElement();
          const decodeTask = this.decodeFromVideoElement(element);
          element.src = url2;
          return decodeTask;
        }
        /**
         * Decodes an image from a URL.
         *
         * @experimental
         */
        decodeFromVideoUrlContinuously(url2, callbackFn) {
          if (!url2) {
            throw new ArgumentException("An URL must be provided.");
          }
          this.reset();
          const element = this.prepareVideoElement();
          const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
          element.src = url2;
          return decodeTask;
        }
        _decodeOnLoadImage(element) {
          return new Promise((resolve, reject) => {
            this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve, reject);
            element.addEventListener("load", this.imageLoadedListener);
          });
        }
        _decodeOnLoadVideo(videoElement) {
          return __awaiter8(this, void 0, void 0, function* () {
            yield this.playVideoOnLoadAsync(videoElement);
            return yield this.decodeOnce(videoElement);
          });
        }
        _decodeOnLoadVideoContinuously(videoElement, callbackFn) {
          return __awaiter8(this, void 0, void 0, function* () {
            yield this.playVideoOnLoadAsync(videoElement);
            this.decodeContinuously(videoElement, callbackFn);
          });
        }
        isImageLoaded(img) {
          if (!img.complete) {
            return false;
          }
          if (img.naturalWidth === 0) {
            return false;
          }
          return true;
        }
        prepareImageElement(imageSource) {
          let imageElement;
          if (typeof imageSource === "undefined") {
            imageElement = document.createElement("img");
            imageElement.width = 200;
            imageElement.height = 200;
          }
          if (typeof imageSource === "string") {
            imageElement = this.getMediaElement(imageSource, "img");
          }
          if (imageSource instanceof HTMLImageElement) {
            imageElement = imageSource;
          }
          return imageElement;
        }
        /**
         * Sets a HTMLVideoElement for scanning or creates a new one.
         *
         * @param videoSource The HTMLVideoElement to be set.
         */
        prepareVideoElement(videoSource) {
          let videoElement;
          if (!videoSource && typeof document !== "undefined") {
            videoElement = document.createElement("video");
            videoElement.width = 200;
            videoElement.height = 200;
          }
          if (typeof videoSource === "string") {
            videoElement = this.getMediaElement(videoSource, "video");
          }
          if (videoSource instanceof HTMLVideoElement) {
            videoElement = videoSource;
          }
          videoElement.setAttribute("autoplay", "true");
          videoElement.setAttribute("muted", "true");
          videoElement.setAttribute("playsinline", "true");
          return videoElement;
        }
        /**
         * Tries to decode from the video input until it finds some value.
         */
        decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {
          this._stopAsyncDecode = false;
          const loop = (resolve, reject) => {
            if (this._stopAsyncDecode) {
              reject(new NotFoundException("Video stream has ended before any code could be detected."));
              this._stopAsyncDecode = void 0;
              return;
            }
            try {
              const result = this.decode(element);
              resolve(result);
            } catch (e) {
              const ifNotFound = retryIfNotFound && e instanceof NotFoundException;
              const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
              const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
              if (ifNotFound || ifChecksumOrFormat) {
                return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve, reject);
              }
              reject(e);
            }
          };
          return new Promise((resolve, reject) => loop(resolve, reject));
        }
        /**
         * Continuously decodes from video input.
         */
        decodeContinuously(element, callbackFn) {
          this._stopContinuousDecode = false;
          const loop = () => {
            if (this._stopContinuousDecode) {
              this._stopContinuousDecode = void 0;
              return;
            }
            try {
              const result = this.decode(element);
              callbackFn(result, null);
              setTimeout(loop, this.timeBetweenScansMillis);
            } catch (e) {
              callbackFn(null, e);
              const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
              const isNotFound = e instanceof NotFoundException;
              if (isChecksumOrFormatError || isNotFound) {
                setTimeout(loop, this._timeBetweenDecodingAttempts);
              }
            }
          };
          loop();
        }
        /**
         * Gets the BinaryBitmap for ya! (and decodes it)
         */
        decode(element) {
          const binaryBitmap = this.createBinaryBitmap(element);
          return this.decodeBitmap(binaryBitmap);
        }
        /**
         * Returns true if media element is indeed a {@link HtmlVideoElement}.
         */
        _isHTMLVideoElement(mediaElement) {
          const potentialVideo = mediaElement;
          return potentialVideo.videoWidth !== 0;
        }
        /**
         * Overwriting this allows you to manipulate the next frame in anyway
         * you want before decode.
         */
        drawFrameOnCanvas(srcElement, dimensions, canvasElementContext) {
          if (!dimensions) {
            dimensions = {
              sx: 0,
              sy: 0,
              sWidth: srcElement.videoWidth,
              sHeight: srcElement.videoHeight,
              dx: 0,
              dy: 0,
              dWidth: srcElement.videoWidth,
              dHeight: srcElement.videoHeight
            };
          }
          if (!canvasElementContext) {
            canvasElementContext = this.captureCanvasContext;
          }
          canvasElementContext.drawImage(
            srcElement,
            dimensions.sx,
            dimensions.sy,
            dimensions.sWidth,
            dimensions.sHeight,
            dimensions.dx,
            dimensions.dy,
            dimensions.dWidth,
            dimensions.dHeight
          );
        }
        /**
         * Ovewriting this allows you to manipulate the snapshot image in anyway
         *  you want before decode.
         */
        drawImageOnCanvas(srcElement, dimensions, canvasElementContext = this.captureCanvasContext) {
          if (!dimensions) {
            dimensions = {
              sx: 0,
              sy: 0,
              sWidth: srcElement.naturalWidth,
              sHeight: srcElement.naturalHeight,
              dx: 0,
              dy: 0,
              dWidth: srcElement.naturalWidth,
              dHeight: srcElement.naturalHeight
            };
          }
          if (!canvasElementContext) {
            canvasElementContext = this.captureCanvasContext;
          }
          canvasElementContext.drawImage(
            srcElement,
            dimensions.sx,
            dimensions.sy,
            dimensions.sWidth,
            dimensions.sHeight,
            dimensions.dx,
            dimensions.dy,
            dimensions.dWidth,
            dimensions.dHeight
          );
        }
        /**
         * Creates a binaryBitmap based in some image source.
         *
         * @param mediaElement HTML element containing drawable image source.
         */
        createBinaryBitmap(mediaElement) {
          const ctx = this.getCaptureCanvasContext(mediaElement);
          if (this._isHTMLVideoElement(mediaElement)) {
            this.drawFrameOnCanvas(mediaElement);
          } else {
            this.drawImageOnCanvas(mediaElement);
          }
          const canvas = this.getCaptureCanvas(mediaElement);
          const luminanceSource = new HTMLCanvasElementLuminanceSource2(canvas);
          const hybridBinarizer = new HybridBinarizer2(luminanceSource);
          return new BinaryBitmap2(hybridBinarizer);
        }
        getCaptureCanvasContext(mediaElement) {
          if (!this.captureCanvasContext) {
            const elem = this.getCaptureCanvas(mediaElement);
            const ctx = elem.getContext("2d");
            this.captureCanvasContext = ctx;
          }
          return this.captureCanvasContext;
        }
        getCaptureCanvas(mediaElement) {
          if (!this.captureCanvas) {
            const elem = this.createCaptureCanvas(mediaElement);
            this.captureCanvas = elem;
          }
          return this.captureCanvas;
        }
        /**
         * Call the encapsulated readers decode
         */
        decodeBitmap(binaryBitmap) {
          return this.reader.decode(binaryBitmap, this._hints);
        }
        /**
         * 🖌 Prepares the canvas for capture and scan frames.
         */
        createCaptureCanvas(mediaElement) {
          if (typeof document === "undefined") {
            this._destroyCaptureCanvas();
            return null;
          }
          const canvasElement = document.createElement("canvas");
          let width;
          let height;
          if (typeof mediaElement !== "undefined") {
            if (mediaElement instanceof HTMLVideoElement) {
              width = mediaElement.videoWidth;
              height = mediaElement.videoHeight;
            } else if (mediaElement instanceof HTMLImageElement) {
              width = mediaElement.naturalWidth || mediaElement.width;
              height = mediaElement.naturalHeight || mediaElement.height;
            }
          }
          canvasElement.style.width = width + "px";
          canvasElement.style.height = height + "px";
          canvasElement.width = width;
          canvasElement.height = height;
          return canvasElement;
        }
        /**
         * Stops the continuous scan and cleans the stream.
         */
        stopStreams() {
          if (this.stream) {
            this.stream.getVideoTracks().forEach((t2) => t2.stop());
            this.stream = void 0;
          }
          if (this._stopAsyncDecode === false) {
            this.stopAsyncDecode();
          }
          if (this._stopContinuousDecode === false) {
            this.stopContinuousDecode();
          }
        }
        /**
         * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.
         *
         * @memberOf BrowserCodeReader
         */
        reset() {
          this.stopStreams();
          this._destroyVideoElement();
          this._destroyImageElement();
          this._destroyCaptureCanvas();
        }
        _destroyVideoElement() {
          if (!this.videoElement) {
            return;
          }
          if (typeof this.videoEndedListener !== "undefined") {
            this.videoElement.removeEventListener("ended", this.videoEndedListener);
          }
          if (typeof this.videoPlayingEventListener !== "undefined") {
            this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
          }
          if (typeof this.videoCanPlayListener !== "undefined") {
            this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
          }
          this.cleanVideoSource(this.videoElement);
          this.videoElement = void 0;
        }
        _destroyImageElement() {
          if (!this.imageElement) {
            return;
          }
          if (void 0 !== this.imageLoadedListener) {
            this.imageElement.removeEventListener("load", this.imageLoadedListener);
          }
          this.imageElement.src = void 0;
          this.imageElement.removeAttribute("src");
          this.imageElement = void 0;
        }
        /**
         * Cleans canvas references 🖌
         */
        _destroyCaptureCanvas() {
          this.captureCanvasContext = void 0;
          this.captureCanvas = void 0;
        }
        /**
         * Defines what the videoElement src will be.
         *
         * @param videoElement
         * @param stream
         */
        addVideoSource(videoElement, stream) {
          try {
            videoElement.srcObject = stream;
          } catch (err) {
            videoElement.src = URL.createObjectURL(stream);
          }
        }
        /**
         * Unbinds a HTML video src property.
         *
         * @param videoElement
         */
        cleanVideoSource(videoElement) {
          try {
            videoElement.srcObject = null;
          } catch (err) {
            videoElement.src = "";
          }
          this.videoElement.removeAttribute("src");
        }
      }
      class Result {
        // public constructor(private text: string,
        //               Uint8Array rawBytes,
        //               ResultPoconst resultPoints: Int32Array,
        //               BarcodeFormat format) {
        //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())
        // }
        // public constructor(text: string,
        //               Uint8Array rawBytes,
        //               ResultPoconst resultPoints: Int32Array,
        //               BarcodeFormat format,
        //               long timestamp) {
        //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,
        //        resultPoints, format, timestamp)
        // }
        constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {
          this.text = text;
          this.rawBytes = rawBytes;
          this.numBits = numBits;
          this.resultPoints = resultPoints;
          this.format = format;
          this.timestamp = timestamp;
          this.text = text;
          this.rawBytes = rawBytes;
          if (void 0 === numBits || null === numBits) {
            this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
          } else {
            this.numBits = numBits;
          }
          this.resultPoints = resultPoints;
          this.format = format;
          this.resultMetadata = null;
          if (void 0 === timestamp || null === timestamp) {
            this.timestamp = System.currentTimeMillis();
          } else {
            this.timestamp = timestamp;
          }
        }
        /**
         * @return raw text encoded by the barcode
         */
        getText() {
          return this.text;
        }
        /**
         * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}
         */
        getRawBytes() {
          return this.rawBytes;
        }
        /**
         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
         * @since 3.3.0
         */
        getNumBits() {
          return this.numBits;
        }
        /**
         * @return points related to the barcode in the image. These are typically points
         *         identifying finder patterns or the corners of the barcode. The exact meaning is
         *         specific to the type of barcode that was decoded.
         */
        getResultPoints() {
          return this.resultPoints;
        }
        /**
         * @return {@link BarcodeFormat} representing the format of the barcode that was decoded
         */
        getBarcodeFormat() {
          return this.format;
        }
        /**
         * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be
         *   {@code null}. This contains optional metadata about what was detected about the barcode,
         *   like orientation.
         */
        getResultMetadata() {
          return this.resultMetadata;
        }
        putMetadata(type, value2) {
          if (this.resultMetadata === null) {
            this.resultMetadata = /* @__PURE__ */ new Map();
          }
          this.resultMetadata.set(type, value2);
        }
        putAllMetadata(metadata) {
          if (metadata !== null) {
            if (this.resultMetadata === null) {
              this.resultMetadata = metadata;
            } else {
              this.resultMetadata = new Map(metadata);
            }
          }
        }
        addResultPoints(newPoints) {
          const oldPoints = this.resultPoints;
          if (oldPoints === null) {
            this.resultPoints = newPoints;
          } else if (newPoints !== null && newPoints.length > 0) {
            const allPoints = new Array(oldPoints.length + newPoints.length);
            System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
            System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
            this.resultPoints = allPoints;
          }
        }
        getTimestamp() {
          return this.timestamp;
        }
        /*@Override*/
        toString() {
          return this.text;
        }
      }
      var BarcodeFormat2;
      (function(BarcodeFormat3) {
        BarcodeFormat3[BarcodeFormat3["AZTEC"] = 0] = "AZTEC";
        BarcodeFormat3[BarcodeFormat3["CODABAR"] = 1] = "CODABAR";
        BarcodeFormat3[BarcodeFormat3["CODE_39"] = 2] = "CODE_39";
        BarcodeFormat3[BarcodeFormat3["CODE_93"] = 3] = "CODE_93";
        BarcodeFormat3[BarcodeFormat3["CODE_128"] = 4] = "CODE_128";
        BarcodeFormat3[BarcodeFormat3["DATA_MATRIX"] = 5] = "DATA_MATRIX";
        BarcodeFormat3[BarcodeFormat3["EAN_8"] = 6] = "EAN_8";
        BarcodeFormat3[BarcodeFormat3["EAN_13"] = 7] = "EAN_13";
        BarcodeFormat3[BarcodeFormat3["ITF"] = 8] = "ITF";
        BarcodeFormat3[BarcodeFormat3["MAXICODE"] = 9] = "MAXICODE";
        BarcodeFormat3[BarcodeFormat3["PDF_417"] = 10] = "PDF_417";
        BarcodeFormat3[BarcodeFormat3["QR_CODE"] = 11] = "QR_CODE";
        BarcodeFormat3[BarcodeFormat3["RSS_14"] = 12] = "RSS_14";
        BarcodeFormat3[BarcodeFormat3["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
        BarcodeFormat3[BarcodeFormat3["UPC_A"] = 14] = "UPC_A";
        BarcodeFormat3[BarcodeFormat3["UPC_E"] = 15] = "UPC_E";
        BarcodeFormat3[BarcodeFormat3["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
      })(BarcodeFormat2 || (BarcodeFormat2 = {}));
      var BarcodeFormat$1 = BarcodeFormat2;
      var ResultMetadataType;
      (function(ResultMetadataType2) {
        ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
        ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
        ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
        ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
        ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
        ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
        ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
        ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
        ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
        ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
        ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
      })(ResultMetadataType || (ResultMetadataType = {}));
      var ResultMetadataType$1 = ResultMetadataType;
      class DecoderResult {
        // public constructor(rawBytes: Uint8Array,
        //                      text: string,
        //                      List<Uint8Array> byteSegments,
        //                      String ecLevel) {
        //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)
        // }
        constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {
          this.rawBytes = rawBytes;
          this.text = text;
          this.byteSegments = byteSegments;
          this.ecLevel = ecLevel;
          this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
          this.structuredAppendParity = structuredAppendParity;
          this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
        }
        /**
         * @return raw bytes representing the result, or {@code null} if not applicable
         */
        getRawBytes() {
          return this.rawBytes;
        }
        /**
         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
         * @since 3.3.0
         */
        getNumBits() {
          return this.numBits;
        }
        /**
         * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}
         * @since 3.3.0
         */
        setNumBits(numBits) {
          this.numBits = numBits;
        }
        /**
         * @return text representation of the result
         */
        getText() {
          return this.text;
        }
        /**
         * @return list of byte segments in the result, or {@code null} if not applicable
         */
        getByteSegments() {
          return this.byteSegments;
        }
        /**
         * @return name of error correction level used, or {@code null} if not applicable
         */
        getECLevel() {
          return this.ecLevel;
        }
        /**
         * @return number of errors corrected, or {@code null} if not applicable
         */
        getErrorsCorrected() {
          return this.errorsCorrected;
        }
        setErrorsCorrected(errorsCorrected) {
          this.errorsCorrected = errorsCorrected;
        }
        /**
         * @return number of erasures corrected, or {@code null} if not applicable
         */
        getErasures() {
          return this.erasures;
        }
        setErasures(erasures) {
          this.erasures = erasures;
        }
        /**
         * @return arbitrary additional metadata
         */
        getOther() {
          return this.other;
        }
        setOther(other) {
          this.other = other;
        }
        hasStructuredAppend() {
          return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
        }
        getStructuredAppendParity() {
          return this.structuredAppendParity;
        }
        getStructuredAppendSequenceNumber() {
          return this.structuredAppendSequenceNumber;
        }
      }
      class AbstractGenericGF {
        /**
         * @return 2 to the power of a in GF(size)
         */
        exp(a2) {
          return this.expTable[a2];
        }
        /**
         * @return base 2 log of a in GF(size)
         */
        log(a2) {
          if (a2 === 0) {
            throw new IllegalArgumentException();
          }
          return this.logTable[a2];
        }
        /**
         * Implements both addition and subtraction -- they are the same in GF(size).
         *
         * @return sum/difference of a and b
         */
        static addOrSubtract(a2, b2) {
          return a2 ^ b2;
        }
      }
      class GenericGFPoly {
        /**
         * @param field the {@link GenericGF} instance representing the field to use
         * to perform computations
         * @param coefficients coefficients as ints representing elements of GF(size), arranged
         * from most significant (highest-power term) coefficient to least significant
         * @throws IllegalArgumentException if argument is null or empty,
         * or if leading coefficient is 0 and this is not a
         * constant polynomial (that is, it is not the monomial "0")
         */
        constructor(field, coefficients) {
          if (coefficients.length === 0) {
            throw new IllegalArgumentException();
          }
          this.field = field;
          const coefficientsLength = coefficients.length;
          if (coefficientsLength > 1 && coefficients[0] === 0) {
            let firstNonZero = 1;
            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
              firstNonZero++;
            }
            if (firstNonZero === coefficientsLength) {
              this.coefficients = Int32Array.from([0]);
            } else {
              this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
              System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
            }
          } else {
            this.coefficients = coefficients;
          }
        }
        getCoefficients() {
          return this.coefficients;
        }
        /**
         * @return degree of this polynomial
         */
        getDegree() {
          return this.coefficients.length - 1;
        }
        /**
         * @return true iff this polynomial is the monomial "0"
         */
        isZero() {
          return this.coefficients[0] === 0;
        }
        /**
         * @return coefficient of x^degree term in this polynomial
         */
        getCoefficient(degree) {
          return this.coefficients[this.coefficients.length - 1 - degree];
        }
        /**
         * @return evaluation of this polynomial at a given point
         */
        evaluateAt(a2) {
          if (a2 === 0) {
            return this.getCoefficient(0);
          }
          const coefficients = this.coefficients;
          let result;
          if (a2 === 1) {
            result = 0;
            for (let i3 = 0, length2 = coefficients.length; i3 !== length2; i3++) {
              const coefficient = coefficients[i3];
              result = AbstractGenericGF.addOrSubtract(result, coefficient);
            }
            return result;
          }
          result = coefficients[0];
          const size = coefficients.length;
          const field = this.field;
          for (let i3 = 1; i3 < size; i3++) {
            result = AbstractGenericGF.addOrSubtract(field.multiply(a2, result), coefficients[i3]);
          }
          return result;
        }
        addOrSubtract(other) {
          if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
          }
          if (this.isZero()) {
            return other;
          }
          if (other.isZero()) {
            return this;
          }
          let smallerCoefficients = this.coefficients;
          let largerCoefficients = other.coefficients;
          if (smallerCoefficients.length > largerCoefficients.length) {
            const temp = smallerCoefficients;
            smallerCoefficients = largerCoefficients;
            largerCoefficients = temp;
          }
          let sumDiff = new Int32Array(largerCoefficients.length);
          const lengthDiff = largerCoefficients.length - smallerCoefficients.length;
          System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
          for (let i3 = lengthDiff; i3 < largerCoefficients.length; i3++) {
            sumDiff[i3] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i3 - lengthDiff], largerCoefficients[i3]);
          }
          return new GenericGFPoly(this.field, sumDiff);
        }
        multiply(other) {
          if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
          }
          if (this.isZero() || other.isZero()) {
            return this.field.getZero();
          }
          const aCoefficients = this.coefficients;
          const aLength = aCoefficients.length;
          const bCoefficients = other.coefficients;
          const bLength = bCoefficients.length;
          const product = new Int32Array(aLength + bLength - 1);
          const field = this.field;
          for (let i3 = 0; i3 < aLength; i3++) {
            const aCoeff = aCoefficients[i3];
            for (let j2 = 0; j2 < bLength; j2++) {
              product[i3 + j2] = AbstractGenericGF.addOrSubtract(product[i3 + j2], field.multiply(aCoeff, bCoefficients[j2]));
            }
          }
          return new GenericGFPoly(field, product);
        }
        multiplyScalar(scalar) {
          if (scalar === 0) {
            return this.field.getZero();
          }
          if (scalar === 1) {
            return this;
          }
          const size = this.coefficients.length;
          const field = this.field;
          const product = new Int32Array(size);
          const coefficients = this.coefficients;
          for (let i3 = 0; i3 < size; i3++) {
            product[i3] = field.multiply(coefficients[i3], scalar);
          }
          return new GenericGFPoly(field, product);
        }
        multiplyByMonomial(degree, coefficient) {
          if (degree < 0) {
            throw new IllegalArgumentException();
          }
          if (coefficient === 0) {
            return this.field.getZero();
          }
          const coefficients = this.coefficients;
          const size = coefficients.length;
          const product = new Int32Array(size + degree);
          const field = this.field;
          for (let i3 = 0; i3 < size; i3++) {
            product[i3] = field.multiply(coefficients[i3], coefficient);
          }
          return new GenericGFPoly(field, product);
        }
        divide(other) {
          if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
          }
          if (other.isZero()) {
            throw new IllegalArgumentException("Divide by 0");
          }
          const field = this.field;
          let quotient = field.getZero();
          let remainder = this;
          const denominatorLeadingTerm = other.getCoefficient(other.getDegree());
          const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
            const degreeDifference = remainder.getDegree() - other.getDegree();
            const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
            const term = other.multiplyByMonomial(degreeDifference, scale);
            const iterationQuotient = field.buildMonomial(degreeDifference, scale);
            quotient = quotient.addOrSubtract(iterationQuotient);
            remainder = remainder.addOrSubtract(term);
          }
          return [quotient, remainder];
        }
        /*@Override*/
        toString() {
          let result = "";
          for (let degree = this.getDegree(); degree >= 0; degree--) {
            let coefficient = this.getCoefficient(degree);
            if (coefficient !== 0) {
              if (coefficient < 0) {
                result += " - ";
                coefficient = -coefficient;
              } else {
                if (result.length > 0) {
                  result += " + ";
                }
              }
              if (degree === 0 || coefficient !== 1) {
                const alphaPower = this.field.log(coefficient);
                if (alphaPower === 0) {
                  result += "1";
                } else if (alphaPower === 1) {
                  result += "a";
                } else {
                  result += "a^";
                  result += alphaPower;
                }
              }
              if (degree !== 0) {
                if (degree === 1) {
                  result += "x";
                } else {
                  result += "x^";
                  result += degree;
                }
              }
            }
          }
          return result;
        }
      }
      class ArithmeticException extends Exception {
      }
      ArithmeticException.kind = "ArithmeticException";
      class GenericGF extends AbstractGenericGF {
        /**
         * Create a representation of GF(size) using the given primitive polynomial.
         *
         * @param primitive irreducible polynomial whose coefficients are represented by
         *  the bits of an int, where the least-significant bit represents the constant
         *  coefficient
         * @param size the size of the field
         * @param b the factor b in the generator polynomial can be 0- or 1-based
         *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
         *  In most cases it should be 1, but for QR code it is 0.
         */
        constructor(primitive, size, generatorBase) {
          super();
          this.primitive = primitive;
          this.size = size;
          this.generatorBase = generatorBase;
          const expTable = new Int32Array(size);
          let x2 = 1;
          for (let i3 = 0; i3 < size; i3++) {
            expTable[i3] = x2;
            x2 *= 2;
            if (x2 >= size) {
              x2 ^= primitive;
              x2 &= size - 1;
            }
          }
          this.expTable = expTable;
          const logTable = new Int32Array(size);
          for (let i3 = 0; i3 < size - 1; i3++) {
            logTable[expTable[i3]] = i3;
          }
          this.logTable = logTable;
          this.zero = new GenericGFPoly(this, Int32Array.from([0]));
          this.one = new GenericGFPoly(this, Int32Array.from([1]));
        }
        getZero() {
          return this.zero;
        }
        getOne() {
          return this.one;
        }
        /**
         * @return the monomial representing coefficient * x^degree
         */
        buildMonomial(degree, coefficient) {
          if (degree < 0) {
            throw new IllegalArgumentException();
          }
          if (coefficient === 0) {
            return this.zero;
          }
          const coefficients = new Int32Array(degree + 1);
          coefficients[0] = coefficient;
          return new GenericGFPoly(this, coefficients);
        }
        /**
         * @return multiplicative inverse of a
         */
        inverse(a2) {
          if (a2 === 0) {
            throw new ArithmeticException();
          }
          return this.expTable[this.size - this.logTable[a2] - 1];
        }
        /**
         * @return product of a and b in GF(size)
         */
        multiply(a2, b2) {
          if (a2 === 0 || b2 === 0) {
            return 0;
          }
          return this.expTable[(this.logTable[a2] + this.logTable[b2]) % (this.size - 1)];
        }
        getSize() {
          return this.size;
        }
        getGeneratorBase() {
          return this.generatorBase;
        }
        /*@Override*/
        toString() {
          return "GF(0x" + Integer.toHexString(this.primitive) + "," + this.size + ")";
        }
        equals(o2) {
          return o2 === this;
        }
      }
      GenericGF.AZTEC_DATA_12 = new GenericGF(4201, 4096, 1);
      GenericGF.AZTEC_DATA_10 = new GenericGF(1033, 1024, 1);
      GenericGF.AZTEC_DATA_6 = new GenericGF(67, 64, 1);
      GenericGF.AZTEC_PARAM = new GenericGF(19, 16, 1);
      GenericGF.QR_CODE_FIELD_256 = new GenericGF(285, 256, 0);
      GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(301, 256, 1);
      GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
      GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
      class ReedSolomonException extends Exception {
      }
      ReedSolomonException.kind = "ReedSolomonException";
      class IllegalStateException extends Exception {
      }
      IllegalStateException.kind = "IllegalStateException";
      class ReedSolomonDecoder {
        constructor(field) {
          this.field = field;
        }
        /**
         * <p>Decodes given set of received codewords, which include both data and error-correction
         * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
         * in the input.</p>
         *
         * @param received data and error-correction codewords
         * @param twoS number of error-correction codewords available
         * @throws ReedSolomonException if decoding fails for any reason
         */
        decode(received, twoS) {
          const field = this.field;
          const poly = new GenericGFPoly(field, received);
          const syndromeCoefficients = new Int32Array(twoS);
          let noError = true;
          for (let i3 = 0; i3 < twoS; i3++) {
            const evalResult = poly.evaluateAt(field.exp(i3 + field.getGeneratorBase()));
            syndromeCoefficients[syndromeCoefficients.length - 1 - i3] = evalResult;
            if (evalResult !== 0) {
              noError = false;
            }
          }
          if (noError) {
            return;
          }
          const syndrome = new GenericGFPoly(field, syndromeCoefficients);
          const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
          const sigma = sigmaOmega[0];
          const omega = sigmaOmega[1];
          const errorLocations = this.findErrorLocations(sigma);
          const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
          for (let i3 = 0; i3 < errorLocations.length; i3++) {
            const position = received.length - 1 - field.log(errorLocations[i3]);
            if (position < 0) {
              throw new ReedSolomonException("Bad error location");
            }
            received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i3]);
          }
        }
        runEuclideanAlgorithm(a2, b2, R2) {
          if (a2.getDegree() < b2.getDegree()) {
            const temp = a2;
            a2 = b2;
            b2 = temp;
          }
          const field = this.field;
          let rLast = a2;
          let r = b2;
          let tLast = field.getZero();
          let t2 = field.getOne();
          while (r.getDegree() >= (R2 / 2 | 0)) {
            let rLastLast = rLast;
            let tLastLast = tLast;
            rLast = r;
            tLast = t2;
            if (rLast.isZero()) {
              throw new ReedSolomonException("r_{i-1} was zero");
            }
            r = rLastLast;
            let q2 = field.getZero();
            const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
            const dltInverse = field.inverse(denominatorLeadingTerm);
            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
              const degreeDiff = r.getDegree() - rLast.getDegree();
              const scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
              q2 = q2.addOrSubtract(field.buildMonomial(degreeDiff, scale));
              r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t2 = q2.multiply(tLast).addOrSubtract(tLastLast);
            if (r.getDegree() >= rLast.getDegree()) {
              throw new IllegalStateException("Division algorithm failed to reduce polynomial?");
            }
          }
          const sigmaTildeAtZero = t2.getCoefficient(0);
          if (sigmaTildeAtZero === 0) {
            throw new ReedSolomonException("sigmaTilde(0) was zero");
          }
          const inverse = field.inverse(sigmaTildeAtZero);
          const sigma = t2.multiplyScalar(inverse);
          const omega = r.multiplyScalar(inverse);
          return [sigma, omega];
        }
        findErrorLocations(errorLocator) {
          const numErrors = errorLocator.getDegree();
          if (numErrors === 1) {
            return Int32Array.from([errorLocator.getCoefficient(1)]);
          }
          const result = new Int32Array(numErrors);
          let e = 0;
          const field = this.field;
          for (let i3 = 1; i3 < field.getSize() && e < numErrors; i3++) {
            if (errorLocator.evaluateAt(i3) === 0) {
              result[e] = field.inverse(i3);
              e++;
            }
          }
          if (e !== numErrors) {
            throw new ReedSolomonException("Error locator degree does not match number of roots");
          }
          return result;
        }
        findErrorMagnitudes(errorEvaluator, errorLocations) {
          const s2 = errorLocations.length;
          const result = new Int32Array(s2);
          const field = this.field;
          for (let i3 = 0; i3 < s2; i3++) {
            const xiInverse = field.inverse(errorLocations[i3]);
            let denominator = 1;
            for (let j2 = 0; j2 < s2; j2++) {
              if (i3 !== j2) {
                const term = field.multiply(errorLocations[j2], xiInverse);
                const termPlus1 = (term & 1) === 0 ? term | 1 : term & ~1;
                denominator = field.multiply(denominator, termPlus1);
              }
            }
            result[i3] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
            if (field.getGeneratorBase() !== 0) {
              result[i3] = field.multiply(result[i3], xiInverse);
            }
          }
          return result;
        }
      }
      var Table;
      (function(Table2) {
        Table2[Table2["UPPER"] = 0] = "UPPER";
        Table2[Table2["LOWER"] = 1] = "LOWER";
        Table2[Table2["MIXED"] = 2] = "MIXED";
        Table2[Table2["DIGIT"] = 3] = "DIGIT";
        Table2[Table2["PUNCT"] = 4] = "PUNCT";
        Table2[Table2["BINARY"] = 5] = "BINARY";
      })(Table || (Table = {}));
      class Decoder2 {
        decode(detectorResult) {
          this.ddata = detectorResult;
          let matrix = detectorResult.getBits();
          let rawbits = this.extractBits(matrix);
          let correctedBits = this.correctBits(rawbits);
          let rawBytes = Decoder2.convertBoolArrayToByteArray(correctedBits);
          let result = Decoder2.getEncodedData(correctedBits);
          let decoderResult = new DecoderResult(rawBytes, result, null, null);
          decoderResult.setNumBits(correctedBits.length);
          return decoderResult;
        }
        // This method is used for testing the high-level encoder
        static highLevelDecode(correctedBits) {
          return this.getEncodedData(correctedBits);
        }
        /**
         * Gets the string encoded in the aztec code bits
         *
         * @return the decoded string
         */
        static getEncodedData(correctedBits) {
          let endIndex = correctedBits.length;
          let latchTable = Table.UPPER;
          let shiftTable = Table.UPPER;
          let result = "";
          let index = 0;
          while (index < endIndex) {
            if (shiftTable === Table.BINARY) {
              if (endIndex - index < 5) {
                break;
              }
              let length2 = Decoder2.readCode(correctedBits, index, 5);
              index += 5;
              if (length2 === 0) {
                if (endIndex - index < 11) {
                  break;
                }
                length2 = Decoder2.readCode(correctedBits, index, 11) + 31;
                index += 11;
              }
              for (let charCount = 0; charCount < length2; charCount++) {
                if (endIndex - index < 8) {
                  index = endIndex;
                  break;
                }
                const code = Decoder2.readCode(correctedBits, index, 8);
                result += /*(char)*/
                StringUtils.castAsNonUtf8Char(code);
                index += 8;
              }
              shiftTable = latchTable;
            } else {
              let size = shiftTable === Table.DIGIT ? 4 : 5;
              if (endIndex - index < size) {
                break;
              }
              let code = Decoder2.readCode(correctedBits, index, size);
              index += size;
              let str = Decoder2.getCharacter(shiftTable, code);
              if (str.startsWith("CTRL_")) {
                latchTable = shiftTable;
                shiftTable = Decoder2.getTable(str.charAt(5));
                if (str.charAt(6) === "L") {
                  latchTable = shiftTable;
                }
              } else {
                result += str;
                shiftTable = latchTable;
              }
            }
          }
          return result;
        }
        /**
         * gets the table corresponding to the char passed
         */
        static getTable(t2) {
          switch (t2) {
            case "L":
              return Table.LOWER;
            case "P":
              return Table.PUNCT;
            case "M":
              return Table.MIXED;
            case "D":
              return Table.DIGIT;
            case "B":
              return Table.BINARY;
            case "U":
            default:
              return Table.UPPER;
          }
        }
        /**
         * Gets the character (or string) corresponding to the passed code in the given table
         *
         * @param table the table used
         * @param code the code of the character
         */
        static getCharacter(table, code) {
          switch (table) {
            case Table.UPPER:
              return Decoder2.UPPER_TABLE[code];
            case Table.LOWER:
              return Decoder2.LOWER_TABLE[code];
            case Table.MIXED:
              return Decoder2.MIXED_TABLE[code];
            case Table.PUNCT:
              return Decoder2.PUNCT_TABLE[code];
            case Table.DIGIT:
              return Decoder2.DIGIT_TABLE[code];
            default:
              throw new IllegalStateException("Bad table");
          }
        }
        /**
         * <p>Performs RS error correction on an array of bits.</p>
         *
         * @return the corrected array
         * @throws FormatException if the input contains too many errors
         */
        correctBits(rawbits) {
          let gf;
          let codewordSize;
          if (this.ddata.getNbLayers() <= 2) {
            codewordSize = 6;
            gf = GenericGF.AZTEC_DATA_6;
          } else if (this.ddata.getNbLayers() <= 8) {
            codewordSize = 8;
            gf = GenericGF.AZTEC_DATA_8;
          } else if (this.ddata.getNbLayers() <= 22) {
            codewordSize = 10;
            gf = GenericGF.AZTEC_DATA_10;
          } else {
            codewordSize = 12;
            gf = GenericGF.AZTEC_DATA_12;
          }
          let numDataCodewords = this.ddata.getNbDatablocks();
          let numCodewords = rawbits.length / codewordSize;
          if (numCodewords < numDataCodewords) {
            throw new FormatException();
          }
          let offset = rawbits.length % codewordSize;
          let dataWords = new Int32Array(numCodewords);
          for (let i3 = 0; i3 < numCodewords; i3++, offset += codewordSize) {
            dataWords[i3] = Decoder2.readCode(rawbits, offset, codewordSize);
          }
          try {
            let rsDecoder = new ReedSolomonDecoder(gf);
            rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
          } catch (ex) {
            throw new FormatException(ex);
          }
          let mask = (1 << codewordSize) - 1;
          let stuffedBits = 0;
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            let dataWord = dataWords[i3];
            if (dataWord === 0 || dataWord === mask) {
              throw new FormatException();
            } else if (dataWord === 1 || dataWord === mask - 1) {
              stuffedBits++;
            }
          }
          let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
          let index = 0;
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            let dataWord = dataWords[i3];
            if (dataWord === 1 || dataWord === mask - 1) {
              correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
              index += codewordSize - 1;
            } else {
              for (let bit = codewordSize - 1; bit >= 0; --bit) {
                correctedBits[index++] = (dataWord & 1 << bit) !== 0;
              }
            }
          }
          return correctedBits;
        }
        /**
         * Gets the array of bits from an Aztec Code matrix
         *
         * @return the array of bits
         */
        extractBits(matrix) {
          let compact = this.ddata.isCompact();
          let layers = this.ddata.getNbLayers();
          let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
          let alignmentMap = new Int32Array(baseMatrixSize);
          let rawbits = new Array(this.totalBitsInLayer(layers, compact));
          if (compact) {
            for (let i3 = 0; i3 < alignmentMap.length; i3++) {
              alignmentMap[i3] = i3;
            }
          } else {
            let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
            let origCenter = baseMatrixSize / 2;
            let center = Integer.truncDivision(matrixSize, 2);
            for (let i3 = 0; i3 < origCenter; i3++) {
              let newOffset = i3 + Integer.truncDivision(i3, 15);
              alignmentMap[origCenter - i3 - 1] = center - newOffset - 1;
              alignmentMap[origCenter + i3] = center + newOffset + 1;
            }
          }
          for (let i3 = 0, rowOffset = 0; i3 < layers; i3++) {
            let rowSize = (layers - i3) * 4 + (compact ? 9 : 12);
            let low = i3 * 2;
            let high = baseMatrixSize - 1 - low;
            for (let j2 = 0; j2 < rowSize; j2++) {
              let columnOffset = j2 * 2;
              for (let k2 = 0; k2 < 2; k2++) {
                rawbits[rowOffset + columnOffset + k2] = matrix.get(alignmentMap[low + k2], alignmentMap[low + j2]);
                rawbits[rowOffset + 2 * rowSize + columnOffset + k2] = matrix.get(alignmentMap[low + j2], alignmentMap[high - k2]);
                rawbits[rowOffset + 4 * rowSize + columnOffset + k2] = matrix.get(alignmentMap[high - k2], alignmentMap[high - j2]);
                rawbits[rowOffset + 6 * rowSize + columnOffset + k2] = matrix.get(alignmentMap[high - j2], alignmentMap[low + k2]);
              }
            }
            rowOffset += rowSize * 8;
          }
          return rawbits;
        }
        /**
         * Reads a code of given length and at given index in an array of bits
         */
        static readCode(rawbits, startIndex, length2) {
          let res = 0;
          for (let i3 = startIndex; i3 < startIndex + length2; i3++) {
            res <<= 1;
            if (rawbits[i3]) {
              res |= 1;
            }
          }
          return res;
        }
        /**
         * Reads a code of length 8 in an array of bits, padding with zeros
         */
        static readByte(rawbits, startIndex) {
          let n2 = rawbits.length - startIndex;
          if (n2 >= 8) {
            return Decoder2.readCode(rawbits, startIndex, 8);
          }
          return Decoder2.readCode(rawbits, startIndex, n2) << 8 - n2;
        }
        /**
         * Packs a bit array into bytes, most significant bit first
         */
        static convertBoolArrayToByteArray(boolArr) {
          let byteArr = new Uint8Array((boolArr.length + 7) / 8);
          for (let i3 = 0; i3 < byteArr.length; i3++) {
            byteArr[i3] = Decoder2.readByte(boolArr, 8 * i3);
          }
          return byteArr;
        }
        totalBitsInLayer(layers, compact) {
          return ((compact ? 88 : 112) + 16 * layers) * layers;
        }
      }
      Decoder2.UPPER_TABLE = [
        "CTRL_PS",
        " ",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "CTRL_LL",
        "CTRL_ML",
        "CTRL_DL",
        "CTRL_BS"
      ];
      Decoder2.LOWER_TABLE = [
        "CTRL_PS",
        " ",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "CTRL_US",
        "CTRL_ML",
        "CTRL_DL",
        "CTRL_BS"
      ];
      Decoder2.MIXED_TABLE = [
        // Module parse failed: Octal literal in strict mode (50:29)
        // so number string were scaped
        "CTRL_PS",
        " ",
        "\\1",
        "\\2",
        "\\3",
        "\\4",
        "\\5",
        "\\6",
        "\\7",
        "\b",
        "	",
        "\n",
        "\\13",
        "\f",
        "\r",
        "\\33",
        "\\34",
        "\\35",
        "\\36",
        "\\37",
        "@",
        "\\",
        "^",
        "_",
        "`",
        "|",
        "~",
        "\\177",
        "CTRL_LL",
        "CTRL_UL",
        "CTRL_PL",
        "CTRL_BS"
      ];
      Decoder2.PUNCT_TABLE = [
        "",
        "\r",
        "\r\n",
        ". ",
        ", ",
        ": ",
        "!",
        '"',
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "{",
        "}",
        "CTRL_UL"
      ];
      Decoder2.DIGIT_TABLE = [
        "CTRL_PS",
        " ",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        ",",
        ".",
        "CTRL_UL",
        "CTRL_US"
      ];
      class MathUtils {
        constructor() {
        }
        /**
         * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
         * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
         * differ slightly from {@link Math#round(float)} in that half rounds down for negative
         * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
         *
         * @param d real value to round
         * @return nearest {@code int}
         */
        static round(d2) {
          if (NaN === d2)
            return 0;
          if (d2 <= Number.MIN_SAFE_INTEGER)
            return Number.MIN_SAFE_INTEGER;
          if (d2 >= Number.MAX_SAFE_INTEGER)
            return Number.MAX_SAFE_INTEGER;
          return (
            /*(int) */
            d2 + (d2 < 0 ? -0.5 : 0.5) | 0
          );
        }
        // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js
        /**
         * @param aX point A x coordinate
         * @param aY point A y coordinate
         * @param bX point B x coordinate
         * @param bY point B y coordinate
         * @return Euclidean distance between points A and B
         */
        static distance(aX, aY, bX, bY) {
          const xDiff = aX - bX;
          const yDiff = aY - bY;
          return (
            /*(float) */
            Math.sqrt(xDiff * xDiff + yDiff * yDiff)
          );
        }
        /**
         * @param aX point A x coordinate
         * @param aY point A y coordinate
         * @param bX point B x coordinate
         * @param bY point B y coordinate
         * @return Euclidean distance between points A and B
         */
        // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {
        //   const xDiff = aX - bX
        //   const yDiff = aY - bY
        //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        // }
        /**
         * @param array values to sum
         * @return sum of values in array
         */
        static sum(array) {
          let count = 0;
          for (let i3 = 0, length2 = array.length; i3 !== length2; i3++) {
            const a2 = array[i3];
            count += a2;
          }
          return count;
        }
      }
      class Float {
        /**
         * SincTS has no difference between int and float, there's all numbers,
         * this is used only to polyfill Java code.
         */
        static floatToIntBits(f2) {
          return f2;
        }
      }
      Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
      class ResultPoint {
        constructor(x2, y2) {
          this.x = x2;
          this.y = y2;
        }
        getX() {
          return this.x;
        }
        getY() {
          return this.y;
        }
        /*@Override*/
        equals(other) {
          if (other instanceof ResultPoint) {
            const otherPoint = other;
            return this.x === otherPoint.x && this.y === otherPoint.y;
          }
          return false;
        }
        /*@Override*/
        hashCode() {
          return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
        }
        /*@Override*/
        toString() {
          return "(" + this.x + "," + this.y + ")";
        }
        /**
         * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
         * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
         *
         * @param patterns array of three {@code ResultPoint} to order
         */
        static orderBestPatterns(patterns) {
          const zeroOneDistance = this.distance(patterns[0], patterns[1]);
          const oneTwoDistance = this.distance(patterns[1], patterns[2]);
          const zeroTwoDistance = this.distance(patterns[0], patterns[2]);
          let pointA;
          let pointB;
          let pointC;
          if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
            pointB = patterns[0];
            pointA = patterns[1];
            pointC = patterns[2];
          } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
            pointB = patterns[1];
            pointA = patterns[0];
            pointC = patterns[2];
          } else {
            pointB = patterns[2];
            pointA = patterns[0];
            pointC = patterns[1];
          }
          if (this.crossProductZ(pointA, pointB, pointC) < 0) {
            const temp = pointA;
            pointA = pointC;
            pointC = temp;
          }
          patterns[0] = pointA;
          patterns[1] = pointB;
          patterns[2] = pointC;
        }
        /**
         * @param pattern1 first pattern
         * @param pattern2 second pattern
         * @return distance between two points
         */
        static distance(pattern1, pattern2) {
          return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
        }
        /**
         * Returns the z component of the cross product between vectors BC and BA.
         */
        static crossProductZ(pointA, pointB, pointC) {
          const bX = pointB.x;
          const bY = pointB.y;
          return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
        }
      }
      class DetectorResult {
        constructor(bits2, points) {
          this.bits = bits2;
          this.points = points;
        }
        getBits() {
          return this.bits;
        }
        getPoints() {
          return this.points;
        }
      }
      class AztecDetectorResult extends DetectorResult {
        constructor(bits2, points, compact, nbDatablocks, nbLayers) {
          super(bits2, points);
          this.compact = compact;
          this.nbDatablocks = nbDatablocks;
          this.nbLayers = nbLayers;
        }
        getNbLayers() {
          return this.nbLayers;
        }
        getNbDatablocks() {
          return this.nbDatablocks;
        }
        isCompact() {
          return this.compact;
        }
      }
      class WhiteRectangleDetector {
        // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {
        //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)
        // }
        /**
         * @param image barcode image to find a rectangle in
         * @param initSize initial size of search area around center
         * @param x x position of search center
         * @param y y position of search center
         * @throws NotFoundException if image is too small to accommodate {@code initSize}
         */
        constructor(image, initSize, x2, y2) {
          this.image = image;
          this.height = image.getHeight();
          this.width = image.getWidth();
          if (void 0 === initSize || null === initSize) {
            initSize = WhiteRectangleDetector.INIT_SIZE;
          }
          if (void 0 === x2 || null === x2) {
            x2 = image.getWidth() / 2 | 0;
          }
          if (void 0 === y2 || null === y2) {
            y2 = image.getHeight() / 2 | 0;
          }
          const halfsize = initSize / 2 | 0;
          this.leftInit = x2 - halfsize;
          this.rightInit = x2 + halfsize;
          this.upInit = y2 - halfsize;
          this.downInit = y2 + halfsize;
          if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
            throw new NotFoundException();
          }
        }
        /**
         * <p>
         * Detects a candidate barcode-like rectangular region within an image. It
         * starts around the center of the image, increases the size of the candidate
         * region until it finds a white rectangular region.
         * </p>
         *
         * @return {@link ResultPoint}[] describing the corners of the rectangular
         *         region. The first and last points are opposed on the diagonal, as
         *         are the second and third. The first point will be the topmost
         *         point and the last, the bottommost. The second point will be
         *         leftmost and the third, the rightmost
         * @throws NotFoundException if no Data Matrix Code can be found
         */
        detect() {
          let left = this.leftInit;
          let right = this.rightInit;
          let up = this.upInit;
          let down = this.downInit;
          let sizeExceeded = false;
          let aBlackPointFoundOnBorder = true;
          let atLeastOneBlackPointFoundOnBorder = false;
          let atLeastOneBlackPointFoundOnRight = false;
          let atLeastOneBlackPointFoundOnBottom = false;
          let atLeastOneBlackPointFoundOnLeft = false;
          let atLeastOneBlackPointFoundOnTop = false;
          const width = this.width;
          const height = this.height;
          while (aBlackPointFoundOnBorder) {
            aBlackPointFoundOnBorder = false;
            let rightBorderNotWhite = true;
            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
              rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
              if (rightBorderNotWhite) {
                right++;
                aBlackPointFoundOnBorder = true;
                atLeastOneBlackPointFoundOnRight = true;
              } else if (!atLeastOneBlackPointFoundOnRight) {
                right++;
              }
            }
            if (right >= width) {
              sizeExceeded = true;
              break;
            }
            let bottomBorderNotWhite = true;
            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
              bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
              if (bottomBorderNotWhite) {
                down++;
                aBlackPointFoundOnBorder = true;
                atLeastOneBlackPointFoundOnBottom = true;
              } else if (!atLeastOneBlackPointFoundOnBottom) {
                down++;
              }
            }
            if (down >= height) {
              sizeExceeded = true;
              break;
            }
            let leftBorderNotWhite = true;
            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
              leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
              if (leftBorderNotWhite) {
                left--;
                aBlackPointFoundOnBorder = true;
                atLeastOneBlackPointFoundOnLeft = true;
              } else if (!atLeastOneBlackPointFoundOnLeft) {
                left--;
              }
            }
            if (left < 0) {
              sizeExceeded = true;
              break;
            }
            let topBorderNotWhite = true;
            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
              topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
              if (topBorderNotWhite) {
                up--;
                aBlackPointFoundOnBorder = true;
                atLeastOneBlackPointFoundOnTop = true;
              } else if (!atLeastOneBlackPointFoundOnTop) {
                up--;
              }
            }
            if (up < 0) {
              sizeExceeded = true;
              break;
            }
            if (aBlackPointFoundOnBorder) {
              atLeastOneBlackPointFoundOnBorder = true;
            }
          }
          if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
            const maxSize = right - left;
            let z2 = null;
            for (let i3 = 1; z2 === null && i3 < maxSize; i3++) {
              z2 = this.getBlackPointOnSegment(left, down - i3, left + i3, down);
            }
            if (z2 == null) {
              throw new NotFoundException();
            }
            let t2 = null;
            for (let i3 = 1; t2 === null && i3 < maxSize; i3++) {
              t2 = this.getBlackPointOnSegment(left, up + i3, left + i3, up);
            }
            if (t2 == null) {
              throw new NotFoundException();
            }
            let x2 = null;
            for (let i3 = 1; x2 === null && i3 < maxSize; i3++) {
              x2 = this.getBlackPointOnSegment(right, up + i3, right - i3, up);
            }
            if (x2 == null) {
              throw new NotFoundException();
            }
            let y2 = null;
            for (let i3 = 1; y2 === null && i3 < maxSize; i3++) {
              y2 = this.getBlackPointOnSegment(right, down - i3, right - i3, down);
            }
            if (y2 == null) {
              throw new NotFoundException();
            }
            return this.centerEdges(y2, z2, x2, t2);
          } else {
            throw new NotFoundException();
          }
        }
        getBlackPointOnSegment(aX, aY, bX, bY) {
          const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));
          const xStep = (bX - aX) / dist;
          const yStep = (bY - aY) / dist;
          const image = this.image;
          for (let i3 = 0; i3 < dist; i3++) {
            const x2 = MathUtils.round(aX + i3 * xStep);
            const y2 = MathUtils.round(aY + i3 * yStep);
            if (image.get(x2, y2)) {
              return new ResultPoint(x2, y2);
            }
          }
          return null;
        }
        /**
         * recenters the points of a constant distance towards the center
         *
         * @param y bottom most point
         * @param z left most point
         * @param x right most point
         * @param t top most point
         * @return {@link ResultPoint}[] describing the corners of the rectangular
         *         region. The first and last points are opposed on the diagonal, as
         *         are the second and third. The first point will be the topmost
         *         point and the last, the bottommost. The second point will be
         *         leftmost and the third, the rightmost
         */
        centerEdges(y2, z2, x2, t2) {
          const yi = y2.getX();
          const yj = y2.getY();
          const zi = z2.getX();
          const zj = z2.getY();
          const xi = x2.getX();
          const xj = x2.getY();
          const ti = t2.getX();
          const tj = t2.getY();
          const CORR = WhiteRectangleDetector.CORR;
          if (yi < this.width / 2) {
            return [
              new ResultPoint(ti - CORR, tj + CORR),
              new ResultPoint(zi + CORR, zj + CORR),
              new ResultPoint(xi - CORR, xj - CORR),
              new ResultPoint(yi + CORR, yj - CORR)
            ];
          } else {
            return [
              new ResultPoint(ti + CORR, tj + CORR),
              new ResultPoint(zi + CORR, zj - CORR),
              new ResultPoint(xi - CORR, xj + CORR),
              new ResultPoint(yi - CORR, yj - CORR)
            ];
          }
        }
        /**
         * Determines whether a segment contains a black point
         *
         * @param a          min value of the scanned coordinate
         * @param b          max value of the scanned coordinate
         * @param fixed      value of fixed coordinate
         * @param horizontal set to true if scan must be horizontal, false if vertical
         * @return true if a black point has been found, else false.
         */
        containsBlackPoint(a2, b2, fixed, horizontal) {
          const image = this.image;
          if (horizontal) {
            for (let x2 = a2; x2 <= b2; x2++) {
              if (image.get(x2, fixed)) {
                return true;
              }
            }
          } else {
            for (let y2 = a2; y2 <= b2; y2++) {
              if (image.get(fixed, y2)) {
                return true;
              }
            }
          }
          return false;
        }
      }
      WhiteRectangleDetector.INIT_SIZE = 10;
      WhiteRectangleDetector.CORR = 1;
      class GridSampler {
        /**
         * <p>Checks a set of points that have been transformed to sample points on an image against
         * the image's dimensions to see if the point are even within the image.</p>
         *
         * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
         * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
         * patterns in an image where the QR Code runs all the way to the image border.</p>
         *
         * <p>For efficiency, the method will check points from either end of the line until one is found
         * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
         *
         * @param image image into which the points should map
         * @param points actual points in x1,y1,...,xn,yn form
         * @throws NotFoundException if an endpoint is lies outside the image boundaries
         */
        static checkAndNudgePoints(image, points) {
          const width = image.getWidth();
          const height = image.getHeight();
          let nudged = true;
          for (let offset = 0; offset < points.length && nudged; offset += 2) {
            const x2 = Math.floor(points[offset]);
            const y2 = Math.floor(points[offset + 1]);
            if (x2 < -1 || x2 > width || y2 < -1 || y2 > height) {
              throw new NotFoundException();
            }
            nudged = false;
            if (x2 === -1) {
              points[offset] = 0;
              nudged = true;
            } else if (x2 === width) {
              points[offset] = width - 1;
              nudged = true;
            }
            if (y2 === -1) {
              points[offset + 1] = 0;
              nudged = true;
            } else if (y2 === height) {
              points[offset + 1] = height - 1;
              nudged = true;
            }
          }
          nudged = true;
          for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
            const x2 = Math.floor(points[offset]);
            const y2 = Math.floor(points[offset + 1]);
            if (x2 < -1 || x2 > width || y2 < -1 || y2 > height) {
              throw new NotFoundException();
            }
            nudged = false;
            if (x2 === -1) {
              points[offset] = 0;
              nudged = true;
            } else if (x2 === width) {
              points[offset] = width - 1;
              nudged = true;
            }
            if (y2 === -1) {
              points[offset + 1] = 0;
              nudged = true;
            } else if (y2 === height) {
              points[offset + 1] = height - 1;
              nudged = true;
            }
          }
        }
      }
      class PerspectiveTransform {
        constructor(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
          this.a11 = a11;
          this.a21 = a21;
          this.a31 = a31;
          this.a12 = a12;
          this.a22 = a22;
          this.a32 = a32;
          this.a13 = a13;
          this.a23 = a23;
          this.a33 = a33;
        }
        static quadrilateralToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
          const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
          const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
          return sToQ.times(qToS);
        }
        transformPoints(points) {
          const max2 = points.length;
          const a11 = this.a11;
          const a12 = this.a12;
          const a13 = this.a13;
          const a21 = this.a21;
          const a22 = this.a22;
          const a23 = this.a23;
          const a31 = this.a31;
          const a32 = this.a32;
          const a33 = this.a33;
          for (let i3 = 0; i3 < max2; i3 += 2) {
            const x2 = points[i3];
            const y2 = points[i3 + 1];
            const denominator = a13 * x2 + a23 * y2 + a33;
            points[i3] = (a11 * x2 + a21 * y2 + a31) / denominator;
            points[i3 + 1] = (a12 * x2 + a22 * y2 + a32) / denominator;
          }
        }
        transformPointsWithValues(xValues, yValues) {
          const a11 = this.a11;
          const a12 = this.a12;
          const a13 = this.a13;
          const a21 = this.a21;
          const a22 = this.a22;
          const a23 = this.a23;
          const a31 = this.a31;
          const a32 = this.a32;
          const a33 = this.a33;
          const n2 = xValues.length;
          for (let i3 = 0; i3 < n2; i3++) {
            const x2 = xValues[i3];
            const y2 = yValues[i3];
            const denominator = a13 * x2 + a23 * y2 + a33;
            xValues[i3] = (a11 * x2 + a21 * y2 + a31) / denominator;
            yValues[i3] = (a12 * x2 + a22 * y2 + a32) / denominator;
          }
        }
        static squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3) {
          const dx3 = x0 - x1 + x2 - x3;
          const dy3 = y0 - y1 + y2 - y3;
          if (dx3 === 0 && dy3 === 0) {
            return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1);
          } else {
            const dx1 = x1 - x2;
            const dx2 = x3 - x2;
            const dy1 = y1 - y2;
            const dy2 = y3 - y2;
            const denominator = dx1 * dy2 - dx2 * dy1;
            const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
            const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
            return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1);
          }
        }
        static quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3) {
          return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
        }
        buildAdjoint() {
          return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
        }
        times(other) {
          return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
        }
      }
      class DefaultGridSampler extends GridSampler {
        /*@Override*/
        sampleGrid(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
          const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
          return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
        }
        /*@Override*/
        sampleGridWithTransform(image, dimensionX, dimensionY, transform) {
          if (dimensionX <= 0 || dimensionY <= 0) {
            throw new NotFoundException();
          }
          const bits2 = new BitMatrix(dimensionX, dimensionY);
          const points = new Float32Array(2 * dimensionX);
          for (let y2 = 0; y2 < dimensionY; y2++) {
            const max2 = points.length;
            const iValue = y2 + 0.5;
            for (let x2 = 0; x2 < max2; x2 += 2) {
              points[x2] = x2 / 2 + 0.5;
              points[x2 + 1] = iValue;
            }
            transform.transformPoints(points);
            GridSampler.checkAndNudgePoints(image, points);
            try {
              for (let x2 = 0; x2 < max2; x2 += 2) {
                if (image.get(Math.floor(points[x2]), Math.floor(points[x2 + 1]))) {
                  bits2.set(x2 / 2, y2);
                }
              }
            } catch (aioobe) {
              throw new NotFoundException();
            }
          }
          return bits2;
        }
      }
      class GridSamplerInstance {
        /**
         * Sets the implementation of GridSampler used by the library. One global
         * instance is stored, which may sound problematic. But, the implementation provided
         * ought to be appropriate for the entire platform, and all uses of this library
         * in the whole lifetime of the JVM. For instance, an Android activity can swap in
         * an implementation that takes advantage of native platform libraries.
         *
         * @param newGridSampler The platform-specific object to install.
         */
        static setGridSampler(newGridSampler) {
          GridSamplerInstance.gridSampler = newGridSampler;
        }
        /**
         * @return the current implementation of GridSampler
         */
        static getInstance() {
          return GridSamplerInstance.gridSampler;
        }
      }
      GridSamplerInstance.gridSampler = new DefaultGridSampler();
      class Point {
        constructor(x2, y2) {
          this.x = x2;
          this.y = y2;
        }
        toResultPoint() {
          return new ResultPoint(this.getX(), this.getY());
        }
        getX() {
          return this.x;
        }
        getY() {
          return this.y;
        }
      }
      class Detector {
        constructor(image) {
          this.EXPECTED_CORNER_BITS = new Int32Array([
            3808,
            476,
            2107,
            1799
          ]);
          this.image = image;
        }
        detect() {
          return this.detectMirror(false);
        }
        /**
         * Detects an Aztec Code in an image.
         *
         * @param isMirror if true, image is a mirror-image of original
         * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code
         * @throws NotFoundException if no Aztec Code can be found
         */
        detectMirror(isMirror) {
          let pCenter = this.getMatrixCenter();
          let bullsEyeCorners = this.getBullsEyeCorners(pCenter);
          if (isMirror) {
            let temp = bullsEyeCorners[0];
            bullsEyeCorners[0] = bullsEyeCorners[2];
            bullsEyeCorners[2] = temp;
          }
          this.extractParameters(bullsEyeCorners);
          let bits2 = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
          let corners = this.getMatrixCornerPoints(bullsEyeCorners);
          return new AztecDetectorResult(bits2, corners, this.compact, this.nbDataBlocks, this.nbLayers);
        }
        /**
         * Extracts the number of data layers and data blocks from the layer around the bull's eye.
         *
         * @param bullsEyeCorners the array of bull's eye corners
         * @throws NotFoundException in case of too many errors or invalid parameters
         */
        extractParameters(bullsEyeCorners) {
          if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
            throw new NotFoundException();
          }
          let length2 = 2 * this.nbCenterLayers;
          let sides = new Int32Array([
            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length2),
            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length2),
            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length2),
            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length2)
            // Top
          ]);
          this.shift = this.getRotation(sides, length2);
          let parameterData = 0;
          for (let i3 = 0; i3 < 4; i3++) {
            let side = sides[(this.shift + i3) % 4];
            if (this.compact) {
              parameterData <<= 7;
              parameterData += side >> 1 & 127;
            } else {
              parameterData <<= 10;
              parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
            }
          }
          let correctedData = this.getCorrectedParameterData(parameterData, this.compact);
          if (this.compact) {
            this.nbLayers = (correctedData >> 6) + 1;
            this.nbDataBlocks = (correctedData & 63) + 1;
          } else {
            this.nbLayers = (correctedData >> 11) + 1;
            this.nbDataBlocks = (correctedData & 2047) + 1;
          }
        }
        getRotation(sides, length2) {
          let cornerBits = 0;
          sides.forEach((side, idx, arr) => {
            let t2 = (side >> length2 - 2 << 1) + (side & 1);
            cornerBits = (cornerBits << 3) + t2;
          });
          cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
          for (let shift = 0; shift < 4; shift++) {
            if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
              return shift;
            }
          }
          throw new NotFoundException();
        }
        /**
         * Corrects the parameter bits using Reed-Solomon algorithm.
         *
         * @param parameterData parameter bits
         * @param compact true if this is a compact Aztec code
         * @throws NotFoundException if the array contains too many errors
         */
        getCorrectedParameterData(parameterData, compact) {
          let numCodewords;
          let numDataCodewords;
          if (compact) {
            numCodewords = 7;
            numDataCodewords = 2;
          } else {
            numCodewords = 10;
            numDataCodewords = 4;
          }
          let numECCodewords = numCodewords - numDataCodewords;
          let parameterWords = new Int32Array(numCodewords);
          for (let i3 = numCodewords - 1; i3 >= 0; --i3) {
            parameterWords[i3] = parameterData & 15;
            parameterData >>= 4;
          }
          try {
            let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
            rsDecoder.decode(parameterWords, numECCodewords);
          } catch (ignored) {
            throw new NotFoundException();
          }
          let result = 0;
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            result = (result << 4) + parameterWords[i3];
          }
          return result;
        }
        /**
         * Finds the corners of a bull-eye centered on the passed point.
         * This returns the centers of the diagonal points just outside the bull's eye
         * Returns [topRight, bottomRight, bottomLeft, topLeft]
         *
         * @param pCenter Center point
         * @return The corners of the bull-eye
         * @throws NotFoundException If no valid bull-eye can be found
         */
        getBullsEyeCorners(pCenter) {
          let pina = pCenter;
          let pinb = pCenter;
          let pinc = pCenter;
          let pind = pCenter;
          let color = true;
          for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
            let pouta = this.getFirstDifferent(pina, color, 1, -1);
            let poutb = this.getFirstDifferent(pinb, color, 1, 1);
            let poutc = this.getFirstDifferent(pinc, color, -1, 1);
            let poutd = this.getFirstDifferent(pind, color, -1, -1);
            if (this.nbCenterLayers > 2) {
              let q2 = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
              if (q2 < 0.75 || q2 > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
                break;
              }
            }
            pina = pouta;
            pinb = poutb;
            pinc = poutc;
            pind = poutd;
            color = !color;
          }
          if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
            throw new NotFoundException();
          }
          this.compact = this.nbCenterLayers === 5;
          let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);
          let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);
          let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);
          let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);
          return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
        }
        /**
         * Finds a candidate center point of an Aztec code from an image
         *
         * @return the center point
         */
        getMatrixCenter() {
          let pointA;
          let pointB;
          let pointC;
          let pointD;
          try {
            let cornerPoints = new WhiteRectangleDetector(this.image).detect();
            pointA = cornerPoints[0];
            pointB = cornerPoints[1];
            pointC = cornerPoints[2];
            pointD = cornerPoints[3];
          } catch (e) {
            let cx2 = this.image.getWidth() / 2;
            let cy2 = this.image.getHeight() / 2;
            pointA = this.getFirstDifferent(new Point(cx2 + 7, cy2 - 7), false, 1, -1).toResultPoint();
            pointB = this.getFirstDifferent(new Point(cx2 + 7, cy2 + 7), false, 1, 1).toResultPoint();
            pointC = this.getFirstDifferent(new Point(cx2 - 7, cy2 + 7), false, -1, 1).toResultPoint();
            pointD = this.getFirstDifferent(new Point(cx2 - 7, cy2 - 7), false, -1, -1).toResultPoint();
          }
          let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
          let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
          try {
            let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();
            pointA = cornerPoints[0];
            pointB = cornerPoints[1];
            pointC = cornerPoints[2];
            pointD = cornerPoints[3];
          } catch (e) {
            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
          }
          cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
          cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
          return new Point(cx, cy);
        }
        /**
         * Gets the Aztec code corners from the bull's eye corners and the parameters.
         *
         * @param bullsEyeCorners the array of bull's eye corners
         * @return the array of aztec code corners
         */
        getMatrixCornerPoints(bullsEyeCorners) {
          return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
        }
        /**
         * Creates a BitMatrix by sampling the provided image.
         * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the
         * diagonal just outside the bull's eye.
         */
        sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {
          let sampler = GridSamplerInstance.getInstance();
          let dimension = this.getDimension();
          let low = dimension / 2 - this.nbCenterLayers;
          let high = dimension / 2 + this.nbCenterLayers;
          return sampler.sampleGrid(
            image,
            dimension,
            dimension,
            low,
            low,
            // topleft
            high,
            low,
            // topright
            high,
            high,
            // bottomright
            low,
            high,
            // bottomleft
            topLeft.getX(),
            topLeft.getY(),
            topRight.getX(),
            topRight.getY(),
            bottomRight.getX(),
            bottomRight.getY(),
            bottomLeft.getX(),
            bottomLeft.getY()
          );
        }
        /**
         * Samples a line.
         *
         * @param p1   start point (inclusive)
         * @param p2   end point (exclusive)
         * @param size number of bits
         * @return the array of bits as an int (first bit is high-order bit of result)
         */
        sampleLine(p1, p2, size) {
          let result = 0;
          let d2 = this.distanceResultPoint(p1, p2);
          let moduleSize = d2 / size;
          let px = p1.getX();
          let py = p1.getY();
          let dx = moduleSize * (p2.getX() - p1.getX()) / d2;
          let dy = moduleSize * (p2.getY() - p1.getY()) / d2;
          for (let i3 = 0; i3 < size; i3++) {
            if (this.image.get(MathUtils.round(px + i3 * dx), MathUtils.round(py + i3 * dy))) {
              result |= 1 << size - i3 - 1;
            }
          }
          return result;
        }
        /**
         * @return true if the border of the rectangle passed in parameter is compound of white points only
         *         or black points only
         */
        isWhiteOrBlackRectangle(p1, p2, p3, p4) {
          let corr = 3;
          p1 = new Point(p1.getX() - corr, p1.getY() + corr);
          p2 = new Point(p2.getX() - corr, p2.getY() - corr);
          p3 = new Point(p3.getX() + corr, p3.getY() - corr);
          p4 = new Point(p4.getX() + corr, p4.getY() + corr);
          let cInit = this.getColor(p4, p1);
          if (cInit === 0) {
            return false;
          }
          let c2 = this.getColor(p1, p2);
          if (c2 !== cInit) {
            return false;
          }
          c2 = this.getColor(p2, p3);
          if (c2 !== cInit) {
            return false;
          }
          c2 = this.getColor(p3, p4);
          return c2 === cInit;
        }
        /**
         * Gets the color of a segment
         *
         * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else
         */
        getColor(p1, p2) {
          let d2 = this.distancePoint(p1, p2);
          let dx = (p2.getX() - p1.getX()) / d2;
          let dy = (p2.getY() - p1.getY()) / d2;
          let error = 0;
          let px = p1.getX();
          let py = p1.getY();
          let colorModel = this.image.get(p1.getX(), p1.getY());
          let iMax = Math.ceil(d2);
          for (let i3 = 0; i3 < iMax; i3++) {
            px += dx;
            py += dy;
            if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {
              error++;
            }
          }
          let errRatio = error / d2;
          if (errRatio > 0.1 && errRatio < 0.9) {
            return 0;
          }
          return errRatio <= 0.1 === colorModel ? 1 : -1;
        }
        /**
         * Gets the coordinate of the first point with a different color in the given direction
         */
        getFirstDifferent(init, color, dx, dy) {
          let x2 = init.getX() + dx;
          let y2 = init.getY() + dy;
          while (this.isValid(x2, y2) && this.image.get(x2, y2) === color) {
            x2 += dx;
            y2 += dy;
          }
          x2 -= dx;
          y2 -= dy;
          while (this.isValid(x2, y2) && this.image.get(x2, y2) === color) {
            x2 += dx;
          }
          x2 -= dx;
          while (this.isValid(x2, y2) && this.image.get(x2, y2) === color) {
            y2 += dy;
          }
          y2 -= dy;
          return new Point(x2, y2);
        }
        /**
         * Expand the square represented by the corner points by pushing out equally in all directions
         *
         * @param cornerPoints the corners of the square, which has the bull's eye at its center
         * @param oldSide the original length of the side of the square in the target bit matrix
         * @param newSide the new length of the size of the square in the target bit matrix
         * @return the corners of the expanded square
         */
        expandSquare(cornerPoints, oldSide, newSide) {
          let ratio = newSide / (2 * oldSide);
          let dx = cornerPoints[0].getX() - cornerPoints[2].getX();
          let dy = cornerPoints[0].getY() - cornerPoints[2].getY();
          let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
          let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
          let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
          let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
          dx = cornerPoints[1].getX() - cornerPoints[3].getX();
          dy = cornerPoints[1].getY() - cornerPoints[3].getY();
          centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
          centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
          let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
          let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
          let results = [result0, result1, result2, result3];
          return results;
        }
        isValid(x2, y2) {
          return x2 >= 0 && x2 < this.image.getWidth() && y2 > 0 && y2 < this.image.getHeight();
        }
        isValidPoint(point) {
          let x2 = MathUtils.round(point.getX());
          let y2 = MathUtils.round(point.getY());
          return this.isValid(x2, y2);
        }
        distancePoint(a2, b2) {
          return MathUtils.distance(a2.getX(), a2.getY(), b2.getX(), b2.getY());
        }
        distanceResultPoint(a2, b2) {
          return MathUtils.distance(a2.getX(), a2.getY(), b2.getX(), b2.getY());
        }
        getDimension() {
          if (this.compact) {
            return 4 * this.nbLayers + 11;
          }
          if (this.nbLayers <= 4) {
            return 4 * this.nbLayers + 15;
          }
          return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
        }
      }
      class AztecReader {
        /**
         * Locates and decodes a Data Matrix code in an image.
         *
         * @return a String representing the content encoded by the Data Matrix code
         * @throws NotFoundException if a Data Matrix code cannot be found
         * @throws FormatException if a Data Matrix code cannot be decoded
         */
        decode(image, hints = null) {
          let exception = null;
          let detector = new Detector(image.getBlackMatrix());
          let points = null;
          let decoderResult = null;
          try {
            let detectorResult = detector.detectMirror(false);
            points = detectorResult.getPoints();
            this.reportFoundResultPoints(hints, points);
            decoderResult = new Decoder2().decode(detectorResult);
          } catch (e) {
            exception = e;
          }
          if (decoderResult == null) {
            try {
              let detectorResult = detector.detectMirror(true);
              points = detectorResult.getPoints();
              this.reportFoundResultPoints(hints, points);
              decoderResult = new Decoder2().decode(detectorResult);
            } catch (e) {
              if (exception != null) {
                throw exception;
              }
              throw e;
            }
          }
          let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());
          let byteSegments = decoderResult.getByteSegments();
          if (byteSegments != null) {
            result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
          }
          let ecLevel = decoderResult.getECLevel();
          if (ecLevel != null) {
            result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
          }
          return result;
        }
        reportFoundResultPoints(hints, points) {
          if (hints != null) {
            let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            if (rpcb != null) {
              points.forEach((point, idx, arr) => {
                rpcb.foundPossibleResultPoint(point);
              });
            }
          }
        }
        // @Override
        reset() {
        }
      }
      class BrowserAztecCodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserAztecCodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         *
         * @memberOf BrowserAztecCodeReader
         */
        constructor(timeBetweenScansMillis = 500) {
          super(new AztecReader(), timeBetweenScansMillis);
        }
      }
      class OneDReader {
        /*
        @Override
        public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {
          return decode(image, null);
        }
        */
        // Note that we don't try rotation without the try harder flag, even if rotation was supported.
        // @Override
        decode(image, hints) {
          try {
            return this.doDecode(image, hints);
          } catch (nfe) {
            const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
            if (tryHarder && image.isRotateSupported()) {
              const rotatedImage = image.rotateCounterClockwise();
              const result = this.doDecode(rotatedImage, hints);
              const metadata = result.getResultMetadata();
              let orientation = 270;
              if (metadata !== null && metadata.get(ResultMetadataType$1.ORIENTATION) === true) {
                orientation = orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360;
              }
              result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);
              const points = result.getResultPoints();
              if (points !== null) {
                const height = rotatedImage.getHeight();
                for (let i3 = 0; i3 < points.length; i3++) {
                  points[i3] = new ResultPoint(height - points[i3].getY() - 1, points[i3].getX());
                }
              }
              return result;
            } else {
              throw new NotFoundException();
            }
          }
        }
        // @Override
        reset() {
        }
        /**
         * We're going to examine rows from the middle outward, searching alternately above and below the
         * middle, and farther out each time. rowStep is the number of rows between each successive
         * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
         * middle + rowStep, then middle - (2 * rowStep), etc.
         * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
         * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
         * image if "trying harder".
         *
         * @param image The image to decode
         * @param hints Any hints that were requested
         * @return The contents of the decoded barcode
         * @throws NotFoundException Any spontaneous errors which occur
         */
        doDecode(image, hints) {
          const width = image.getWidth();
          const height = image.getHeight();
          let row = new BitArray(width);
          const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
          const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
          let maxLines;
          if (tryHarder) {
            maxLines = height;
          } else {
            maxLines = 15;
          }
          const middle = Math.trunc(height / 2);
          for (let x2 = 0; x2 < maxLines; x2++) {
            const rowStepsAboveOrBelow = Math.trunc((x2 + 1) / 2);
            const isAbove = (x2 & 1) === 0;
            const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
            if (rowNumber < 0 || rowNumber >= height) {
              break;
            }
            try {
              row = image.getBlackRow(rowNumber, row);
            } catch (ignored) {
              continue;
            }
            for (let attempt = 0; attempt < 2; attempt++) {
              if (attempt === 1) {
                row.reverse();
                if (hints && hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true) {
                  const newHints = /* @__PURE__ */ new Map();
                  hints.forEach((hint, key) => newHints.set(key, hint));
                  newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                  hints = newHints;
                }
              }
              try {
                const result = this.decodeRow(rowNumber, row, hints);
                if (attempt === 1) {
                  result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);
                  const points = result.getResultPoints();
                  if (points !== null) {
                    points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());
                    points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());
                  }
                }
                return result;
              } catch (re3) {
              }
            }
          }
          throw new NotFoundException();
        }
        /**
         * Records the size of successive runs of white and black pixels in a row, starting at a given point.
         * The values are recorded in the given array, and the number of runs recorded is equal to the size
         * of the array. If the row starts on a white pixel at the given start point, then the first count
         * recorded is the run of white pixels starting from that point; likewise it is the count of a run
         * of black pixels if the row begin on a black pixels at that point.
         *
         * @param row row to count from
         * @param start offset into row to start at
         * @param counters array into which to record counts
         * @throws NotFoundException if counters cannot be filled entirely from row before running out
         *  of pixels
         */
        static recordPattern(row, start, counters) {
          const numCounters = counters.length;
          for (let index = 0; index < numCounters; index++)
            counters[index] = 0;
          const end = row.getSize();
          if (start >= end) {
            throw new NotFoundException();
          }
          let isWhite = !row.get(start);
          let counterPosition = 0;
          let i3 = start;
          while (i3 < end) {
            if (row.get(i3) !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (++counterPosition === numCounters) {
                break;
              } else {
                counters[counterPosition] = 1;
                isWhite = !isWhite;
              }
            }
            i3++;
          }
          if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i3 === end)) {
            throw new NotFoundException();
          }
        }
        static recordPatternInReverse(row, start, counters) {
          let numTransitionsLeft = counters.length;
          let last = row.get(start);
          while (start > 0 && numTransitionsLeft >= 0) {
            if (row.get(--start) !== last) {
              numTransitionsLeft--;
              last = !last;
            }
          }
          if (numTransitionsLeft >= 0) {
            throw new NotFoundException();
          }
          OneDReader.recordPattern(row, start + 1, counters);
        }
        /**
         * Determines how closely a set of observed counts of runs of black/white values matches a given
         * target pattern. This is reported as the ratio of the total variance from the expected pattern
         * proportions across all pattern elements, to the length of the pattern.
         *
         * @param counters observed counters
         * @param pattern expected pattern
         * @param maxIndividualVariance The most any counter can differ before we give up
         * @return ratio of total variance between counters and pattern compared to total pattern size
         */
        static patternMatchVariance(counters, pattern, maxIndividualVariance) {
          const numCounters = counters.length;
          let total = 0;
          let patternLength = 0;
          for (let i3 = 0; i3 < numCounters; i3++) {
            total += counters[i3];
            patternLength += pattern[i3];
          }
          if (total < patternLength) {
            return Number.POSITIVE_INFINITY;
          }
          const unitBarWidth = total / patternLength;
          maxIndividualVariance *= unitBarWidth;
          let totalVariance = 0;
          for (let x2 = 0; x2 < numCounters; x2++) {
            const counter = counters[x2];
            const scaledPattern = pattern[x2] * unitBarWidth;
            const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
            if (variance > maxIndividualVariance) {
              return Number.POSITIVE_INFINITY;
            }
            totalVariance += variance;
          }
          return totalVariance / total;
        }
      }
      class Code128Reader extends OneDReader {
        static findStartPattern(row) {
          const width = row.getSize();
          const rowOffset = row.getNextSet(0);
          let counterPosition = 0;
          let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
          let patternStart = rowOffset;
          let isWhite = false;
          const patternLength = 6;
          for (let i3 = rowOffset; i3 < width; i3++) {
            if (row.get(i3) !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition === patternLength - 1) {
                let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
                let bestMatch = -1;
                for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                  const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                  if (variance < bestVariance) {
                    bestVariance = variance;
                    bestMatch = startCode;
                  }
                }
                if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i3 - patternStart) / 2), patternStart, false)) {
                  return Int32Array.from([patternStart, i3, bestMatch]);
                }
                patternStart += counters[0] + counters[1];
                counters = counters.slice(2, counters.length - 1);
                counters[counterPosition - 1] = 0;
                counters[counterPosition] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          throw new NotFoundException();
        }
        static decodeCode(row, counters, rowOffset) {
          OneDReader.recordPattern(row, rowOffset, counters);
          let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
          let bestMatch = -1;
          for (let d2 = 0; d2 < Code128Reader.CODE_PATTERNS.length; d2++) {
            const pattern = Code128Reader.CODE_PATTERNS[d2];
            const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
              bestVariance = variance;
              bestMatch = d2;
            }
          }
          if (bestMatch >= 0) {
            return bestMatch;
          } else {
            throw new NotFoundException();
          }
        }
        decodeRow(rowNumber, row, hints) {
          const convertFNC1 = hints && hints.get(DecodeHintType$1.ASSUME_GS1) === true;
          const startPatternInfo = Code128Reader.findStartPattern(row);
          const startCode = startPatternInfo[2];
          let currentRawCodesIndex = 0;
          const rawCodes = new Uint8Array(20);
          rawCodes[currentRawCodesIndex++] = startCode;
          let codeSet;
          switch (startCode) {
            case Code128Reader.CODE_START_A:
              codeSet = Code128Reader.CODE_CODE_A;
              break;
            case Code128Reader.CODE_START_B:
              codeSet = Code128Reader.CODE_CODE_B;
              break;
            case Code128Reader.CODE_START_C:
              codeSet = Code128Reader.CODE_CODE_C;
              break;
            default:
              throw new FormatException();
          }
          let done = false;
          let isNextShifted = false;
          let result = "";
          let lastStart = startPatternInfo[0];
          let nextStart = startPatternInfo[1];
          const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
          let lastCode = 0;
          let code = 0;
          let checksumTotal = startCode;
          let multiplier = 0;
          let lastCharacterWasPrintable = true;
          let upperMode = false;
          let shiftUpperMode = false;
          while (!done) {
            const unshift = isNextShifted;
            isNextShifted = false;
            lastCode = code;
            code = Code128Reader.decodeCode(row, counters, nextStart);
            rawCodes[currentRawCodesIndex++] = code;
            if (code !== Code128Reader.CODE_STOP) {
              lastCharacterWasPrintable = true;
            }
            if (code !== Code128Reader.CODE_STOP) {
              multiplier++;
              checksumTotal += multiplier * code;
            }
            lastStart = nextStart;
            nextStart += counters.reduce((previous, current) => previous + current, 0);
            switch (code) {
              case Code128Reader.CODE_START_A:
              case Code128Reader.CODE_START_B:
              case Code128Reader.CODE_START_C:
                throw new FormatException();
            }
            switch (codeSet) {
              case Code128Reader.CODE_CODE_A:
                if (code < 64) {
                  if (shiftUpperMode === upperMode) {
                    result += String.fromCharCode(" ".charCodeAt(0) + code);
                  } else {
                    result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                  }
                  shiftUpperMode = false;
                } else if (code < 96) {
                  if (shiftUpperMode === upperMode) {
                    result += String.fromCharCode(code - 64);
                  } else {
                    result += String.fromCharCode(code + 64);
                  }
                  shiftUpperMode = false;
                } else {
                  if (code !== Code128Reader.CODE_STOP) {
                    lastCharacterWasPrintable = false;
                  }
                  switch (code) {
                    case Code128Reader.CODE_FNC_1:
                      if (convertFNC1) {
                        if (result.length === 0) {
                          result += "]C1";
                        } else {
                          result += String.fromCharCode(29);
                        }
                      }
                      break;
                    case Code128Reader.CODE_FNC_2:
                    case Code128Reader.CODE_FNC_3:
                      break;
                    case Code128Reader.CODE_FNC_4_A:
                      if (!upperMode && shiftUpperMode) {
                        upperMode = true;
                        shiftUpperMode = false;
                      } else if (upperMode && shiftUpperMode) {
                        upperMode = false;
                        shiftUpperMode = false;
                      } else {
                        shiftUpperMode = true;
                      }
                      break;
                    case Code128Reader.CODE_SHIFT:
                      isNextShifted = true;
                      codeSet = Code128Reader.CODE_CODE_B;
                      break;
                    case Code128Reader.CODE_CODE_B:
                      codeSet = Code128Reader.CODE_CODE_B;
                      break;
                    case Code128Reader.CODE_CODE_C:
                      codeSet = Code128Reader.CODE_CODE_C;
                      break;
                    case Code128Reader.CODE_STOP:
                      done = true;
                      break;
                  }
                }
                break;
              case Code128Reader.CODE_CODE_B:
                if (code < 96) {
                  if (shiftUpperMode === upperMode) {
                    result += String.fromCharCode(" ".charCodeAt(0) + code);
                  } else {
                    result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                  }
                  shiftUpperMode = false;
                } else {
                  if (code !== Code128Reader.CODE_STOP) {
                    lastCharacterWasPrintable = false;
                  }
                  switch (code) {
                    case Code128Reader.CODE_FNC_1:
                      if (convertFNC1) {
                        if (result.length === 0) {
                          result += "]C1";
                        } else {
                          result += String.fromCharCode(29);
                        }
                      }
                      break;
                    case Code128Reader.CODE_FNC_2:
                    case Code128Reader.CODE_FNC_3:
                      break;
                    case Code128Reader.CODE_FNC_4_B:
                      if (!upperMode && shiftUpperMode) {
                        upperMode = true;
                        shiftUpperMode = false;
                      } else if (upperMode && shiftUpperMode) {
                        upperMode = false;
                        shiftUpperMode = false;
                      } else {
                        shiftUpperMode = true;
                      }
                      break;
                    case Code128Reader.CODE_SHIFT:
                      isNextShifted = true;
                      codeSet = Code128Reader.CODE_CODE_A;
                      break;
                    case Code128Reader.CODE_CODE_A:
                      codeSet = Code128Reader.CODE_CODE_A;
                      break;
                    case Code128Reader.CODE_CODE_C:
                      codeSet = Code128Reader.CODE_CODE_C;
                      break;
                    case Code128Reader.CODE_STOP:
                      done = true;
                      break;
                  }
                }
                break;
              case Code128Reader.CODE_CODE_C:
                if (code < 100) {
                  if (code < 10) {
                    result += "0";
                  }
                  result += code;
                } else {
                  if (code !== Code128Reader.CODE_STOP) {
                    lastCharacterWasPrintable = false;
                  }
                  switch (code) {
                    case Code128Reader.CODE_FNC_1:
                      if (convertFNC1) {
                        if (result.length === 0) {
                          result += "]C1";
                        } else {
                          result += String.fromCharCode(29);
                        }
                      }
                      break;
                    case Code128Reader.CODE_CODE_A:
                      codeSet = Code128Reader.CODE_CODE_A;
                      break;
                    case Code128Reader.CODE_CODE_B:
                      codeSet = Code128Reader.CODE_CODE_B;
                      break;
                    case Code128Reader.CODE_STOP:
                      done = true;
                      break;
                  }
                }
                break;
            }
            if (unshift) {
              codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
            }
          }
          const lastPatternSize = nextStart - lastStart;
          nextStart = row.getNextUnset(nextStart);
          if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
            throw new NotFoundException();
          }
          checksumTotal -= multiplier * lastCode;
          if (checksumTotal % 103 !== lastCode) {
            throw new ChecksumException();
          }
          const resultLength = result.length;
          if (resultLength === 0) {
            throw new NotFoundException();
          }
          if (resultLength > 0 && lastCharacterWasPrintable) {
            if (codeSet === Code128Reader.CODE_CODE_C) {
              result = result.substring(0, resultLength - 2);
            } else {
              result = result.substring(0, resultLength - 1);
            }
          }
          const left = (startPatternInfo[1] + startPatternInfo[0]) / 2;
          const right = lastStart + lastPatternSize / 2;
          const rawCodesSize = rawCodes.length;
          const rawBytes = new Uint8Array(rawCodesSize);
          for (let i3 = 0; i3 < rawCodesSize; i3++) {
            rawBytes[i3] = rawCodes[i3];
          }
          const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
          return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, (/* @__PURE__ */ new Date()).getTime());
        }
      }
      Code128Reader.CODE_PATTERNS = [
        Int32Array.from([2, 1, 2, 2, 2, 2]),
        Int32Array.from([2, 2, 2, 1, 2, 2]),
        Int32Array.from([2, 2, 2, 2, 2, 1]),
        Int32Array.from([1, 2, 1, 2, 2, 3]),
        Int32Array.from([1, 2, 1, 3, 2, 2]),
        Int32Array.from([1, 3, 1, 2, 2, 2]),
        Int32Array.from([1, 2, 2, 2, 1, 3]),
        Int32Array.from([1, 2, 2, 3, 1, 2]),
        Int32Array.from([1, 3, 2, 2, 1, 2]),
        Int32Array.from([2, 2, 1, 2, 1, 3]),
        Int32Array.from([2, 2, 1, 3, 1, 2]),
        Int32Array.from([2, 3, 1, 2, 1, 2]),
        Int32Array.from([1, 1, 2, 2, 3, 2]),
        Int32Array.from([1, 2, 2, 1, 3, 2]),
        Int32Array.from([1, 2, 2, 2, 3, 1]),
        Int32Array.from([1, 1, 3, 2, 2, 2]),
        Int32Array.from([1, 2, 3, 1, 2, 2]),
        Int32Array.from([1, 2, 3, 2, 2, 1]),
        Int32Array.from([2, 2, 3, 2, 1, 1]),
        Int32Array.from([2, 2, 1, 1, 3, 2]),
        Int32Array.from([2, 2, 1, 2, 3, 1]),
        Int32Array.from([2, 1, 3, 2, 1, 2]),
        Int32Array.from([2, 2, 3, 1, 1, 2]),
        Int32Array.from([3, 1, 2, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 2, 2, 2]),
        Int32Array.from([3, 2, 1, 1, 2, 2]),
        Int32Array.from([3, 2, 1, 2, 2, 1]),
        Int32Array.from([3, 1, 2, 2, 1, 2]),
        Int32Array.from([3, 2, 2, 1, 1, 2]),
        Int32Array.from([3, 2, 2, 2, 1, 1]),
        Int32Array.from([2, 1, 2, 1, 2, 3]),
        Int32Array.from([2, 1, 2, 3, 2, 1]),
        Int32Array.from([2, 3, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 1, 3, 2, 3]),
        Int32Array.from([1, 3, 1, 1, 2, 3]),
        Int32Array.from([1, 3, 1, 3, 2, 1]),
        Int32Array.from([1, 1, 2, 3, 1, 3]),
        Int32Array.from([1, 3, 2, 1, 1, 3]),
        Int32Array.from([1, 3, 2, 3, 1, 1]),
        Int32Array.from([2, 1, 1, 3, 1, 3]),
        Int32Array.from([2, 3, 1, 1, 1, 3]),
        Int32Array.from([2, 3, 1, 3, 1, 1]),
        Int32Array.from([1, 1, 2, 1, 3, 3]),
        Int32Array.from([1, 1, 2, 3, 3, 1]),
        Int32Array.from([1, 3, 2, 1, 3, 1]),
        Int32Array.from([1, 1, 3, 1, 2, 3]),
        Int32Array.from([1, 1, 3, 3, 2, 1]),
        Int32Array.from([1, 3, 3, 1, 2, 1]),
        Int32Array.from([3, 1, 3, 1, 2, 1]),
        Int32Array.from([2, 1, 1, 3, 3, 1]),
        Int32Array.from([2, 3, 1, 1, 3, 1]),
        Int32Array.from([2, 1, 3, 1, 1, 3]),
        Int32Array.from([2, 1, 3, 3, 1, 1]),
        Int32Array.from([2, 1, 3, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 2, 3]),
        Int32Array.from([3, 1, 1, 3, 2, 1]),
        Int32Array.from([3, 3, 1, 1, 2, 1]),
        Int32Array.from([3, 1, 2, 1, 1, 3]),
        Int32Array.from([3, 1, 2, 3, 1, 1]),
        Int32Array.from([3, 3, 2, 1, 1, 1]),
        Int32Array.from([3, 1, 4, 1, 1, 1]),
        Int32Array.from([2, 2, 1, 4, 1, 1]),
        Int32Array.from([4, 3, 1, 1, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 2, 4]),
        Int32Array.from([1, 1, 1, 4, 2, 2]),
        Int32Array.from([1, 2, 1, 1, 2, 4]),
        Int32Array.from([1, 2, 1, 4, 2, 1]),
        Int32Array.from([1, 4, 1, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 2, 2, 1]),
        Int32Array.from([1, 1, 2, 2, 1, 4]),
        Int32Array.from([1, 1, 2, 4, 1, 2]),
        Int32Array.from([1, 2, 2, 1, 1, 4]),
        Int32Array.from([1, 2, 2, 4, 1, 1]),
        Int32Array.from([1, 4, 2, 1, 1, 2]),
        Int32Array.from([1, 4, 2, 2, 1, 1]),
        Int32Array.from([2, 4, 1, 2, 1, 1]),
        Int32Array.from([2, 2, 1, 1, 1, 4]),
        Int32Array.from([4, 1, 3, 1, 1, 1]),
        Int32Array.from([2, 4, 1, 1, 1, 2]),
        Int32Array.from([1, 3, 4, 1, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 4, 2]),
        Int32Array.from([1, 2, 1, 1, 4, 2]),
        Int32Array.from([1, 2, 1, 2, 4, 1]),
        Int32Array.from([1, 1, 4, 2, 1, 2]),
        Int32Array.from([1, 2, 4, 1, 1, 2]),
        Int32Array.from([1, 2, 4, 2, 1, 1]),
        Int32Array.from([4, 1, 1, 2, 1, 2]),
        Int32Array.from([4, 2, 1, 1, 1, 2]),
        Int32Array.from([4, 2, 1, 2, 1, 1]),
        Int32Array.from([2, 1, 2, 1, 4, 1]),
        Int32Array.from([2, 1, 4, 1, 2, 1]),
        Int32Array.from([4, 1, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 1, 1, 4, 3]),
        Int32Array.from([1, 1, 1, 3, 4, 1]),
        Int32Array.from([1, 3, 1, 1, 4, 1]),
        Int32Array.from([1, 1, 4, 1, 1, 3]),
        Int32Array.from([1, 1, 4, 3, 1, 1]),
        Int32Array.from([4, 1, 1, 1, 1, 3]),
        Int32Array.from([4, 1, 1, 3, 1, 1]),
        Int32Array.from([1, 1, 3, 1, 4, 1]),
        Int32Array.from([1, 1, 4, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 4, 1]),
        Int32Array.from([4, 1, 1, 1, 3, 1]),
        Int32Array.from([2, 1, 1, 4, 1, 2]),
        Int32Array.from([2, 1, 1, 2, 1, 4]),
        Int32Array.from([2, 1, 1, 2, 3, 2]),
        Int32Array.from([2, 3, 3, 1, 1, 1, 2])
      ];
      Code128Reader.MAX_AVG_VARIANCE = 0.25;
      Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
      Code128Reader.CODE_SHIFT = 98;
      Code128Reader.CODE_CODE_C = 99;
      Code128Reader.CODE_CODE_B = 100;
      Code128Reader.CODE_CODE_A = 101;
      Code128Reader.CODE_FNC_1 = 102;
      Code128Reader.CODE_FNC_2 = 97;
      Code128Reader.CODE_FNC_3 = 96;
      Code128Reader.CODE_FNC_4_A = 101;
      Code128Reader.CODE_FNC_4_B = 100;
      Code128Reader.CODE_START_A = 103;
      Code128Reader.CODE_START_B = 104;
      Code128Reader.CODE_START_C = 105;
      Code128Reader.CODE_STOP = 106;
      class Code39Reader extends OneDReader {
        /**
         * Creates a reader that assumes all encoded data is data, and does not treat the final
         * character as a check digit. It will not decoded "extended Code 39" sequences.
         */
        // public Code39Reader() {
        //   this(false);
        // }
        /**
         * Creates a reader that can be configured to check the last character as a check digit.
         * It will not decoded "extended Code 39" sequences.
         *
         * @param usingCheckDigit if true, treat the last data character as a check digit, not
         * data, and verify that the checksum passes.
         */
        // public Code39Reader(boolean usingCheckDigit) {
        //   this(usingCheckDigit, false);
        // }
        /**
         * Creates a reader that can be configured to check the last character as a check digit,
         * or optionally attempt to decode "extended Code 39" sequences that are used to encode
         * the full ASCII character set.
         *
         * @param usingCheckDigit if true, treat the last data character as a check digit, not
         * data, and verify that the checksum passes.
         * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the
         * text.
         */
        constructor(usingCheckDigit = false, extendedMode = false) {
          super();
          this.usingCheckDigit = usingCheckDigit;
          this.extendedMode = extendedMode;
          this.decodeRowResult = "";
          this.counters = new Int32Array(9);
        }
        decodeRow(rowNumber, row, hints) {
          let theCounters = this.counters;
          theCounters.fill(0);
          this.decodeRowResult = "";
          let start = Code39Reader.findAsteriskPattern(row, theCounters);
          let nextStart = row.getNextSet(start[1]);
          let end = row.getSize();
          let decodedChar;
          let lastStart;
          do {
            Code39Reader.recordPattern(row, nextStart, theCounters);
            let pattern = Code39Reader.toNarrowWidePattern(theCounters);
            if (pattern < 0) {
              throw new NotFoundException();
            }
            decodedChar = Code39Reader.patternToChar(pattern);
            this.decodeRowResult += decodedChar;
            lastStart = nextStart;
            for (let counter of theCounters) {
              nextStart += counter;
            }
            nextStart = row.getNextSet(nextStart);
          } while (decodedChar !== "*");
          this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
          let lastPatternSize = 0;
          for (let counter of theCounters) {
            lastPatternSize += counter;
          }
          let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
          if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {
            throw new NotFoundException();
          }
          if (this.usingCheckDigit) {
            let max2 = this.decodeRowResult.length - 1;
            let total = 0;
            for (let i3 = 0; i3 < max2; i3++) {
              total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i3));
            }
            if (this.decodeRowResult.charAt(max2) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
              throw new ChecksumException();
            }
            this.decodeRowResult = this.decodeRowResult.substring(0, max2);
          }
          if (this.decodeRowResult.length === 0) {
            throw new NotFoundException();
          }
          let resultString;
          if (this.extendedMode) {
            resultString = Code39Reader.decodeExtended(this.decodeRowResult);
          } else {
            resultString = this.decodeRowResult;
          }
          let left = (start[1] + start[0]) / 2;
          let right = lastStart + lastPatternSize / 2;
          return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, (/* @__PURE__ */ new Date()).getTime());
        }
        static findAsteriskPattern(row, counters) {
          let width = row.getSize();
          let rowOffset = row.getNextSet(0);
          let counterPosition = 0;
          let patternStart = rowOffset;
          let isWhite = false;
          let patternLength = counters.length;
          for (let i3 = rowOffset; i3 < width; i3++) {
            if (row.get(i3) !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition === patternLength - 1) {
                if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i3 - patternStart) / 2)), patternStart, false)) {
                  return [patternStart, i3];
                }
                patternStart += counters[0] + counters[1];
                counters.copyWithin(0, 2, 2 + counterPosition - 1);
                counters[counterPosition - 1] = 0;
                counters[counterPosition] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          throw new NotFoundException();
        }
        // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions
        // per image when using some of our blackbox images.
        static toNarrowWidePattern(counters) {
          let numCounters = counters.length;
          let maxNarrowCounter = 0;
          let wideCounters;
          do {
            let minCounter = 2147483647;
            for (let counter of counters) {
              if (counter < minCounter && counter > maxNarrowCounter) {
                minCounter = counter;
              }
            }
            maxNarrowCounter = minCounter;
            wideCounters = 0;
            let totalWideCountersWidth = 0;
            let pattern = 0;
            for (let i3 = 0; i3 < numCounters; i3++) {
              let counter = counters[i3];
              if (counter > maxNarrowCounter) {
                pattern |= 1 << numCounters - 1 - i3;
                wideCounters++;
                totalWideCountersWidth += counter;
              }
            }
            if (wideCounters === 3) {
              for (let i3 = 0; i3 < numCounters && wideCounters > 0; i3++) {
                let counter = counters[i3];
                if (counter > maxNarrowCounter) {
                  wideCounters--;
                  if (counter * 2 >= totalWideCountersWidth) {
                    return -1;
                  }
                }
              }
              return pattern;
            }
          } while (wideCounters > 3);
          return -1;
        }
        static patternToChar(pattern) {
          for (let i3 = 0; i3 < Code39Reader.CHARACTER_ENCODINGS.length; i3++) {
            if (Code39Reader.CHARACTER_ENCODINGS[i3] === pattern) {
              return Code39Reader.ALPHABET_STRING.charAt(i3);
            }
          }
          if (pattern === Code39Reader.ASTERISK_ENCODING) {
            return "*";
          }
          throw new NotFoundException();
        }
        static decodeExtended(encoded) {
          let length2 = encoded.length;
          let decoded = "";
          for (let i3 = 0; i3 < length2; i3++) {
            let c2 = encoded.charAt(i3);
            if (c2 === "+" || c2 === "$" || c2 === "%" || c2 === "/") {
              let next = encoded.charAt(i3 + 1);
              let decodedChar = "\0";
              switch (c2) {
                case "+":
                  if (next >= "A" && next <= "Z") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                  } else {
                    throw new FormatException();
                  }
                  break;
                case "$":
                  if (next >= "A" && next <= "Z") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                  } else {
                    throw new FormatException();
                  }
                  break;
                case "%":
                  if (next >= "A" && next <= "E") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                  } else if (next >= "F" && next <= "J") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                  } else if (next >= "K" && next <= "O") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                  } else if (next >= "P" && next <= "T") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                  } else if (next === "U") {
                    decodedChar = "\0";
                  } else if (next === "V") {
                    decodedChar = "@";
                  } else if (next === "W") {
                    decodedChar = "`";
                  } else if (next === "X" || next === "Y" || next === "Z") {
                    decodedChar = "\x7F";
                  } else {
                    throw new FormatException();
                  }
                  break;
                case "/":
                  if (next >= "A" && next <= "O") {
                    decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                  } else if (next === "Z") {
                    decodedChar = ":";
                  } else {
                    throw new FormatException();
                  }
                  break;
              }
              decoded += decodedChar;
              i3++;
            } else {
              decoded += c2;
            }
          }
          return decoded;
        }
      }
      Code39Reader.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
      Code39Reader.CHARACTER_ENCODINGS = [
        52,
        289,
        97,
        352,
        49,
        304,
        112,
        37,
        292,
        100,
        265,
        73,
        328,
        25,
        280,
        88,
        13,
        268,
        76,
        28,
        259,
        67,
        322,
        19,
        274,
        82,
        7,
        262,
        70,
        22,
        385,
        193,
        448,
        145,
        400,
        208,
        133,
        388,
        196,
        168,
        162,
        138,
        42
        // /-%
      ];
      Code39Reader.ASTERISK_ENCODING = 148;
      class ITFReader extends OneDReader {
        constructor() {
          super(...arguments);
          this.narrowLineWidth = -1;
        }
        // See ITFWriter.PATTERNS
        /*
        
          /!**
           * Patterns of Wide / Narrow lines to indicate each digit
           *!/
          */
        decodeRow(rowNumber, row, hints) {
          let startRange = this.decodeStart(row);
          let endRange = this.decodeEnd(row);
          let result = new StringBuilder();
          ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
          let resultString = result.toString();
          let allowedLengths = null;
          if (hints != null) {
            allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
          }
          if (allowedLengths == null) {
            allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
          }
          let length2 = resultString.length;
          let lengthOK = false;
          let maxAllowedLength = 0;
          for (let value2 of allowedLengths) {
            if (length2 === value2) {
              lengthOK = true;
              break;
            }
            if (value2 > maxAllowedLength) {
              maxAllowedLength = value2;
            }
          }
          if (!lengthOK && length2 > maxAllowedLength) {
            lengthOK = true;
          }
          if (!lengthOK) {
            throw new FormatException();
          }
          const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];
          let resultReturn = new Result(
            resultString,
            null,
            // no natural byte representation for these barcodes
            0,
            points,
            BarcodeFormat$1.ITF,
            (/* @__PURE__ */ new Date()).getTime()
          );
          return resultReturn;
        }
        /*
        /!**
         * @param row          row of black/white values to search
         * @param payloadStart offset of start pattern
         * @param resultString {@link StringBuilder} to append decoded chars to
         * @throws NotFoundException if decoding could not complete successfully
         *!/*/
        static decodeMiddle(row, payloadStart, payloadEnd, resultString) {
          let counterDigitPair = new Int32Array(10);
          let counterBlack = new Int32Array(5);
          let counterWhite = new Int32Array(5);
          counterDigitPair.fill(0);
          counterBlack.fill(0);
          counterWhite.fill(0);
          while (payloadStart < payloadEnd) {
            OneDReader.recordPattern(row, payloadStart, counterDigitPair);
            for (let k2 = 0; k2 < 5; k2++) {
              let twoK = 2 * k2;
              counterBlack[k2] = counterDigitPair[twoK];
              counterWhite[k2] = counterDigitPair[twoK + 1];
            }
            let bestMatch = ITFReader.decodeDigit(counterBlack);
            resultString.append(bestMatch.toString());
            bestMatch = this.decodeDigit(counterWhite);
            resultString.append(bestMatch.toString());
            counterDigitPair.forEach(function(counterDigit) {
              payloadStart += counterDigit;
            });
          }
        }
        /*/!**
         * Identify where the start of the middle / payload section starts.
         *
         * @param row row of black/white values to search
         * @return Array, containing index of start of 'start block' and end of
         *         'start block'
         *!/*/
        decodeStart(row) {
          let endStart = ITFReader.skipWhiteSpace(row);
          let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
          this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
          this.validateQuietZone(row, startPattern[0]);
          return startPattern;
        }
        /*/!**
         * The start & end patterns must be pre/post fixed by a quiet zone. This
         * zone must be at least 10 times the width of a narrow line.  Scan back until
         * we either get to the start of the barcode or match the necessary number of
         * quiet zone pixels.
         *
         * Note: Its assumed the row is reversed when using this method to find
         * quiet zone after the end pattern.
         *
         * ref: http://www.barcode-1.net/i25code.html
         *
         * @param row bit array representing the scanned barcode.
         * @param startPattern index into row of the start or end pattern.
         * @throws NotFoundException if the quiet zone cannot be found
         *!/*/
        validateQuietZone(row, startPattern) {
          let quietCount = this.narrowLineWidth * 10;
          quietCount = quietCount < startPattern ? quietCount : startPattern;
          for (let i3 = startPattern - 1; quietCount > 0 && i3 >= 0; i3--) {
            if (row.get(i3)) {
              break;
            }
            quietCount--;
          }
          if (quietCount !== 0) {
            throw new NotFoundException();
          }
        }
        /*
        /!**
         * Skip all whitespace until we get to the first black line.
         *
         * @param row row of black/white values to search
         * @return index of the first black line.
         * @throws NotFoundException Throws exception if no black lines are found in the row
         *!/*/
        static skipWhiteSpace(row) {
          const width = row.getSize();
          const endStart = row.getNextSet(0);
          if (endStart === width) {
            throw new NotFoundException();
          }
          return endStart;
        }
        /*/!**
         * Identify where the end of the middle / payload section ends.
         *
         * @param row row of black/white values to search
         * @return Array, containing index of start of 'end block' and end of 'end
         *         block'
         *!/*/
        decodeEnd(row) {
          row.reverse();
          try {
            let endStart = ITFReader.skipWhiteSpace(row);
            let endPattern;
            try {
              endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
            } catch (error) {
              if (error instanceof NotFoundException) {
                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
              }
            }
            this.validateQuietZone(row, endPattern[0]);
            let temp = endPattern[0];
            endPattern[0] = row.getSize() - endPattern[1];
            endPattern[1] = row.getSize() - temp;
            return endPattern;
          } finally {
            row.reverse();
          }
        }
        /*
        /!**
         * @param row       row of black/white values to search
         * @param rowOffset position to start search
         * @param pattern   pattern of counts of number of black and white pixels that are
         *                  being searched for as a pattern
         * @return start/end horizontal offset of guard pattern, as an array of two
         *         ints
         * @throws NotFoundException if pattern is not found
         *!/*/
        static findGuardPattern(row, rowOffset, pattern) {
          let patternLength = pattern.length;
          let counters = new Int32Array(patternLength);
          let width = row.getSize();
          let isWhite = false;
          let counterPosition = 0;
          let patternStart = rowOffset;
          counters.fill(0);
          for (let x2 = rowOffset; x2 < width; x2++) {
            if (row.get(x2) !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition === patternLength - 1) {
                if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                  return [patternStart, x2];
                }
                patternStart += counters[0] + counters[1];
                System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                counters[counterPosition - 1] = 0;
                counters[counterPosition] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          throw new NotFoundException();
        }
        /*/!**
         * Attempts to decode a sequence of ITF black/white lines into single
         * digit.
         *
         * @param counters the counts of runs of observed black/white/black/... values
         * @return The decoded digit
         * @throws NotFoundException if digit cannot be decoded
         *!/*/
        static decodeDigit(counters) {
          let bestVariance = ITFReader.MAX_AVG_VARIANCE;
          let bestMatch = -1;
          let max2 = ITFReader.PATTERNS.length;
          for (let i3 = 0; i3 < max2; i3++) {
            let pattern = ITFReader.PATTERNS[i3];
            let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
              bestVariance = variance;
              bestMatch = i3;
            } else if (variance === bestVariance) {
              bestMatch = -1;
            }
          }
          if (bestMatch >= 0) {
            return bestMatch % 10;
          } else {
            throw new NotFoundException();
          }
        }
      }
      ITFReader.PATTERNS = [
        Int32Array.from([1, 1, 2, 2, 1]),
        Int32Array.from([2, 1, 1, 1, 2]),
        Int32Array.from([1, 2, 1, 1, 2]),
        Int32Array.from([2, 2, 1, 1, 1]),
        Int32Array.from([1, 1, 2, 1, 2]),
        Int32Array.from([2, 1, 2, 1, 1]),
        Int32Array.from([1, 2, 2, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 2]),
        Int32Array.from([2, 1, 1, 2, 1]),
        Int32Array.from([1, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 3, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 3]),
        Int32Array.from([1, 3, 1, 1, 3]),
        Int32Array.from([3, 3, 1, 1, 1]),
        Int32Array.from([1, 1, 3, 1, 3]),
        Int32Array.from([3, 1, 3, 1, 1]),
        Int32Array.from([1, 3, 3, 1, 1]),
        Int32Array.from([1, 1, 1, 3, 3]),
        Int32Array.from([3, 1, 1, 3, 1]),
        Int32Array.from([1, 3, 1, 3, 1])
        // 9
      ];
      ITFReader.MAX_AVG_VARIANCE = 0.38;
      ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
      ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
      ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
      ITFReader.END_PATTERN_REVERSED = [
        Int32Array.from([1, 1, 2]),
        Int32Array.from([1, 1, 3])
        // 3x
      ];
      class AbstractUPCEANReader extends OneDReader {
        constructor() {
          super(...arguments);
          this.decodeRowStringBuffer = "";
        }
        static findStartGuardPattern(row) {
          let foundStart = false;
          let startRange;
          let nextStart = 0;
          let counters = Int32Array.from([0, 0, 0]);
          while (!foundStart) {
            counters = Int32Array.from([0, 0, 0]);
            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
            let start = startRange[0];
            nextStart = startRange[1];
            let quietStart = start - (nextStart - start);
            if (quietStart >= 0) {
              foundStart = row.isRange(quietStart, start, false);
            }
          }
          return startRange;
        }
        static checkChecksum(s2) {
          return AbstractUPCEANReader.checkStandardUPCEANChecksum(s2);
        }
        static checkStandardUPCEANChecksum(s2) {
          let length2 = s2.length;
          if (length2 === 0)
            return false;
          let check = parseInt(s2.charAt(length2 - 1), 10);
          return AbstractUPCEANReader.getStandardUPCEANChecksum(s2.substring(0, length2 - 1)) === check;
        }
        static getStandardUPCEANChecksum(s2) {
          let length2 = s2.length;
          let sum = 0;
          for (let i3 = length2 - 1; i3 >= 0; i3 -= 2) {
            let digit = s2.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
            if (digit < 0 || digit > 9) {
              throw new FormatException();
            }
            sum += digit;
          }
          sum *= 3;
          for (let i3 = length2 - 2; i3 >= 0; i3 -= 2) {
            let digit = s2.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
            if (digit < 0 || digit > 9) {
              throw new FormatException();
            }
            sum += digit;
          }
          return (1e3 - sum) % 10;
        }
        static decodeEnd(row, endStart) {
          return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
        }
        /**
         * @throws NotFoundException
         */
        static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {
          return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
        }
        /**
         * @param row row of black/white values to search
         * @param rowOffset position to start search
         * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...
         * pixel counts, otherwise, it is interpreted as black/white/black/...
         * @param pattern pattern of counts of number of black and white pixels that are being
         * searched for as a pattern
         * @param counters array of counters, as long as pattern, to re-use
         * @return start/end horizontal offset of guard pattern, as an array of two ints
         * @throws NotFoundException if pattern is not found
         */
        static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {
          let width = row.getSize();
          rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
          let counterPosition = 0;
          let patternStart = rowOffset;
          let patternLength = pattern.length;
          let isWhite = whiteFirst;
          for (let x2 = rowOffset; x2 < width; x2++) {
            if (row.get(x2) !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition === patternLength - 1) {
                if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                  return Int32Array.from([patternStart, x2]);
                }
                patternStart += counters[0] + counters[1];
                let slice = counters.slice(2, counters.length - 1);
                for (let i3 = 0; i3 < counterPosition - 1; i3++) {
                  counters[i3] = slice[i3];
                }
                counters[counterPosition - 1] = 0;
                counters[counterPosition] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          throw new NotFoundException();
        }
        static decodeDigit(row, counters, rowOffset, patterns) {
          this.recordPattern(row, rowOffset, counters);
          let bestVariance = this.MAX_AVG_VARIANCE;
          let bestMatch = -1;
          let max2 = patterns.length;
          for (let i3 = 0; i3 < max2; i3++) {
            let pattern = patterns[i3];
            let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
              bestVariance = variance;
              bestMatch = i3;
            }
          }
          if (bestMatch >= 0) {
            return bestMatch;
          } else {
            throw new NotFoundException();
          }
        }
      }
      AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
      AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
      AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);
      AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
      AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
      AbstractUPCEANReader.L_PATTERNS = [
        Int32Array.from([3, 2, 1, 1]),
        Int32Array.from([2, 2, 2, 1]),
        Int32Array.from([2, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 1]),
        Int32Array.from([1, 1, 3, 2]),
        Int32Array.from([1, 2, 3, 1]),
        Int32Array.from([1, 1, 1, 4]),
        Int32Array.from([1, 3, 1, 2]),
        Int32Array.from([1, 2, 1, 3]),
        Int32Array.from([3, 1, 1, 2])
      ];
      class UPCEANExtension5Support {
        constructor() {
          this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
          this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
          this.decodeRowStringBuffer = "";
        }
        decodeRow(rowNumber, row, extensionStartRange) {
          let result = this.decodeRowStringBuffer;
          let end = this.decodeMiddle(row, extensionStartRange, result);
          let resultString = result.toString();
          let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
          let resultPoints = [
            new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
            new ResultPoint(end, rowNumber)
          ];
          let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
          if (extensionData != null) {
            extensionResult.putAllMetadata(extensionData);
          }
          return extensionResult;
        }
        decodeMiddle(row, startRange, resultString) {
          let counters = this.decodeMiddleCounters;
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          let end = row.getSize();
          let rowOffset = startRange[1];
          let lgPatternFound = 0;
          for (let x2 = 0; x2 < 5 && rowOffset < end; x2++) {
            let bestMatch = AbstractUPCEANReader.decodeDigit(
              row,
              counters,
              rowOffset,
              AbstractUPCEANReader.L_AND_G_PATTERNS
            );
            resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
            for (let counter of counters) {
              rowOffset += counter;
            }
            if (bestMatch >= 10) {
              lgPatternFound |= 1 << 4 - x2;
            }
            if (x2 !== 4) {
              rowOffset = row.getNextSet(rowOffset);
              rowOffset = row.getNextUnset(rowOffset);
            }
          }
          if (resultString.length !== 5) {
            throw new NotFoundException();
          }
          let checkDigit = this.determineCheckDigit(lgPatternFound);
          if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
            throw new NotFoundException();
          }
          return rowOffset;
        }
        static extensionChecksum(s2) {
          let length2 = s2.length;
          let sum = 0;
          for (let i3 = length2 - 2; i3 >= 0; i3 -= 2) {
            sum += s2.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          }
          sum *= 3;
          for (let i3 = length2 - 1; i3 >= 0; i3 -= 2) {
            sum += s2.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          }
          sum *= 3;
          return sum % 10;
        }
        determineCheckDigit(lgPatternFound) {
          for (let d2 = 0; d2 < 10; d2++) {
            if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d2]) {
              return d2;
            }
          }
          throw new NotFoundException();
        }
        static parseExtensionString(raw) {
          if (raw.length !== 5) {
            return null;
          }
          let value2 = UPCEANExtension5Support.parseExtension5String(raw);
          if (value2 == null) {
            return null;
          }
          return /* @__PURE__ */ new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value2]]);
        }
        static parseExtension5String(raw) {
          let currency;
          switch (raw.charAt(0)) {
            case "0":
              currency = "\xA3";
              break;
            case "5":
              currency = "$";
              break;
            case "9":
              switch (raw) {
                case "90000":
                  return null;
                case "99991":
                  return "0.00";
                case "99990":
                  return "Used";
              }
              currency = "";
              break;
            default:
              currency = "";
              break;
          }
          let rawAmount = parseInt(raw.substring(1));
          let unitsString = (rawAmount / 100).toString();
          let hundredths = rawAmount % 100;
          let hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
          return currency + unitsString + "." + hundredthsString;
        }
      }
      class UPCEANExtension2Support {
        constructor() {
          this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
          this.decodeRowStringBuffer = "";
        }
        decodeRow(rowNumber, row, extensionStartRange) {
          let result = this.decodeRowStringBuffer;
          let end = this.decodeMiddle(row, extensionStartRange, result);
          let resultString = result.toString();
          let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
          let resultPoints = [
            new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
            new ResultPoint(end, rowNumber)
          ];
          let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
          if (extensionData != null) {
            extensionResult.putAllMetadata(extensionData);
          }
          return extensionResult;
        }
        decodeMiddle(row, startRange, resultString) {
          let counters = this.decodeMiddleCounters;
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          let end = row.getSize();
          let rowOffset = startRange[1];
          let checkParity = 0;
          for (let x2 = 0; x2 < 2 && rowOffset < end; x2++) {
            let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
            resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
            for (let counter of counters) {
              rowOffset += counter;
            }
            if (bestMatch >= 10) {
              checkParity |= 1 << 1 - x2;
            }
            if (x2 !== 1) {
              rowOffset = row.getNextSet(rowOffset);
              rowOffset = row.getNextUnset(rowOffset);
            }
          }
          if (resultString.length !== 2) {
            throw new NotFoundException();
          }
          if (parseInt(resultString.toString()) % 4 !== checkParity) {
            throw new NotFoundException();
          }
          return rowOffset;
        }
        static parseExtensionString(raw) {
          if (raw.length !== 2) {
            return null;
          }
          return /* @__PURE__ */ new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);
        }
      }
      class UPCEANExtensionSupport {
        static decodeRow(rowNumber, row, rowOffset) {
          let extensionStartRange = AbstractUPCEANReader.findGuardPattern(
            row,
            rowOffset,
            false,
            this.EXTENSION_START_PATTERN,
            new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0)
          );
          try {
            let fiveSupport = new UPCEANExtension5Support();
            return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
          } catch (err) {
            let twoSupport = new UPCEANExtension2Support();
            return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
          }
        }
      }
      UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
      class UPCEANReader extends AbstractUPCEANReader {
        constructor() {
          super();
          this.decodeRowStringBuffer = "";
          UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map((arr) => Int32Array.from(arr));
          for (let i3 = 10; i3 < 20; i3++) {
            let widths = UPCEANReader.L_PATTERNS[i3 - 10];
            let reversedWidths = new Int32Array(widths.length);
            for (let j2 = 0; j2 < widths.length; j2++) {
              reversedWidths[j2] = widths[widths.length - j2 - 1];
            }
            UPCEANReader.L_AND_G_PATTERNS[i3] = reversedWidths;
          }
        }
        decodeRow(rowNumber, row, hints) {
          let startGuardRange = UPCEANReader.findStartGuardPattern(row);
          let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (resultPointCallback != null) {
            const resultPoint2 = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
            resultPointCallback.foundPossibleResultPoint(resultPoint2);
          }
          let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
          let endStart = budello.rowOffset;
          let result = budello.resultString;
          if (resultPointCallback != null) {
            const resultPoint2 = new ResultPoint(endStart, rowNumber);
            resultPointCallback.foundPossibleResultPoint(resultPoint2);
          }
          let endRange = this.decodeEnd(row, endStart);
          if (resultPointCallback != null) {
            const resultPoint2 = new ResultPoint((endRange[0] + endRange[1]) / 2, rowNumber);
            resultPointCallback.foundPossibleResultPoint(resultPoint2);
          }
          let end = endRange[1];
          let quietEnd = end + (end - endRange[0]);
          if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
            throw new NotFoundException();
          }
          let resultString = result.toString();
          if (resultString.length < 8) {
            throw new FormatException();
          }
          if (!UPCEANReader.checkChecksum(resultString)) {
            throw new ChecksumException();
          }
          let left = (startGuardRange[1] + startGuardRange[0]) / 2;
          let right = (endRange[1] + endRange[0]) / 2;
          let format = this.getBarcodeFormat();
          let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
          let decodeResult = new Result(resultString, null, 0, resultPoint, format, (/* @__PURE__ */ new Date()).getTime());
          let extensionLength = 0;
          try {
            let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);
            decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());
            decodeResult.putAllMetadata(extensionResult.getResultMetadata());
            decodeResult.addResultPoints(extensionResult.getResultPoints());
            extensionLength = extensionResult.getText().length;
          } catch (ignoreError) {
          }
          let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
          if (allowedExtensions != null) {
            let valid = false;
            for (let length2 in allowedExtensions) {
              if (extensionLength.toString() === length2) {
                valid = true;
                break;
              }
            }
            if (!valid) {
              throw new NotFoundException();
            }
          }
          return decodeResult;
        }
        decodeEnd(row, endStart) {
          return UPCEANReader.findGuardPattern(
            row,
            endStart,
            false,
            UPCEANReader.START_END_PATTERN,
            new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0)
          );
        }
        static checkChecksum(s2) {
          return UPCEANReader.checkStandardUPCEANChecksum(s2);
        }
        static checkStandardUPCEANChecksum(s2) {
          let length2 = s2.length;
          if (length2 === 0)
            return false;
          let check = parseInt(s2.charAt(length2 - 1), 10);
          return UPCEANReader.getStandardUPCEANChecksum(s2.substring(0, length2 - 1)) === check;
        }
        static getStandardUPCEANChecksum(s2) {
          let length2 = s2.length;
          let sum = 0;
          for (let i3 = length2 - 1; i3 >= 0; i3 -= 2) {
            let digit = s2.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
            if (digit < 0 || digit > 9) {
              throw new FormatException();
            }
            sum += digit;
          }
          sum *= 3;
          for (let i3 = length2 - 2; i3 >= 0; i3 -= 2) {
            let digit = s2.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
            if (digit < 0 || digit > 9) {
              throw new FormatException();
            }
            sum += digit;
          }
          return (1e3 - sum) % 10;
        }
      }
      class EAN13Reader extends UPCEANReader {
        constructor() {
          super();
          this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        }
        decodeMiddle(row, startRange, resultString) {
          let counters = this.decodeMiddleCounters;
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          let end = row.getSize();
          let rowOffset = startRange[1];
          let lgPatternFound = 0;
          for (let x2 = 0; x2 < 6 && rowOffset < end; x2++) {
            let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);
            resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
            for (let counter of counters) {
              rowOffset += counter;
            }
            if (bestMatch >= 10) {
              lgPatternFound |= 1 << 5 - x2;
            }
          }
          resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
          let middleRange = UPCEANReader.findGuardPattern(
            row,
            rowOffset,
            true,
            UPCEANReader.MIDDLE_PATTERN,
            new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0)
          );
          rowOffset = middleRange[1];
          for (let x2 = 0; x2 < 6 && rowOffset < end; x2++) {
            let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
            resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
            for (let counter of counters) {
              rowOffset += counter;
            }
          }
          return { rowOffset, resultString };
        }
        getBarcodeFormat() {
          return BarcodeFormat$1.EAN_13;
        }
        static determineFirstDigit(resultString, lgPatternFound) {
          for (let d2 = 0; d2 < 10; d2++) {
            if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d2]) {
              resultString = String.fromCharCode("0".charCodeAt(0) + d2) + resultString;
              return resultString;
            }
          }
          throw new NotFoundException();
        }
      }
      EAN13Reader.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
      class EAN8Reader extends UPCEANReader {
        constructor() {
          super();
          this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        }
        decodeMiddle(row, startRange, resultString) {
          const counters = this.decodeMiddleCounters;
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          let end = row.getSize();
          let rowOffset = startRange[1];
          for (let x2 = 0; x2 < 4 && rowOffset < end; x2++) {
            let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
            resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
            for (let counter of counters) {
              rowOffset += counter;
            }
          }
          let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
          rowOffset = middleRange[1];
          for (let x2 = 0; x2 < 4 && rowOffset < end; x2++) {
            let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
            resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
            for (let counter of counters) {
              rowOffset += counter;
            }
          }
          return { rowOffset, resultString };
        }
        getBarcodeFormat() {
          return BarcodeFormat$1.EAN_8;
        }
      }
      class UPCAReader extends UPCEANReader {
        constructor() {
          super(...arguments);
          this.ean13Reader = new EAN13Reader();
        }
        // @Override
        getBarcodeFormat() {
          return BarcodeFormat$1.UPC_A;
        }
        // Note that we don't try rotation without the try harder flag, even if rotation was supported.
        // @Override
        decode(image, hints) {
          return this.maybeReturnResult(this.ean13Reader.decode(image));
        }
        // @Override
        decodeRow(rowNumber, row, hints) {
          return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
        }
        // @Override
        decodeMiddle(row, startRange, resultString) {
          return this.ean13Reader.decodeMiddle(row, startRange, resultString);
        }
        maybeReturnResult(result) {
          let text = result.getText();
          if (text.charAt(0) === "0") {
            let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
            if (result.getResultMetadata() != null) {
              upcaResult.putAllMetadata(result.getResultMetadata());
            }
            return upcaResult;
          } else {
            throw new NotFoundException();
          }
        }
        reset() {
          this.ean13Reader.reset();
        }
      }
      class UPCEReader extends UPCEANReader {
        constructor() {
          super();
          this.decodeMiddleCounters = new Int32Array(4);
        }
        /**
         * @throws NotFoundException
         */
        // @Override
        decodeMiddle(row, startRange, result) {
          const counters = this.decodeMiddleCounters.map((x2) => x2);
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          const end = row.getSize();
          let rowOffset = startRange[1];
          let lgPatternFound = 0;
          for (let x2 = 0; x2 < 6 && rowOffset < end; x2++) {
            const bestMatch = UPCEReader.decodeDigit(
              row,
              counters,
              rowOffset,
              UPCEReader.L_AND_G_PATTERNS
            );
            result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
            for (let counter of counters) {
              rowOffset += counter;
            }
            if (bestMatch >= 10) {
              lgPatternFound |= 1 << 5 - x2;
            }
          }
          let resultString = UPCEReader.determineNumSysAndCheckDigit(
            result,
            lgPatternFound
          );
          return { rowOffset, resultString };
        }
        /**
         * @throws NotFoundException
         */
        // @Override
        decodeEnd(row, endStart) {
          return UPCEReader.findGuardPatternWithoutCounters(
            row,
            endStart,
            true,
            UPCEReader.MIDDLE_END_PATTERN
          );
        }
        /**
         * @throws FormatException
         */
        // @Override
        checkChecksum(s2) {
          return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s2));
        }
        /**
         * @throws NotFoundException
         */
        static determineNumSysAndCheckDigit(resultString, lgPatternFound) {
          for (let numSys = 0; numSys <= 1; numSys++) {
            for (let d2 = 0; d2 < 10; d2++) {
              if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d2]) {
                let prefix = String.fromCharCode("0".charCodeAt(0) + numSys);
                let suffix = String.fromCharCode("0".charCodeAt(0) + d2);
                return prefix + resultString + suffix;
              }
            }
          }
          throw NotFoundException.getNotFoundInstance();
        }
        // @Override
        getBarcodeFormat() {
          return BarcodeFormat$1.UPC_E;
        }
        /**
         * Expands a UPC-E value back into its full, equivalent UPC-A code value.
         *
         * @param upce UPC-E code as string of digits
         * @return equivalent UPC-A code as string of digits
         */
        static convertUPCEtoUPCA(upce) {
          const upceChars = upce.slice(1, 7).split("").map((x2) => x2.charCodeAt(0));
          const result = new StringBuilder(
            /*12*/
          );
          result.append(upce.charAt(0));
          let lastChar = upceChars[5];
          switch (lastChar) {
            case 0:
            case 1:
            case 2:
              result.appendChars(upceChars, 0, 2);
              result.append(lastChar);
              result.append("0000");
              result.appendChars(upceChars, 2, 3);
              break;
            case 3:
              result.appendChars(upceChars, 0, 3);
              result.append("00000");
              result.appendChars(upceChars, 3, 2);
              break;
            case 4:
              result.appendChars(upceChars, 0, 4);
              result.append("00000");
              result.append(upceChars[4]);
              break;
            default:
              result.appendChars(upceChars, 0, 5);
              result.append("0000");
              result.append(lastChar);
              break;
          }
          if (upce.length >= 8) {
            result.append(upce.charAt(7));
          }
          return result.toString();
        }
      }
      UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
      UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
        Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
        Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 26])
      ];
      class MultiFormatUPCEANReader extends OneDReader {
        constructor(hints) {
          super();
          let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
          let readers = [];
          if (!isNullOrUndefined2(possibleFormats)) {
            if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {
              readers.push(new EAN13Reader());
            }
            if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {
              readers.push(new UPCAReader());
            }
            if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {
              readers.push(new EAN8Reader());
            }
            if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {
              readers.push(new UPCEReader());
            }
          } else {
            readers.push(new EAN13Reader());
            readers.push(new UPCAReader());
            readers.push(new EAN8Reader());
            readers.push(new UPCEReader());
          }
          this.readers = readers;
        }
        decodeRow(rowNumber, row, hints) {
          for (let reader of this.readers) {
            try {
              const result = reader.decodeRow(rowNumber, row, hints);
              const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 && result.getText().charAt(0) === "0";
              const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
              const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);
              if (ean13MayBeUPCA && canReturnUPCA) {
                const rawBytes = result.getRawBytes();
                const resultUPCA = new Result(
                  result.getText().substring(1),
                  rawBytes,
                  rawBytes ? rawBytes.length : null,
                  result.getResultPoints(),
                  BarcodeFormat$1.UPC_A
                );
                resultUPCA.putAllMetadata(result.getResultMetadata());
                return resultUPCA;
              }
              return result;
            } catch (err) {
            }
          }
          throw new NotFoundException();
        }
        reset() {
          for (let reader of this.readers) {
            reader.reset();
          }
        }
      }
      class AbstractRSSReader extends OneDReader {
        constructor() {
          super();
          this.decodeFinderCounters = new Int32Array(4);
          this.dataCharacterCounters = new Int32Array(8);
          this.oddRoundingErrors = new Array(4);
          this.evenRoundingErrors = new Array(4);
          this.oddCounts = new Array(this.dataCharacterCounters.length / 2);
          this.evenCounts = new Array(this.dataCharacterCounters.length / 2);
        }
        getDecodeFinderCounters() {
          return this.decodeFinderCounters;
        }
        getDataCharacterCounters() {
          return this.dataCharacterCounters;
        }
        getOddRoundingErrors() {
          return this.oddRoundingErrors;
        }
        getEvenRoundingErrors() {
          return this.evenRoundingErrors;
        }
        getOddCounts() {
          return this.oddCounts;
        }
        getEvenCounts() {
          return this.evenCounts;
        }
        parseFinderValue(counters, finderPatterns) {
          for (let value2 = 0; value2 < finderPatterns.length; value2++) {
            if (OneDReader.patternMatchVariance(counters, finderPatterns[value2], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
              return value2;
            }
          }
          throw new NotFoundException();
        }
        /**
         * @param array values to sum
         * @return sum of values
         * @deprecated call {@link MathUtils#sum(int[])}
         */
        static count(array) {
          return MathUtils.sum(new Int32Array(array));
        }
        static increment(array, errors) {
          let index = 0;
          let biggestError = errors[0];
          for (let i3 = 1; i3 < array.length; i3++) {
            if (errors[i3] > biggestError) {
              biggestError = errors[i3];
              index = i3;
            }
          }
          array[index]++;
        }
        static decrement(array, errors) {
          let index = 0;
          let biggestError = errors[0];
          for (let i3 = 1; i3 < array.length; i3++) {
            if (errors[i3] < biggestError) {
              biggestError = errors[i3];
              index = i3;
            }
          }
          array[index]--;
        }
        static isFinderPattern(counters) {
          let firstTwoSum = counters[0] + counters[1];
          let sum = firstTwoSum + counters[2] + counters[3];
          let ratio = firstTwoSum / sum;
          if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
            let minCounter = Number.MAX_SAFE_INTEGER;
            let maxCounter = Number.MIN_SAFE_INTEGER;
            for (let counter of counters) {
              if (counter > maxCounter) {
                maxCounter = counter;
              }
              if (counter < minCounter) {
                minCounter = counter;
              }
            }
            return maxCounter < 10 * minCounter;
          }
          return false;
        }
      }
      AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
      AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
      AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
      AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
      class DataCharacter {
        constructor(value2, checksumPortion) {
          this.value = value2;
          this.checksumPortion = checksumPortion;
        }
        getValue() {
          return this.value;
        }
        getChecksumPortion() {
          return this.checksumPortion;
        }
        toString() {
          return this.value + "(" + this.checksumPortion + ")";
        }
        equals(o2) {
          if (!(o2 instanceof DataCharacter)) {
            return false;
          }
          const that = o2;
          return this.value === that.value && this.checksumPortion === that.checksumPortion;
        }
        hashCode() {
          return this.value ^ this.checksumPortion;
        }
      }
      class FinderPattern {
        constructor(value2, startEnd, start, end, rowNumber) {
          this.value = value2;
          this.startEnd = startEnd;
          this.value = value2;
          this.startEnd = startEnd;
          this.resultPoints = new Array();
          this.resultPoints.push(new ResultPoint(start, rowNumber));
          this.resultPoints.push(new ResultPoint(end, rowNumber));
        }
        getValue() {
          return this.value;
        }
        getStartEnd() {
          return this.startEnd;
        }
        getResultPoints() {
          return this.resultPoints;
        }
        equals(o2) {
          if (!(o2 instanceof FinderPattern)) {
            return false;
          }
          const that = o2;
          return this.value === that.value;
        }
        hashCode() {
          return this.value;
        }
      }
      class RSSUtils {
        constructor() {
        }
        static getRSSvalue(widths, maxWidth, noNarrow) {
          let n2 = 0;
          for (let width of widths) {
            n2 += width;
          }
          let val = 0;
          let narrowMask = 0;
          let elements = widths.length;
          for (let bar = 0; bar < elements - 1; bar++) {
            let elmWidth;
            for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
              let subVal = RSSUtils.combins(n2 - elmWidth - 1, elements - bar - 2);
              if (noNarrow && narrowMask === 0 && n2 - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
                subVal -= RSSUtils.combins(n2 - elmWidth - (elements - bar), elements - bar - 2);
              }
              if (elements - bar - 1 > 1) {
                let lessVal = 0;
                for (let mxwElement = n2 - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                  lessVal += RSSUtils.combins(n2 - elmWidth - mxwElement - 1, elements - bar - 3);
                }
                subVal -= lessVal * (elements - 1 - bar);
              } else if (n2 - elmWidth > maxWidth) {
                subVal--;
              }
              val += subVal;
            }
            n2 -= elmWidth;
          }
          return val;
        }
        static combins(n2, r) {
          let maxDenom;
          let minDenom;
          if (n2 - r > r) {
            minDenom = r;
            maxDenom = n2 - r;
          } else {
            minDenom = n2 - r;
            maxDenom = r;
          }
          let val = 1;
          let j2 = 1;
          for (let i3 = n2; i3 > maxDenom; i3--) {
            val *= i3;
            if (j2 <= minDenom) {
              val /= j2;
              j2++;
            }
          }
          while (j2 <= minDenom) {
            val /= j2;
            j2++;
          }
          return val;
        }
      }
      class BitArrayBuilder {
        static buildBitArray(pairs) {
          let charNumber = pairs.length * 2 - 1;
          if (pairs[pairs.length - 1].getRightChar() == null) {
            charNumber -= 1;
          }
          let size = 12 * charNumber;
          let binary = new BitArray(size);
          let accPos = 0;
          let firstPair = pairs[0];
          let firstValue = firstPair.getRightChar().getValue();
          for (let i3 = 11; i3 >= 0; --i3) {
            if ((firstValue & 1 << i3) != 0) {
              binary.set(accPos);
            }
            accPos++;
          }
          for (let i3 = 1; i3 < pairs.length; ++i3) {
            let currentPair = pairs[i3];
            let leftValue = currentPair.getLeftChar().getValue();
            for (let j2 = 11; j2 >= 0; --j2) {
              if ((leftValue & 1 << j2) != 0) {
                binary.set(accPos);
              }
              accPos++;
            }
            if (currentPair.getRightChar() != null) {
              let rightValue = currentPair.getRightChar().getValue();
              for (let j2 = 11; j2 >= 0; --j2) {
                if ((rightValue & 1 << j2) != 0) {
                  binary.set(accPos);
                }
                accPos++;
              }
            }
          }
          return binary;
        }
      }
      class BlockParsedResult {
        constructor(finished, decodedInformation) {
          if (decodedInformation) {
            this.decodedInformation = null;
          } else {
            this.finished = finished;
            this.decodedInformation = decodedInformation;
          }
        }
        getDecodedInformation() {
          return this.decodedInformation;
        }
        isFinished() {
          return this.finished;
        }
      }
      class DecodedObject {
        constructor(newPosition) {
          this.newPosition = newPosition;
        }
        getNewPosition() {
          return this.newPosition;
        }
      }
      class DecodedChar extends DecodedObject {
        constructor(newPosition, value2) {
          super(newPosition);
          this.value = value2;
        }
        getValue() {
          return this.value;
        }
        isFNC1() {
          return this.value === DecodedChar.FNC1;
        }
      }
      DecodedChar.FNC1 = "$";
      class DecodedInformation extends DecodedObject {
        constructor(newPosition, newString, remainingValue) {
          super(newPosition);
          if (remainingValue) {
            this.remaining = true;
            this.remainingValue = this.remainingValue;
          } else {
            this.remaining = false;
            this.remainingValue = 0;
          }
          this.newString = newString;
        }
        getNewString() {
          return this.newString;
        }
        isRemaining() {
          return this.remaining;
        }
        getRemainingValue() {
          return this.remainingValue;
        }
      }
      class DecodedNumeric extends DecodedObject {
        constructor(newPosition, firstDigit, secondDigit) {
          super(newPosition);
          if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
            throw new FormatException();
          }
          this.firstDigit = firstDigit;
          this.secondDigit = secondDigit;
        }
        getFirstDigit() {
          return this.firstDigit;
        }
        getSecondDigit() {
          return this.secondDigit;
        }
        getValue() {
          return this.firstDigit * 10 + this.secondDigit;
        }
        isFirstDigitFNC1() {
          return this.firstDigit === DecodedNumeric.FNC1;
        }
        isSecondDigitFNC1() {
          return this.secondDigit === DecodedNumeric.FNC1;
        }
        isAnyFNC1() {
          return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
        }
      }
      DecodedNumeric.FNC1 = 10;
      class FieldParser {
        constructor() {
        }
        static parseFieldsInGeneralPurpose(rawInformation) {
          if (!rawInformation) {
            return null;
          }
          if (rawInformation.length < 2) {
            throw new NotFoundException();
          }
          let firstTwoDigits = rawInformation.substring(0, 2);
          for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {
            if (dataLength[0] === firstTwoDigits) {
              if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
              }
              return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
            }
          }
          if (rawInformation.length < 3) {
            throw new NotFoundException();
          }
          let firstThreeDigits = rawInformation.substring(0, 3);
          for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {
            if (dataLength[0] === firstThreeDigits) {
              if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
              }
              return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
            }
          }
          for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {
            if (dataLength[0] === firstThreeDigits) {
              if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
              }
              return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
            }
          }
          if (rawInformation.length < 4) {
            throw new NotFoundException();
          }
          let firstFourDigits = rawInformation.substring(0, 4);
          for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {
            if (dataLength[0] === firstFourDigits) {
              if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
              }
              return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
            }
          }
          throw new NotFoundException();
        }
        static processFixedAI(aiSize, fieldSize, rawInformation) {
          if (rawInformation.length < aiSize) {
            throw new NotFoundException();
          }
          let ai = rawInformation.substring(0, aiSize);
          if (rawInformation.length < aiSize + fieldSize) {
            throw new NotFoundException();
          }
          let field = rawInformation.substring(aiSize, aiSize + fieldSize);
          let remaining = rawInformation.substring(aiSize + fieldSize);
          let result = "(" + ai + ")" + field;
          let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
          return parsedAI == null ? result : result + parsedAI;
        }
        static processVariableAI(aiSize, variableFieldSize, rawInformation) {
          let ai = rawInformation.substring(0, aiSize);
          let maxSize;
          if (rawInformation.length < aiSize + variableFieldSize) {
            maxSize = rawInformation.length;
          } else {
            maxSize = aiSize + variableFieldSize;
          }
          let field = rawInformation.substring(aiSize, maxSize);
          let remaining = rawInformation.substring(maxSize);
          let result = "(" + ai + ")" + field;
          let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
          return parsedAI == null ? result : result + parsedAI;
        }
      }
      FieldParser.VARIABLE_LENGTH = [];
      FieldParser.TWO_DIGIT_DATA_LENGTH = [
        ["00", 18],
        ["01", 14],
        ["02", 14],
        ["10", FieldParser.VARIABLE_LENGTH, 20],
        ["11", 6],
        ["12", 6],
        ["13", 6],
        ["15", 6],
        ["17", 6],
        ["20", 2],
        ["21", FieldParser.VARIABLE_LENGTH, 20],
        ["22", FieldParser.VARIABLE_LENGTH, 29],
        ["30", FieldParser.VARIABLE_LENGTH, 8],
        ["37", FieldParser.VARIABLE_LENGTH, 8],
        // internal company codes
        ["90", FieldParser.VARIABLE_LENGTH, 30],
        ["91", FieldParser.VARIABLE_LENGTH, 30],
        ["92", FieldParser.VARIABLE_LENGTH, 30],
        ["93", FieldParser.VARIABLE_LENGTH, 30],
        ["94", FieldParser.VARIABLE_LENGTH, 30],
        ["95", FieldParser.VARIABLE_LENGTH, 30],
        ["96", FieldParser.VARIABLE_LENGTH, 30],
        ["97", FieldParser.VARIABLE_LENGTH, 3],
        ["98", FieldParser.VARIABLE_LENGTH, 30],
        ["99", FieldParser.VARIABLE_LENGTH, 30]
      ];
      FieldParser.THREE_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["240", FieldParser.VARIABLE_LENGTH, 30],
        ["241", FieldParser.VARIABLE_LENGTH, 30],
        ["242", FieldParser.VARIABLE_LENGTH, 6],
        ["250", FieldParser.VARIABLE_LENGTH, 30],
        ["251", FieldParser.VARIABLE_LENGTH, 30],
        ["253", FieldParser.VARIABLE_LENGTH, 17],
        ["254", FieldParser.VARIABLE_LENGTH, 20],
        ["400", FieldParser.VARIABLE_LENGTH, 30],
        ["401", FieldParser.VARIABLE_LENGTH, 30],
        ["402", 17],
        ["403", FieldParser.VARIABLE_LENGTH, 30],
        ["410", 13],
        ["411", 13],
        ["412", 13],
        ["413", 13],
        ["414", 13],
        ["420", FieldParser.VARIABLE_LENGTH, 20],
        ["421", FieldParser.VARIABLE_LENGTH, 15],
        ["422", 3],
        ["423", FieldParser.VARIABLE_LENGTH, 15],
        ["424", 3],
        ["425", 3],
        ["426", 3]
      ];
      FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["310", 6],
        ["311", 6],
        ["312", 6],
        ["313", 6],
        ["314", 6],
        ["315", 6],
        ["316", 6],
        ["320", 6],
        ["321", 6],
        ["322", 6],
        ["323", 6],
        ["324", 6],
        ["325", 6],
        ["326", 6],
        ["327", 6],
        ["328", 6],
        ["329", 6],
        ["330", 6],
        ["331", 6],
        ["332", 6],
        ["333", 6],
        ["334", 6],
        ["335", 6],
        ["336", 6],
        ["340", 6],
        ["341", 6],
        ["342", 6],
        ["343", 6],
        ["344", 6],
        ["345", 6],
        ["346", 6],
        ["347", 6],
        ["348", 6],
        ["349", 6],
        ["350", 6],
        ["351", 6],
        ["352", 6],
        ["353", 6],
        ["354", 6],
        ["355", 6],
        ["356", 6],
        ["357", 6],
        ["360", 6],
        ["361", 6],
        ["362", 6],
        ["363", 6],
        ["364", 6],
        ["365", 6],
        ["366", 6],
        ["367", 6],
        ["368", 6],
        ["369", 6],
        ["390", FieldParser.VARIABLE_LENGTH, 15],
        ["391", FieldParser.VARIABLE_LENGTH, 18],
        ["392", FieldParser.VARIABLE_LENGTH, 15],
        ["393", FieldParser.VARIABLE_LENGTH, 18],
        ["703", FieldParser.VARIABLE_LENGTH, 30]
      ];
      FieldParser.FOUR_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["7001", 13],
        ["7002", FieldParser.VARIABLE_LENGTH, 30],
        ["7003", 10],
        ["8001", 14],
        ["8002", FieldParser.VARIABLE_LENGTH, 20],
        ["8003", FieldParser.VARIABLE_LENGTH, 30],
        ["8004", FieldParser.VARIABLE_LENGTH, 30],
        ["8005", 6],
        ["8006", 18],
        ["8007", FieldParser.VARIABLE_LENGTH, 30],
        ["8008", FieldParser.VARIABLE_LENGTH, 12],
        ["8018", 18],
        ["8020", FieldParser.VARIABLE_LENGTH, 25],
        ["8100", 6],
        ["8101", 10],
        ["8102", 2],
        ["8110", FieldParser.VARIABLE_LENGTH, 70],
        ["8200", FieldParser.VARIABLE_LENGTH, 70]
      ];
      class GeneralAppIdDecoder {
        constructor(information) {
          this.buffer = new StringBuilder();
          this.information = information;
        }
        decodeAllCodes(buff, initialPosition) {
          let currentPosition = initialPosition;
          let remaining = null;
          do {
            let info = this.decodeGeneralPurposeField(currentPosition, remaining);
            let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
            if (parsedFields != null) {
              buff.append(parsedFields);
            }
            if (info.isRemaining()) {
              remaining = "" + info.getRemainingValue();
            } else {
              remaining = null;
            }
            if (currentPosition === info.getNewPosition()) {
              break;
            }
            currentPosition = info.getNewPosition();
          } while (true);
          return buff.toString();
        }
        isStillNumeric(pos) {
          if (pos + 7 > this.information.getSize()) {
            return pos + 4 <= this.information.getSize();
          }
          for (let i3 = pos; i3 < pos + 3; ++i3) {
            if (this.information.get(i3)) {
              return true;
            }
          }
          return this.information.get(pos + 3);
        }
        decodeNumeric(pos) {
          if (pos + 7 > this.information.getSize()) {
            let numeric2 = this.extractNumericValueFromBitArray(pos, 4);
            if (numeric2 === 0) {
              return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);
            }
            return new DecodedNumeric(this.information.getSize(), numeric2 - 1, DecodedNumeric.FNC1);
          }
          let numeric = this.extractNumericValueFromBitArray(pos, 7);
          let digit1 = (numeric - 8) / 11;
          let digit2 = (numeric - 8) % 11;
          return new DecodedNumeric(pos + 7, digit1, digit2);
        }
        extractNumericValueFromBitArray(pos, bits2) {
          return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits2);
        }
        static extractNumericValueFromBitArray(information, pos, bits2) {
          let value2 = 0;
          for (let i3 = 0; i3 < bits2; ++i3) {
            if (information.get(pos + i3)) {
              value2 |= 1 << bits2 - i3 - 1;
            }
          }
          return value2;
        }
        decodeGeneralPurposeField(pos, remaining) {
          this.buffer.setLengthToZero();
          if (remaining != null) {
            this.buffer.append(remaining);
          }
          this.current.setPosition(pos);
          let lastDecoded = this.parseBlocks();
          if (lastDecoded != null && lastDecoded.isRemaining()) {
            return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
          }
          return new DecodedInformation(this.current.getPosition(), this.buffer.toString());
        }
        parseBlocks() {
          let isFinished;
          let result;
          do {
            let initialPosition = this.current.getPosition();
            if (this.current.isAlpha()) {
              result = this.parseAlphaBlock();
              isFinished = result.isFinished();
            } else if (this.current.isIsoIec646()) {
              result = this.parseIsoIec646Block();
              isFinished = result.isFinished();
            } else {
              result = this.parseNumericBlock();
              isFinished = result.isFinished();
            }
            let positionChanged = initialPosition !== this.current.getPosition();
            if (!positionChanged && !isFinished) {
              break;
            }
          } while (!isFinished);
          return result.getDecodedInformation();
        }
        parseNumericBlock() {
          while (this.isStillNumeric(this.current.getPosition())) {
            let numeric = this.decodeNumeric(this.current.getPosition());
            this.current.setPosition(numeric.getNewPosition());
            if (numeric.isFirstDigitFNC1()) {
              let information;
              if (numeric.isSecondDigitFNC1()) {
                information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
              } else {
                information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
              }
              return new BlockParsedResult(true, information);
            }
            this.buffer.append(numeric.getFirstDigit());
            if (numeric.isSecondDigitFNC1()) {
              let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
              return new BlockParsedResult(true, information);
            }
            this.buffer.append(numeric.getSecondDigit());
          }
          if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
            this.current.setAlpha();
            this.current.incrementPosition(4);
          }
          return new BlockParsedResult(false);
        }
        parseIsoIec646Block() {
          while (this.isStillIsoIec646(this.current.getPosition())) {
            let iso = this.decodeIsoIec646(this.current.getPosition());
            this.current.setPosition(iso.getNewPosition());
            if (iso.isFNC1()) {
              let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
              return new BlockParsedResult(true, information);
            }
            this.buffer.append(iso.getValue());
          }
          if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
            this.current.incrementPosition(3);
            this.current.setNumeric();
          } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
            if (this.current.getPosition() + 5 < this.information.getSize()) {
              this.current.incrementPosition(5);
            } else {
              this.current.setPosition(this.information.getSize());
            }
            this.current.setAlpha();
          }
          return new BlockParsedResult(false);
        }
        parseAlphaBlock() {
          while (this.isStillAlpha(this.current.getPosition())) {
            let alpha = this.decodeAlphanumeric(this.current.getPosition());
            this.current.setPosition(alpha.getNewPosition());
            if (alpha.isFNC1()) {
              let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
              return new BlockParsedResult(true, information);
            }
            this.buffer.append(alpha.getValue());
          }
          if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
            this.current.incrementPosition(3);
            this.current.setNumeric();
          } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
            if (this.current.getPosition() + 5 < this.information.getSize()) {
              this.current.incrementPosition(5);
            } else {
              this.current.setPosition(this.information.getSize());
            }
            this.current.setIsoIec646();
          }
          return new BlockParsedResult(false);
        }
        isStillIsoIec646(pos) {
          if (pos + 5 > this.information.getSize()) {
            return false;
          }
          let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
          if (fiveBitValue >= 5 && fiveBitValue < 16) {
            return true;
          }
          if (pos + 7 > this.information.getSize()) {
            return false;
          }
          let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
          if (sevenBitValue >= 64 && sevenBitValue < 116) {
            return true;
          }
          if (pos + 8 > this.information.getSize()) {
            return false;
          }
          let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
          return eightBitValue >= 232 && eightBitValue < 253;
        }
        decodeIsoIec646(pos) {
          let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
          if (fiveBitValue === 15) {
            return new DecodedChar(pos + 5, DecodedChar.FNC1);
          }
          if (fiveBitValue >= 5 && fiveBitValue < 15) {
            return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
          }
          let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
          if (sevenBitValue >= 64 && sevenBitValue < 90) {
            return new DecodedChar(pos + 7, "" + (sevenBitValue + 1));
          }
          if (sevenBitValue >= 90 && sevenBitValue < 116) {
            return new DecodedChar(pos + 7, "" + (sevenBitValue + 7));
          }
          let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
          let c2;
          switch (eightBitValue) {
            case 232:
              c2 = "!";
              break;
            case 233:
              c2 = '"';
              break;
            case 234:
              c2 = "%";
              break;
            case 235:
              c2 = "&";
              break;
            case 236:
              c2 = "'";
              break;
            case 237:
              c2 = "(";
              break;
            case 238:
              c2 = ")";
              break;
            case 239:
              c2 = "*";
              break;
            case 240:
              c2 = "+";
              break;
            case 241:
              c2 = ",";
              break;
            case 242:
              c2 = "-";
              break;
            case 243:
              c2 = ".";
              break;
            case 244:
              c2 = "/";
              break;
            case 245:
              c2 = ":";
              break;
            case 246:
              c2 = ";";
              break;
            case 247:
              c2 = "<";
              break;
            case 248:
              c2 = "=";
              break;
            case 249:
              c2 = ">";
              break;
            case 250:
              c2 = "?";
              break;
            case 251:
              c2 = "_";
              break;
            case 252:
              c2 = " ";
              break;
            default:
              throw new FormatException();
          }
          return new DecodedChar(pos + 8, c2);
        }
        isStillAlpha(pos) {
          if (pos + 5 > this.information.getSize()) {
            return false;
          }
          let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
          if (fiveBitValue >= 5 && fiveBitValue < 16) {
            return true;
          }
          if (pos + 6 > this.information.getSize()) {
            return false;
          }
          let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
          return sixBitValue >= 16 && sixBitValue < 63;
        }
        decodeAlphanumeric(pos) {
          let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
          if (fiveBitValue === 15) {
            return new DecodedChar(pos + 5, DecodedChar.FNC1);
          }
          if (fiveBitValue >= 5 && fiveBitValue < 15) {
            return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
          }
          let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
          if (sixBitValue >= 32 && sixBitValue < 58) {
            return new DecodedChar(pos + 6, "" + (sixBitValue + 33));
          }
          let c2;
          switch (sixBitValue) {
            case 58:
              c2 = "*";
              break;
            case 59:
              c2 = ",";
              break;
            case 60:
              c2 = "-";
              break;
            case 61:
              c2 = ".";
              break;
            case 62:
              c2 = "/";
              break;
            default:
              throw new IllegalStateException("Decoding invalid alphanumeric value: " + sixBitValue);
          }
          return new DecodedChar(pos + 6, c2);
        }
        isAlphaTo646ToAlphaLatch(pos) {
          if (pos + 1 > this.information.getSize()) {
            return false;
          }
          for (let i3 = 0; i3 < 5 && i3 + pos < this.information.getSize(); ++i3) {
            if (i3 === 2) {
              if (!this.information.get(pos + 2)) {
                return false;
              }
            } else if (this.information.get(pos + i3)) {
              return false;
            }
          }
          return true;
        }
        isAlphaOr646ToNumericLatch(pos) {
          if (pos + 3 > this.information.getSize()) {
            return false;
          }
          for (let i3 = pos; i3 < pos + 3; ++i3) {
            if (this.information.get(i3)) {
              return false;
            }
          }
          return true;
        }
        isNumericToAlphaNumericLatch(pos) {
          if (pos + 1 > this.information.getSize()) {
            return false;
          }
          for (let i3 = 0; i3 < 4 && i3 + pos < this.information.getSize(); ++i3) {
            if (this.information.get(pos + i3)) {
              return false;
            }
          }
          return true;
        }
      }
      class AbstractExpandedDecoder {
        constructor(information) {
          this.information = information;
          this.generalDecoder = new GeneralAppIdDecoder(information);
        }
        getInformation() {
          return this.information;
        }
        getGeneralDecoder() {
          return this.generalDecoder;
        }
      }
      class AI01decoder extends AbstractExpandedDecoder {
        constructor(information) {
          super(information);
        }
        encodeCompressedGtin(buf, currentPos) {
          buf.append("(01)");
          let initialPosition = buf.length();
          buf.append("9");
          this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
        }
        encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {
          for (let i3 = 0; i3 < 4; ++i3) {
            let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i3, 10);
            if (currentBlock / 100 === 0) {
              buf.append("0");
            }
            if (currentBlock / 10 === 0) {
              buf.append("0");
            }
            buf.append(currentBlock);
          }
          AI01decoder.appendCheckDigit(buf, initialBufferPosition);
        }
        static appendCheckDigit(buf, currentPos) {
          let checkDigit = 0;
          for (let i3 = 0; i3 < 13; i3++) {
            let digit = buf.charAt(i3 + currentPos).charCodeAt(0) - "0".charCodeAt(0);
            checkDigit += (i3 & 1) === 0 ? 3 * digit : digit;
          }
          checkDigit = 10 - checkDigit % 10;
          if (checkDigit === 10) {
            checkDigit = 0;
          }
          buf.append(checkDigit);
        }
      }
      AI01decoder.GTIN_SIZE = 40;
      class AI01AndOtherAIs extends AI01decoder {
        // the second one is the encodation method, and the other two are for the variable length
        constructor(information) {
          super(information);
        }
        parseInformation() {
          let buff = new StringBuilder();
          buff.append("(01)");
          let initialGtinPosition = buff.length();
          let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
          buff.append(firstGtinDigit);
          this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
          return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
        }
      }
      AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2;
      class AnyAIDecoder extends AbstractExpandedDecoder {
        constructor(information) {
          super(information);
        }
        parseInformation() {
          let buf = new StringBuilder();
          return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
        }
      }
      AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;
      class AI01weightDecoder extends AI01decoder {
        constructor(information) {
          super(information);
        }
        encodeCompressedWeight(buf, currentPos, weightSize) {
          let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
          this.addWeightCode(buf, originalWeightNumeric);
          let weightNumeric = this.checkWeight(originalWeightNumeric);
          let currentDivisor = 1e5;
          for (let i3 = 0; i3 < 5; ++i3) {
            if (weightNumeric / currentDivisor === 0) {
              buf.append("0");
            }
            currentDivisor /= 10;
          }
          buf.append(weightNumeric);
        }
      }
      class AI013x0xDecoder extends AI01weightDecoder {
        constructor(information) {
          super(information);
        }
        parseInformation() {
          if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
            throw new NotFoundException();
          }
          let buf = new StringBuilder();
          this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
          this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
          return buf.toString();
        }
      }
      AI013x0xDecoder.HEADER_SIZE = 4 + 1;
      AI013x0xDecoder.WEIGHT_SIZE = 15;
      class AI013103decoder extends AI013x0xDecoder {
        constructor(information) {
          super(information);
        }
        addWeightCode(buf, weight) {
          buf.append("(3103)");
        }
        checkWeight(weight) {
          return weight;
        }
      }
      class AI01320xDecoder extends AI013x0xDecoder {
        constructor(information) {
          super(information);
        }
        addWeightCode(buf, weight) {
          if (weight < 1e4) {
            buf.append("(3202)");
          } else {
            buf.append("(3203)");
          }
        }
        checkWeight(weight) {
          if (weight < 1e4) {
            return weight;
          }
          return weight - 1e4;
        }
      }
      class AI01392xDecoder extends AI01decoder {
        constructor(information) {
          super(information);
        }
        parseInformation() {
          if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
            throw new NotFoundException();
          }
          let buf = new StringBuilder();
          this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
          let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
          buf.append("(392");
          buf.append(lastAIdigit);
          buf.append(")");
          let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
          buf.append(decodedInformation.getNewString());
          return buf.toString();
        }
      }
      AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
      AI01392xDecoder.LAST_DIGIT_SIZE = 2;
      class AI01393xDecoder extends AI01decoder {
        constructor(information) {
          super(information);
        }
        parseInformation() {
          if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
            throw new NotFoundException();
          }
          let buf = new StringBuilder();
          this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
          let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
          buf.append("(393");
          buf.append(lastAIdigit);
          buf.append(")");
          let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
          if (firstThreeDigits / 100 == 0) {
            buf.append("0");
          }
          if (firstThreeDigits / 10 == 0) {
            buf.append("0");
          }
          buf.append(firstThreeDigits);
          let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
          buf.append(generalInformation.getNewString());
          return buf.toString();
        }
      }
      AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
      AI01393xDecoder.LAST_DIGIT_SIZE = 2;
      AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;
      class AI013x0x1xDecoder extends AI01weightDecoder {
        constructor(information, firstAIdigits, dateCode) {
          super(information);
          this.dateCode = dateCode;
          this.firstAIdigits = firstAIdigits;
        }
        parseInformation() {
          if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
            throw new NotFoundException();
          }
          let buf = new StringBuilder();
          this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
          this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
          this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
          return buf.toString();
        }
        encodeCompressedDate(buf, currentPos) {
          let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
          if (numericDate == 38400) {
            return;
          }
          buf.append("(");
          buf.append(this.dateCode);
          buf.append(")");
          let day = numericDate % 32;
          numericDate /= 32;
          let month = numericDate % 12 + 1;
          numericDate /= 12;
          let year = numericDate;
          if (year / 10 == 0) {
            buf.append("0");
          }
          buf.append(year);
          if (month / 10 == 0) {
            buf.append("0");
          }
          buf.append(month);
          if (day / 10 == 0) {
            buf.append("0");
          }
          buf.append(day);
        }
        addWeightCode(buf, weight) {
          buf.append("(");
          buf.append(this.firstAIdigits);
          buf.append(weight / 1e5);
          buf.append(")");
        }
        checkWeight(weight) {
          return weight % 1e5;
        }
      }
      AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
      AI013x0x1xDecoder.WEIGHT_SIZE = 20;
      AI013x0x1xDecoder.DATE_SIZE = 16;
      function createDecoder(information) {
        try {
          if (information.get(1)) {
            return new AI01AndOtherAIs(information);
          }
          if (!information.get(2)) {
            return new AnyAIDecoder(information);
          }
          let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);
          switch (fourBitEncodationMethod) {
            case 4:
              return new AI013103decoder(information);
            case 5:
              return new AI01320xDecoder(information);
          }
          let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);
          switch (fiveBitEncodationMethod) {
            case 12:
              return new AI01392xDecoder(information);
            case 13:
              return new AI01393xDecoder(information);
          }
          let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);
          switch (sevenBitEncodationMethod) {
            case 56:
              return new AI013x0x1xDecoder(information, "310", "11");
            case 57:
              return new AI013x0x1xDecoder(information, "320", "11");
            case 58:
              return new AI013x0x1xDecoder(information, "310", "13");
            case 59:
              return new AI013x0x1xDecoder(information, "320", "13");
            case 60:
              return new AI013x0x1xDecoder(information, "310", "15");
            case 61:
              return new AI013x0x1xDecoder(information, "320", "15");
            case 62:
              return new AI013x0x1xDecoder(information, "310", "17");
            case 63:
              return new AI013x0x1xDecoder(information, "320", "17");
          }
        } catch (e) {
          console.log(e);
          throw new IllegalStateException("unknown decoder: " + information);
        }
      }
      class ExpandedPair {
        constructor(leftChar, rightChar, finderPatter, mayBeLast) {
          this.leftchar = leftChar;
          this.rightchar = rightChar;
          this.finderpattern = finderPatter;
          this.maybeLast = mayBeLast;
        }
        mayBeLast() {
          return this.maybeLast;
        }
        getLeftChar() {
          return this.leftchar;
        }
        getRightChar() {
          return this.rightchar;
        }
        getFinderPattern() {
          return this.finderpattern;
        }
        mustBeLast() {
          return this.rightchar == null;
        }
        toString() {
          return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
        }
        static equals(o1, o2) {
          if (!(o1 instanceof ExpandedPair)) {
            return false;
          }
          return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
        }
        static equalsOrNull(o1, o2) {
          return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
        }
        hashCode() {
          let value2 = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
          return value2;
        }
      }
      class ExpandedRow {
        constructor(pairs, rowNumber, wasReversed) {
          this.pairs = pairs;
          this.rowNumber = rowNumber;
          this.wasReversed = wasReversed;
        }
        getPairs() {
          return this.pairs;
        }
        getRowNumber() {
          return this.rowNumber;
        }
        isReversed() {
          return this.wasReversed;
        }
        // check implementation
        isEquivalent(otherPairs) {
          return this.checkEqualitity(this, otherPairs);
        }
        // @Override
        toString() {
          return "{ " + this.pairs + " }";
        }
        /**
         * Two rows are equal if they contain the same pairs in the same order.
         */
        // @Override
        // check implementation
        equals(o1, o2) {
          if (!(o1 instanceof ExpandedRow)) {
            return false;
          }
          return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
        }
        checkEqualitity(pair1, pair2) {
          if (!pair1 || !pair2)
            return;
          let result;
          pair1.forEach((e1, i3) => {
            pair2.forEach((e2) => {
              if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
                result = true;
              }
            });
          });
          return result;
        }
      }
      class RSSExpandedReader extends AbstractRSSReader {
        constructor(verbose) {
          super(...arguments);
          this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
          this.rows = new Array();
          this.startEnd = [2];
          this.verbose = verbose === true;
        }
        decodeRow(rowNumber, row, hints) {
          this.pairs.length = 0;
          this.startFromEven = false;
          try {
            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
          } catch (e) {
            if (this.verbose) {
              console.log(e);
            }
          }
          this.pairs.length = 0;
          this.startFromEven = true;
          return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
        }
        reset() {
          this.pairs.length = 0;
          this.rows.length = 0;
        }
        // Not private for testing
        decodeRow2pairs(rowNumber, row) {
          let done = false;
          while (!done) {
            try {
              this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
            } catch (error) {
              if (error instanceof NotFoundException) {
                if (!this.pairs.length) {
                  throw new NotFoundException();
                }
                done = true;
              }
            }
          }
          if (this.checkChecksum()) {
            return this.pairs;
          }
          let tryStackedDecode;
          if (this.rows.length) {
            tryStackedDecode = true;
          } else {
            tryStackedDecode = false;
          }
          this.storeRow(rowNumber, false);
          if (tryStackedDecode) {
            let ps = this.checkRowsBoolean(false);
            if (ps != null) {
              return ps;
            }
            ps = this.checkRowsBoolean(true);
            if (ps != null) {
              return ps;
            }
          }
          throw new NotFoundException();
        }
        // Need to Verify
        checkRowsBoolean(reverse) {
          if (this.rows.length > 25) {
            this.rows.length = 0;
            return null;
          }
          this.pairs.length = 0;
          if (reverse) {
            this.rows = this.rows.reverse();
          }
          let ps = null;
          try {
            ps = this.checkRows(new Array(), 0);
          } catch (e) {
            if (this.verbose) {
              console.log(e);
            }
          }
          if (reverse) {
            this.rows = this.rows.reverse();
          }
          return ps;
        }
        // Try to construct a valid rows sequence
        // Recursion is used to implement backtracking
        checkRows(collectedRows, currentRow) {
          for (let i3 = currentRow; i3 < this.rows.length; i3++) {
            let row = this.rows[i3];
            this.pairs.length = 0;
            for (let collectedRow of collectedRows) {
              this.pairs.push(collectedRow.getPairs());
            }
            this.pairs.push(row.getPairs());
            if (!RSSExpandedReader.isValidSequence(this.pairs)) {
              continue;
            }
            if (this.checkChecksum()) {
              return this.pairs;
            }
            let rs = new Array(collectedRows);
            rs.push(row);
            try {
              return this.checkRows(rs, i3 + 1);
            } catch (e) {
              if (this.verbose) {
                console.log(e);
              }
            }
          }
          throw new NotFoundException();
        }
        // Whether the pairs form a valid find pattern sequence,
        // either complete or a prefix
        static isValidSequence(pairs) {
          for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {
            if (pairs.length > sequence.length) {
              continue;
            }
            let stop = true;
            for (let j2 = 0; j2 < pairs.length; j2++) {
              if (pairs[j2].getFinderPattern().getValue() != sequence[j2]) {
                stop = false;
                break;
              }
            }
            if (stop) {
              return true;
            }
          }
          return false;
        }
        storeRow(rowNumber, wasReversed) {
          let insertPos = 0;
          let prevIsSame = false;
          let nextIsSame = false;
          while (insertPos < this.rows.length) {
            let erow = this.rows[insertPos];
            if (erow.getRowNumber() > rowNumber) {
              nextIsSame = erow.isEquivalent(this.pairs);
              break;
            }
            prevIsSame = erow.isEquivalent(this.pairs);
            insertPos++;
          }
          if (nextIsSame || prevIsSame) {
            return;
          }
          if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
            return;
          }
          this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));
          this.removePartialRows(this.pairs, this.rows);
        }
        // Remove all the rows that contains only specified pairs
        removePartialRows(pairs, rows) {
          for (let row of rows) {
            if (row.getPairs().length === pairs.length) {
              continue;
            }
            for (let p2 of row.getPairs()) {
              for (let pp of pairs) {
                if (ExpandedPair.equals(p2, pp)) {
                  break;
                }
              }
            }
          }
        }
        // Returns true when one of the rows already contains all the pairs
        static isPartialRow(pairs, rows) {
          for (let r of rows) {
            let allFound = true;
            for (let p2 of pairs) {
              let found = false;
              for (let pp of r.getPairs()) {
                if (p2.equals(pp)) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                allFound = false;
                break;
              }
            }
            if (allFound) {
              return true;
            }
          }
          return false;
        }
        // Only used for unit testing
        getRows() {
          return this.rows;
        }
        // Not private for unit testing
        static constructResult(pairs) {
          let binary = BitArrayBuilder.buildBitArray(pairs);
          let decoder = createDecoder(binary);
          let resultingString = decoder.parseInformation();
          let firstPoints = pairs[0].getFinderPattern().getResultPoints();
          let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
          let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
          return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);
        }
        checkChecksum() {
          let firstPair = this.pairs.get(0);
          let checkCharacter = firstPair.getLeftChar();
          let firstCharacter = firstPair.getRightChar();
          if (firstCharacter == null) {
            return false;
          }
          let checksum = firstCharacter.getChecksumPortion();
          let s2 = 2;
          for (let i3 = 1; i3 < this.pairs.size(); ++i3) {
            let currentPair = this.pairs.get(i3);
            checksum += currentPair.getLeftChar().getChecksumPortion();
            s2++;
            let currentRightChar = currentPair.getRightChar();
            if (currentRightChar != null) {
              checksum += currentRightChar.getChecksumPortion();
              s2++;
            }
          }
          checksum %= 211;
          let checkCharacterValue = 211 * (s2 - 4) + checksum;
          return checkCharacterValue == checkCharacter.getValue();
        }
        static getNextSecondBar(row, initialPos) {
          let currentPos;
          if (row.get(initialPos)) {
            currentPos = row.getNextUnset(initialPos);
            currentPos = row.getNextSet(currentPos);
          } else {
            currentPos = row.getNextSet(initialPos);
            currentPos = row.getNextUnset(currentPos);
          }
          return currentPos;
        }
        // not private for testing
        retrieveNextPair(row, previousPairs, rowNumber) {
          let isOddPattern = previousPairs.length % 2 == 0;
          if (this.startFromEven) {
            isOddPattern = !isOddPattern;
          }
          let pattern;
          let keepFinding = true;
          let forcedOffset = -1;
          do {
            this.findNextPair(row, previousPairs, forcedOffset);
            pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
            if (pattern == null) {
              forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
            } else {
              keepFinding = false;
            }
          } while (keepFinding);
          let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
          if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
            throw new NotFoundException();
          }
          let rightChar;
          try {
            rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
          } catch (e) {
            rightChar = null;
            if (this.verbose) {
              console.log(e);
            }
          }
          return new ExpandedPair(leftChar, rightChar, pattern, true);
        }
        isEmptyPair(pairs) {
          if (pairs.length === 0) {
            return true;
          }
          return false;
        }
        findNextPair(row, previousPairs, forcedOffset) {
          let counters = this.getDecodeFinderCounters();
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          let width = row.getSize();
          let rowOffset;
          if (forcedOffset >= 0) {
            rowOffset = forcedOffset;
          } else if (this.isEmptyPair(previousPairs)) {
            rowOffset = 0;
          } else {
            let lastPair = previousPairs[previousPairs.length - 1];
            rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
          }
          let searchingEvenPair = previousPairs.length % 2 != 0;
          if (this.startFromEven) {
            searchingEvenPair = !searchingEvenPair;
          }
          let isWhite = false;
          while (rowOffset < width) {
            isWhite = !row.get(rowOffset);
            if (!isWhite) {
              break;
            }
            rowOffset++;
          }
          let counterPosition = 0;
          let patternStart = rowOffset;
          for (let x2 = rowOffset; x2 < width; x2++) {
            if (row.get(x2) != isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition == 3) {
                if (searchingEvenPair) {
                  RSSExpandedReader.reverseCounters(counters);
                }
                if (RSSExpandedReader.isFinderPattern(counters)) {
                  this.startEnd[0] = patternStart;
                  this.startEnd[1] = x2;
                  return;
                }
                if (searchingEvenPair) {
                  RSSExpandedReader.reverseCounters(counters);
                }
                patternStart += counters[0] + counters[1];
                counters[0] = counters[2];
                counters[1] = counters[3];
                counters[2] = 0;
                counters[3] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          throw new NotFoundException();
        }
        static reverseCounters(counters) {
          let length2 = counters.length;
          for (let i3 = 0; i3 < length2 / 2; ++i3) {
            let tmp = counters[i3];
            counters[i3] = counters[length2 - i3 - 1];
            counters[length2 - i3 - 1] = tmp;
          }
        }
        parseFoundFinderPattern(row, rowNumber, oddPattern) {
          let firstCounter;
          let start;
          let end;
          if (oddPattern) {
            let firstElementStart = this.startEnd[0] - 1;
            while (firstElementStart >= 0 && !row.get(firstElementStart)) {
              firstElementStart--;
            }
            firstElementStart++;
            firstCounter = this.startEnd[0] - firstElementStart;
            start = firstElementStart;
            end = this.startEnd[1];
          } else {
            start = this.startEnd[0];
            end = row.getNextUnset(this.startEnd[1] + 1);
            firstCounter = end - this.startEnd[1];
          }
          let counters = this.getDecodeFinderCounters();
          System.arraycopy(counters, 0, counters, 1, counters.length - 1);
          counters[0] = firstCounter;
          let value2;
          try {
            value2 = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
          } catch (e) {
            return null;
          }
          return new FinderPattern(value2, [start, end], start, end, rowNumber);
        }
        decodeDataCharacter(row, pattern, isOddPattern, leftChar) {
          let counters = this.getDataCharacterCounters();
          for (let x2 = 0; x2 < counters.length; x2++) {
            counters[x2] = 0;
          }
          if (leftChar) {
            RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
          } else {
            RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
            for (let i3 = 0, j2 = counters.length - 1; i3 < j2; i3++, j2--) {
              let temp = counters[i3];
              counters[i3] = counters[j2];
              counters[j2] = temp;
            }
          }
          let numModules = 17;
          let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
          let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
          if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
            throw new NotFoundException();
          }
          let oddCounts = this.getOddCounts();
          let evenCounts = this.getEvenCounts();
          let oddRoundingErrors = this.getOddRoundingErrors();
          let evenRoundingErrors = this.getEvenRoundingErrors();
          for (let i3 = 0; i3 < counters.length; i3++) {
            let value3 = 1 * counters[i3] / elementWidth;
            let count = value3 + 0.5;
            if (count < 1) {
              if (value3 < 0.3) {
                throw new NotFoundException();
              }
              count = 1;
            } else if (count > 8) {
              if (value3 > 8.7) {
                throw new NotFoundException();
              }
              count = 8;
            }
            let offset = i3 / 2;
            if ((i3 & 1) == 0) {
              oddCounts[offset] = count;
              oddRoundingErrors[offset] = value3 - count;
            } else {
              evenCounts[offset] = count;
              evenRoundingErrors[offset] = value3 - count;
            }
          }
          this.adjustOddEvenCounts(numModules);
          let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
          let oddSum = 0;
          let oddChecksumPortion = 0;
          for (let i3 = oddCounts.length - 1; i3 >= 0; i3--) {
            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
              let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i3];
              oddChecksumPortion += oddCounts[i3] * weight;
            }
            oddSum += oddCounts[i3];
          }
          let evenChecksumPortion = 0;
          for (let i3 = evenCounts.length - 1; i3 >= 0; i3--) {
            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
              let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i3 + 1];
              evenChecksumPortion += evenCounts[i3] * weight;
            }
          }
          let checksumPortion = oddChecksumPortion + evenChecksumPortion;
          if ((oddSum & 1) != 0 || oddSum > 13 || oddSum < 4) {
            throw new NotFoundException();
          }
          let group = (13 - oddSum) / 2;
          let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
          let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
          let gSum = RSSExpandedReader.GSUM[group];
          let value2 = vOdd * tEven + vEven + gSum;
          return new DataCharacter(value2, checksumPortion);
        }
        static isNotA1left(pattern, isOddPattern, leftChar) {
          return !(pattern.getValue() == 0 && isOddPattern && leftChar);
        }
        adjustOddEvenCounts(numModules) {
          let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
          let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
          let incrementOdd = false;
          let decrementOdd = false;
          if (oddSum > 13) {
            decrementOdd = true;
          } else if (oddSum < 4) {
            incrementOdd = true;
          }
          let incrementEven = false;
          let decrementEven = false;
          if (evenSum > 13) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
          let mismatch = oddSum + evenSum - numModules;
          let oddParityBad = (oddSum & 1) == 1;
          let evenParityBad = (evenSum & 1) == 0;
          if (mismatch == 1) {
            if (oddParityBad) {
              if (evenParityBad) {
                throw new NotFoundException();
              }
              decrementOdd = true;
            } else {
              if (!evenParityBad) {
                throw new NotFoundException();
              }
              decrementEven = true;
            }
          } else if (mismatch == -1) {
            if (oddParityBad) {
              if (evenParityBad) {
                throw new NotFoundException();
              }
              incrementOdd = true;
            } else {
              if (!evenParityBad) {
                throw new NotFoundException();
              }
              incrementEven = true;
            }
          } else if (mismatch == 0) {
            if (oddParityBad) {
              if (!evenParityBad) {
                throw new NotFoundException();
              }
              if (oddSum < evenSum) {
                incrementOdd = true;
                decrementEven = true;
              } else {
                decrementOdd = true;
                incrementEven = true;
              }
            } else {
              if (evenParityBad) {
                throw new NotFoundException();
              }
            }
          } else {
            throw new NotFoundException();
          }
          if (incrementOdd) {
            if (decrementOdd) {
              throw new NotFoundException();
            }
            RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
          }
          if (decrementOdd) {
            RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
          }
          if (incrementEven) {
            if (decrementEven) {
              throw new NotFoundException();
            }
            RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
          }
          if (decrementEven) {
            RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
          }
        }
      }
      RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
      RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
      RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
      RSSExpandedReader.FINDER_PATTERNS = [
        Int32Array.from([1, 8, 4, 1]),
        Int32Array.from([3, 6, 4, 1]),
        Int32Array.from([3, 4, 6, 1]),
        Int32Array.from([3, 2, 8, 1]),
        Int32Array.from([2, 6, 5, 1]),
        Int32Array.from([2, 2, 9, 1])
        // F
      ];
      RSSExpandedReader.WEIGHTS = [
        [1, 3, 9, 27, 81, 32, 96, 77],
        [20, 60, 180, 118, 143, 7, 21, 63],
        [189, 145, 13, 39, 117, 140, 209, 205],
        [193, 157, 49, 147, 19, 57, 171, 91],
        [62, 186, 136, 197, 169, 85, 44, 132],
        [185, 133, 188, 142, 4, 12, 36, 108],
        [113, 128, 173, 97, 80, 29, 87, 50],
        [150, 28, 84, 41, 123, 158, 52, 156],
        [46, 138, 203, 187, 139, 206, 196, 166],
        [76, 17, 51, 153, 37, 111, 122, 155],
        [43, 129, 176, 106, 107, 110, 119, 146],
        [16, 48, 144, 10, 30, 90, 59, 177],
        [109, 116, 137, 200, 178, 112, 125, 164],
        [70, 210, 208, 202, 184, 130, 179, 115],
        [134, 191, 151, 31, 93, 68, 204, 190],
        [148, 22, 66, 198, 172, 94, 71, 2],
        [6, 18, 54, 162, 64, 192, 154, 40],
        [120, 149, 25, 75, 14, 42, 126, 167],
        [79, 26, 78, 23, 69, 207, 199, 175],
        [103, 98, 83, 38, 114, 131, 182, 124],
        [161, 61, 183, 127, 170, 88, 53, 159],
        [55, 165, 73, 8, 24, 72, 5, 15],
        [45, 135, 194, 160, 58, 174, 100, 89]
      ];
      RSSExpandedReader.FINDER_PAT_A = 0;
      RSSExpandedReader.FINDER_PAT_B = 1;
      RSSExpandedReader.FINDER_PAT_C = 2;
      RSSExpandedReader.FINDER_PAT_D = 3;
      RSSExpandedReader.FINDER_PAT_E = 4;
      RSSExpandedReader.FINDER_PAT_F = 5;
      RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F]
      ];
      RSSExpandedReader.MAX_PAIRS = 11;
      class Pair extends DataCharacter {
        constructor(value2, checksumPortion, finderPattern) {
          super(value2, checksumPortion);
          this.count = 0;
          this.finderPattern = finderPattern;
        }
        getFinderPattern() {
          return this.finderPattern;
        }
        getCount() {
          return this.count;
        }
        incrementCount() {
          this.count++;
        }
      }
      class RSS14Reader extends AbstractRSSReader {
        constructor() {
          super(...arguments);
          this.possibleLeftPairs = [];
          this.possibleRightPairs = [];
        }
        decodeRow(rowNumber, row, hints) {
          const leftPair = this.decodePair(row, false, rowNumber, hints);
          RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
          row.reverse();
          let rightPair = this.decodePair(row, true, rowNumber, hints);
          RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
          row.reverse();
          for (let left of this.possibleLeftPairs) {
            if (left.getCount() > 1) {
              for (let right of this.possibleRightPairs) {
                if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                  return RSS14Reader.constructResult(left, right);
                }
              }
            }
          }
          throw new NotFoundException();
        }
        static addOrTally(possiblePairs, pair) {
          if (pair == null) {
            return;
          }
          let found = false;
          for (let other of possiblePairs) {
            if (other.getValue() === pair.getValue()) {
              other.incrementCount();
              found = true;
              break;
            }
          }
          if (!found) {
            possiblePairs.push(pair);
          }
        }
        reset() {
          this.possibleLeftPairs.length = 0;
          this.possibleRightPairs.length = 0;
        }
        static constructResult(leftPair, rightPair) {
          let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
          let text = new String(symbolValue).toString();
          let buffer = new StringBuilder();
          for (let i3 = 13 - text.length; i3 > 0; i3--) {
            buffer.append("0");
          }
          buffer.append(text);
          let checkDigit = 0;
          for (let i3 = 0; i3 < 13; i3++) {
            let digit = buffer.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
            checkDigit += (i3 & 1) === 0 ? 3 * digit : digit;
          }
          checkDigit = 10 - checkDigit % 10;
          if (checkDigit === 10) {
            checkDigit = 0;
          }
          buffer.append(checkDigit.toString());
          let leftPoints = leftPair.getFinderPattern().getResultPoints();
          let rightPoints = rightPair.getFinderPattern().getResultPoints();
          return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, (/* @__PURE__ */ new Date()).getTime());
        }
        static checkChecksum(leftPair, rightPair) {
          let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
          let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
          if (targetCheckValue > 72) {
            targetCheckValue--;
          }
          if (targetCheckValue > 8) {
            targetCheckValue--;
          }
          return checkValue === targetCheckValue;
        }
        decodePair(row, right, rowNumber, hints) {
          try {
            let startEnd = this.findFinderPattern(row, right);
            let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
            let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            if (resultPointCallback != null) {
              let center = (startEnd[0] + startEnd[1]) / 2;
              if (right) {
                center = row.getSize() - 1 - center;
              }
              resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));
            }
            let outside = this.decodeDataCharacter(row, pattern, true);
            let inside = this.decodeDataCharacter(row, pattern, false);
            return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
          } catch (err) {
            return null;
          }
        }
        decodeDataCharacter(row, pattern, outsideChar) {
          let counters = this.getDataCharacterCounters();
          for (let x2 = 0; x2 < counters.length; x2++) {
            counters[x2] = 0;
          }
          if (outsideChar) {
            OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
          } else {
            OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
            for (let i3 = 0, j2 = counters.length - 1; i3 < j2; i3++, j2--) {
              let temp = counters[i3];
              counters[i3] = counters[j2];
              counters[j2] = temp;
            }
          }
          let numModules = outsideChar ? 16 : 15;
          let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
          let oddCounts = this.getOddCounts();
          let evenCounts = this.getEvenCounts();
          let oddRoundingErrors = this.getOddRoundingErrors();
          let evenRoundingErrors = this.getEvenRoundingErrors();
          for (let i3 = 0; i3 < counters.length; i3++) {
            let value2 = counters[i3] / elementWidth;
            let count = Math.floor(value2 + 0.5);
            if (count < 1) {
              count = 1;
            } else if (count > 8) {
              count = 8;
            }
            let offset = Math.floor(i3 / 2);
            if ((i3 & 1) === 0) {
              oddCounts[offset] = count;
              oddRoundingErrors[offset] = value2 - count;
            } else {
              evenCounts[offset] = count;
              evenRoundingErrors[offset] = value2 - count;
            }
          }
          this.adjustOddEvenCounts(outsideChar, numModules);
          let oddSum = 0;
          let oddChecksumPortion = 0;
          for (let i3 = oddCounts.length - 1; i3 >= 0; i3--) {
            oddChecksumPortion *= 9;
            oddChecksumPortion += oddCounts[i3];
            oddSum += oddCounts[i3];
          }
          let evenChecksumPortion = 0;
          let evenSum = 0;
          for (let i3 = evenCounts.length - 1; i3 >= 0; i3--) {
            evenChecksumPortion *= 9;
            evenChecksumPortion += evenCounts[i3];
            evenSum += evenCounts[i3];
          }
          let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
          if (outsideChar) {
            if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
              throw new NotFoundException();
            }
            let group = (12 - oddSum) / 2;
            let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
            let evenWidest = 9 - oddWidest;
            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);
            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);
            let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
            let gSum = RSS14Reader.OUTSIDE_GSUM[group];
            return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);
          } else {
            if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
              throw new NotFoundException();
            }
            let group = (10 - evenSum) / 2;
            let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
            let evenWidest = 9 - oddWidest;
            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
            let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
            let gSum = RSS14Reader.INSIDE_GSUM[group];
            return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);
          }
        }
        findFinderPattern(row, rightFinderPattern) {
          let counters = this.getDecodeFinderCounters();
          counters[0] = 0;
          counters[1] = 0;
          counters[2] = 0;
          counters[3] = 0;
          let width = row.getSize();
          let isWhite = false;
          let rowOffset = 0;
          while (rowOffset < width) {
            isWhite = !row.get(rowOffset);
            if (rightFinderPattern === isWhite) {
              break;
            }
            rowOffset++;
          }
          let counterPosition = 0;
          let patternStart = rowOffset;
          for (let x2 = rowOffset; x2 < width; x2++) {
            if (row.get(x2) !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition === 3) {
                if (AbstractRSSReader.isFinderPattern(counters)) {
                  return [patternStart, x2];
                }
                patternStart += counters[0] + counters[1];
                counters[0] = counters[2];
                counters[1] = counters[3];
                counters[2] = 0;
                counters[3] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          throw new NotFoundException();
        }
        parseFoundFinderPattern(row, rowNumber, right, startEnd) {
          let firstIsBlack = row.get(startEnd[0]);
          let firstElementStart = startEnd[0] - 1;
          while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
            firstElementStart--;
          }
          firstElementStart++;
          const firstCounter = startEnd[0] - firstElementStart;
          const counters = this.getDecodeFinderCounters();
          const copy = new Int32Array(counters.length);
          System.arraycopy(counters, 0, copy, 1, counters.length - 1);
          copy[0] = firstCounter;
          const value2 = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
          let start = firstElementStart;
          let end = startEnd[1];
          if (right) {
            start = row.getSize() - 1 - start;
            end = row.getSize() - 1 - end;
          }
          return new FinderPattern(value2, [firstElementStart, startEnd[1]], start, end, rowNumber);
        }
        adjustOddEvenCounts(outsideChar, numModules) {
          let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
          let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
          let incrementOdd = false;
          let decrementOdd = false;
          let incrementEven = false;
          let decrementEven = false;
          if (outsideChar) {
            if (oddSum > 12) {
              decrementOdd = true;
            } else if (oddSum < 4) {
              incrementOdd = true;
            }
            if (evenSum > 12) {
              decrementEven = true;
            } else if (evenSum < 4) {
              incrementEven = true;
            }
          } else {
            if (oddSum > 11) {
              decrementOdd = true;
            } else if (oddSum < 5) {
              incrementOdd = true;
            }
            if (evenSum > 10) {
              decrementEven = true;
            } else if (evenSum < 4) {
              incrementEven = true;
            }
          }
          let mismatch = oddSum + evenSum - numModules;
          let oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
          let evenParityBad = (evenSum & 1) === 1;
          if (mismatch === 1) {
            if (oddParityBad) {
              if (evenParityBad) {
                throw new NotFoundException();
              }
              decrementOdd = true;
            } else {
              if (!evenParityBad) {
                throw new NotFoundException();
              }
              decrementEven = true;
            }
          } else if (mismatch === -1) {
            if (oddParityBad) {
              if (evenParityBad) {
                throw new NotFoundException();
              }
              incrementOdd = true;
            } else {
              if (!evenParityBad) {
                throw new NotFoundException();
              }
              incrementEven = true;
            }
          } else if (mismatch === 0) {
            if (oddParityBad) {
              if (!evenParityBad) {
                throw new NotFoundException();
              }
              if (oddSum < evenSum) {
                incrementOdd = true;
                decrementEven = true;
              } else {
                decrementOdd = true;
                incrementEven = true;
              }
            } else {
              if (evenParityBad) {
                throw new NotFoundException();
              }
            }
          } else {
            throw new NotFoundException();
          }
          if (incrementOdd) {
            if (decrementOdd) {
              throw new NotFoundException();
            }
            AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
          }
          if (decrementOdd) {
            AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
          }
          if (incrementEven) {
            if (decrementEven) {
              throw new NotFoundException();
            }
            AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
          }
          if (decrementEven) {
            AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
          }
        }
      }
      RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
      RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
      RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
      RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
      RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
      RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
      RSS14Reader.FINDER_PATTERNS = [
        Int32Array.from([3, 8, 2, 1]),
        Int32Array.from([3, 5, 5, 1]),
        Int32Array.from([3, 3, 7, 1]),
        Int32Array.from([3, 1, 9, 1]),
        Int32Array.from([2, 7, 4, 1]),
        Int32Array.from([2, 5, 6, 1]),
        Int32Array.from([2, 3, 8, 1]),
        Int32Array.from([1, 5, 7, 1]),
        Int32Array.from([1, 3, 9, 1])
      ];
      class MultiFormatOneDReader extends OneDReader {
        constructor(hints, verbose) {
          super();
          this.readers = [];
          this.verbose = verbose === true;
          const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
          const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
          if (possibleFormats) {
            if (possibleFormats.includes(BarcodeFormat$1.EAN_13) || possibleFormats.includes(BarcodeFormat$1.UPC_A) || possibleFormats.includes(BarcodeFormat$1.EAN_8) || possibleFormats.includes(BarcodeFormat$1.UPC_E)) {
              this.readers.push(new MultiFormatUPCEANReader(hints));
            }
            if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {
              this.readers.push(new Code39Reader(useCode39CheckDigit));
            }
            if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {
              this.readers.push(new Code128Reader());
            }
            if (possibleFormats.includes(BarcodeFormat$1.ITF)) {
              this.readers.push(new ITFReader());
            }
            if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {
              this.readers.push(new RSS14Reader());
            }
            if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {
              this.readers.push(new RSSExpandedReader(this.verbose));
            }
          } else {
            this.readers.push(new MultiFormatUPCEANReader(hints));
            this.readers.push(new Code39Reader());
            this.readers.push(new MultiFormatUPCEANReader(hints));
            this.readers.push(new Code128Reader());
            this.readers.push(new ITFReader());
            this.readers.push(new RSS14Reader());
            this.readers.push(new RSSExpandedReader(this.verbose));
          }
        }
        // @Override
        decodeRow(rowNumber, row, hints) {
          for (let i3 = 0; i3 < this.readers.length; i3++) {
            try {
              return this.readers[i3].decodeRow(rowNumber, row, hints);
            } catch (re3) {
            }
          }
          throw new NotFoundException();
        }
        // @Override
        reset() {
          this.readers.forEach((reader) => reader.reset());
        }
      }
      class BrowserBarcodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserBarcodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         * @param {Map<DecodeHintType, any>} hints
         */
        constructor(timeBetweenScansMillis = 500, hints) {
          super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);
        }
      }
      class ECBlocks {
        constructor(ecCodewords, ecBlocks1, ecBlocks2) {
          this.ecCodewords = ecCodewords;
          this.ecBlocks = [ecBlocks1];
          ecBlocks2 && this.ecBlocks.push(ecBlocks2);
        }
        getECCodewords() {
          return this.ecCodewords;
        }
        getECBlocks() {
          return this.ecBlocks;
        }
      }
      class ECB {
        constructor(count, dataCodewords) {
          this.count = count;
          this.dataCodewords = dataCodewords;
        }
        getCount() {
          return this.count;
        }
        getDataCodewords() {
          return this.dataCodewords;
        }
      }
      class Version {
        constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
          this.versionNumber = versionNumber;
          this.symbolSizeRows = symbolSizeRows;
          this.symbolSizeColumns = symbolSizeColumns;
          this.dataRegionSizeRows = dataRegionSizeRows;
          this.dataRegionSizeColumns = dataRegionSizeColumns;
          this.ecBlocks = ecBlocks;
          let total = 0;
          const ecCodewords = ecBlocks.getECCodewords();
          const ecbArray = ecBlocks.getECBlocks();
          for (let ecBlock of ecbArray) {
            total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
          }
          this.totalCodewords = total;
        }
        getVersionNumber() {
          return this.versionNumber;
        }
        getSymbolSizeRows() {
          return this.symbolSizeRows;
        }
        getSymbolSizeColumns() {
          return this.symbolSizeColumns;
        }
        getDataRegionSizeRows() {
          return this.dataRegionSizeRows;
        }
        getDataRegionSizeColumns() {
          return this.dataRegionSizeColumns;
        }
        getTotalCodewords() {
          return this.totalCodewords;
        }
        getECBlocks() {
          return this.ecBlocks;
        }
        /**
         * <p>Deduces version information from Data Matrix dimensions.</p>
         *
         * @param numRows Number of rows in modules
         * @param numColumns Number of columns in modules
         * @return Version for a Data Matrix Code of those dimensions
         * @throws FormatException if dimensions do correspond to a valid Data Matrix size
         */
        static getVersionForDimensions(numRows, numColumns) {
          if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
            throw new FormatException();
          }
          for (let version of Version.VERSIONS) {
            if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
              return version;
            }
          }
          throw new FormatException();
        }
        //  @Override
        toString() {
          return "" + this.versionNumber;
        }
        /**
         * See ISO 16022:2006 5.5.1 Table 7
         */
        static buildVersions() {
          return [
            new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
            new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
            new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
            new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
            new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
            new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
            new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
            new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
            new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
            new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
            new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
            new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
            new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
            new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
            new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
            new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
            new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
            new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
            new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
            new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
            new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
            new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
            new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
            new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
            new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
            new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
            new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
            new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
            new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
            new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
          ];
        }
      }
      Version.VERSIONS = Version.buildVersions();
      class BitMatrixParser {
        /**
         * @param bitMatrix {@link BitMatrix} to parse
         * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2
         */
        constructor(bitMatrix) {
          const dimension = bitMatrix.getHeight();
          if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
            throw new FormatException();
          }
          this.version = BitMatrixParser.readVersion(bitMatrix);
          this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
          this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
        }
        getVersion() {
          return this.version;
        }
        /**
         * <p>Creates the version object based on the dimension of the original bit matrix from
         * the datamatrix code.</p>
         *
         * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>
         *
         * @param bitMatrix Original {@link BitMatrix} including alignment patterns
         * @return {@link Version} encapsulating the Data Matrix Code's "version"
         * @throws FormatException if the dimensions of the mapping matrix are not valid
         * Data Matrix dimensions.
         */
        static readVersion(bitMatrix) {
          const numRows = bitMatrix.getHeight();
          const numColumns = bitMatrix.getWidth();
          return Version.getVersionForDimensions(numRows, numColumns);
        }
        /**
         * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)
         * in the correct order in order to reconstitute the codewords bytes contained within the
         * Data Matrix Code.</p>
         *
         * @return bytes encoded within the Data Matrix Code
         * @throws FormatException if the exact number of bytes expected is not read
         */
        readCodewords() {
          const result = new Int8Array(this.version.getTotalCodewords());
          let resultOffset = 0;
          let row = 4;
          let column = 0;
          const numRows = this.mappingBitMatrix.getHeight();
          const numColumns = this.mappingBitMatrix.getWidth();
          let corner1Read = false;
          let corner2Read = false;
          let corner3Read = false;
          let corner4Read = false;
          do {
            if (row === numRows && column === 0 && !corner1Read) {
              result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
              row -= 2;
              column += 2;
              corner1Read = true;
            } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
              result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
              row -= 2;
              column += 2;
              corner2Read = true;
            } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
              result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
              row -= 2;
              column += 2;
              corner3Read = true;
            } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
              result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
              row -= 2;
              column += 2;
              corner4Read = true;
            } else {
              do {
                if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
                  result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
                }
                row -= 2;
                column += 2;
              } while (row >= 0 && column < numColumns);
              row += 1;
              column += 3;
              do {
                if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
                  result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
                }
                row += 2;
                column -= 2;
              } while (row < numRows && column >= 0);
              row += 3;
              column += 1;
            }
          } while (row < numRows || column < numColumns);
          if (resultOffset !== this.version.getTotalCodewords()) {
            throw new FormatException();
          }
          return result;
        }
        /**
         * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>
         *
         * @param row Row to read in the mapping matrix
         * @param column Column to read in the mapping matrix
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return value of the given bit in the mapping matrix
         */
        readModule(row, column, numRows, numColumns) {
          if (row < 0) {
            row += numRows;
            column += 4 - (numRows + 4 & 7);
          }
          if (column < 0) {
            column += numColumns;
            row += 4 - (numColumns + 4 & 7);
          }
          this.readMappingMatrix.set(column, row);
          return this.mappingBitMatrix.get(column, row);
        }
        /**
         * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>
         *
         * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>
         *
         * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
         * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the utah shape
         */
        readUtah(row, column, numRows, numColumns) {
          let currentByte = 0;
          if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row - 1, column, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row, column - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row, column - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(row, column, numRows, numColumns)) {
            currentByte |= 1;
          }
          return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 1.</p>
         *
         * <p>See ISO 16022:2006, Figure F.3</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 1
         */
        readCorner1(numRows, numColumns) {
          let currentByte = 0;
          if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 2.</p>
         *
         * <p>See ISO 16022:2006, Figure F.4</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 2
         */
        readCorner2(numRows, numColumns) {
          let currentByte = 0;
          if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 3.</p>
         *
         * <p>See ISO 16022:2006, Figure F.5</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 3
         */
        readCorner3(numRows, numColumns) {
          let currentByte = 0;
          if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 4.</p>
         *
         * <p>See ISO 16022:2006, Figure F.6</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 4
         */
        readCorner4(numRows, numColumns) {
          let currentByte = 0;
          if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          currentByte <<= 1;
          if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
          }
          return currentByte;
        }
        /**
         * <p>Extracts the data region from a {@link BitMatrix} that contains
         * alignment patterns.</p>
         *
         * @param bitMatrix Original {@link BitMatrix} with alignment patterns
         * @return BitMatrix that has the alignment patterns removed
         */
        extractDataRegion(bitMatrix) {
          const symbolSizeRows = this.version.getSymbolSizeRows();
          const symbolSizeColumns = this.version.getSymbolSizeColumns();
          if (bitMatrix.getHeight() !== symbolSizeRows) {
            throw new IllegalArgumentException("Dimension of bitMatrix must match the version size");
          }
          const dataRegionSizeRows = this.version.getDataRegionSizeRows();
          const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
          const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
          const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
          const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
          const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
          const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);
          for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
            const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
            for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
              const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
              for (let i3 = 0; i3 < dataRegionSizeRows; ++i3) {
                const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i3;
                const writeRowOffset = dataRegionRowOffset + i3;
                for (let j2 = 0; j2 < dataRegionSizeColumns; ++j2) {
                  const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j2;
                  if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                    const writeColumnOffset = dataRegionColumnOffset + j2;
                    bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                  }
                }
              }
            }
          }
          return bitMatrixWithoutAlignment;
        }
      }
      class DataBlock {
        constructor(numDataCodewords, codewords) {
          this.numDataCodewords = numDataCodewords;
          this.codewords = codewords;
        }
        /**
         * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.
         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
         * method will separate the data into original blocks.</p>
         *
         * @param rawCodewords bytes as read directly from the Data Matrix Code
         * @param version version of the Data Matrix Code
         * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
         *         Data Matrix Code
         */
        static getDataBlocks(rawCodewords, version) {
          const ecBlocks = version.getECBlocks();
          let totalBlocks = 0;
          const ecBlockArray = ecBlocks.getECBlocks();
          for (let ecBlock of ecBlockArray) {
            totalBlocks += ecBlock.getCount();
          }
          const result = new Array(totalBlocks);
          let numResultBlocks = 0;
          for (let ecBlock of ecBlockArray) {
            for (let i3 = 0; i3 < ecBlock.getCount(); i3++) {
              const numDataCodewords = ecBlock.getDataCodewords();
              const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
              result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
            }
          }
          const longerBlocksTotalCodewords = result[0].codewords.length;
          const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
          const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
          let rawCodewordsOffset = 0;
          for (let i3 = 0; i3 < shorterBlocksNumDataCodewords; i3++) {
            for (let j2 = 0; j2 < numResultBlocks; j2++) {
              result[j2].codewords[i3] = rawCodewords[rawCodewordsOffset++];
            }
          }
          const specialVersion = version.getVersionNumber() === 24;
          const numLongerBlocks = specialVersion ? 8 : numResultBlocks;
          for (let j2 = 0; j2 < numLongerBlocks; j2++) {
            result[j2].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
          }
          const max2 = result[0].codewords.length;
          for (let i3 = longerBlocksNumDataCodewords; i3 < max2; i3++) {
            for (let j2 = 0; j2 < numResultBlocks; j2++) {
              const jOffset = specialVersion ? (j2 + 8) % numResultBlocks : j2;
              const iOffset = specialVersion && jOffset > 7 ? i3 - 1 : i3;
              result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
            }
          }
          if (rawCodewordsOffset !== rawCodewords.length) {
            throw new IllegalArgumentException();
          }
          return result;
        }
        getNumDataCodewords() {
          return this.numDataCodewords;
        }
        getCodewords() {
          return this.codewords;
        }
      }
      class BitSource {
        /**
         * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.
         * Bits are read within a byte from most-significant to least-significant bit.
         */
        constructor(bytes) {
          this.bytes = bytes;
          this.byteOffset = 0;
          this.bitOffset = 0;
        }
        /**
         * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
         */
        getBitOffset() {
          return this.bitOffset;
        }
        /**
         * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
         */
        getByteOffset() {
          return this.byteOffset;
        }
        /**
         * @param numBits number of bits to read
         * @return int representing the bits read. The bits will appear as the least-significant
         *         bits of the int
         * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available
         */
        readBits(numBits) {
          if (numBits < 1 || numBits > 32 || numBits > this.available()) {
            throw new IllegalArgumentException("" + numBits);
          }
          let result = 0;
          let bitOffset = this.bitOffset;
          let byteOffset = this.byteOffset;
          const bytes = this.bytes;
          if (bitOffset > 0) {
            const bitsLeft = 8 - bitOffset;
            const toRead = numBits < bitsLeft ? numBits : bitsLeft;
            const bitsToNotRead = bitsLeft - toRead;
            const mask = 255 >> 8 - toRead << bitsToNotRead;
            result = (bytes[byteOffset] & mask) >> bitsToNotRead;
            numBits -= toRead;
            bitOffset += toRead;
            if (bitOffset === 8) {
              bitOffset = 0;
              byteOffset++;
            }
          }
          if (numBits > 0) {
            while (numBits >= 8) {
              result = result << 8 | bytes[byteOffset] & 255;
              byteOffset++;
              numBits -= 8;
            }
            if (numBits > 0) {
              const bitsToNotRead = 8 - numBits;
              const mask = 255 >> bitsToNotRead << bitsToNotRead;
              result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;
              bitOffset += numBits;
            }
          }
          this.bitOffset = bitOffset;
          this.byteOffset = byteOffset;
          return result;
        }
        /**
         * @return number of bits that can be read successfully
         */
        available() {
          return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
        }
      }
      var Mode;
      (function(Mode2) {
        Mode2[Mode2["PAD_ENCODE"] = 0] = "PAD_ENCODE";
        Mode2[Mode2["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
        Mode2[Mode2["C40_ENCODE"] = 2] = "C40_ENCODE";
        Mode2[Mode2["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
        Mode2[Mode2["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
        Mode2[Mode2["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
        Mode2[Mode2["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
      })(Mode || (Mode = {}));
      class DecodedBitStreamParser {
        static decode(bytes) {
          const bits2 = new BitSource(bytes);
          const result = new StringBuilder();
          const resultTrailer = new StringBuilder();
          const byteSegments = new Array();
          let mode = Mode.ASCII_ENCODE;
          do {
            if (mode === Mode.ASCII_ENCODE) {
              mode = this.decodeAsciiSegment(bits2, result, resultTrailer);
            } else {
              switch (mode) {
                case Mode.C40_ENCODE:
                  this.decodeC40Segment(bits2, result);
                  break;
                case Mode.TEXT_ENCODE:
                  this.decodeTextSegment(bits2, result);
                  break;
                case Mode.ANSIX12_ENCODE:
                  this.decodeAnsiX12Segment(bits2, result);
                  break;
                case Mode.EDIFACT_ENCODE:
                  this.decodeEdifactSegment(bits2, result);
                  break;
                case Mode.BASE256_ENCODE:
                  this.decodeBase256Segment(bits2, result, byteSegments);
                  break;
                default:
                  throw new FormatException();
              }
              mode = Mode.ASCII_ENCODE;
            }
          } while (mode !== Mode.PAD_ENCODE && bits2.available() > 0);
          if (resultTrailer.length() > 0) {
            result.append(resultTrailer.toString());
          }
          return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
        }
        /**
         * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2
         */
        static decodeAsciiSegment(bits2, result, resultTrailer) {
          let upperShift = false;
          do {
            let oneByte = bits2.readBits(8);
            if (oneByte === 0) {
              throw new FormatException();
            } else if (oneByte <= 128) {
              if (upperShift) {
                oneByte += 128;
              }
              result.append(String.fromCharCode(oneByte - 1));
              return Mode.ASCII_ENCODE;
            } else if (oneByte === 129) {
              return Mode.PAD_ENCODE;
            } else if (oneByte <= 229) {
              const value2 = oneByte - 130;
              if (value2 < 10) {
                result.append("0");
              }
              result.append("" + value2);
            } else {
              switch (oneByte) {
                case 230:
                  return Mode.C40_ENCODE;
                case 231:
                  return Mode.BASE256_ENCODE;
                case 232:
                  result.append(String.fromCharCode(29));
                  break;
                case 233:
                case 234:
                  break;
                case 235:
                  upperShift = true;
                  break;
                case 236:
                  result.append("[)>05");
                  resultTrailer.insert(0, "");
                  break;
                case 237:
                  result.append("[)>06");
                  resultTrailer.insert(0, "");
                  break;
                case 238:
                  return Mode.ANSIX12_ENCODE;
                case 239:
                  return Mode.TEXT_ENCODE;
                case 240:
                  return Mode.EDIFACT_ENCODE;
                case 241:
                  break;
                default:
                  if (oneByte !== 254 || bits2.available() !== 0) {
                    throw new FormatException();
                  }
                  break;
              }
            }
          } while (bits2.available() > 0);
          return Mode.ASCII_ENCODE;
        }
        /**
         * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1
         */
        static decodeC40Segment(bits2, result) {
          let upperShift = false;
          const cValues = [];
          let shift = 0;
          do {
            if (bits2.available() === 8) {
              return;
            }
            const firstByte = bits2.readBits(8);
            if (firstByte === 254) {
              return;
            }
            this.parseTwoBytes(firstByte, bits2.readBits(8), cValues);
            for (let i3 = 0; i3 < 3; i3++) {
              const cValue = cValues[i3];
              switch (shift) {
                case 0:
                  if (cValue < 3) {
                    shift = cValue + 1;
                  } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                    const c40char = this.C40_BASIC_SET_CHARS[cValue];
                    if (upperShift) {
                      result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                      upperShift = false;
                    } else {
                      result.append(c40char);
                    }
                  } else {
                    throw new FormatException();
                  }
                  break;
                case 1:
                  if (upperShift) {
                    result.append(String.fromCharCode(cValue + 128));
                    upperShift = false;
                  } else {
                    result.append(String.fromCharCode(cValue));
                  }
                  shift = 0;
                  break;
                case 2:
                  if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                    const c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                    if (upperShift) {
                      result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                      upperShift = false;
                    } else {
                      result.append(c40char);
                    }
                  } else {
                    switch (cValue) {
                      case 27:
                        result.append(String.fromCharCode(29));
                        break;
                      case 30:
                        upperShift = true;
                        break;
                      default:
                        throw new FormatException();
                    }
                  }
                  shift = 0;
                  break;
                case 3:
                  if (upperShift) {
                    result.append(String.fromCharCode(cValue + 224));
                    upperShift = false;
                  } else {
                    result.append(String.fromCharCode(cValue + 96));
                  }
                  shift = 0;
                  break;
                default:
                  throw new FormatException();
              }
            }
          } while (bits2.available() > 0);
        }
        /**
         * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2
         */
        static decodeTextSegment(bits2, result) {
          let upperShift = false;
          let cValues = [];
          let shift = 0;
          do {
            if (bits2.available() === 8) {
              return;
            }
            const firstByte = bits2.readBits(8);
            if (firstByte === 254) {
              return;
            }
            this.parseTwoBytes(firstByte, bits2.readBits(8), cValues);
            for (let i3 = 0; i3 < 3; i3++) {
              const cValue = cValues[i3];
              switch (shift) {
                case 0:
                  if (cValue < 3) {
                    shift = cValue + 1;
                  } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                    const textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                    if (upperShift) {
                      result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                      upperShift = false;
                    } else {
                      result.append(textChar);
                    }
                  } else {
                    throw new FormatException();
                  }
                  break;
                case 1:
                  if (upperShift) {
                    result.append(String.fromCharCode(cValue + 128));
                    upperShift = false;
                  } else {
                    result.append(String.fromCharCode(cValue));
                  }
                  shift = 0;
                  break;
                case 2:
                  if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                    const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                    if (upperShift) {
                      result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                      upperShift = false;
                    } else {
                      result.append(textChar);
                    }
                  } else {
                    switch (cValue) {
                      case 27:
                        result.append(String.fromCharCode(29));
                        break;
                      case 30:
                        upperShift = true;
                        break;
                      default:
                        throw new FormatException();
                    }
                  }
                  shift = 0;
                  break;
                case 3:
                  if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                    const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                    if (upperShift) {
                      result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                      upperShift = false;
                    } else {
                      result.append(textChar);
                    }
                    shift = 0;
                  } else {
                    throw new FormatException();
                  }
                  break;
                default:
                  throw new FormatException();
              }
            }
          } while (bits2.available() > 0);
        }
        /**
         * See ISO 16022:2006, 5.2.7
         */
        static decodeAnsiX12Segment(bits2, result) {
          const cValues = [];
          do {
            if (bits2.available() === 8) {
              return;
            }
            const firstByte = bits2.readBits(8);
            if (firstByte === 254) {
              return;
            }
            this.parseTwoBytes(firstByte, bits2.readBits(8), cValues);
            for (let i3 = 0; i3 < 3; i3++) {
              const cValue = cValues[i3];
              switch (cValue) {
                case 0:
                  result.append("\r");
                  break;
                case 1:
                  result.append("*");
                  break;
                case 2:
                  result.append(">");
                  break;
                case 3:
                  result.append(" ");
                  break;
                default:
                  if (cValue < 14) {
                    result.append(String.fromCharCode(cValue + 44));
                  } else if (cValue < 40) {
                    result.append(String.fromCharCode(cValue + 51));
                  } else {
                    throw new FormatException();
                  }
                  break;
              }
            }
          } while (bits2.available() > 0);
        }
        static parseTwoBytes(firstByte, secondByte, result) {
          let fullBitValue = (firstByte << 8) + secondByte - 1;
          let temp = Math.floor(fullBitValue / 1600);
          result[0] = temp;
          fullBitValue -= temp * 1600;
          temp = Math.floor(fullBitValue / 40);
          result[1] = temp;
          result[2] = fullBitValue - temp * 40;
        }
        /**
         * See ISO 16022:2006, 5.2.8 and Annex C Table C.3
         */
        static decodeEdifactSegment(bits2, result) {
          do {
            if (bits2.available() <= 16) {
              return;
            }
            for (let i3 = 0; i3 < 4; i3++) {
              let edifactValue = bits2.readBits(6);
              if (edifactValue === 31) {
                const bitsLeft = 8 - bits2.getBitOffset();
                if (bitsLeft !== 8) {
                  bits2.readBits(bitsLeft);
                }
                return;
              }
              if ((edifactValue & 32) === 0) {
                edifactValue |= 64;
              }
              result.append(String.fromCharCode(edifactValue));
            }
          } while (bits2.available() > 0);
        }
        /**
         * See ISO 16022:2006, 5.2.9 and Annex B, B.2
         */
        static decodeBase256Segment(bits2, result, byteSegments) {
          let codewordPosition = 1 + bits2.getByteOffset();
          const d1 = this.unrandomize255State(bits2.readBits(8), codewordPosition++);
          let count;
          if (d1 === 0) {
            count = bits2.available() / 8 | 0;
          } else if (d1 < 250) {
            count = d1;
          } else {
            count = 250 * (d1 - 249) + this.unrandomize255State(bits2.readBits(8), codewordPosition++);
          }
          if (count < 0) {
            throw new FormatException();
          }
          const bytes = new Uint8Array(count);
          for (let i3 = 0; i3 < count; i3++) {
            if (bits2.available() < 8) {
              throw new FormatException();
            }
            bytes[i3] = this.unrandomize255State(bits2.readBits(8), codewordPosition++);
          }
          byteSegments.push(bytes);
          try {
            result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));
          } catch (uee) {
            throw new IllegalStateException("Platform does not support required encoding: " + uee.message);
          }
        }
        /**
         * See ISO 16022:2006, Annex B, B.2
         */
        static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {
          const pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
          const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
          return tempVariable >= 0 ? tempVariable : tempVariable + 256;
        }
      }
      DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
        "*",
        "*",
        "*",
        " ",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z"
      ];
      DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
        "!",
        '"',
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "@",
        "[",
        "\\",
        "]",
        "^",
        "_"
      ];
      DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
        "*",
        "*",
        "*",
        " ",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z"
      ];
      DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
      DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
        "`",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "{",
        "|",
        "}",
        "~",
        String.fromCharCode(127)
      ];
      class Decoder$1 {
        constructor() {
          this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
        }
        /**
         * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken
         * to mean a black module.</p>
         *
         * @param bits booleans representing white/black Data Matrix Code modules
         * @return text and bytes encoded within the Data Matrix Code
         * @throws FormatException if the Data Matrix Code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        decode(bits2) {
          const parser = new BitMatrixParser(bits2);
          const version = parser.getVersion();
          const codewords = parser.readCodewords();
          const dataBlocks = DataBlock.getDataBlocks(codewords, version);
          let totalBytes = 0;
          for (let db of dataBlocks) {
            totalBytes += db.getNumDataCodewords();
          }
          const resultBytes = new Uint8Array(totalBytes);
          const dataBlocksCount = dataBlocks.length;
          for (let j2 = 0; j2 < dataBlocksCount; j2++) {
            const dataBlock = dataBlocks[j2];
            const codewordBytes = dataBlock.getCodewords();
            const numDataCodewords = dataBlock.getNumDataCodewords();
            this.correctErrors(codewordBytes, numDataCodewords);
            for (let i3 = 0; i3 < numDataCodewords; i3++) {
              resultBytes[i3 * dataBlocksCount + j2] = codewordBytes[i3];
            }
          }
          return DecodedBitStreamParser.decode(resultBytes);
        }
        /**
         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
         * correct the errors in-place using Reed-Solomon error correction.</p>
         *
         * @param codewordBytes data and error correction codewords
         * @param numDataCodewords number of codewords that are data bytes
         * @throws ChecksumException if error correction fails
         */
        correctErrors(codewordBytes, numDataCodewords) {
          const codewordsInts = new Int32Array(codewordBytes);
          try {
            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
          } catch (ignored) {
            throw new ChecksumException();
          }
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            codewordBytes[i3] = codewordsInts[i3];
          }
        }
      }
      class Detector$1 {
        constructor(image) {
          this.image = image;
          this.rectangleDetector = new WhiteRectangleDetector(this.image);
        }
        /**
         * <p>Detects a Data Matrix Code in an image.</p>
         *
         * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code
         * @throws NotFoundException if no Data Matrix Code can be found
         */
        detect() {
          const cornerPoints = this.rectangleDetector.detect();
          let points = this.detectSolid1(cornerPoints);
          points = this.detectSolid2(points);
          points[3] = this.correctTopRight(points);
          if (!points[3]) {
            throw new NotFoundException();
          }
          points = this.shiftToModuleCenter(points);
          const topLeft = points[0];
          const bottomLeft = points[1];
          const bottomRight = points[2];
          const topRight = points[3];
          let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
          let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
          if ((dimensionTop & 1) === 1) {
            dimensionTop += 1;
          }
          if ((dimensionRight & 1) === 1) {
            dimensionRight += 1;
          }
          if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
            dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
          }
          let bits2 = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
          return new DetectorResult(bits2, [topLeft, bottomLeft, bottomRight, topRight]);
        }
        static shiftPoint(point, to, div) {
          let x2 = (to.getX() - point.getX()) / (div + 1);
          let y2 = (to.getY() - point.getY()) / (div + 1);
          return new ResultPoint(point.getX() + x2, point.getY() + y2);
        }
        static moveAway(point, fromX, fromY) {
          let x2 = point.getX();
          let y2 = point.getY();
          if (x2 < fromX) {
            x2 -= 1;
          } else {
            x2 += 1;
          }
          if (y2 < fromY) {
            y2 -= 1;
          } else {
            y2 += 1;
          }
          return new ResultPoint(x2, y2);
        }
        /**
         * Detect a solid side which has minimum transition.
         */
        detectSolid1(cornerPoints) {
          let pointA = cornerPoints[0];
          let pointB = cornerPoints[1];
          let pointC = cornerPoints[3];
          let pointD = cornerPoints[2];
          let trAB = this.transitionsBetween(pointA, pointB);
          let trBC = this.transitionsBetween(pointB, pointC);
          let trCD = this.transitionsBetween(pointC, pointD);
          let trDA = this.transitionsBetween(pointD, pointA);
          let min = trAB;
          let points = [pointD, pointA, pointB, pointC];
          if (min > trBC) {
            min = trBC;
            points[0] = pointA;
            points[1] = pointB;
            points[2] = pointC;
            points[3] = pointD;
          }
          if (min > trCD) {
            min = trCD;
            points[0] = pointB;
            points[1] = pointC;
            points[2] = pointD;
            points[3] = pointA;
          }
          if (min > trDA) {
            points[0] = pointC;
            points[1] = pointD;
            points[2] = pointA;
            points[3] = pointB;
          }
          return points;
        }
        /**
         * Detect a second solid side next to first solid side.
         */
        detectSolid2(points) {
          let pointA = points[0];
          let pointB = points[1];
          let pointC = points[2];
          let pointD = points[3];
          let tr = this.transitionsBetween(pointA, pointD);
          let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);
          let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);
          let trBA = this.transitionsBetween(pointBs, pointA);
          let trCD = this.transitionsBetween(pointCs, pointD);
          if (trBA < trCD) {
            points[0] = pointA;
            points[1] = pointB;
            points[2] = pointC;
            points[3] = pointD;
          } else {
            points[0] = pointB;
            points[1] = pointC;
            points[2] = pointD;
            points[3] = pointA;
          }
          return points;
        }
        /**
         * Calculates the corner position of the white top right module.
         */
        correctTopRight(points) {
          let pointA = points[0];
          let pointB = points[1];
          let pointC = points[2];
          let pointD = points[3];
          let trTop = this.transitionsBetween(pointA, pointD);
          let trRight = this.transitionsBetween(pointB, pointD);
          let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);
          let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);
          trTop = this.transitionsBetween(pointAs, pointD);
          trRight = this.transitionsBetween(pointCs, pointD);
          let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
          let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
          if (!this.isValid(candidate1)) {
            if (this.isValid(candidate2)) {
              return candidate2;
            }
            return null;
          }
          if (!this.isValid(candidate2)) {
            return candidate1;
          }
          let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
          let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
          if (sumc1 > sumc2) {
            return candidate1;
          } else {
            return candidate2;
          }
        }
        /**
         * Shift the edge points to the module center.
         */
        shiftToModuleCenter(points) {
          let pointA = points[0];
          let pointB = points[1];
          let pointC = points[2];
          let pointD = points[3];
          let dimH = this.transitionsBetween(pointA, pointD) + 1;
          let dimV = this.transitionsBetween(pointC, pointD) + 1;
          let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
          let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);
          dimH = this.transitionsBetween(pointAs, pointD) + 1;
          dimV = this.transitionsBetween(pointCs, pointD) + 1;
          if ((dimH & 1) === 1) {
            dimH += 1;
          }
          if ((dimV & 1) === 1) {
            dimV += 1;
          }
          let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
          let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
          pointA = Detector$1.moveAway(pointA, centerX, centerY);
          pointB = Detector$1.moveAway(pointB, centerX, centerY);
          pointC = Detector$1.moveAway(pointC, centerX, centerY);
          pointD = Detector$1.moveAway(pointD, centerX, centerY);
          let pointBs;
          let pointDs;
          pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
          pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);
          pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);
          pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);
          pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);
          pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);
          pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);
          pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);
          return [pointAs, pointBs, pointCs, pointDs];
        }
        isValid(p2) {
          return p2.getX() >= 0 && p2.getX() < this.image.getWidth() && p2.getY() > 0 && p2.getY() < this.image.getHeight();
        }
        static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
          const sampler = GridSamplerInstance.getInstance();
          return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
        }
        /**
         * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.
         */
        transitionsBetween(from2, to) {
          let fromX = Math.trunc(from2.getX());
          let fromY = Math.trunc(from2.getY());
          let toX = Math.trunc(to.getX());
          let toY = Math.trunc(to.getY());
          let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
          if (steep) {
            let temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
          }
          let dx = Math.abs(toX - fromX);
          let dy = Math.abs(toY - fromY);
          let error = -dx / 2;
          let ystep = fromY < toY ? 1 : -1;
          let xstep = fromX < toX ? 1 : -1;
          let transitions = 0;
          let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
          for (let x2 = fromX, y2 = fromY; x2 !== toX; x2 += xstep) {
            let isBlack = this.image.get(steep ? y2 : x2, steep ? x2 : y2);
            if (isBlack !== inBlack) {
              transitions++;
              inBlack = isBlack;
            }
            error += dy;
            if (error > 0) {
              if (y2 === toY) {
                break;
              }
              y2 += ystep;
              error -= dx;
            }
          }
          return transitions;
        }
      }
      class DataMatrixReader {
        constructor() {
          this.decoder = new Decoder$1();
        }
        /**
         * Locates and decodes a Data Matrix code in an image.
         *
         * @return a String representing the content encoded by the Data Matrix code
         * @throws NotFoundException if a Data Matrix code cannot be found
         * @throws FormatException if a Data Matrix code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        // @Override
        // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {
        //   return decode(image, null);
        // }
        // @Override
        decode(image, hints = null) {
          let decoderResult;
          let points;
          if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {
            const bits2 = DataMatrixReader.extractPureBits(image.getBlackMatrix());
            decoderResult = this.decoder.decode(bits2);
            points = DataMatrixReader.NO_POINTS;
          } else {
            const detectorResult = new Detector$1(image.getBlackMatrix()).detect();
            decoderResult = this.decoder.decode(detectorResult.getBits());
            points = detectorResult.getPoints();
          }
          const rawBytes = decoderResult.getRawBytes();
          const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());
          const byteSegments = decoderResult.getByteSegments();
          if (byteSegments != null) {
            result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
          }
          const ecLevel = decoderResult.getECLevel();
          if (ecLevel != null) {
            result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
          }
          return result;
        }
        // @Override
        reset() {
        }
        /**
         * This method detects a code in a "pure" image -- that is, pure monochrome image
         * which contains only an unrotated, unskewed, image of a code, with some white border
         * around it. This is a specialized method that works exceptionally fast in this special
         * case.
         *
         * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)
         */
        static extractPureBits(image) {
          const leftTopBlack = image.getTopLeftOnBit();
          const rightBottomBlack = image.getBottomRightOnBit();
          if (leftTopBlack == null || rightBottomBlack == null) {
            throw new NotFoundException();
          }
          const moduleSize = this.moduleSize(leftTopBlack, image);
          let top = leftTopBlack[1];
          const bottom = rightBottomBlack[1];
          let left = leftTopBlack[0];
          const right = rightBottomBlack[0];
          const matrixWidth = (right - left + 1) / moduleSize;
          const matrixHeight = (bottom - top + 1) / moduleSize;
          if (matrixWidth <= 0 || matrixHeight <= 0) {
            throw new NotFoundException();
          }
          const nudge = moduleSize / 2;
          top += nudge;
          left += nudge;
          const bits2 = new BitMatrix(matrixWidth, matrixHeight);
          for (let y2 = 0; y2 < matrixHeight; y2++) {
            const iOffset = top + y2 * moduleSize;
            for (let x2 = 0; x2 < matrixWidth; x2++) {
              if (image.get(left + x2 * moduleSize, iOffset)) {
                bits2.set(x2, y2);
              }
            }
          }
          return bits2;
        }
        static moduleSize(leftTopBlack, image) {
          const width = image.getWidth();
          let x2 = leftTopBlack[0];
          const y2 = leftTopBlack[1];
          while (x2 < width && image.get(x2, y2)) {
            x2++;
          }
          if (x2 === width) {
            throw new NotFoundException();
          }
          const moduleSize = x2 - leftTopBlack[0];
          if (moduleSize === 0) {
            throw new NotFoundException();
          }
          return moduleSize;
        }
      }
      DataMatrixReader.NO_POINTS = [];
      class BrowserDatamatrixCodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserQRCodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         */
        constructor(timeBetweenScansMillis = 500) {
          super(new DataMatrixReader(), timeBetweenScansMillis);
        }
      }
      var ErrorCorrectionLevelValues;
      (function(ErrorCorrectionLevelValues2) {
        ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
        ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
        ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
        ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
      })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
      class ErrorCorrectionLevel {
        constructor(value2, stringValue, bits2) {
          this.value = value2;
          this.stringValue = stringValue;
          this.bits = bits2;
          ErrorCorrectionLevel.FOR_BITS.set(bits2, this);
          ErrorCorrectionLevel.FOR_VALUE.set(value2, this);
        }
        getValue() {
          return this.value;
        }
        getBits() {
          return this.bits;
        }
        static fromString(s2) {
          switch (s2) {
            case "L":
              return ErrorCorrectionLevel.L;
            case "M":
              return ErrorCorrectionLevel.M;
            case "Q":
              return ErrorCorrectionLevel.Q;
            case "H":
              return ErrorCorrectionLevel.H;
            default:
              throw new ArgumentException(s2 + "not available");
          }
        }
        toString() {
          return this.stringValue;
        }
        equals(o2) {
          if (!(o2 instanceof ErrorCorrectionLevel)) {
            return false;
          }
          const other = o2;
          return this.value === other.value;
        }
        /**
         * @param bits int containing the two bits encoding a QR Code's error correction level
         * @return ErrorCorrectionLevel representing the encoded error correction level
         */
        static forBits(bits2) {
          if (bits2 < 0 || bits2 >= ErrorCorrectionLevel.FOR_BITS.size) {
            throw new IllegalArgumentException();
          }
          return ErrorCorrectionLevel.FOR_BITS.get(bits2);
        }
      }
      ErrorCorrectionLevel.FOR_BITS = /* @__PURE__ */ new Map();
      ErrorCorrectionLevel.FOR_VALUE = /* @__PURE__ */ new Map();
      ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, "L", 1);
      ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, "M", 0);
      ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, "Q", 3);
      ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, "H", 2);
      class FormatInformation {
        constructor(formatInfo) {
          this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 3);
          this.dataMask = /*(byte) */
          formatInfo & 7;
        }
        static numBitsDiffering(a2, b2) {
          return Integer.bitCount(a2 ^ b2);
        }
        /**
         * @param maskedFormatInfo1 format info indicator, with mask still applied
         * @param maskedFormatInfo2 second copy of same info; both are checked at the same time
         *  to establish best match
         * @return information about the format it specifies, or {@code null}
         *  if doesn't seem to match any known pattern
         */
        static decodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
          const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
          if (formatInfo !== null) {
            return formatInfo;
          }
          return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
        }
        static doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
          let bestDifference = Number.MAX_SAFE_INTEGER;
          let bestFormatInfo = 0;
          for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {
            const targetInfo = decodeInfo[0];
            if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
              return new FormatInformation(decodeInfo[1]);
            }
            let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
            if (bitsDifference < bestDifference) {
              bestFormatInfo = decodeInfo[1];
              bestDifference = bitsDifference;
            }
            if (maskedFormatInfo1 !== maskedFormatInfo2) {
              bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
              if (bitsDifference < bestDifference) {
                bestFormatInfo = decodeInfo[1];
                bestDifference = bitsDifference;
              }
            }
          }
          if (bestDifference <= 3) {
            return new FormatInformation(bestFormatInfo);
          }
          return null;
        }
        getErrorCorrectionLevel() {
          return this.errorCorrectionLevel;
        }
        getDataMask() {
          return this.dataMask;
        }
        /*@Override*/
        hashCode() {
          return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
        }
        /*@Override*/
        equals(o2) {
          if (!(o2 instanceof FormatInformation)) {
            return false;
          }
          const other = o2;
          return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
        }
      }
      FormatInformation.FORMAT_INFO_MASK_QR = 21522;
      FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
        Int32Array.from([21522, 0]),
        Int32Array.from([20773, 1]),
        Int32Array.from([24188, 2]),
        Int32Array.from([23371, 3]),
        Int32Array.from([17913, 4]),
        Int32Array.from([16590, 5]),
        Int32Array.from([20375, 6]),
        Int32Array.from([19104, 7]),
        Int32Array.from([30660, 8]),
        Int32Array.from([29427, 9]),
        Int32Array.from([32170, 10]),
        Int32Array.from([30877, 11]),
        Int32Array.from([26159, 12]),
        Int32Array.from([25368, 13]),
        Int32Array.from([27713, 14]),
        Int32Array.from([26998, 15]),
        Int32Array.from([5769, 16]),
        Int32Array.from([5054, 17]),
        Int32Array.from([7399, 18]),
        Int32Array.from([6608, 19]),
        Int32Array.from([1890, 20]),
        Int32Array.from([597, 21]),
        Int32Array.from([3340, 22]),
        Int32Array.from([2107, 23]),
        Int32Array.from([13663, 24]),
        Int32Array.from([12392, 25]),
        Int32Array.from([16177, 26]),
        Int32Array.from([14854, 27]),
        Int32Array.from([9396, 28]),
        Int32Array.from([8579, 29]),
        Int32Array.from([11994, 30]),
        Int32Array.from([11245, 31])
      ];
      class ECBlocks$1 {
        constructor(ecCodewordsPerBlock, ...ecBlocks) {
          this.ecCodewordsPerBlock = ecCodewordsPerBlock;
          this.ecBlocks = ecBlocks;
        }
        getECCodewordsPerBlock() {
          return this.ecCodewordsPerBlock;
        }
        getNumBlocks() {
          let total = 0;
          const ecBlocks = this.ecBlocks;
          for (const ecBlock of ecBlocks) {
            total += ecBlock.getCount();
          }
          return total;
        }
        getTotalECCodewords() {
          return this.ecCodewordsPerBlock * this.getNumBlocks();
        }
        getECBlocks() {
          return this.ecBlocks;
        }
      }
      class ECB$1 {
        constructor(count, dataCodewords) {
          this.count = count;
          this.dataCodewords = dataCodewords;
        }
        getCount() {
          return this.count;
        }
        getDataCodewords() {
          return this.dataCodewords;
        }
      }
      class Version$1 {
        constructor(versionNumber, alignmentPatternCenters, ...ecBlocks) {
          this.versionNumber = versionNumber;
          this.alignmentPatternCenters = alignmentPatternCenters;
          this.ecBlocks = ecBlocks;
          let total = 0;
          const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
          const ecbArray = ecBlocks[0].getECBlocks();
          for (const ecBlock of ecbArray) {
            total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
          }
          this.totalCodewords = total;
        }
        getVersionNumber() {
          return this.versionNumber;
        }
        getAlignmentPatternCenters() {
          return this.alignmentPatternCenters;
        }
        getTotalCodewords() {
          return this.totalCodewords;
        }
        getDimensionForVersion() {
          return 17 + 4 * this.versionNumber;
        }
        getECBlocksForLevel(ecLevel) {
          return this.ecBlocks[ecLevel.getValue()];
        }
        /**
         * <p>Deduces version information purely from QR Code dimensions.</p>
         *
         * @param dimension dimension in modules
         * @return Version for a QR Code of that dimension
         * @throws FormatException if dimension is not 1 mod 4
         */
        static getProvisionalVersionForDimension(dimension) {
          if (dimension % 4 !== 1) {
            throw new FormatException();
          }
          try {
            return this.getVersionForNumber((dimension - 17) / 4);
          } catch (ignored) {
            throw new FormatException();
          }
        }
        static getVersionForNumber(versionNumber) {
          if (versionNumber < 1 || versionNumber > 40) {
            throw new IllegalArgumentException();
          }
          return Version$1.VERSIONS[versionNumber - 1];
        }
        static decodeVersionInformation(versionBits) {
          let bestDifference = Number.MAX_SAFE_INTEGER;
          let bestVersion = 0;
          for (let i3 = 0; i3 < Version$1.VERSION_DECODE_INFO.length; i3++) {
            const targetVersion = Version$1.VERSION_DECODE_INFO[i3];
            if (targetVersion === versionBits) {
              return Version$1.getVersionForNumber(i3 + 7);
            }
            const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
            if (bitsDifference < bestDifference) {
              bestVersion = i3 + 7;
              bestDifference = bitsDifference;
            }
          }
          if (bestDifference <= 3) {
            return Version$1.getVersionForNumber(bestVersion);
          }
          return null;
        }
        /**
         * See ISO 18004:2006 Annex E
         */
        buildFunctionPattern() {
          const dimension = this.getDimensionForVersion();
          const bitMatrix = new BitMatrix(dimension);
          bitMatrix.setRegion(0, 0, 9, 9);
          bitMatrix.setRegion(dimension - 8, 0, 8, 9);
          bitMatrix.setRegion(0, dimension - 8, 9, 8);
          const max2 = this.alignmentPatternCenters.length;
          for (let x2 = 0; x2 < max2; x2++) {
            const i3 = this.alignmentPatternCenters[x2] - 2;
            for (let y2 = 0; y2 < max2; y2++) {
              if (x2 === 0 && (y2 === 0 || y2 === max2 - 1) || x2 === max2 - 1 && y2 === 0) {
                continue;
              }
              bitMatrix.setRegion(this.alignmentPatternCenters[y2] - 2, i3, 5, 5);
            }
          }
          bitMatrix.setRegion(6, 9, 1, dimension - 17);
          bitMatrix.setRegion(9, 6, dimension - 17, 1);
          if (this.versionNumber > 6) {
            bitMatrix.setRegion(dimension - 11, 0, 3, 6);
            bitMatrix.setRegion(0, dimension - 11, 6, 3);
          }
          return bitMatrix;
        }
        /*@Override*/
        toString() {
          return "" + this.versionNumber;
        }
      }
      Version$1.VERSION_DECODE_INFO = Int32Array.from([
        31892,
        34236,
        39577,
        42195,
        48118,
        51042,
        55367,
        58893,
        63784,
        68472,
        70749,
        76311,
        79154,
        84390,
        87683,
        92361,
        96236,
        102084,
        102881,
        110507,
        110734,
        117786,
        119615,
        126325,
        127568,
        133589,
        136944,
        141498,
        145311,
        150283,
        152622,
        158308,
        161089,
        167017
      ]);
      Version$1.VERSIONS = [
        new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),
        new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),
        new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),
        new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),
        new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),
        new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),
        new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),
        new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),
        new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),
        new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),
        new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),
        new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),
        new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),
        new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),
        new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),
        new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),
        new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),
        new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),
        new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),
        new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),
        new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),
        new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),
        new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),
        new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),
        new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),
        new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),
        new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),
        new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),
        new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),
        new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),
        new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),
        new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),
        new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),
        new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),
        new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),
        new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),
        new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),
        new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),
        new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),
        new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))
      ];
      var DataMaskValues;
      (function(DataMaskValues2) {
        DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
        DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
        DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
        DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
        DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
        DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
        DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
        DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
      })(DataMaskValues || (DataMaskValues = {}));
      class DataMask {
        // See ISO 18004:2006 6.8.1
        constructor(value2, isMasked) {
          this.value = value2;
          this.isMasked = isMasked;
        }
        // End of enum constants.
        /**
         * <p>Implementations of this method reverse the data masking process applied to a QR Code and
         * make its bits ready to read.</p>
         *
         * @param bits representation of QR Code bits
         * @param dimension dimension of QR Code, represented by bits, being unmasked
         */
        unmaskBitMatrix(bits2, dimension) {
          for (let i3 = 0; i3 < dimension; i3++) {
            for (let j2 = 0; j2 < dimension; j2++) {
              if (this.isMasked(i3, j2)) {
                bits2.flip(j2, i3);
              }
            }
          }
        }
      }
      DataMask.values = /* @__PURE__ */ new Map([
        /**
         * 000: mask bits for which (x + y) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i3, j2) => {
          return (i3 + j2 & 1) === 0;
        })],
        /**
         * 001: mask bits for which x mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i3, j2) => {
          return (i3 & 1) === 0;
        })],
        /**
         * 010: mask bits for which y mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i3, j2) => {
          return j2 % 3 === 0;
        })],
        /**
         * 011: mask bits for which (x + y) mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i3, j2) => {
          return (i3 + j2) % 3 === 0;
        })],
        /**
         * 100: mask bits for which (x/2 + y/3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i3, j2) => {
          return (Math.floor(i3 / 2) + Math.floor(j2 / 3) & 1) === 0;
        })],
        /**
         * 101: mask bits for which xy mod 2 + xy mod 3 == 0
         * equivalently, such that xy mod 6 == 0
         */
        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i3, j2) => {
          return i3 * j2 % 6 === 0;
        })],
        /**
         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that xy mod 6 < 3
         */
        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i3, j2) => {
          return i3 * j2 % 6 < 3;
        })],
        /**
         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that (x + y + xy mod 3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i3, j2) => {
          return (i3 + j2 + i3 * j2 % 3 & 1) === 0;
        })]
      ]);
      class BitMatrixParser$1 {
        /**
         * @param bitMatrix {@link BitMatrix} to parse
         * @throws FormatException if dimension is not >= 21 and 1 mod 4
         */
        constructor(bitMatrix) {
          const dimension = bitMatrix.getHeight();
          if (dimension < 21 || (dimension & 3) !== 1) {
            throw new FormatException();
          }
          this.bitMatrix = bitMatrix;
        }
        /**
         * <p>Reads format information from one of its two locations within the QR Code.</p>
         *
         * @return {@link FormatInformation} encapsulating the QR Code's format info
         * @throws FormatException if both format information locations cannot be parsed as
         * the valid encoding of format information
         */
        readFormatInformation() {
          if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
            return this.parsedFormatInfo;
          }
          let formatInfoBits1 = 0;
          for (let i3 = 0; i3 < 6; i3++) {
            formatInfoBits1 = this.copyBit(i3, 8, formatInfoBits1);
          }
          formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
          formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
          formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
          for (let j2 = 5; j2 >= 0; j2--) {
            formatInfoBits1 = this.copyBit(8, j2, formatInfoBits1);
          }
          const dimension = this.bitMatrix.getHeight();
          let formatInfoBits2 = 0;
          const jMin = dimension - 7;
          for (let j2 = dimension - 1; j2 >= jMin; j2--) {
            formatInfoBits2 = this.copyBit(8, j2, formatInfoBits2);
          }
          for (let i3 = dimension - 8; i3 < dimension; i3++) {
            formatInfoBits2 = this.copyBit(i3, 8, formatInfoBits2);
          }
          this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
          if (this.parsedFormatInfo !== null) {
            return this.parsedFormatInfo;
          }
          throw new FormatException();
        }
        /**
         * <p>Reads version information from one of its two locations within the QR Code.</p>
         *
         * @return {@link Version} encapsulating the QR Code's version
         * @throws FormatException if both version information locations cannot be parsed as
         * the valid encoding of version information
         */
        readVersion() {
          if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
            return this.parsedVersion;
          }
          const dimension = this.bitMatrix.getHeight();
          const provisionalVersion = Math.floor((dimension - 17) / 4);
          if (provisionalVersion <= 6) {
            return Version$1.getVersionForNumber(provisionalVersion);
          }
          let versionBits = 0;
          const ijMin = dimension - 11;
          for (let j2 = 5; j2 >= 0; j2--) {
            for (let i3 = dimension - 9; i3 >= ijMin; i3--) {
              versionBits = this.copyBit(i3, j2, versionBits);
            }
          }
          let theParsedVersion = Version$1.decodeVersionInformation(versionBits);
          if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
            this.parsedVersion = theParsedVersion;
            return theParsedVersion;
          }
          versionBits = 0;
          for (let i3 = 5; i3 >= 0; i3--) {
            for (let j2 = dimension - 9; j2 >= ijMin; j2--) {
              versionBits = this.copyBit(i3, j2, versionBits);
            }
          }
          theParsedVersion = Version$1.decodeVersionInformation(versionBits);
          if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
            this.parsedVersion = theParsedVersion;
            return theParsedVersion;
          }
          throw new FormatException();
        }
        copyBit(i3, j2, versionBits) {
          const bit = this.isMirror ? this.bitMatrix.get(j2, i3) : this.bitMatrix.get(i3, j2);
          return bit ? versionBits << 1 | 1 : versionBits << 1;
        }
        /**
         * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
         * correct order in order to reconstruct the codewords bytes contained within the
         * QR Code.</p>
         *
         * @return bytes encoded within the QR Code
         * @throws FormatException if the exact number of bytes expected is not read
         */
        readCodewords() {
          const formatInfo = this.readFormatInformation();
          const version = this.readVersion();
          const dataMask = DataMask.values.get(formatInfo.getDataMask());
          const dimension = this.bitMatrix.getHeight();
          dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
          const functionPattern = version.buildFunctionPattern();
          let readingUp = true;
          const result = new Uint8Array(version.getTotalCodewords());
          let resultOffset = 0;
          let currentByte = 0;
          let bitsRead = 0;
          for (let j2 = dimension - 1; j2 > 0; j2 -= 2) {
            if (j2 === 6) {
              j2--;
            }
            for (let count = 0; count < dimension; count++) {
              const i3 = readingUp ? dimension - 1 - count : count;
              for (let col = 0; col < 2; col++) {
                if (!functionPattern.get(j2 - col, i3)) {
                  bitsRead++;
                  currentByte <<= 1;
                  if (this.bitMatrix.get(j2 - col, i3)) {
                    currentByte |= 1;
                  }
                  if (bitsRead === 8) {
                    result[resultOffset++] = /*(byte) */
                    currentByte;
                    bitsRead = 0;
                    currentByte = 0;
                  }
                }
              }
            }
            readingUp = !readingUp;
          }
          if (resultOffset !== version.getTotalCodewords()) {
            throw new FormatException();
          }
          return result;
        }
        /**
         * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
         */
        remask() {
          if (this.parsedFormatInfo === null) {
            return;
          }
          const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
          const dimension = this.bitMatrix.getHeight();
          dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        }
        /**
         * Prepare the parser for a mirrored operation.
         * This flag has effect only on the {@link #readFormatInformation()} and the
         * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
         * {@link #mirror()} method should be called.
         *
         * @param mirror Whether to read version and format information mirrored.
         */
        setMirror(isMirror) {
          this.parsedVersion = null;
          this.parsedFormatInfo = null;
          this.isMirror = isMirror;
        }
        /** Mirror the bit matrix in order to attempt a second reading. */
        mirror() {
          const bitMatrix = this.bitMatrix;
          for (let x2 = 0, width = bitMatrix.getWidth(); x2 < width; x2++) {
            for (let y2 = x2 + 1, height = bitMatrix.getHeight(); y2 < height; y2++) {
              if (bitMatrix.get(x2, y2) !== bitMatrix.get(y2, x2)) {
                bitMatrix.flip(y2, x2);
                bitMatrix.flip(x2, y2);
              }
            }
          }
        }
      }
      class DataBlock$1 {
        constructor(numDataCodewords, codewords) {
          this.numDataCodewords = numDataCodewords;
          this.codewords = codewords;
        }
        /**
         * <p>When QR Codes use multiple data blocks, they are actually interleaved.
         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
         * method will separate the data into original blocks.</p>
         *
         * @param rawCodewords bytes as read directly from the QR Code
         * @param version version of the QR Code
         * @param ecLevel error-correction level of the QR Code
         * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
         *         QR Code
         */
        static getDataBlocks(rawCodewords, version, ecLevel) {
          if (rawCodewords.length !== version.getTotalCodewords()) {
            throw new IllegalArgumentException();
          }
          const ecBlocks = version.getECBlocksForLevel(ecLevel);
          let totalBlocks = 0;
          const ecBlockArray = ecBlocks.getECBlocks();
          for (const ecBlock of ecBlockArray) {
            totalBlocks += ecBlock.getCount();
          }
          const result = new Array(totalBlocks);
          let numResultBlocks = 0;
          for (const ecBlock of ecBlockArray) {
            for (let i3 = 0; i3 < ecBlock.getCount(); i3++) {
              const numDataCodewords = ecBlock.getDataCodewords();
              const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
              result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));
            }
          }
          const shorterBlocksTotalCodewords = result[0].codewords.length;
          let longerBlocksStartAt = result.length - 1;
          while (longerBlocksStartAt >= 0) {
            const numCodewords = result[longerBlocksStartAt].codewords.length;
            if (numCodewords === shorterBlocksTotalCodewords) {
              break;
            }
            longerBlocksStartAt--;
          }
          longerBlocksStartAt++;
          const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
          let rawCodewordsOffset = 0;
          for (let i3 = 0; i3 < shorterBlocksNumDataCodewords; i3++) {
            for (let j2 = 0; j2 < numResultBlocks; j2++) {
              result[j2].codewords[i3] = rawCodewords[rawCodewordsOffset++];
            }
          }
          for (let j2 = longerBlocksStartAt; j2 < numResultBlocks; j2++) {
            result[j2].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
          }
          const max2 = result[0].codewords.length;
          for (let i3 = shorterBlocksNumDataCodewords; i3 < max2; i3++) {
            for (let j2 = 0; j2 < numResultBlocks; j2++) {
              const iOffset = j2 < longerBlocksStartAt ? i3 : i3 + 1;
              result[j2].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
            }
          }
          return result;
        }
        getNumDataCodewords() {
          return this.numDataCodewords;
        }
        getCodewords() {
          return this.codewords;
        }
      }
      var ModeValues;
      (function(ModeValues2) {
        ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
        ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
        ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
        ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
        ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
        ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
        ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
        ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
        ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
        ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
      })(ModeValues || (ModeValues = {}));
      class Mode$1 {
        constructor(value2, stringValue, characterCountBitsForVersions, bits2) {
          this.value = value2;
          this.stringValue = stringValue;
          this.characterCountBitsForVersions = characterCountBitsForVersions;
          this.bits = bits2;
          Mode$1.FOR_BITS.set(bits2, this);
          Mode$1.FOR_VALUE.set(value2, this);
        }
        /**
         * @param bits four bits encoding a QR Code data mode
         * @return Mode encoded by these bits
         * @throws IllegalArgumentException if bits do not correspond to a known mode
         */
        static forBits(bits2) {
          const mode = Mode$1.FOR_BITS.get(bits2);
          if (void 0 === mode) {
            throw new IllegalArgumentException();
          }
          return mode;
        }
        /**
         * @param version version in question
         * @return number of bits used, in this QR Code symbol {@link Version}, to encode the
         *         count of characters that will follow encoded in this Mode
         */
        getCharacterCountBits(version) {
          const versionNumber = version.getVersionNumber();
          let offset;
          if (versionNumber <= 9) {
            offset = 0;
          } else if (versionNumber <= 26) {
            offset = 1;
          } else {
            offset = 2;
          }
          return this.characterCountBitsForVersions[offset];
        }
        getValue() {
          return this.value;
        }
        getBits() {
          return this.bits;
        }
        equals(o2) {
          if (!(o2 instanceof Mode$1)) {
            return false;
          }
          const other = o2;
          return this.value === other.value;
        }
        toString() {
          return this.stringValue;
        }
      }
      Mode$1.FOR_BITS = /* @__PURE__ */ new Map();
      Mode$1.FOR_VALUE = /* @__PURE__ */ new Map();
      Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
      Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
      Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
      Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
      Mode$1.BYTE = new Mode$1(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
      Mode$1.ECI = new Mode$1(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
      Mode$1.KANJI = new Mode$1(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
      Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
      Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
      Mode$1.HANZI = new Mode$1(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
      class DecodedBitStreamParser$1 {
        static decode(bytes, version, ecLevel, hints) {
          const bits2 = new BitSource(bytes);
          let result = new StringBuilder();
          const byteSegments = new Array();
          let symbolSequence = -1;
          let parityData = -1;
          try {
            let currentCharacterSetECI = null;
            let fc1InEffect = false;
            let mode;
            do {
              if (bits2.available() < 4) {
                mode = Mode$1.TERMINATOR;
              } else {
                const modeBits = bits2.readBits(4);
                mode = Mode$1.forBits(modeBits);
              }
              switch (mode) {
                case Mode$1.TERMINATOR:
                  break;
                case Mode$1.FNC1_FIRST_POSITION:
                case Mode$1.FNC1_SECOND_POSITION:
                  fc1InEffect = true;
                  break;
                case Mode$1.STRUCTURED_APPEND:
                  if (bits2.available() < 16) {
                    throw new FormatException();
                  }
                  symbolSequence = bits2.readBits(8);
                  parityData = bits2.readBits(8);
                  break;
                case Mode$1.ECI:
                  const value2 = DecodedBitStreamParser$1.parseECIValue(bits2);
                  currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value2);
                  if (currentCharacterSetECI === null) {
                    throw new FormatException();
                  }
                  break;
                case Mode$1.HANZI:
                  const subset = bits2.readBits(4);
                  const countHanzi = bits2.readBits(mode.getCharacterCountBits(version));
                  if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {
                    DecodedBitStreamParser$1.decodeHanziSegment(bits2, result, countHanzi);
                  }
                  break;
                default:
                  const count = bits2.readBits(mode.getCharacterCountBits(version));
                  switch (mode) {
                    case Mode$1.NUMERIC:
                      DecodedBitStreamParser$1.decodeNumericSegment(bits2, result, count);
                      break;
                    case Mode$1.ALPHANUMERIC:
                      DecodedBitStreamParser$1.decodeAlphanumericSegment(bits2, result, count, fc1InEffect);
                      break;
                    case Mode$1.BYTE:
                      DecodedBitStreamParser$1.decodeByteSegment(bits2, result, count, currentCharacterSetECI, byteSegments, hints);
                      break;
                    case Mode$1.KANJI:
                      DecodedBitStreamParser$1.decodeKanjiSegment(bits2, result, count);
                      break;
                    default:
                      throw new FormatException();
                  }
                  break;
              }
            } while (mode !== Mode$1.TERMINATOR);
          } catch (iae) {
            throw new FormatException();
          }
          return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
        }
        /**
         * See specification GBT 18284-2000
         */
        static decodeHanziSegment(bits2, result, count) {
          if (count * 13 > bits2.available()) {
            throw new FormatException();
          }
          const buffer = new Uint8Array(2 * count);
          let offset = 0;
          while (count > 0) {
            const twoBytes = bits2.readBits(13);
            let assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
            if (assembledTwoBytes < 959) {
              assembledTwoBytes += 41377;
            } else {
              assembledTwoBytes += 42657;
            }
            buffer[offset] = /*(byte) */
            assembledTwoBytes >> 8 & 255;
            buffer[offset + 1] = /*(byte) */
            assembledTwoBytes & 255;
            offset += 2;
            count--;
          }
          try {
            result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
          } catch (ignored) {
            throw new FormatException(ignored);
          }
        }
        static decodeKanjiSegment(bits2, result, count) {
          if (count * 13 > bits2.available()) {
            throw new FormatException();
          }
          const buffer = new Uint8Array(2 * count);
          let offset = 0;
          while (count > 0) {
            const twoBytes = bits2.readBits(13);
            let assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
            if (assembledTwoBytes < 7936) {
              assembledTwoBytes += 33088;
            } else {
              assembledTwoBytes += 49472;
            }
            buffer[offset] = /*(byte) */
            assembledTwoBytes >> 8;
            buffer[offset + 1] = /*(byte) */
            assembledTwoBytes;
            offset += 2;
            count--;
          }
          try {
            result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
          } catch (ignored) {
            throw new FormatException(ignored);
          }
        }
        static decodeByteSegment(bits2, result, count, currentCharacterSetECI, byteSegments, hints) {
          if (8 * count > bits2.available()) {
            throw new FormatException();
          }
          const readBytes = new Uint8Array(count);
          for (let i3 = 0; i3 < count; i3++) {
            readBytes[i3] = /*(byte) */
            bits2.readBits(8);
          }
          let encoding;
          if (currentCharacterSetECI === null) {
            encoding = StringUtils.guessEncoding(readBytes, hints);
          } else {
            encoding = currentCharacterSetECI.getName();
          }
          try {
            result.append(StringEncoding.decode(readBytes, encoding));
          } catch (ignored) {
            throw new FormatException(ignored);
          }
          byteSegments.push(readBytes);
        }
        static toAlphaNumericChar(value2) {
          if (value2 >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {
            throw new FormatException();
          }
          return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value2];
        }
        static decodeAlphanumericSegment(bits2, result, count, fc1InEffect) {
          const start = result.length();
          while (count > 1) {
            if (bits2.available() < 11) {
              throw new FormatException();
            }
            const nextTwoCharsBits = bits2.readBits(11);
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));
            count -= 2;
          }
          if (count === 1) {
            if (bits2.available() < 6) {
              throw new FormatException();
            }
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits2.readBits(6)));
          }
          if (fc1InEffect) {
            for (let i3 = start; i3 < result.length(); i3++) {
              if (result.charAt(i3) === "%") {
                if (i3 < result.length() - 1 && result.charAt(i3 + 1) === "%") {
                  result.deleteCharAt(i3 + 1);
                } else {
                  result.setCharAt(i3, String.fromCharCode(29));
                }
              }
            }
          }
        }
        static decodeNumericSegment(bits2, result, count) {
          while (count >= 3) {
            if (bits2.available() < 10) {
              throw new FormatException();
            }
            const threeDigitsBits = bits2.readBits(10);
            if (threeDigitsBits >= 1e3) {
              throw new FormatException();
            }
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));
            count -= 3;
          }
          if (count === 2) {
            if (bits2.available() < 7) {
              throw new FormatException();
            }
            const twoDigitsBits = bits2.readBits(7);
            if (twoDigitsBits >= 100) {
              throw new FormatException();
            }
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));
          } else if (count === 1) {
            if (bits2.available() < 4) {
              throw new FormatException();
            }
            const digitBits = bits2.readBits(4);
            if (digitBits >= 10) {
              throw new FormatException();
            }
            result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
          }
        }
        static parseECIValue(bits2) {
          const firstByte = bits2.readBits(8);
          if ((firstByte & 128) === 0) {
            return firstByte & 127;
          }
          if ((firstByte & 192) === 128) {
            const secondByte = bits2.readBits(8);
            return (firstByte & 63) << 8 & 4294967295 | secondByte;
          }
          if ((firstByte & 224) === 192) {
            const secondThirdBytes = bits2.readBits(16);
            return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
          }
          throw new FormatException();
        }
      }
      DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
      DecodedBitStreamParser$1.GB2312_SUBSET = 1;
      class QRCodeDecoderMetaData {
        constructor(mirrored) {
          this.mirrored = mirrored;
        }
        /**
         * @return true if the QR Code was mirrored.
         */
        isMirrored() {
          return this.mirrored;
        }
        /**
         * Apply the result points' order correction due to mirroring.
         *
         * @param points Array of points to apply mirror correction to.
         */
        applyMirroredCorrection(points) {
          if (!this.mirrored || points === null || points.length < 3) {
            return;
          }
          const bottomLeft = points[0];
          points[0] = points[2];
          points[2] = bottomLeft;
        }
      }
      class Decoder$2 {
        constructor() {
          this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
        }
        // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {
        //   return decode(image, null)
        // }
        /**
         * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
         * "true" is taken to mean a black module.</p>
         *
         * @param image booleans representing white/black QR Code modules
         * @param hints decoding hints that should be used to influence decoding
         * @return text and bytes encoded within the QR Code
         * @throws FormatException if the QR Code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        decodeBooleanArray(image, hints) {
          return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
        }
        // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {
        //   return decode(bits, null)
        // }
        /**
         * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
         *
         * @param bits booleans representing white/black QR Code modules
         * @param hints decoding hints that should be used to influence decoding
         * @return text and bytes encoded within the QR Code
         * @throws FormatException if the QR Code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        decodeBitMatrix(bits2, hints) {
          const parser = new BitMatrixParser$1(bits2);
          let ex = null;
          try {
            return this.decodeBitMatrixParser(parser, hints);
          } catch (e) {
            ex = e;
          }
          try {
            parser.remask();
            parser.setMirror(true);
            parser.readVersion();
            parser.readFormatInformation();
            parser.mirror();
            const result = this.decodeBitMatrixParser(parser, hints);
            result.setOther(new QRCodeDecoderMetaData(true));
            return result;
          } catch (e) {
            if (ex !== null) {
              throw ex;
            }
            throw e;
          }
        }
        decodeBitMatrixParser(parser, hints) {
          const version = parser.readVersion();
          const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
          const codewords = parser.readCodewords();
          const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);
          let totalBytes = 0;
          for (const dataBlock of dataBlocks) {
            totalBytes += dataBlock.getNumDataCodewords();
          }
          const resultBytes = new Uint8Array(totalBytes);
          let resultOffset = 0;
          for (const dataBlock of dataBlocks) {
            const codewordBytes = dataBlock.getCodewords();
            const numDataCodewords = dataBlock.getNumDataCodewords();
            this.correctErrors(codewordBytes, numDataCodewords);
            for (let i3 = 0; i3 < numDataCodewords; i3++) {
              resultBytes[resultOffset++] = codewordBytes[i3];
            }
          }
          return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);
        }
        /**
         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
         * correct the errors in-place using Reed-Solomon error correction.</p>
         *
         * @param codewordBytes data and error correction codewords
         * @param numDataCodewords number of codewords that are data bytes
         * @throws ChecksumException if error correction fails
         */
        correctErrors(codewordBytes, numDataCodewords) {
          const codewordsInts = new Int32Array(codewordBytes);
          try {
            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
          } catch (ignored) {
            throw new ChecksumException();
          }
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            codewordBytes[i3] = /*(byte) */
            codewordsInts[i3];
          }
        }
      }
      class AlignmentPattern extends ResultPoint {
        constructor(posX, posY, estimatedModuleSize) {
          super(posX, posY);
          this.estimatedModuleSize = estimatedModuleSize;
        }
        /**
         * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
         */
        aboutEquals(moduleSize, i3, j2) {
          if (Math.abs(i3 - this.getY()) <= moduleSize && Math.abs(j2 - this.getX()) <= moduleSize) {
            const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
          }
          return false;
        }
        /**
         * Combines this object's current estimate of a finder pattern position and module size
         * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
         */
        combineEstimate(i3, j2, newModuleSize) {
          const combinedX = (this.getX() + j2) / 2;
          const combinedY = (this.getY() + i3) / 2;
          const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
          return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
        }
      }
      class AlignmentPatternFinder {
        /**
         * <p>Creates a finder that will look in a portion of the whole image.</p>
         *
         * @param image image to search
         * @param startX left column from which to start searching
         * @param startY top row from which to start searching
         * @param width width of region to search
         * @param height height of region to search
         * @param moduleSize estimated module size so far
         */
        constructor(image, startX, startY, width, height, moduleSize, resultPointCallback) {
          this.image = image;
          this.startX = startX;
          this.startY = startY;
          this.width = width;
          this.height = height;
          this.moduleSize = moduleSize;
          this.resultPointCallback = resultPointCallback;
          this.possibleCenters = [];
          this.crossCheckStateCount = new Int32Array(3);
        }
        /**
         * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
         * it's pretty performance-critical and so is written to be fast foremost.</p>
         *
         * @return {@link AlignmentPattern} if found
         * @throws NotFoundException if not found
         */
        find() {
          const startX = this.startX;
          const height = this.height;
          const width = this.width;
          const maxJ = startX + width;
          const middleI = this.startY + height / 2;
          const stateCount = new Int32Array(3);
          const image = this.image;
          for (let iGen = 0; iGen < height; iGen++) {
            const i3 = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            let j2 = startX;
            while (j2 < maxJ && !image.get(j2, i3)) {
              j2++;
            }
            let currentState = 0;
            while (j2 < maxJ) {
              if (image.get(j2, i3)) {
                if (currentState === 1) {
                  stateCount[1]++;
                } else {
                  if (currentState === 2) {
                    if (this.foundPatternCross(stateCount)) {
                      const confirmed = this.handlePossibleCenter(stateCount, i3, j2);
                      if (confirmed !== null) {
                        return confirmed;
                      }
                    }
                    stateCount[0] = stateCount[2];
                    stateCount[1] = 1;
                    stateCount[2] = 0;
                    currentState = 1;
                  } else {
                    stateCount[++currentState]++;
                  }
                }
              } else {
                if (currentState === 1) {
                  currentState++;
                }
                stateCount[currentState]++;
              }
              j2++;
            }
            if (this.foundPatternCross(stateCount)) {
              const confirmed = this.handlePossibleCenter(stateCount, i3, maxJ);
              if (confirmed !== null) {
                return confirmed;
              }
            }
          }
          if (this.possibleCenters.length !== 0) {
            return this.possibleCenters[0];
          }
          throw new NotFoundException();
        }
        /**
         * Given a count of black/white/black pixels just seen and an end position,
         * figures the location of the center of this black/white/black run.
         */
        static centerFromEnd(stateCount, end) {
          return end - stateCount[2] - stateCount[1] / 2;
        }
        /**
         * @param stateCount count of black/white/black pixels just read
         * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios
         *         used by alignment patterns to be considered a match
         */
        foundPatternCross(stateCount) {
          const moduleSize = this.moduleSize;
          const maxVariance = moduleSize / 2;
          for (let i3 = 0; i3 < 3; i3++) {
            if (Math.abs(moduleSize - stateCount[i3]) >= maxVariance) {
              return false;
            }
          }
          return true;
        }
        /**
         * <p>After a horizontal scan finds a potential alignment pattern, this method
         * "cross-checks" by scanning down vertically through the center of the possible
         * alignment pattern to see if the same proportion is detected.</p>
         *
         * @param startI row where an alignment pattern was detected
         * @param centerJ center of the section that appears to cross an alignment pattern
         * @param maxCount maximum reasonable number of modules that should be
         * observed in any reading state, based on the results of the horizontal scan
         * @return vertical center of alignment pattern, or {@link Float#NaN} if not found
         */
        crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
          const image = this.image;
          const maxI = image.getHeight();
          const stateCount = this.crossCheckStateCount;
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          let i3 = startI;
          while (i3 >= 0 && image.get(centerJ, i3) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i3--;
          }
          if (i3 < 0 || stateCount[1] > maxCount) {
            return NaN;
          }
          while (i3 >= 0 && !image.get(centerJ, i3) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i3--;
          }
          if (stateCount[0] > maxCount) {
            return NaN;
          }
          i3 = startI + 1;
          while (i3 < maxI && image.get(centerJ, i3) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i3++;
          }
          if (i3 === maxI || stateCount[1] > maxCount) {
            return NaN;
          }
          while (i3 < maxI && !image.get(centerJ, i3) && stateCount[2] <= maxCount) {
            stateCount[2]++;
            i3++;
          }
          if (stateCount[2] > maxCount) {
            return NaN;
          }
          const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
          if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN;
          }
          return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i3) : NaN;
        }
        /**
         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
         * cross check with a vertical scan, and if successful, will see if this pattern had been
         * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
         * found the alignment pattern.</p>
         *
         * @param stateCount reading state module counts from horizontal scan
         * @param i row where alignment pattern may be found
         * @param j end of possible alignment pattern in row
         * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not
         */
        handlePossibleCenter(stateCount, i3, j2) {
          const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
          const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j2);
          const centerI = this.crossCheckVertical(
            i3,
            /*(int) */
            centerJ,
            2 * stateCount[1],
            stateCountTotal
          );
          if (!isNaN(centerI)) {
            const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
            for (const center of this.possibleCenters) {
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
              }
            }
            const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
            this.possibleCenters.push(point);
            if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
              this.resultPointCallback.foundPossibleResultPoint(point);
            }
          }
          return null;
        }
      }
      class FinderPattern$1 extends ResultPoint {
        // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {
        //   this(posX, posY, estimatedModuleSize, 1)
        // }
        constructor(posX, posY, estimatedModuleSize, count) {
          super(posX, posY);
          this.estimatedModuleSize = estimatedModuleSize;
          this.count = count;
          if (void 0 === count) {
            this.count = 1;
          }
        }
        getEstimatedModuleSize() {
          return this.estimatedModuleSize;
        }
        getCount() {
          return this.count;
        }
        /*
        void incrementCount() {
          this.count++
        }
         */
        /**
         * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
         */
        aboutEquals(moduleSize, i3, j2) {
          if (Math.abs(i3 - this.getY()) <= moduleSize && Math.abs(j2 - this.getX()) <= moduleSize) {
            const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
          }
          return false;
        }
        /**
         * Combines this object's current estimate of a finder pattern position and module size
         * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
         * based on count.
         */
        combineEstimate(i3, j2, newModuleSize) {
          const combinedCount = this.count + 1;
          const combinedX = (this.count * this.getX() + j2) / combinedCount;
          const combinedY = (this.count * this.getY() + i3) / combinedCount;
          const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
          return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);
        }
      }
      class FinderPatternInfo {
        constructor(patternCenters) {
          this.bottomLeft = patternCenters[0];
          this.topLeft = patternCenters[1];
          this.topRight = patternCenters[2];
        }
        getBottomLeft() {
          return this.bottomLeft;
        }
        getTopLeft() {
          return this.topLeft;
        }
        getTopRight() {
          return this.topRight;
        }
      }
      class FinderPatternFinder {
        /**
         * <p>Creates a finder that will search the image for three finder patterns.</p>
         *
         * @param image image to search
         */
        // public constructor(image: BitMatrix) {
        //   this(image, null)
        // }
        constructor(image, resultPointCallback) {
          this.image = image;
          this.resultPointCallback = resultPointCallback;
          this.possibleCenters = [];
          this.crossCheckStateCount = new Int32Array(5);
          this.resultPointCallback = resultPointCallback;
        }
        getImage() {
          return this.image;
        }
        getPossibleCenters() {
          return this.possibleCenters;
        }
        find(hints) {
          const tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.TRY_HARDER);
          const pureBarcode = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE);
          const image = this.image;
          const maxI = image.getHeight();
          const maxJ = image.getWidth();
          let iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder.MAX_MODULES));
          if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
            iSkip = FinderPatternFinder.MIN_SKIP;
          }
          let done = false;
          const stateCount = new Int32Array(5);
          for (let i3 = iSkip - 1; i3 < maxI && !done; i3 += iSkip) {
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            stateCount[3] = 0;
            stateCount[4] = 0;
            let currentState = 0;
            for (let j2 = 0; j2 < maxJ; j2++) {
              if (image.get(j2, i3)) {
                if ((currentState & 1) === 1) {
                  currentState++;
                }
                stateCount[currentState]++;
              } else {
                if ((currentState & 1) === 0) {
                  if (currentState === 4) {
                    if (FinderPatternFinder.foundPatternCross(stateCount)) {
                      const confirmed = this.handlePossibleCenter(stateCount, i3, j2, pureBarcode);
                      if (confirmed === true) {
                        iSkip = 2;
                        if (this.hasSkipped === true) {
                          done = this.haveMultiplyConfirmedCenters();
                        } else {
                          const rowSkip = this.findRowSkip();
                          if (rowSkip > stateCount[2]) {
                            i3 += rowSkip - stateCount[2] - iSkip;
                            j2 = maxJ - 1;
                          }
                        }
                      } else {
                        stateCount[0] = stateCount[2];
                        stateCount[1] = stateCount[3];
                        stateCount[2] = stateCount[4];
                        stateCount[3] = 1;
                        stateCount[4] = 0;
                        currentState = 3;
                        continue;
                      }
                      currentState = 0;
                      stateCount[0] = 0;
                      stateCount[1] = 0;
                      stateCount[2] = 0;
                      stateCount[3] = 0;
                      stateCount[4] = 0;
                    } else {
                      stateCount[0] = stateCount[2];
                      stateCount[1] = stateCount[3];
                      stateCount[2] = stateCount[4];
                      stateCount[3] = 1;
                      stateCount[4] = 0;
                      currentState = 3;
                    }
                  } else {
                    stateCount[++currentState]++;
                  }
                } else {
                  stateCount[currentState]++;
                }
              }
            }
            if (FinderPatternFinder.foundPatternCross(stateCount)) {
              const confirmed = this.handlePossibleCenter(stateCount, i3, maxJ, pureBarcode);
              if (confirmed === true) {
                iSkip = stateCount[0];
                if (this.hasSkipped) {
                  done = this.haveMultiplyConfirmedCenters();
                }
              }
            }
          }
          const patternInfo = this.selectBestPatterns();
          ResultPoint.orderBestPatterns(patternInfo);
          return new FinderPatternInfo(patternInfo);
        }
        /**
         * Given a count of black/white/black/white/black pixels just seen and an end position,
         * figures the location of the center of this run.
         */
        static centerFromEnd(stateCount, end) {
          return end - stateCount[4] - stateCount[3] - stateCount[2] / 2;
        }
        /**
         * @param stateCount count of black/white/black/white/black pixels just read
         * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
         *         used by finder patterns to be considered a match
         */
        static foundPatternCross(stateCount) {
          let totalModuleSize = 0;
          for (let i3 = 0; i3 < 5; i3++) {
            const count = stateCount[i3];
            if (count === 0) {
              return false;
            }
            totalModuleSize += count;
          }
          if (totalModuleSize < 7) {
            return false;
          }
          const moduleSize = totalModuleSize / 7;
          const maxVariance = moduleSize / 2;
          return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
        }
        getCrossCheckStateCount() {
          const crossCheckStateCount = this.crossCheckStateCount;
          crossCheckStateCount[0] = 0;
          crossCheckStateCount[1] = 0;
          crossCheckStateCount[2] = 0;
          crossCheckStateCount[3] = 0;
          crossCheckStateCount[4] = 0;
          return crossCheckStateCount;
        }
        /**
         * After a vertical and horizontal scan finds a potential finder pattern, this method
         * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
         * finder pattern to see if the same proportion is detected.
         *
         * @param startI row where a finder pattern was detected
         * @param centerJ center of the section that appears to cross a finder pattern
         * @param maxCount maximum reasonable number of modules that should be
         *  observed in any reading state, based on the results of the horizontal scan
         * @param originalStateCountTotal The original state count total.
         * @return true if proportions are withing expected limits
         */
        crossCheckDiagonal(startI, centerJ, maxCount, originalStateCountTotal) {
          const stateCount = this.getCrossCheckStateCount();
          let i3 = 0;
          const image = this.image;
          while (startI >= i3 && centerJ >= i3 && image.get(centerJ - i3, startI - i3)) {
            stateCount[2]++;
            i3++;
          }
          if (startI < i3 || centerJ < i3) {
            return false;
          }
          while (startI >= i3 && centerJ >= i3 && !image.get(centerJ - i3, startI - i3) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i3++;
          }
          if (startI < i3 || centerJ < i3 || stateCount[1] > maxCount) {
            return false;
          }
          while (startI >= i3 && centerJ >= i3 && image.get(centerJ - i3, startI - i3) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i3++;
          }
          if (stateCount[0] > maxCount) {
            return false;
          }
          const maxI = image.getHeight();
          const maxJ = image.getWidth();
          i3 = 1;
          while (startI + i3 < maxI && centerJ + i3 < maxJ && image.get(centerJ + i3, startI + i3)) {
            stateCount[2]++;
            i3++;
          }
          if (startI + i3 >= maxI || centerJ + i3 >= maxJ) {
            return false;
          }
          while (startI + i3 < maxI && centerJ + i3 < maxJ && !image.get(centerJ + i3, startI + i3) && stateCount[3] < maxCount) {
            stateCount[3]++;
            i3++;
          }
          if (startI + i3 >= maxI || centerJ + i3 >= maxJ || stateCount[3] >= maxCount) {
            return false;
          }
          while (startI + i3 < maxI && centerJ + i3 < maxJ && image.get(centerJ + i3, startI + i3) && stateCount[4] < maxCount) {
            stateCount[4]++;
            i3++;
          }
          if (stateCount[4] >= maxCount) {
            return false;
          }
          const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder.foundPatternCross(stateCount);
        }
        /**
         * <p>After a horizontal scan finds a potential finder pattern, this method
         * "cross-checks" by scanning down vertically through the center of the possible
         * finder pattern to see if the same proportion is detected.</p>
         *
         * @param startI row where a finder pattern was detected
         * @param centerJ center of the section that appears to cross a finder pattern
         * @param maxCount maximum reasonable number of modules that should be
         * observed in any reading state, based on the results of the horizontal scan
         * @return vertical center of finder pattern, or {@link Float#NaN} if not found
         */
        crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
          const image = this.image;
          const maxI = image.getHeight();
          const stateCount = this.getCrossCheckStateCount();
          let i3 = startI;
          while (i3 >= 0 && image.get(centerJ, i3)) {
            stateCount[2]++;
            i3--;
          }
          if (i3 < 0) {
            return NaN;
          }
          while (i3 >= 0 && !image.get(centerJ, i3) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i3--;
          }
          if (i3 < 0 || stateCount[1] > maxCount) {
            return NaN;
          }
          while (i3 >= 0 && image.get(centerJ, i3) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i3--;
          }
          if (stateCount[0] > maxCount) {
            return NaN;
          }
          i3 = startI + 1;
          while (i3 < maxI && image.get(centerJ, i3)) {
            stateCount[2]++;
            i3++;
          }
          if (i3 === maxI) {
            return NaN;
          }
          while (i3 < maxI && !image.get(centerJ, i3) && stateCount[3] < maxCount) {
            stateCount[3]++;
            i3++;
          }
          if (i3 === maxI || stateCount[3] >= maxCount) {
            return NaN;
          }
          while (i3 < maxI && image.get(centerJ, i3) && stateCount[4] < maxCount) {
            stateCount[4]++;
            i3++;
          }
          if (stateCount[4] >= maxCount) {
            return NaN;
          }
          const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN;
          }
          return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i3) : NaN;
        }
        /**
         * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
         * except it reads horizontally instead of vertically. This is used to cross-cross
         * check a vertical cross check and locate the real center of the alignment pattern.</p>
         */
        crossCheckHorizontal(startJ, centerI, maxCount, originalStateCountTotal) {
          const image = this.image;
          const maxJ = image.getWidth();
          const stateCount = this.getCrossCheckStateCount();
          let j2 = startJ;
          while (j2 >= 0 && image.get(j2, centerI)) {
            stateCount[2]++;
            j2--;
          }
          if (j2 < 0) {
            return NaN;
          }
          while (j2 >= 0 && !image.get(j2, centerI) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            j2--;
          }
          if (j2 < 0 || stateCount[1] > maxCount) {
            return NaN;
          }
          while (j2 >= 0 && image.get(j2, centerI) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            j2--;
          }
          if (stateCount[0] > maxCount) {
            return NaN;
          }
          j2 = startJ + 1;
          while (j2 < maxJ && image.get(j2, centerI)) {
            stateCount[2]++;
            j2++;
          }
          if (j2 === maxJ) {
            return NaN;
          }
          while (j2 < maxJ && !image.get(j2, centerI) && stateCount[3] < maxCount) {
            stateCount[3]++;
            j2++;
          }
          if (j2 === maxJ || stateCount[3] >= maxCount) {
            return NaN;
          }
          while (j2 < maxJ && image.get(j2, centerI) && stateCount[4] < maxCount) {
            stateCount[4]++;
            j2++;
          }
          if (stateCount[4] >= maxCount) {
            return NaN;
          }
          const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
            return NaN;
          }
          return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j2) : NaN;
        }
        /**
         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
         * cross check with a vertical scan, and if successful, will, ah, cross-cross-check
         * with another horizontal scan. This is needed primarily to locate the real horizontal
         * center of the pattern in cases of extreme skew.
         * And then we cross-cross-cross check with another diagonal scan.</p>
         *
         * <p>If that succeeds the finder pattern location is added to a list that tracks
         * the number of times each location has been nearly-matched as a finder pattern.
         * Each additional find is more evidence that the location is in fact a finder
         * pattern center
         *
         * @param stateCount reading state module counts from horizontal scan
         * @param i row where finder pattern may be found
         * @param j end of possible finder pattern in row
         * @param pureBarcode true if in "pure barcode" mode
         * @return true if a finder pattern candidate was found this time
         */
        handlePossibleCenter(stateCount, i3, j2, pureBarcode) {
          const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
          let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j2);
          let centerI = this.crossCheckVertical(
            i3,
            /*(int) */
            Math.floor(centerJ),
            stateCount[2],
            stateCountTotal
          );
          if (!isNaN(centerI)) {
            centerJ = this.crossCheckHorizontal(
              /*(int) */
              Math.floor(centerJ),
              /*(int) */
              Math.floor(centerI),
              stateCount[2],
              stateCountTotal
            );
            if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(
              /*(int) */
              Math.floor(centerI),
              /*(int) */
              Math.floor(centerJ),
              stateCount[2],
              stateCountTotal
            ))) {
              const estimatedModuleSize = stateCountTotal / 7;
              let found = false;
              const possibleCenters = this.possibleCenters;
              for (let index = 0, length2 = possibleCenters.length; index < length2; index++) {
                const center = possibleCenters[index];
                if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                  possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                  found = true;
                  break;
                }
              }
              if (!found) {
                const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);
                possibleCenters.push(point);
                if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                  this.resultPointCallback.foundPossibleResultPoint(point);
                }
              }
              return true;
            }
          }
          return false;
        }
        /**
         * @return number of rows we could safely skip during scanning, based on the first
         *         two finder patterns that have been located. In some cases their position will
         *         allow us to infer that the third pattern must lie below a certain point farther
         *         down in the image.
         */
        findRowSkip() {
          const max2 = this.possibleCenters.length;
          if (max2 <= 1) {
            return 0;
          }
          let firstConfirmedCenter = null;
          for (const center of this.possibleCenters) {
            if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
              if (firstConfirmedCenter == null) {
                firstConfirmedCenter = center;
              } else {
                this.hasSkipped = true;
                return (
                  /*(int) */
                  Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2)
                );
              }
            }
          }
          return 0;
        }
        /**
         * @return true iff we have found at least 3 finder patterns that have been detected
         *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
         *         candidates is "pretty similar"
         */
        haveMultiplyConfirmedCenters() {
          let confirmedCount = 0;
          let totalModuleSize = 0;
          const max2 = this.possibleCenters.length;
          for (const pattern of this.possibleCenters) {
            if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
              confirmedCount++;
              totalModuleSize += pattern.getEstimatedModuleSize();
            }
          }
          if (confirmedCount < 3) {
            return false;
          }
          const average = totalModuleSize / max2;
          let totalDeviation = 0;
          for (const pattern of this.possibleCenters) {
            totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
          }
          return totalDeviation <= 0.05 * totalModuleSize;
        }
        /**
         * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
         *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module
         *         size differs from the average among those patterns the least
         * @throws NotFoundException if 3 such finder patterns do not exist
         */
        selectBestPatterns() {
          const startSize = this.possibleCenters.length;
          if (startSize < 3) {
            throw new NotFoundException();
          }
          const possibleCenters = this.possibleCenters;
          let average;
          if (startSize > 3) {
            let totalModuleSize = 0;
            let square = 0;
            for (const center of this.possibleCenters) {
              const size = center.getEstimatedModuleSize();
              totalModuleSize += size;
              square += size * size;
            }
            average = totalModuleSize / startSize;
            let stdDev = Math.sqrt(square / startSize - average * average);
            possibleCenters.sort(
              /**
               * <p>Orders by furthest from average</p>
               */
              // FurthestFromAverageComparator implements Comparator<FinderPattern>
              (center1, center2) => {
                const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? -1 : dA > dB ? 1 : 0;
              }
            );
            const limit = Math.max(0.2 * average, stdDev);
            for (let i3 = 0; i3 < possibleCenters.length && possibleCenters.length > 3; i3++) {
              const pattern = possibleCenters[i3];
              if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
                possibleCenters.splice(i3, 1);
                i3--;
              }
            }
          }
          if (possibleCenters.length > 3) {
            let totalModuleSize = 0;
            for (const possibleCenter of possibleCenters) {
              totalModuleSize += possibleCenter.getEstimatedModuleSize();
            }
            average = totalModuleSize / possibleCenters.length;
            possibleCenters.sort(
              /**
               * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
               */
              // CenterComparator implements Comparator<FinderPattern>
              (center1, center2) => {
                if (center2.getCount() === center1.getCount()) {
                  const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                  const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                  return dA < dB ? 1 : dA > dB ? -1 : 0;
                } else {
                  return center2.getCount() - center1.getCount();
                }
              }
            );
            possibleCenters.splice(3);
          }
          return [
            possibleCenters[0],
            possibleCenters[1],
            possibleCenters[2]
          ];
        }
      }
      FinderPatternFinder.CENTER_QUORUM = 2;
      FinderPatternFinder.MIN_SKIP = 3;
      FinderPatternFinder.MAX_MODULES = 57;
      class Detector$2 {
        constructor(image) {
          this.image = image;
        }
        getImage() {
          return this.image;
        }
        getResultPointCallback() {
          return this.resultPointCallback;
        }
        /**
         * <p>Detects a QR Code in an image.</p>
         *
         * @return {@link DetectorResult} encapsulating results of detecting a QR Code
         * @throws NotFoundException if QR Code cannot be found
         * @throws FormatException if a QR Code cannot be decoded
         */
        // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {
        //   return detect(null)
        // }
        /**
         * <p>Detects a QR Code in an image.</p>
         *
         * @param hints optional hints to detector
         * @return {@link DetectorResult} encapsulating results of detecting a QR Code
         * @throws NotFoundException if QR Code cannot be found
         * @throws FormatException if a QR Code cannot be decoded
         */
        detect(hints) {
          this.resultPointCallback = hints === null || hints === void 0 ? null : (
            /*(ResultPointCallback) */
            hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK)
          );
          const finder = new FinderPatternFinder(this.image, this.resultPointCallback);
          const info = finder.find(hints);
          return this.processFinderPatternInfo(info);
        }
        processFinderPatternInfo(info) {
          const topLeft = info.getTopLeft();
          const topRight = info.getTopRight();
          const bottomLeft = info.getBottomLeft();
          const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
          if (moduleSize < 1) {
            throw new NotFoundException("No pattern found in proccess finder.");
          }
          const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
          const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);
          const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
          let alignmentPattern = null;
          if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
            const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
            const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
            const correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
            const estAlignmentX = (
              /*(int) */
              Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()))
            );
            const estAlignmentY = (
              /*(int) */
              Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()))
            );
            for (let i3 = 4; i3 <= 16; i3 <<= 1) {
              try {
                alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i3);
                break;
              } catch (re3) {
                if (!(re3 instanceof NotFoundException)) {
                  throw re3;
                }
              }
            }
          }
          const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
          const bits2 = Detector$2.sampleGrid(this.image, transform, dimension);
          let points;
          if (alignmentPattern === null) {
            points = [bottomLeft, topLeft, topRight];
          } else {
            points = [bottomLeft, topLeft, topRight, alignmentPattern];
          }
          return new DetectorResult(bits2, points);
        }
        static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
          const dimMinusThree = dimension - 3.5;
          let bottomRightX;
          let bottomRightY;
          let sourceBottomRightX;
          let sourceBottomRightY;
          if (alignmentPattern !== null) {
            bottomRightX = alignmentPattern.getX();
            bottomRightY = alignmentPattern.getY();
            sourceBottomRightX = dimMinusThree - 3;
            sourceBottomRightY = sourceBottomRightX;
          } else {
            bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
            bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
            sourceBottomRightX = dimMinusThree;
            sourceBottomRightY = dimMinusThree;
          }
          return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
        }
        static sampleGrid(image, transform, dimension) {
          const sampler = GridSamplerInstance.getInstance();
          return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
        }
        /**
         * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
         * of the finder patterns and estimated module size.</p>
         */
        static computeDimension(topLeft, topRight, bottomLeft, moduleSize) {
          const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
          const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
          let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
          switch (dimension & 3) {
            case 0:
              dimension++;
              break;
            case 2:
              dimension--;
              break;
            case 3:
              throw new NotFoundException("Dimensions could be not found.");
          }
          return dimension;
        }
        /**
         * <p>Computes an average estimated module size based on estimated derived from the positions
         * of the three finder patterns.</p>
         *
         * @param topLeft detected top-left finder pattern center
         * @param topRight detected top-right finder pattern center
         * @param bottomLeft detected bottom-left finder pattern center
         * @return estimated module size
         */
        calculateModuleSize(topLeft, topRight, bottomLeft) {
          return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
        }
        /**
         * <p>Estimates module size based on two finder patterns -- it uses
         * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
         * width of each, measuring along the axis between their centers.</p>
         */
        calculateModuleSizeOneWay(pattern, otherPattern) {
          const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(
            /*(int) */
            Math.floor(pattern.getX()),
            /*(int) */
            Math.floor(pattern.getY()),
            /*(int) */
            Math.floor(otherPattern.getX()),
            /*(int) */
            Math.floor(otherPattern.getY())
          );
          const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(
            /*(int) */
            Math.floor(otherPattern.getX()),
            /*(int) */
            Math.floor(otherPattern.getY()),
            /*(int) */
            Math.floor(pattern.getX()),
            /*(int) */
            Math.floor(pattern.getY())
          );
          if (isNaN(moduleSizeEst1)) {
            return moduleSizeEst2 / 7;
          }
          if (isNaN(moduleSizeEst2)) {
            return moduleSizeEst1 / 7;
          }
          return (moduleSizeEst1 + moduleSizeEst2) / 14;
        }
        /**
         * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
         * a finder pattern by looking for a black-white-black run from the center in the direction
         * of another point (another finder pattern center), and in the opposite direction too.
         */
        sizeOfBlackWhiteBlackRunBothWays(fromX, fromY, toX, toY) {
          let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
          let scale = 1;
          let otherToX = fromX - (toX - fromX);
          if (otherToX < 0) {
            scale = fromX / /*(float) */
            (fromX - otherToX);
            otherToX = 0;
          } else if (otherToX >= this.image.getWidth()) {
            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */
            (otherToX - fromX);
            otherToX = this.image.getWidth() - 1;
          }
          let otherToY = (
            /*(int) */
            Math.floor(fromY - (toY - fromY) * scale)
          );
          scale = 1;
          if (otherToY < 0) {
            scale = fromY / /*(float) */
            (fromY - otherToY);
            otherToY = 0;
          } else if (otherToY >= this.image.getHeight()) {
            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */
            (otherToY - fromY);
            otherToY = this.image.getHeight() - 1;
          }
          otherToX = /*(int) */
          Math.floor(fromX + (otherToX - fromX) * scale);
          result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
          return result - 1;
        }
        /**
         * <p>This method traces a line from a point in the image, in the direction towards another point.
         * It begins in a black region, and keeps going until it finds white, then black, then white again.
         * It reports the distance from the start to this point.</p>
         *
         * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
         * may be skewed or rotated.</p>
         */
        sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY) {
          const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
          if (steep) {
            let temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
          }
          const dx = Math.abs(toX - fromX);
          const dy = Math.abs(toY - fromY);
          let error = -dx / 2;
          const xstep = fromX < toX ? 1 : -1;
          const ystep = fromY < toY ? 1 : -1;
          let state = 0;
          const xLimit = toX + xstep;
          for (let x2 = fromX, y2 = fromY; x2 !== xLimit; x2 += xstep) {
            const realX = steep ? y2 : x2;
            const realY = steep ? x2 : y2;
            if (state === 1 === this.image.get(realX, realY)) {
              if (state === 2) {
                return MathUtils.distance(x2, y2, fromX, fromY);
              }
              state++;
            }
            error += dy;
            if (error > 0) {
              if (y2 === toY) {
                break;
              }
              y2 += ystep;
              error -= dx;
            }
          }
          if (state === 2) {
            return MathUtils.distance(toX + xstep, toY, fromX, fromY);
          }
          return NaN;
        }
        /**
         * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
         * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
         *
         * @param overallEstModuleSize estimated module size so far
         * @param estAlignmentX x coordinate of center of area probably containing alignment pattern
         * @param estAlignmentY y coordinate of above
         * @param allowanceFactor number of pixels in all directions to search from the center
         * @return {@link AlignmentPattern} if found, or null otherwise
         * @throws NotFoundException if an unexpected error occurs during detection
         */
        findAlignmentInRegion(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
          const allowance = (
            /*(int) */
            Math.floor(allowanceFactor * overallEstModuleSize)
          );
          const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
          const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
          if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
            throw new NotFoundException("Alignment top exceeds estimated module size.");
          }
          const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
          const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
          if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
            throw new NotFoundException("Alignment bottom exceeds estimated module size.");
          }
          const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
          return alignmentFinder.find();
        }
      }
      class QRCodeReader {
        constructor() {
          this.decoder = new Decoder$2();
        }
        getDecoder() {
          return this.decoder;
        }
        /**
         * Locates and decodes a QR code in an image.
         *
         * @return a representing: string the content encoded by the QR code
         * @throws NotFoundException if a QR code cannot be found
         * @throws FormatException if a QR code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        /*@Override*/
        // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {
        //   return this.decode(image, null)
        // }
        /*@Override*/
        decode(image, hints) {
          let decoderResult;
          let points;
          if (hints !== void 0 && hints !== null && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE)) {
            const bits2 = QRCodeReader.extractPureBits(image.getBlackMatrix());
            decoderResult = this.decoder.decodeBitMatrix(bits2, hints);
            points = QRCodeReader.NO_POINTS;
          } else {
            const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);
            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
            points = detectorResult.getPoints();
          }
          if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
            decoderResult.getOther().applyMirroredCorrection(points);
          }
          const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.QR_CODE, void 0);
          const byteSegments = decoderResult.getByteSegments();
          if (byteSegments !== null) {
            result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
          }
          const ecLevel = decoderResult.getECLevel();
          if (ecLevel !== null) {
            result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
          }
          if (decoderResult.hasStructuredAppend()) {
            result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
            result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
          }
          return result;
        }
        /*@Override*/
        reset() {
        }
        /**
         * This method detects a code in a "pure" image -- that is, pure monochrome image
         * which contains only an unrotated, unskewed, image of a code, with some white border
         * around it. This is a specialized method that works exceptionally fast in this special
         * case.
         *
         * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
         */
        static extractPureBits(image) {
          const leftTopBlack = image.getTopLeftOnBit();
          const rightBottomBlack = image.getBottomRightOnBit();
          if (leftTopBlack === null || rightBottomBlack === null) {
            throw new NotFoundException();
          }
          const moduleSize = this.moduleSize(leftTopBlack, image);
          let top = leftTopBlack[1];
          let bottom = rightBottomBlack[1];
          let left = leftTopBlack[0];
          let right = rightBottomBlack[0];
          if (left >= right || top >= bottom) {
            throw new NotFoundException();
          }
          if (bottom - top !== right - left) {
            right = left + (bottom - top);
            if (right >= image.getWidth()) {
              throw new NotFoundException();
            }
          }
          const matrixWidth = Math.round((right - left + 1) / moduleSize);
          const matrixHeight = Math.round((bottom - top + 1) / moduleSize);
          if (matrixWidth <= 0 || matrixHeight <= 0) {
            throw new NotFoundException();
          }
          if (matrixHeight !== matrixWidth) {
            throw new NotFoundException();
          }
          const nudge = (
            /*(int) */
            Math.floor(moduleSize / 2)
          );
          top += nudge;
          left += nudge;
          const nudgedTooFarRight = left + /*(int) */
          Math.floor((matrixWidth - 1) * moduleSize) - right;
          if (nudgedTooFarRight > 0) {
            if (nudgedTooFarRight > nudge) {
              throw new NotFoundException();
            }
            left -= nudgedTooFarRight;
          }
          const nudgedTooFarDown = top + /*(int) */
          Math.floor((matrixHeight - 1) * moduleSize) - bottom;
          if (nudgedTooFarDown > 0) {
            if (nudgedTooFarDown > nudge) {
              throw new NotFoundException();
            }
            top -= nudgedTooFarDown;
          }
          const bits2 = new BitMatrix(matrixWidth, matrixHeight);
          for (let y2 = 0; y2 < matrixHeight; y2++) {
            const iOffset = top + /*(int) */
            Math.floor(y2 * moduleSize);
            for (let x2 = 0; x2 < matrixWidth; x2++) {
              if (image.get(left + /*(int) */
              Math.floor(x2 * moduleSize), iOffset)) {
                bits2.set(x2, y2);
              }
            }
          }
          return bits2;
        }
        static moduleSize(leftTopBlack, image) {
          const height = image.getHeight();
          const width = image.getWidth();
          let x2 = leftTopBlack[0];
          let y2 = leftTopBlack[1];
          let inBlack = true;
          let transitions = 0;
          while (x2 < width && y2 < height) {
            if (inBlack !== image.get(x2, y2)) {
              if (++transitions === 5) {
                break;
              }
              inBlack = !inBlack;
            }
            x2++;
            y2++;
          }
          if (x2 === width || y2 === height) {
            throw new NotFoundException();
          }
          return (x2 - leftTopBlack[0]) / 7;
        }
      }
      QRCodeReader.NO_POINTS = new Array();
      class PDF417Common {
        PDF417Common() {
        }
        /**
         * @param moduleBitCount values to sum
         * @return sum of values
         * @deprecated call {@link MathUtils#sum(int[])}
         */
        // @Deprecated
        static getBitCountSum(moduleBitCount) {
          return MathUtils.sum(moduleBitCount);
        }
        static toIntArray(list) {
          if (list == null || !list.length) {
            return PDF417Common.EMPTY_INT_ARRAY;
          }
          const result = new Int32Array(list.length);
          let i3 = 0;
          for (const integer of list) {
            result[i3++] = integer;
          }
          return result;
        }
        /**
         * @param symbol encoded symbol to translate to a codeword
         * @return the codeword corresponding to the symbol.
         */
        static getCodeword(symbol) {
          const i3 = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 262143);
          if (i3 < 0) {
            return -1;
          }
          return (PDF417Common.CODEWORD_TABLE[i3] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
        }
      }
      PDF417Common.NUMBER_OF_CODEWORDS = 929;
      PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
      PDF417Common.MIN_ROWS_IN_BARCODE = 3;
      PDF417Common.MAX_ROWS_IN_BARCODE = 90;
      PDF417Common.MODULES_IN_CODEWORD = 17;
      PDF417Common.MODULES_IN_STOP_PATTERN = 18;
      PDF417Common.BARS_IN_MODULE = 8;
      PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
      PDF417Common.SYMBOL_TABLE = Int32Array.from([
        66142,
        66170,
        66206,
        66236,
        66290,
        66292,
        66350,
        66382,
        66396,
        66454,
        66470,
        66476,
        66594,
        66600,
        66614,
        66626,
        66628,
        66632,
        66640,
        66654,
        66662,
        66668,
        66682,
        66690,
        66718,
        66720,
        66748,
        66758,
        66776,
        66798,
        66802,
        66804,
        66820,
        66824,
        66832,
        66846,
        66848,
        66876,
        66880,
        66936,
        66950,
        66956,
        66968,
        66992,
        67006,
        67022,
        67036,
        67042,
        67044,
        67048,
        67062,
        67118,
        67150,
        67164,
        67214,
        67228,
        67256,
        67294,
        67322,
        67350,
        67366,
        67372,
        67398,
        67404,
        67416,
        67438,
        67474,
        67476,
        67490,
        67492,
        67496,
        67510,
        67618,
        67624,
        67650,
        67656,
        67664,
        67678,
        67686,
        67692,
        67706,
        67714,
        67716,
        67728,
        67742,
        67744,
        67772,
        67782,
        67788,
        67800,
        67822,
        67826,
        67828,
        67842,
        67848,
        67870,
        67872,
        67900,
        67904,
        67960,
        67974,
        67992,
        68016,
        68030,
        68046,
        68060,
        68066,
        68068,
        68072,
        68086,
        68104,
        68112,
        68126,
        68128,
        68156,
        68160,
        68216,
        68336,
        68358,
        68364,
        68376,
        68400,
        68414,
        68448,
        68476,
        68494,
        68508,
        68536,
        68546,
        68548,
        68552,
        68560,
        68574,
        68582,
        68588,
        68654,
        68686,
        68700,
        68706,
        68708,
        68712,
        68726,
        68750,
        68764,
        68792,
        68802,
        68804,
        68808,
        68816,
        68830,
        68838,
        68844,
        68858,
        68878,
        68892,
        68920,
        68976,
        68990,
        68994,
        68996,
        69e3,
        69008,
        69022,
        69024,
        69052,
        69062,
        69068,
        69080,
        69102,
        69106,
        69108,
        69142,
        69158,
        69164,
        69190,
        69208,
        69230,
        69254,
        69260,
        69272,
        69296,
        69310,
        69326,
        69340,
        69386,
        69394,
        69396,
        69410,
        69416,
        69430,
        69442,
        69444,
        69448,
        69456,
        69470,
        69478,
        69484,
        69554,
        69556,
        69666,
        69672,
        69698,
        69704,
        69712,
        69726,
        69754,
        69762,
        69764,
        69776,
        69790,
        69792,
        69820,
        69830,
        69836,
        69848,
        69870,
        69874,
        69876,
        69890,
        69918,
        69920,
        69948,
        69952,
        70008,
        70022,
        70040,
        70064,
        70078,
        70094,
        70108,
        70114,
        70116,
        70120,
        70134,
        70152,
        70174,
        70176,
        70264,
        70384,
        70412,
        70448,
        70462,
        70496,
        70524,
        70542,
        70556,
        70584,
        70594,
        70600,
        70608,
        70622,
        70630,
        70636,
        70664,
        70672,
        70686,
        70688,
        70716,
        70720,
        70776,
        70896,
        71136,
        71180,
        71192,
        71216,
        71230,
        71264,
        71292,
        71360,
        71416,
        71452,
        71480,
        71536,
        71550,
        71554,
        71556,
        71560,
        71568,
        71582,
        71584,
        71612,
        71622,
        71628,
        71640,
        71662,
        71726,
        71732,
        71758,
        71772,
        71778,
        71780,
        71784,
        71798,
        71822,
        71836,
        71864,
        71874,
        71880,
        71888,
        71902,
        71910,
        71916,
        71930,
        71950,
        71964,
        71992,
        72048,
        72062,
        72066,
        72068,
        72080,
        72094,
        72096,
        72124,
        72134,
        72140,
        72152,
        72174,
        72178,
        72180,
        72206,
        72220,
        72248,
        72304,
        72318,
        72416,
        72444,
        72456,
        72464,
        72478,
        72480,
        72508,
        72512,
        72568,
        72588,
        72600,
        72624,
        72638,
        72654,
        72668,
        72674,
        72676,
        72680,
        72694,
        72726,
        72742,
        72748,
        72774,
        72780,
        72792,
        72814,
        72838,
        72856,
        72880,
        72894,
        72910,
        72924,
        72930,
        72932,
        72936,
        72950,
        72966,
        72972,
        72984,
        73008,
        73022,
        73056,
        73084,
        73102,
        73116,
        73144,
        73156,
        73160,
        73168,
        73182,
        73190,
        73196,
        73210,
        73226,
        73234,
        73236,
        73250,
        73252,
        73256,
        73270,
        73282,
        73284,
        73296,
        73310,
        73318,
        73324,
        73346,
        73348,
        73352,
        73360,
        73374,
        73376,
        73404,
        73414,
        73420,
        73432,
        73454,
        73498,
        73518,
        73522,
        73524,
        73550,
        73564,
        73570,
        73572,
        73576,
        73590,
        73800,
        73822,
        73858,
        73860,
        73872,
        73886,
        73888,
        73916,
        73944,
        73970,
        73972,
        73992,
        74014,
        74016,
        74044,
        74048,
        74104,
        74118,
        74136,
        74160,
        74174,
        74210,
        74212,
        74216,
        74230,
        74244,
        74256,
        74270,
        74272,
        74360,
        74480,
        74502,
        74508,
        74544,
        74558,
        74592,
        74620,
        74638,
        74652,
        74680,
        74690,
        74696,
        74704,
        74726,
        74732,
        74782,
        74784,
        74812,
        74992,
        75232,
        75288,
        75326,
        75360,
        75388,
        75456,
        75512,
        75576,
        75632,
        75646,
        75650,
        75652,
        75664,
        75678,
        75680,
        75708,
        75718,
        75724,
        75736,
        75758,
        75808,
        75836,
        75840,
        75896,
        76016,
        76256,
        76736,
        76824,
        76848,
        76862,
        76896,
        76924,
        76992,
        77048,
        77296,
        77340,
        77368,
        77424,
        77438,
        77536,
        77564,
        77572,
        77576,
        77584,
        77600,
        77628,
        77632,
        77688,
        77702,
        77708,
        77720,
        77744,
        77758,
        77774,
        77788,
        77870,
        77902,
        77916,
        77922,
        77928,
        77966,
        77980,
        78008,
        78018,
        78024,
        78032,
        78046,
        78060,
        78074,
        78094,
        78136,
        78192,
        78206,
        78210,
        78212,
        78224,
        78238,
        78240,
        78268,
        78278,
        78284,
        78296,
        78322,
        78324,
        78350,
        78364,
        78448,
        78462,
        78560,
        78588,
        78600,
        78622,
        78624,
        78652,
        78656,
        78712,
        78726,
        78744,
        78768,
        78782,
        78798,
        78812,
        78818,
        78820,
        78824,
        78838,
        78862,
        78876,
        78904,
        78960,
        78974,
        79072,
        79100,
        79296,
        79352,
        79368,
        79376,
        79390,
        79392,
        79420,
        79424,
        79480,
        79600,
        79628,
        79640,
        79664,
        79678,
        79712,
        79740,
        79772,
        79800,
        79810,
        79812,
        79816,
        79824,
        79838,
        79846,
        79852,
        79894,
        79910,
        79916,
        79942,
        79948,
        79960,
        79982,
        79988,
        80006,
        80024,
        80048,
        80062,
        80078,
        80092,
        80098,
        80100,
        80104,
        80134,
        80140,
        80176,
        80190,
        80224,
        80252,
        80270,
        80284,
        80312,
        80328,
        80336,
        80350,
        80358,
        80364,
        80378,
        80390,
        80396,
        80408,
        80432,
        80446,
        80480,
        80508,
        80576,
        80632,
        80654,
        80668,
        80696,
        80752,
        80766,
        80776,
        80784,
        80798,
        80800,
        80828,
        80844,
        80856,
        80878,
        80882,
        80884,
        80914,
        80916,
        80930,
        80932,
        80936,
        80950,
        80962,
        80968,
        80976,
        80990,
        80998,
        81004,
        81026,
        81028,
        81040,
        81054,
        81056,
        81084,
        81094,
        81100,
        81112,
        81134,
        81154,
        81156,
        81160,
        81168,
        81182,
        81184,
        81212,
        81216,
        81272,
        81286,
        81292,
        81304,
        81328,
        81342,
        81358,
        81372,
        81380,
        81384,
        81398,
        81434,
        81454,
        81458,
        81460,
        81486,
        81500,
        81506,
        81508,
        81512,
        81526,
        81550,
        81564,
        81592,
        81602,
        81604,
        81608,
        81616,
        81630,
        81638,
        81644,
        81702,
        81708,
        81722,
        81734,
        81740,
        81752,
        81774,
        81778,
        81780,
        82050,
        82078,
        82080,
        82108,
        82180,
        82184,
        82192,
        82206,
        82208,
        82236,
        82240,
        82296,
        82316,
        82328,
        82352,
        82366,
        82402,
        82404,
        82408,
        82440,
        82448,
        82462,
        82464,
        82492,
        82496,
        82552,
        82672,
        82694,
        82700,
        82712,
        82736,
        82750,
        82784,
        82812,
        82830,
        82882,
        82884,
        82888,
        82896,
        82918,
        82924,
        82952,
        82960,
        82974,
        82976,
        83004,
        83008,
        83064,
        83184,
        83424,
        83468,
        83480,
        83504,
        83518,
        83552,
        83580,
        83648,
        83704,
        83740,
        83768,
        83824,
        83838,
        83842,
        83844,
        83848,
        83856,
        83872,
        83900,
        83910,
        83916,
        83928,
        83950,
        83984,
        84e3,
        84028,
        84032,
        84088,
        84208,
        84448,
        84928,
        85040,
        85054,
        85088,
        85116,
        85184,
        85240,
        85488,
        85560,
        85616,
        85630,
        85728,
        85756,
        85764,
        85768,
        85776,
        85790,
        85792,
        85820,
        85824,
        85880,
        85894,
        85900,
        85912,
        85936,
        85966,
        85980,
        86048,
        86080,
        86136,
        86256,
        86496,
        86976,
        88160,
        88188,
        88256,
        88312,
        88560,
        89056,
        89200,
        89214,
        89312,
        89340,
        89536,
        89592,
        89608,
        89616,
        89632,
        89664,
        89720,
        89840,
        89868,
        89880,
        89904,
        89952,
        89980,
        89998,
        90012,
        90040,
        90190,
        90204,
        90254,
        90268,
        90296,
        90306,
        90308,
        90312,
        90334,
        90382,
        90396,
        90424,
        90480,
        90494,
        90500,
        90504,
        90512,
        90526,
        90528,
        90556,
        90566,
        90572,
        90584,
        90610,
        90612,
        90638,
        90652,
        90680,
        90736,
        90750,
        90848,
        90876,
        90884,
        90888,
        90896,
        90910,
        90912,
        90940,
        90944,
        91e3,
        91014,
        91020,
        91032,
        91056,
        91070,
        91086,
        91100,
        91106,
        91108,
        91112,
        91126,
        91150,
        91164,
        91192,
        91248,
        91262,
        91360,
        91388,
        91584,
        91640,
        91664,
        91678,
        91680,
        91708,
        91712,
        91768,
        91888,
        91928,
        91952,
        91966,
        92e3,
        92028,
        92046,
        92060,
        92088,
        92098,
        92100,
        92104,
        92112,
        92126,
        92134,
        92140,
        92188,
        92216,
        92272,
        92384,
        92412,
        92608,
        92664,
        93168,
        93200,
        93214,
        93216,
        93244,
        93248,
        93304,
        93424,
        93664,
        93720,
        93744,
        93758,
        93792,
        93820,
        93888,
        93944,
        93980,
        94008,
        94064,
        94078,
        94084,
        94088,
        94096,
        94110,
        94112,
        94140,
        94150,
        94156,
        94168,
        94246,
        94252,
        94278,
        94284,
        94296,
        94318,
        94342,
        94348,
        94360,
        94384,
        94398,
        94414,
        94428,
        94440,
        94470,
        94476,
        94488,
        94512,
        94526,
        94560,
        94588,
        94606,
        94620,
        94648,
        94658,
        94660,
        94664,
        94672,
        94686,
        94694,
        94700,
        94714,
        94726,
        94732,
        94744,
        94768,
        94782,
        94816,
        94844,
        94912,
        94968,
        94990,
        95004,
        95032,
        95088,
        95102,
        95112,
        95120,
        95134,
        95136,
        95164,
        95180,
        95192,
        95214,
        95218,
        95220,
        95244,
        95256,
        95280,
        95294,
        95328,
        95356,
        95424,
        95480,
        95728,
        95758,
        95772,
        95800,
        95856,
        95870,
        95968,
        95996,
        96008,
        96016,
        96030,
        96032,
        96060,
        96064,
        96120,
        96152,
        96176,
        96190,
        96220,
        96226,
        96228,
        96232,
        96290,
        96292,
        96296,
        96310,
        96322,
        96324,
        96328,
        96336,
        96350,
        96358,
        96364,
        96386,
        96388,
        96392,
        96400,
        96414,
        96416,
        96444,
        96454,
        96460,
        96472,
        96494,
        96498,
        96500,
        96514,
        96516,
        96520,
        96528,
        96542,
        96544,
        96572,
        96576,
        96632,
        96646,
        96652,
        96664,
        96688,
        96702,
        96718,
        96732,
        96738,
        96740,
        96744,
        96758,
        96772,
        96776,
        96784,
        96798,
        96800,
        96828,
        96832,
        96888,
        97008,
        97030,
        97036,
        97048,
        97072,
        97086,
        97120,
        97148,
        97166,
        97180,
        97208,
        97220,
        97224,
        97232,
        97246,
        97254,
        97260,
        97326,
        97330,
        97332,
        97358,
        97372,
        97378,
        97380,
        97384,
        97398,
        97422,
        97436,
        97464,
        97474,
        97476,
        97480,
        97488,
        97502,
        97510,
        97516,
        97550,
        97564,
        97592,
        97648,
        97666,
        97668,
        97672,
        97680,
        97694,
        97696,
        97724,
        97734,
        97740,
        97752,
        97774,
        97830,
        97836,
        97850,
        97862,
        97868,
        97880,
        97902,
        97906,
        97908,
        97926,
        97932,
        97944,
        97968,
        97998,
        98012,
        98018,
        98020,
        98024,
        98038,
        98618,
        98674,
        98676,
        98838,
        98854,
        98874,
        98892,
        98904,
        98926,
        98930,
        98932,
        98968,
        99006,
        99042,
        99044,
        99048,
        99062,
        99166,
        99194,
        99246,
        99286,
        99350,
        99366,
        99372,
        99386,
        99398,
        99416,
        99438,
        99442,
        99444,
        99462,
        99504,
        99518,
        99534,
        99548,
        99554,
        99556,
        99560,
        99574,
        99590,
        99596,
        99608,
        99632,
        99646,
        99680,
        99708,
        99726,
        99740,
        99768,
        99778,
        99780,
        99784,
        99792,
        99806,
        99814,
        99820,
        99834,
        99858,
        99860,
        99874,
        99880,
        99894,
        99906,
        99920,
        99934,
        99962,
        99970,
        99972,
        99976,
        99984,
        99998,
        1e5,
        100028,
        100038,
        100044,
        100056,
        100078,
        100082,
        100084,
        100142,
        100174,
        100188,
        100246,
        100262,
        100268,
        100306,
        100308,
        100390,
        100396,
        100410,
        100422,
        100428,
        100440,
        100462,
        100466,
        100468,
        100486,
        100504,
        100528,
        100542,
        100558,
        100572,
        100578,
        100580,
        100584,
        100598,
        100620,
        100656,
        100670,
        100704,
        100732,
        100750,
        100792,
        100802,
        100808,
        100816,
        100830,
        100838,
        100844,
        100858,
        100888,
        100912,
        100926,
        100960,
        100988,
        101056,
        101112,
        101148,
        101176,
        101232,
        101246,
        101250,
        101252,
        101256,
        101264,
        101278,
        101280,
        101308,
        101318,
        101324,
        101336,
        101358,
        101362,
        101364,
        101410,
        101412,
        101416,
        101430,
        101442,
        101448,
        101456,
        101470,
        101478,
        101498,
        101506,
        101508,
        101520,
        101534,
        101536,
        101564,
        101580,
        101618,
        101620,
        101636,
        101640,
        101648,
        101662,
        101664,
        101692,
        101696,
        101752,
        101766,
        101784,
        101838,
        101858,
        101860,
        101864,
        101934,
        101938,
        101940,
        101966,
        101980,
        101986,
        101988,
        101992,
        102030,
        102044,
        102072,
        102082,
        102084,
        102088,
        102096,
        102138,
        102166,
        102182,
        102188,
        102214,
        102220,
        102232,
        102254,
        102282,
        102290,
        102292,
        102306,
        102308,
        102312,
        102326,
        102444,
        102458,
        102470,
        102476,
        102488,
        102514,
        102516,
        102534,
        102552,
        102576,
        102590,
        102606,
        102620,
        102626,
        102632,
        102646,
        102662,
        102668,
        102704,
        102718,
        102752,
        102780,
        102798,
        102812,
        102840,
        102850,
        102856,
        102864,
        102878,
        102886,
        102892,
        102906,
        102936,
        102974,
        103008,
        103036,
        103104,
        103160,
        103224,
        103280,
        103294,
        103298,
        103300,
        103312,
        103326,
        103328,
        103356,
        103366,
        103372,
        103384,
        103406,
        103410,
        103412,
        103472,
        103486,
        103520,
        103548,
        103616,
        103672,
        103920,
        103992,
        104048,
        104062,
        104160,
        104188,
        104194,
        104196,
        104200,
        104208,
        104224,
        104252,
        104256,
        104312,
        104326,
        104332,
        104344,
        104368,
        104382,
        104398,
        104412,
        104418,
        104420,
        104424,
        104482,
        104484,
        104514,
        104520,
        104528,
        104542,
        104550,
        104570,
        104578,
        104580,
        104592,
        104606,
        104608,
        104636,
        104652,
        104690,
        104692,
        104706,
        104712,
        104734,
        104736,
        104764,
        104768,
        104824,
        104838,
        104856,
        104910,
        104930,
        104932,
        104936,
        104968,
        104976,
        104990,
        104992,
        105020,
        105024,
        105080,
        105200,
        105240,
        105278,
        105312,
        105372,
        105410,
        105412,
        105416,
        105424,
        105446,
        105518,
        105524,
        105550,
        105564,
        105570,
        105572,
        105576,
        105614,
        105628,
        105656,
        105666,
        105672,
        105680,
        105702,
        105722,
        105742,
        105756,
        105784,
        105840,
        105854,
        105858,
        105860,
        105864,
        105872,
        105888,
        105932,
        105970,
        105972,
        106006,
        106022,
        106028,
        106054,
        106060,
        106072,
        106100,
        106118,
        106124,
        106136,
        106160,
        106174,
        106190,
        106210,
        106212,
        106216,
        106250,
        106258,
        106260,
        106274,
        106276,
        106280,
        106306,
        106308,
        106312,
        106320,
        106334,
        106348,
        106394,
        106414,
        106418,
        106420,
        106566,
        106572,
        106610,
        106612,
        106630,
        106636,
        106648,
        106672,
        106686,
        106722,
        106724,
        106728,
        106742,
        106758,
        106764,
        106776,
        106800,
        106814,
        106848,
        106876,
        106894,
        106908,
        106936,
        106946,
        106948,
        106952,
        106960,
        106974,
        106982,
        106988,
        107032,
        107056,
        107070,
        107104,
        107132,
        107200,
        107256,
        107292,
        107320,
        107376,
        107390,
        107394,
        107396,
        107400,
        107408,
        107422,
        107424,
        107452,
        107462,
        107468,
        107480,
        107502,
        107506,
        107508,
        107544,
        107568,
        107582,
        107616,
        107644,
        107712,
        107768,
        108016,
        108060,
        108088,
        108144,
        108158,
        108256,
        108284,
        108290,
        108292,
        108296,
        108304,
        108318,
        108320,
        108348,
        108352,
        108408,
        108422,
        108428,
        108440,
        108464,
        108478,
        108494,
        108508,
        108514,
        108516,
        108520,
        108592,
        108640,
        108668,
        108736,
        108792,
        109040,
        109536,
        109680,
        109694,
        109792,
        109820,
        110016,
        110072,
        110084,
        110088,
        110096,
        110112,
        110140,
        110144,
        110200,
        110320,
        110342,
        110348,
        110360,
        110384,
        110398,
        110432,
        110460,
        110478,
        110492,
        110520,
        110532,
        110536,
        110544,
        110558,
        110658,
        110686,
        110714,
        110722,
        110724,
        110728,
        110736,
        110750,
        110752,
        110780,
        110796,
        110834,
        110836,
        110850,
        110852,
        110856,
        110864,
        110878,
        110880,
        110908,
        110912,
        110968,
        110982,
        111e3,
        111054,
        111074,
        111076,
        111080,
        111108,
        111112,
        111120,
        111134,
        111136,
        111164,
        111168,
        111224,
        111344,
        111372,
        111422,
        111456,
        111516,
        111554,
        111556,
        111560,
        111568,
        111590,
        111632,
        111646,
        111648,
        111676,
        111680,
        111736,
        111856,
        112096,
        112152,
        112224,
        112252,
        112320,
        112440,
        112514,
        112516,
        112520,
        112528,
        112542,
        112544,
        112588,
        112686,
        112718,
        112732,
        112782,
        112796,
        112824,
        112834,
        112836,
        112840,
        112848,
        112870,
        112890,
        112910,
        112924,
        112952,
        113008,
        113022,
        113026,
        113028,
        113032,
        113040,
        113054,
        113056,
        113100,
        113138,
        113140,
        113166,
        113180,
        113208,
        113264,
        113278,
        113376,
        113404,
        113416,
        113424,
        113440,
        113468,
        113472,
        113560,
        113614,
        113634,
        113636,
        113640,
        113686,
        113702,
        113708,
        113734,
        113740,
        113752,
        113778,
        113780,
        113798,
        113804,
        113816,
        113840,
        113854,
        113870,
        113890,
        113892,
        113896,
        113926,
        113932,
        113944,
        113968,
        113982,
        114016,
        114044,
        114076,
        114114,
        114116,
        114120,
        114128,
        114150,
        114170,
        114194,
        114196,
        114210,
        114212,
        114216,
        114242,
        114244,
        114248,
        114256,
        114270,
        114278,
        114306,
        114308,
        114312,
        114320,
        114334,
        114336,
        114364,
        114380,
        114420,
        114458,
        114478,
        114482,
        114484,
        114510,
        114524,
        114530,
        114532,
        114536,
        114842,
        114866,
        114868,
        114970,
        114994,
        114996,
        115042,
        115044,
        115048,
        115062,
        115130,
        115226,
        115250,
        115252,
        115278,
        115292,
        115298,
        115300,
        115304,
        115318,
        115342,
        115394,
        115396,
        115400,
        115408,
        115422,
        115430,
        115436,
        115450,
        115478,
        115494,
        115514,
        115526,
        115532,
        115570,
        115572,
        115738,
        115758,
        115762,
        115764,
        115790,
        115804,
        115810,
        115812,
        115816,
        115830,
        115854,
        115868,
        115896,
        115906,
        115912,
        115920,
        115934,
        115942,
        115948,
        115962,
        115996,
        116024,
        116080,
        116094,
        116098,
        116100,
        116104,
        116112,
        116126,
        116128,
        116156,
        116166,
        116172,
        116184,
        116206,
        116210,
        116212,
        116246,
        116262,
        116268,
        116282,
        116294,
        116300,
        116312,
        116334,
        116338,
        116340,
        116358,
        116364,
        116376,
        116400,
        116414,
        116430,
        116444,
        116450,
        116452,
        116456,
        116498,
        116500,
        116514,
        116520,
        116534,
        116546,
        116548,
        116552,
        116560,
        116574,
        116582,
        116588,
        116602,
        116654,
        116694,
        116714,
        116762,
        116782,
        116786,
        116788,
        116814,
        116828,
        116834,
        116836,
        116840,
        116854,
        116878,
        116892,
        116920,
        116930,
        116936,
        116944,
        116958,
        116966,
        116972,
        116986,
        117006,
        117048,
        117104,
        117118,
        117122,
        117124,
        117136,
        117150,
        117152,
        117180,
        117190,
        117196,
        117208,
        117230,
        117234,
        117236,
        117304,
        117360,
        117374,
        117472,
        117500,
        117506,
        117508,
        117512,
        117520,
        117536,
        117564,
        117568,
        117624,
        117638,
        117644,
        117656,
        117680,
        117694,
        117710,
        117724,
        117730,
        117732,
        117736,
        117750,
        117782,
        117798,
        117804,
        117818,
        117830,
        117848,
        117874,
        117876,
        117894,
        117936,
        117950,
        117966,
        117986,
        117988,
        117992,
        118022,
        118028,
        118040,
        118064,
        118078,
        118112,
        118140,
        118172,
        118210,
        118212,
        118216,
        118224,
        118238,
        118246,
        118266,
        118306,
        118312,
        118338,
        118352,
        118366,
        118374,
        118394,
        118402,
        118404,
        118408,
        118416,
        118430,
        118432,
        118460,
        118476,
        118514,
        118516,
        118574,
        118578,
        118580,
        118606,
        118620,
        118626,
        118628,
        118632,
        118678,
        118694,
        118700,
        118730,
        118738,
        118740,
        118830,
        118834,
        118836,
        118862,
        118876,
        118882,
        118884,
        118888,
        118902,
        118926,
        118940,
        118968,
        118978,
        118980,
        118984,
        118992,
        119006,
        119014,
        119020,
        119034,
        119068,
        119096,
        119152,
        119166,
        119170,
        119172,
        119176,
        119184,
        119198,
        119200,
        119228,
        119238,
        119244,
        119256,
        119278,
        119282,
        119284,
        119324,
        119352,
        119408,
        119422,
        119520,
        119548,
        119554,
        119556,
        119560,
        119568,
        119582,
        119584,
        119612,
        119616,
        119672,
        119686,
        119692,
        119704,
        119728,
        119742,
        119758,
        119772,
        119778,
        119780,
        119784,
        119798,
        119920,
        119934,
        120032,
        120060,
        120256,
        120312,
        120324,
        120328,
        120336,
        120352,
        120384,
        120440,
        120560,
        120582,
        120588,
        120600,
        120624,
        120638,
        120672,
        120700,
        120718,
        120732,
        120760,
        120770,
        120772,
        120776,
        120784,
        120798,
        120806,
        120812,
        120870,
        120876,
        120890,
        120902,
        120908,
        120920,
        120946,
        120948,
        120966,
        120972,
        120984,
        121008,
        121022,
        121038,
        121058,
        121060,
        121064,
        121078,
        121100,
        121112,
        121136,
        121150,
        121184,
        121212,
        121244,
        121282,
        121284,
        121288,
        121296,
        121318,
        121338,
        121356,
        121368,
        121392,
        121406,
        121440,
        121468,
        121536,
        121592,
        121656,
        121730,
        121732,
        121736,
        121744,
        121758,
        121760,
        121804,
        121842,
        121844,
        121890,
        121922,
        121924,
        121928,
        121936,
        121950,
        121958,
        121978,
        121986,
        121988,
        121992,
        122e3,
        122014,
        122016,
        122044,
        122060,
        122098,
        122100,
        122116,
        122120,
        122128,
        122142,
        122144,
        122172,
        122176,
        122232,
        122246,
        122264,
        122318,
        122338,
        122340,
        122344,
        122414,
        122418,
        122420,
        122446,
        122460,
        122466,
        122468,
        122472,
        122510,
        122524,
        122552,
        122562,
        122564,
        122568,
        122576,
        122598,
        122618,
        122646,
        122662,
        122668,
        122694,
        122700,
        122712,
        122738,
        122740,
        122762,
        122770,
        122772,
        122786,
        122788,
        122792,
        123018,
        123026,
        123028,
        123042,
        123044,
        123048,
        123062,
        123098,
        123146,
        123154,
        123156,
        123170,
        123172,
        123176,
        123190,
        123202,
        123204,
        123208,
        123216,
        123238,
        123244,
        123258,
        123290,
        123314,
        123316,
        123402,
        123410,
        123412,
        123426,
        123428,
        123432,
        123446,
        123458,
        123464,
        123472,
        123486,
        123494,
        123500,
        123514,
        123522,
        123524,
        123528,
        123536,
        123552,
        123580,
        123590,
        123596,
        123608,
        123630,
        123634,
        123636,
        123674,
        123698,
        123700,
        123740,
        123746,
        123748,
        123752,
        123834,
        123914,
        123922,
        123924,
        123938,
        123944,
        123958,
        123970,
        123976,
        123984,
        123998,
        124006,
        124012,
        124026,
        124034,
        124036,
        124048,
        124062,
        124064,
        124092,
        124102,
        124108,
        124120,
        124142,
        124146,
        124148,
        124162,
        124164,
        124168,
        124176,
        124190,
        124192,
        124220,
        124224,
        124280,
        124294,
        124300,
        124312,
        124336,
        124350,
        124366,
        124380,
        124386,
        124388,
        124392,
        124406,
        124442,
        124462,
        124466,
        124468,
        124494,
        124508,
        124514,
        124520,
        124558,
        124572,
        124600,
        124610,
        124612,
        124616,
        124624,
        124646,
        124666,
        124694,
        124710,
        124716,
        124730,
        124742,
        124748,
        124760,
        124786,
        124788,
        124818,
        124820,
        124834,
        124836,
        124840,
        124854,
        124946,
        124948,
        124962,
        124964,
        124968,
        124982,
        124994,
        124996,
        125e3,
        125008,
        125022,
        125030,
        125036,
        125050,
        125058,
        125060,
        125064,
        125072,
        125086,
        125088,
        125116,
        125126,
        125132,
        125144,
        125166,
        125170,
        125172,
        125186,
        125188,
        125192,
        125200,
        125216,
        125244,
        125248,
        125304,
        125318,
        125324,
        125336,
        125360,
        125374,
        125390,
        125404,
        125410,
        125412,
        125416,
        125430,
        125444,
        125448,
        125456,
        125472,
        125504,
        125560,
        125680,
        125702,
        125708,
        125720,
        125744,
        125758,
        125792,
        125820,
        125838,
        125852,
        125880,
        125890,
        125892,
        125896,
        125904,
        125918,
        125926,
        125932,
        125978,
        125998,
        126002,
        126004,
        126030,
        126044,
        126050,
        126052,
        126056,
        126094,
        126108,
        126136,
        126146,
        126148,
        126152,
        126160,
        126182,
        126202,
        126222,
        126236,
        126264,
        126320,
        126334,
        126338,
        126340,
        126344,
        126352,
        126366,
        126368,
        126412,
        126450,
        126452,
        126486,
        126502,
        126508,
        126522,
        126534,
        126540,
        126552,
        126574,
        126578,
        126580,
        126598,
        126604,
        126616,
        126640,
        126654,
        126670,
        126684,
        126690,
        126692,
        126696,
        126738,
        126754,
        126756,
        126760,
        126774,
        126786,
        126788,
        126792,
        126800,
        126814,
        126822,
        126828,
        126842,
        126894,
        126898,
        126900,
        126934,
        127126,
        127142,
        127148,
        127162,
        127178,
        127186,
        127188,
        127254,
        127270,
        127276,
        127290,
        127302,
        127308,
        127320,
        127342,
        127346,
        127348,
        127370,
        127378,
        127380,
        127394,
        127396,
        127400,
        127450,
        127510,
        127526,
        127532,
        127546,
        127558,
        127576,
        127598,
        127602,
        127604,
        127622,
        127628,
        127640,
        127664,
        127678,
        127694,
        127708,
        127714,
        127716,
        127720,
        127734,
        127754,
        127762,
        127764,
        127778,
        127784,
        127810,
        127812,
        127816,
        127824,
        127838,
        127846,
        127866,
        127898,
        127918,
        127922,
        127924,
        128022,
        128038,
        128044,
        128058,
        128070,
        128076,
        128088,
        128110,
        128114,
        128116,
        128134,
        128140,
        128152,
        128176,
        128190,
        128206,
        128220,
        128226,
        128228,
        128232,
        128246,
        128262,
        128268,
        128280,
        128304,
        128318,
        128352,
        128380,
        128398,
        128412,
        128440,
        128450,
        128452,
        128456,
        128464,
        128478,
        128486,
        128492,
        128506,
        128522,
        128530,
        128532,
        128546,
        128548,
        128552,
        128566,
        128578,
        128580,
        128584,
        128592,
        128606,
        128614,
        128634,
        128642,
        128644,
        128648,
        128656,
        128670,
        128672,
        128700,
        128716,
        128754,
        128756,
        128794,
        128814,
        128818,
        128820,
        128846,
        128860,
        128866,
        128868,
        128872,
        128886,
        128918,
        128934,
        128940,
        128954,
        128978,
        128980,
        129178,
        129198,
        129202,
        129204,
        129238,
        129258,
        129306,
        129326,
        129330,
        129332,
        129358,
        129372,
        129378,
        129380,
        129384,
        129398,
        129430,
        129446,
        129452,
        129466,
        129482,
        129490,
        129492,
        129562,
        129582,
        129586,
        129588,
        129614,
        129628,
        129634,
        129636,
        129640,
        129654,
        129678,
        129692,
        129720,
        129730,
        129732,
        129736,
        129744,
        129758,
        129766,
        129772,
        129814,
        129830,
        129836,
        129850,
        129862,
        129868,
        129880,
        129902,
        129906,
        129908,
        129930,
        129938,
        129940,
        129954,
        129956,
        129960,
        129974,
        130010
      ]);
      PDF417Common.CODEWORD_TABLE = Int32Array.from([
        2627,
        1819,
        2622,
        2621,
        1813,
        1812,
        2729,
        2724,
        2723,
        2779,
        2774,
        2773,
        902,
        896,
        908,
        868,
        865,
        861,
        859,
        2511,
        873,
        871,
        1780,
        835,
        2493,
        825,
        2491,
        842,
        837,
        844,
        1764,
        1762,
        811,
        810,
        809,
        2483,
        807,
        2482,
        806,
        2480,
        815,
        814,
        813,
        812,
        2484,
        817,
        816,
        1745,
        1744,
        1742,
        1746,
        2655,
        2637,
        2635,
        2626,
        2625,
        2623,
        2628,
        1820,
        2752,
        2739,
        2737,
        2728,
        2727,
        2725,
        2730,
        2785,
        2783,
        2778,
        2777,
        2775,
        2780,
        787,
        781,
        747,
        739,
        736,
        2413,
        754,
        752,
        1719,
        692,
        689,
        681,
        2371,
        678,
        2369,
        700,
        697,
        694,
        703,
        1688,
        1686,
        642,
        638,
        2343,
        631,
        2341,
        627,
        2338,
        651,
        646,
        643,
        2345,
        654,
        652,
        1652,
        1650,
        1647,
        1654,
        601,
        599,
        2322,
        596,
        2321,
        594,
        2319,
        2317,
        611,
        610,
        608,
        606,
        2324,
        603,
        2323,
        615,
        614,
        612,
        1617,
        1616,
        1614,
        1612,
        616,
        1619,
        1618,
        2575,
        2538,
        2536,
        905,
        901,
        898,
        909,
        2509,
        2507,
        2504,
        870,
        867,
        864,
        860,
        2512,
        875,
        872,
        1781,
        2490,
        2489,
        2487,
        2485,
        1748,
        836,
        834,
        832,
        830,
        2494,
        827,
        2492,
        843,
        841,
        839,
        845,
        1765,
        1763,
        2701,
        2676,
        2674,
        2653,
        2648,
        2656,
        2634,
        2633,
        2631,
        2629,
        1821,
        2638,
        2636,
        2770,
        2763,
        2761,
        2750,
        2745,
        2753,
        2736,
        2735,
        2733,
        2731,
        1848,
        2740,
        2738,
        2786,
        2784,
        591,
        588,
        576,
        569,
        566,
        2296,
        1590,
        537,
        534,
        526,
        2276,
        522,
        2274,
        545,
        542,
        539,
        548,
        1572,
        1570,
        481,
        2245,
        466,
        2242,
        462,
        2239,
        492,
        485,
        482,
        2249,
        496,
        494,
        1534,
        1531,
        1528,
        1538,
        413,
        2196,
        406,
        2191,
        2188,
        425,
        419,
        2202,
        415,
        2199,
        432,
        430,
        427,
        1472,
        1467,
        1464,
        433,
        1476,
        1474,
        368,
        367,
        2160,
        365,
        2159,
        362,
        2157,
        2155,
        2152,
        378,
        377,
        375,
        2166,
        372,
        2165,
        369,
        2162,
        383,
        381,
        379,
        2168,
        1419,
        1418,
        1416,
        1414,
        385,
        1411,
        384,
        1423,
        1422,
        1420,
        1424,
        2461,
        802,
        2441,
        2439,
        790,
        786,
        783,
        794,
        2409,
        2406,
        2403,
        750,
        742,
        738,
        2414,
        756,
        753,
        1720,
        2367,
        2365,
        2362,
        2359,
        1663,
        693,
        691,
        684,
        2373,
        680,
        2370,
        702,
        699,
        696,
        704,
        1690,
        1687,
        2337,
        2336,
        2334,
        2332,
        1624,
        2329,
        1622,
        640,
        637,
        2344,
        634,
        2342,
        630,
        2340,
        650,
        648,
        645,
        2346,
        655,
        653,
        1653,
        1651,
        1649,
        1655,
        2612,
        2597,
        2595,
        2571,
        2568,
        2565,
        2576,
        2534,
        2529,
        2526,
        1787,
        2540,
        2537,
        907,
        904,
        900,
        910,
        2503,
        2502,
        2500,
        2498,
        1768,
        2495,
        1767,
        2510,
        2508,
        2506,
        869,
        866,
        863,
        2513,
        876,
        874,
        1782,
        2720,
        2713,
        2711,
        2697,
        2694,
        2691,
        2702,
        2672,
        2670,
        2664,
        1828,
        2678,
        2675,
        2647,
        2646,
        2644,
        2642,
        1823,
        2639,
        1822,
        2654,
        2652,
        2650,
        2657,
        2771,
        1855,
        2765,
        2762,
        1850,
        1849,
        2751,
        2749,
        2747,
        2754,
        353,
        2148,
        344,
        342,
        336,
        2142,
        332,
        2140,
        345,
        1375,
        1373,
        306,
        2130,
        299,
        2128,
        295,
        2125,
        319,
        314,
        311,
        2132,
        1354,
        1352,
        1349,
        1356,
        262,
        257,
        2101,
        253,
        2096,
        2093,
        274,
        273,
        267,
        2107,
        263,
        2104,
        280,
        278,
        275,
        1316,
        1311,
        1308,
        1320,
        1318,
        2052,
        202,
        2050,
        2044,
        2040,
        219,
        2063,
        212,
        2060,
        208,
        2055,
        224,
        221,
        2066,
        1260,
        1258,
        1252,
        231,
        1248,
        229,
        1266,
        1264,
        1261,
        1268,
        155,
        1998,
        153,
        1996,
        1994,
        1991,
        1988,
        165,
        164,
        2007,
        162,
        2006,
        159,
        2003,
        2e3,
        172,
        171,
        169,
        2012,
        166,
        2010,
        1186,
        1184,
        1182,
        1179,
        175,
        1176,
        173,
        1192,
        1191,
        1189,
        1187,
        176,
        1194,
        1193,
        2313,
        2307,
        2305,
        592,
        589,
        2294,
        2292,
        2289,
        578,
        572,
        568,
        2297,
        580,
        1591,
        2272,
        2267,
        2264,
        1547,
        538,
        536,
        529,
        2278,
        525,
        2275,
        547,
        544,
        541,
        1574,
        1571,
        2237,
        2235,
        2229,
        1493,
        2225,
        1489,
        478,
        2247,
        470,
        2244,
        465,
        2241,
        493,
        488,
        484,
        2250,
        498,
        495,
        1536,
        1533,
        1530,
        1539,
        2187,
        2186,
        2184,
        2182,
        1432,
        2179,
        1430,
        2176,
        1427,
        414,
        412,
        2197,
        409,
        2195,
        405,
        2193,
        2190,
        426,
        424,
        421,
        2203,
        418,
        2201,
        431,
        429,
        1473,
        1471,
        1469,
        1466,
        434,
        1477,
        1475,
        2478,
        2472,
        2470,
        2459,
        2457,
        2454,
        2462,
        803,
        2437,
        2432,
        2429,
        1726,
        2443,
        2440,
        792,
        789,
        785,
        2401,
        2399,
        2393,
        1702,
        2389,
        1699,
        2411,
        2408,
        2405,
        745,
        741,
        2415,
        758,
        755,
        1721,
        2358,
        2357,
        2355,
        2353,
        1661,
        2350,
        1660,
        2347,
        1657,
        2368,
        2366,
        2364,
        2361,
        1666,
        690,
        687,
        2374,
        683,
        2372,
        701,
        698,
        705,
        1691,
        1689,
        2619,
        2617,
        2610,
        2608,
        2605,
        2613,
        2593,
        2588,
        2585,
        1803,
        2599,
        2596,
        2563,
        2561,
        2555,
        1797,
        2551,
        1795,
        2573,
        2570,
        2567,
        2577,
        2525,
        2524,
        2522,
        2520,
        1786,
        2517,
        1785,
        2514,
        1783,
        2535,
        2533,
        2531,
        2528,
        1788,
        2541,
        2539,
        906,
        903,
        911,
        2721,
        1844,
        2715,
        2712,
        1838,
        1836,
        2699,
        2696,
        2693,
        2703,
        1827,
        1826,
        1824,
        2673,
        2671,
        2669,
        2666,
        1829,
        2679,
        2677,
        1858,
        1857,
        2772,
        1854,
        1853,
        1851,
        1856,
        2766,
        2764,
        143,
        1987,
        139,
        1986,
        135,
        133,
        131,
        1984,
        128,
        1983,
        125,
        1981,
        138,
        137,
        136,
        1985,
        1133,
        1132,
        1130,
        112,
        110,
        1974,
        107,
        1973,
        104,
        1971,
        1969,
        122,
        121,
        119,
        117,
        1977,
        114,
        1976,
        124,
        1115,
        1114,
        1112,
        1110,
        1117,
        1116,
        84,
        83,
        1953,
        81,
        1952,
        78,
        1950,
        1948,
        1945,
        94,
        93,
        91,
        1959,
        88,
        1958,
        85,
        1955,
        99,
        97,
        95,
        1961,
        1086,
        1085,
        1083,
        1081,
        1078,
        100,
        1090,
        1089,
        1087,
        1091,
        49,
        47,
        1917,
        44,
        1915,
        1913,
        1910,
        1907,
        59,
        1926,
        56,
        1925,
        53,
        1922,
        1919,
        66,
        64,
        1931,
        61,
        1929,
        1042,
        1040,
        1038,
        71,
        1035,
        70,
        1032,
        68,
        1048,
        1047,
        1045,
        1043,
        1050,
        1049,
        12,
        10,
        1869,
        1867,
        1864,
        1861,
        21,
        1880,
        19,
        1877,
        1874,
        1871,
        28,
        1888,
        25,
        1886,
        22,
        1883,
        982,
        980,
        977,
        974,
        32,
        30,
        991,
        989,
        987,
        984,
        34,
        995,
        994,
        992,
        2151,
        2150,
        2147,
        2146,
        2144,
        356,
        355,
        354,
        2149,
        2139,
        2138,
        2136,
        2134,
        1359,
        343,
        341,
        338,
        2143,
        335,
        2141,
        348,
        347,
        346,
        1376,
        1374,
        2124,
        2123,
        2121,
        2119,
        1326,
        2116,
        1324,
        310,
        308,
        305,
        2131,
        302,
        2129,
        298,
        2127,
        320,
        318,
        316,
        313,
        2133,
        322,
        321,
        1355,
        1353,
        1351,
        1357,
        2092,
        2091,
        2089,
        2087,
        1276,
        2084,
        1274,
        2081,
        1271,
        259,
        2102,
        256,
        2100,
        252,
        2098,
        2095,
        272,
        269,
        2108,
        266,
        2106,
        281,
        279,
        277,
        1317,
        1315,
        1313,
        1310,
        282,
        1321,
        1319,
        2039,
        2037,
        2035,
        2032,
        1203,
        2029,
        1200,
        1197,
        207,
        2053,
        205,
        2051,
        201,
        2049,
        2046,
        2043,
        220,
        218,
        2064,
        215,
        2062,
        211,
        2059,
        228,
        226,
        223,
        2069,
        1259,
        1257,
        1254,
        232,
        1251,
        230,
        1267,
        1265,
        1263,
        2316,
        2315,
        2312,
        2311,
        2309,
        2314,
        2304,
        2303,
        2301,
        2299,
        1593,
        2308,
        2306,
        590,
        2288,
        2287,
        2285,
        2283,
        1578,
        2280,
        1577,
        2295,
        2293,
        2291,
        579,
        577,
        574,
        571,
        2298,
        582,
        581,
        1592,
        2263,
        2262,
        2260,
        2258,
        1545,
        2255,
        1544,
        2252,
        1541,
        2273,
        2271,
        2269,
        2266,
        1550,
        535,
        532,
        2279,
        528,
        2277,
        546,
        543,
        549,
        1575,
        1573,
        2224,
        2222,
        2220,
        1486,
        2217,
        1485,
        2214,
        1482,
        1479,
        2238,
        2236,
        2234,
        2231,
        1496,
        2228,
        1492,
        480,
        477,
        2248,
        473,
        2246,
        469,
        2243,
        490,
        487,
        2251,
        497,
        1537,
        1535,
        1532,
        2477,
        2476,
        2474,
        2479,
        2469,
        2468,
        2466,
        2464,
        1730,
        2473,
        2471,
        2453,
        2452,
        2450,
        2448,
        1729,
        2445,
        1728,
        2460,
        2458,
        2456,
        2463,
        805,
        804,
        2428,
        2427,
        2425,
        2423,
        1725,
        2420,
        1724,
        2417,
        1722,
        2438,
        2436,
        2434,
        2431,
        1727,
        2444,
        2442,
        793,
        791,
        788,
        795,
        2388,
        2386,
        2384,
        1697,
        2381,
        1696,
        2378,
        1694,
        1692,
        2402,
        2400,
        2398,
        2395,
        1703,
        2392,
        1701,
        2412,
        2410,
        2407,
        751,
        748,
        744,
        2416,
        759,
        757,
        1807,
        2620,
        2618,
        1806,
        1805,
        2611,
        2609,
        2607,
        2614,
        1802,
        1801,
        1799,
        2594,
        2592,
        2590,
        2587,
        1804,
        2600,
        2598,
        1794,
        1793,
        1791,
        1789,
        2564,
        2562,
        2560,
        2557,
        1798,
        2554,
        1796,
        2574,
        2572,
        2569,
        2578,
        1847,
        1846,
        2722,
        1843,
        1842,
        1840,
        1845,
        2716,
        2714,
        1835,
        1834,
        1832,
        1830,
        1839,
        1837,
        2700,
        2698,
        2695,
        2704,
        1817,
        1811,
        1810,
        897,
        862,
        1777,
        829,
        826,
        838,
        1760,
        1758,
        808,
        2481,
        1741,
        1740,
        1738,
        1743,
        2624,
        1818,
        2726,
        2776,
        782,
        740,
        737,
        1715,
        686,
        679,
        695,
        1682,
        1680,
        639,
        628,
        2339,
        647,
        644,
        1645,
        1643,
        1640,
        1648,
        602,
        600,
        597,
        595,
        2320,
        593,
        2318,
        609,
        607,
        604,
        1611,
        1610,
        1608,
        1606,
        613,
        1615,
        1613,
        2328,
        926,
        924,
        892,
        886,
        899,
        857,
        850,
        2505,
        1778,
        824,
        823,
        821,
        819,
        2488,
        818,
        2486,
        833,
        831,
        828,
        840,
        1761,
        1759,
        2649,
        2632,
        2630,
        2746,
        2734,
        2732,
        2782,
        2781,
        570,
        567,
        1587,
        531,
        527,
        523,
        540,
        1566,
        1564,
        476,
        467,
        463,
        2240,
        486,
        483,
        1524,
        1521,
        1518,
        1529,
        411,
        403,
        2192,
        399,
        2189,
        423,
        416,
        1462,
        1457,
        1454,
        428,
        1468,
        1465,
        2210,
        366,
        363,
        2158,
        360,
        2156,
        357,
        2153,
        376,
        373,
        370,
        2163,
        1410,
        1409,
        1407,
        1405,
        382,
        1402,
        380,
        1417,
        1415,
        1412,
        1421,
        2175,
        2174,
        777,
        774,
        771,
        784,
        732,
        725,
        722,
        2404,
        743,
        1716,
        676,
        674,
        668,
        2363,
        665,
        2360,
        685,
        1684,
        1681,
        626,
        624,
        622,
        2335,
        620,
        2333,
        617,
        2330,
        641,
        635,
        649,
        1646,
        1644,
        1642,
        2566,
        928,
        925,
        2530,
        2527,
        894,
        891,
        888,
        2501,
        2499,
        2496,
        858,
        856,
        854,
        851,
        1779,
        2692,
        2668,
        2665,
        2645,
        2643,
        2640,
        2651,
        2768,
        2759,
        2757,
        2744,
        2743,
        2741,
        2748,
        352,
        1382,
        340,
        337,
        333,
        1371,
        1369,
        307,
        300,
        296,
        2126,
        315,
        312,
        1347,
        1342,
        1350,
        261,
        258,
        250,
        2097,
        246,
        2094,
        271,
        268,
        264,
        1306,
        1301,
        1298,
        276,
        1312,
        1309,
        2115,
        203,
        2048,
        195,
        2045,
        191,
        2041,
        213,
        209,
        2056,
        1246,
        1244,
        1238,
        225,
        1234,
        222,
        1256,
        1253,
        1249,
        1262,
        2080,
        2079,
        154,
        1997,
        150,
        1995,
        147,
        1992,
        1989,
        163,
        160,
        2004,
        156,
        2001,
        1175,
        1174,
        1172,
        1170,
        1167,
        170,
        1164,
        167,
        1185,
        1183,
        1180,
        1177,
        174,
        1190,
        1188,
        2025,
        2024,
        2022,
        587,
        586,
        564,
        559,
        556,
        2290,
        573,
        1588,
        520,
        518,
        512,
        2268,
        508,
        2265,
        530,
        1568,
        1565,
        461,
        457,
        2233,
        450,
        2230,
        446,
        2226,
        479,
        471,
        489,
        1526,
        1523,
        1520,
        397,
        395,
        2185,
        392,
        2183,
        389,
        2180,
        2177,
        410,
        2194,
        402,
        422,
        1463,
        1461,
        1459,
        1456,
        1470,
        2455,
        799,
        2433,
        2430,
        779,
        776,
        773,
        2397,
        2394,
        2390,
        734,
        728,
        724,
        746,
        1717,
        2356,
        2354,
        2351,
        2348,
        1658,
        677,
        675,
        673,
        670,
        667,
        688,
        1685,
        1683,
        2606,
        2589,
        2586,
        2559,
        2556,
        2552,
        927,
        2523,
        2521,
        2518,
        2515,
        1784,
        2532,
        895,
        893,
        890,
        2718,
        2709,
        2707,
        2689,
        2687,
        2684,
        2663,
        2662,
        2660,
        2658,
        1825,
        2667,
        2769,
        1852,
        2760,
        2758,
        142,
        141,
        1139,
        1138,
        134,
        132,
        129,
        126,
        1982,
        1129,
        1128,
        1126,
        1131,
        113,
        111,
        108,
        105,
        1972,
        101,
        1970,
        120,
        118,
        115,
        1109,
        1108,
        1106,
        1104,
        123,
        1113,
        1111,
        82,
        79,
        1951,
        75,
        1949,
        72,
        1946,
        92,
        89,
        86,
        1956,
        1077,
        1076,
        1074,
        1072,
        98,
        1069,
        96,
        1084,
        1082,
        1079,
        1088,
        1968,
        1967,
        48,
        45,
        1916,
        42,
        1914,
        39,
        1911,
        1908,
        60,
        57,
        54,
        1923,
        50,
        1920,
        1031,
        1030,
        1028,
        1026,
        67,
        1023,
        65,
        1020,
        62,
        1041,
        1039,
        1036,
        1033,
        69,
        1046,
        1044,
        1944,
        1943,
        1941,
        11,
        9,
        1868,
        7,
        1865,
        1862,
        1859,
        20,
        1878,
        16,
        1875,
        13,
        1872,
        970,
        968,
        966,
        963,
        29,
        960,
        26,
        23,
        983,
        981,
        978,
        975,
        33,
        971,
        31,
        990,
        988,
        985,
        1906,
        1904,
        1902,
        993,
        351,
        2145,
        1383,
        331,
        330,
        328,
        326,
        2137,
        323,
        2135,
        339,
        1372,
        1370,
        294,
        293,
        291,
        289,
        2122,
        286,
        2120,
        283,
        2117,
        309,
        303,
        317,
        1348,
        1346,
        1344,
        245,
        244,
        242,
        2090,
        239,
        2088,
        236,
        2085,
        2082,
        260,
        2099,
        249,
        270,
        1307,
        1305,
        1303,
        1300,
        1314,
        189,
        2038,
        186,
        2036,
        183,
        2033,
        2030,
        2026,
        206,
        198,
        2047,
        194,
        216,
        1247,
        1245,
        1243,
        1240,
        227,
        1237,
        1255,
        2310,
        2302,
        2300,
        2286,
        2284,
        2281,
        565,
        563,
        561,
        558,
        575,
        1589,
        2261,
        2259,
        2256,
        2253,
        1542,
        521,
        519,
        517,
        514,
        2270,
        511,
        533,
        1569,
        1567,
        2223,
        2221,
        2218,
        2215,
        1483,
        2211,
        1480,
        459,
        456,
        453,
        2232,
        449,
        474,
        491,
        1527,
        1525,
        1522,
        2475,
        2467,
        2465,
        2451,
        2449,
        2446,
        801,
        800,
        2426,
        2424,
        2421,
        2418,
        1723,
        2435,
        780,
        778,
        775,
        2387,
        2385,
        2382,
        2379,
        1695,
        2375,
        1693,
        2396,
        735,
        733,
        730,
        727,
        749,
        1718,
        2616,
        2615,
        2604,
        2603,
        2601,
        2584,
        2583,
        2581,
        2579,
        1800,
        2591,
        2550,
        2549,
        2547,
        2545,
        1792,
        2542,
        1790,
        2558,
        929,
        2719,
        1841,
        2710,
        2708,
        1833,
        1831,
        2690,
        2688,
        2686,
        1815,
        1809,
        1808,
        1774,
        1756,
        1754,
        1737,
        1736,
        1734,
        1739,
        1816,
        1711,
        1676,
        1674,
        633,
        629,
        1638,
        1636,
        1633,
        1641,
        598,
        1605,
        1604,
        1602,
        1600,
        605,
        1609,
        1607,
        2327,
        887,
        853,
        1775,
        822,
        820,
        1757,
        1755,
        1584,
        524,
        1560,
        1558,
        468,
        464,
        1514,
        1511,
        1508,
        1519,
        408,
        404,
        400,
        1452,
        1447,
        1444,
        417,
        1458,
        1455,
        2208,
        364,
        361,
        358,
        2154,
        1401,
        1400,
        1398,
        1396,
        374,
        1393,
        371,
        1408,
        1406,
        1403,
        1413,
        2173,
        2172,
        772,
        726,
        723,
        1712,
        672,
        669,
        666,
        682,
        1678,
        1675,
        625,
        623,
        621,
        618,
        2331,
        636,
        632,
        1639,
        1637,
        1635,
        920,
        918,
        884,
        880,
        889,
        849,
        848,
        847,
        846,
        2497,
        855,
        852,
        1776,
        2641,
        2742,
        2787,
        1380,
        334,
        1367,
        1365,
        301,
        297,
        1340,
        1338,
        1335,
        1343,
        255,
        251,
        247,
        1296,
        1291,
        1288,
        265,
        1302,
        1299,
        2113,
        204,
        196,
        192,
        2042,
        1232,
        1230,
        1224,
        214,
        1220,
        210,
        1242,
        1239,
        1235,
        1250,
        2077,
        2075,
        151,
        148,
        1993,
        144,
        1990,
        1163,
        1162,
        1160,
        1158,
        1155,
        161,
        1152,
        157,
        1173,
        1171,
        1168,
        1165,
        168,
        1181,
        1178,
        2021,
        2020,
        2018,
        2023,
        585,
        560,
        557,
        1585,
        516,
        509,
        1562,
        1559,
        458,
        447,
        2227,
        472,
        1516,
        1513,
        1510,
        398,
        396,
        393,
        390,
        2181,
        386,
        2178,
        407,
        1453,
        1451,
        1449,
        1446,
        420,
        1460,
        2209,
        769,
        764,
        720,
        712,
        2391,
        729,
        1713,
        664,
        663,
        661,
        659,
        2352,
        656,
        2349,
        671,
        1679,
        1677,
        2553,
        922,
        919,
        2519,
        2516,
        885,
        883,
        881,
        2685,
        2661,
        2659,
        2767,
        2756,
        2755,
        140,
        1137,
        1136,
        130,
        127,
        1125,
        1124,
        1122,
        1127,
        109,
        106,
        102,
        1103,
        1102,
        1100,
        1098,
        116,
        1107,
        1105,
        1980,
        80,
        76,
        73,
        1947,
        1068,
        1067,
        1065,
        1063,
        90,
        1060,
        87,
        1075,
        1073,
        1070,
        1080,
        1966,
        1965,
        46,
        43,
        40,
        1912,
        36,
        1909,
        1019,
        1018,
        1016,
        1014,
        58,
        1011,
        55,
        1008,
        51,
        1029,
        1027,
        1024,
        1021,
        63,
        1037,
        1034,
        1940,
        1939,
        1937,
        1942,
        8,
        1866,
        4,
        1863,
        1,
        1860,
        956,
        954,
        952,
        949,
        946,
        17,
        14,
        969,
        967,
        964,
        961,
        27,
        957,
        24,
        979,
        976,
        972,
        1901,
        1900,
        1898,
        1896,
        986,
        1905,
        1903,
        350,
        349,
        1381,
        329,
        327,
        324,
        1368,
        1366,
        292,
        290,
        287,
        284,
        2118,
        304,
        1341,
        1339,
        1337,
        1345,
        243,
        240,
        237,
        2086,
        233,
        2083,
        254,
        1297,
        1295,
        1293,
        1290,
        1304,
        2114,
        190,
        187,
        184,
        2034,
        180,
        2031,
        177,
        2027,
        199,
        1233,
        1231,
        1229,
        1226,
        217,
        1223,
        1241,
        2078,
        2076,
        584,
        555,
        554,
        552,
        550,
        2282,
        562,
        1586,
        507,
        506,
        504,
        502,
        2257,
        499,
        2254,
        515,
        1563,
        1561,
        445,
        443,
        441,
        2219,
        438,
        2216,
        435,
        2212,
        460,
        454,
        475,
        1517,
        1515,
        1512,
        2447,
        798,
        797,
        2422,
        2419,
        770,
        768,
        766,
        2383,
        2380,
        2376,
        721,
        719,
        717,
        714,
        731,
        1714,
        2602,
        2582,
        2580,
        2548,
        2546,
        2543,
        923,
        921,
        2717,
        2706,
        2705,
        2683,
        2682,
        2680,
        1771,
        1752,
        1750,
        1733,
        1732,
        1731,
        1735,
        1814,
        1707,
        1670,
        1668,
        1631,
        1629,
        1626,
        1634,
        1599,
        1598,
        1596,
        1594,
        1603,
        1601,
        2326,
        1772,
        1753,
        1751,
        1581,
        1554,
        1552,
        1504,
        1501,
        1498,
        1509,
        1442,
        1437,
        1434,
        401,
        1448,
        1445,
        2206,
        1392,
        1391,
        1389,
        1387,
        1384,
        359,
        1399,
        1397,
        1394,
        1404,
        2171,
        2170,
        1708,
        1672,
        1669,
        619,
        1632,
        1630,
        1628,
        1773,
        1378,
        1363,
        1361,
        1333,
        1328,
        1336,
        1286,
        1281,
        1278,
        248,
        1292,
        1289,
        2111,
        1218,
        1216,
        1210,
        197,
        1206,
        193,
        1228,
        1225,
        1221,
        1236,
        2073,
        2071,
        1151,
        1150,
        1148,
        1146,
        152,
        1143,
        149,
        1140,
        145,
        1161,
        1159,
        1156,
        1153,
        158,
        1169,
        1166,
        2017,
        2016,
        2014,
        2019,
        1582,
        510,
        1556,
        1553,
        452,
        448,
        1506,
        1500,
        394,
        391,
        387,
        1443,
        1441,
        1439,
        1436,
        1450,
        2207,
        765,
        716,
        713,
        1709,
        662,
        660,
        657,
        1673,
        1671,
        916,
        914,
        879,
        878,
        877,
        882,
        1135,
        1134,
        1121,
        1120,
        1118,
        1123,
        1097,
        1096,
        1094,
        1092,
        103,
        1101,
        1099,
        1979,
        1059,
        1058,
        1056,
        1054,
        77,
        1051,
        74,
        1066,
        1064,
        1061,
        1071,
        1964,
        1963,
        1007,
        1006,
        1004,
        1002,
        999,
        41,
        996,
        37,
        1017,
        1015,
        1012,
        1009,
        52,
        1025,
        1022,
        1936,
        1935,
        1933,
        1938,
        942,
        940,
        938,
        935,
        932,
        5,
        2,
        955,
        953,
        950,
        947,
        18,
        943,
        15,
        965,
        962,
        958,
        1895,
        1894,
        1892,
        1890,
        973,
        1899,
        1897,
        1379,
        325,
        1364,
        1362,
        288,
        285,
        1334,
        1332,
        1330,
        241,
        238,
        234,
        1287,
        1285,
        1283,
        1280,
        1294,
        2112,
        188,
        185,
        181,
        178,
        2028,
        1219,
        1217,
        1215,
        1212,
        200,
        1209,
        1227,
        2074,
        2072,
        583,
        553,
        551,
        1583,
        505,
        503,
        500,
        513,
        1557,
        1555,
        444,
        442,
        439,
        436,
        2213,
        455,
        451,
        1507,
        1505,
        1502,
        796,
        763,
        762,
        760,
        767,
        711,
        710,
        708,
        706,
        2377,
        718,
        715,
        1710,
        2544,
        917,
        915,
        2681,
        1627,
        1597,
        1595,
        2325,
        1769,
        1749,
        1747,
        1499,
        1438,
        1435,
        2204,
        1390,
        1388,
        1385,
        1395,
        2169,
        2167,
        1704,
        1665,
        1662,
        1625,
        1623,
        1620,
        1770,
        1329,
        1282,
        1279,
        2109,
        1214,
        1207,
        1222,
        2068,
        2065,
        1149,
        1147,
        1144,
        1141,
        146,
        1157,
        1154,
        2013,
        2011,
        2008,
        2015,
        1579,
        1549,
        1546,
        1495,
        1487,
        1433,
        1431,
        1428,
        1425,
        388,
        1440,
        2205,
        1705,
        658,
        1667,
        1664,
        1119,
        1095,
        1093,
        1978,
        1057,
        1055,
        1052,
        1062,
        1962,
        1960,
        1005,
        1003,
        1e3,
        997,
        38,
        1013,
        1010,
        1932,
        1930,
        1927,
        1934,
        941,
        939,
        936,
        933,
        6,
        930,
        3,
        951,
        948,
        944,
        1889,
        1887,
        1884,
        1881,
        959,
        1893,
        1891,
        35,
        1377,
        1360,
        1358,
        1327,
        1325,
        1322,
        1331,
        1277,
        1275,
        1272,
        1269,
        235,
        1284,
        2110,
        1205,
        1204,
        1201,
        1198,
        182,
        1195,
        179,
        1213,
        2070,
        2067,
        1580,
        501,
        1551,
        1548,
        440,
        437,
        1497,
        1494,
        1490,
        1503,
        761,
        709,
        707,
        1706,
        913,
        912,
        2198,
        1386,
        2164,
        2161,
        1621,
        1766,
        2103,
        1208,
        2058,
        2054,
        1145,
        1142,
        2005,
        2002,
        1999,
        2009,
        1488,
        1429,
        1426,
        2200,
        1698,
        1659,
        1656,
        1975,
        1053,
        1957,
        1954,
        1001,
        998,
        1924,
        1921,
        1918,
        1928,
        937,
        934,
        931,
        1879,
        1876,
        1873,
        1870,
        945,
        1885,
        1882,
        1323,
        1273,
        1270,
        2105,
        1202,
        1199,
        1196,
        1211,
        2061,
        2057,
        1576,
        1543,
        1540,
        1484,
        1481,
        1478,
        1491,
        1700
      ]);
      class PDF417DetectorResult {
        constructor(bits2, points) {
          this.bits = bits2;
          this.points = points;
        }
        getBits() {
          return this.bits;
        }
        getPoints() {
          return this.points;
        }
      }
      class Detector$3 {
        /**
         * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>
         *
         * @param image barcode image to decode
         * @param hints optional hints to detector
         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
         * be found and returned
         * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code
         * @throws NotFoundException if no PDF417 Code can be found
         */
        static detectMultiple(image, hints, multiple) {
          let bitMatrix = image.getBlackMatrix();
          let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
          if (!barcodeCoordinates.length) {
            bitMatrix = bitMatrix.clone();
            bitMatrix.rotate180();
            barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
          }
          return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);
        }
        /**
         * Detects PDF417 codes in an image. Only checks 0 degree rotation
         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
         * be found and returned
         * @param bitMatrix bit matrix to detect barcodes in
         * @return List of ResultPoint arrays containing the coordinates of found barcodes
         */
        static detect(multiple, bitMatrix) {
          const barcodeCoordinates = new Array();
          let row = 0;
          let column = 0;
          let foundBarcodeInRow = false;
          while (row < bitMatrix.getHeight()) {
            const vertices = Detector$3.findVertices(bitMatrix, row, column);
            if (vertices[0] == null && vertices[3] == null) {
              if (!foundBarcodeInRow) {
                break;
              }
              foundBarcodeInRow = false;
              column = 0;
              for (const barcodeCoordinate of barcodeCoordinates) {
                if (barcodeCoordinate[1] != null) {
                  row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
                }
                if (barcodeCoordinate[3] != null) {
                  row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
                }
              }
              row += Detector$3.ROW_STEP;
              continue;
            }
            foundBarcodeInRow = true;
            barcodeCoordinates.push(vertices);
            if (!multiple) {
              break;
            }
            if (vertices[2] != null) {
              column = Math.trunc(vertices[2].getX());
              row = Math.trunc(vertices[2].getY());
            } else {
              column = Math.trunc(vertices[4].getX());
              row = Math.trunc(vertices[4].getY());
            }
          }
          return barcodeCoordinates;
        }
        /**
         * Locate the vertices and the codewords area of a black blob using the Start
         * and Stop patterns as locators.
         *
         * @param matrix the scanned barcode image.
         * @return an array containing the vertices:
         *           vertices[0] x, y top left barcode
         *           vertices[1] x, y bottom left barcode
         *           vertices[2] x, y top right barcode
         *           vertices[3] x, y bottom right barcode
         *           vertices[4] x, y top left codeword area
         *           vertices[5] x, y bottom left codeword area
         *           vertices[6] x, y top right codeword area
         *           vertices[7] x, y bottom right codeword area
         */
        static findVertices(matrix, startRow, startColumn) {
          const height = matrix.getHeight();
          const width = matrix.getWidth();
          const result = new Array(8);
          Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);
          if (result[4] != null) {
            startColumn = Math.trunc(result[4].getX());
            startRow = Math.trunc(result[4].getY());
          }
          Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);
          return result;
        }
        static copyToResult(result, tmpResult, destinationIndexes) {
          for (let i3 = 0; i3 < destinationIndexes.length; i3++) {
            result[destinationIndexes[i3]] = tmpResult[i3];
          }
        }
        static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {
          const result = new Array(4);
          let found = false;
          const counters = new Int32Array(pattern.length);
          for (; startRow < height; startRow += Detector$3.ROW_STEP) {
            let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
            if (loc != null) {
              while (startRow > 0) {
                const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
                if (previousRowLoc != null) {
                  loc = previousRowLoc;
                } else {
                  startRow++;
                  break;
                }
              }
              result[0] = new ResultPoint(loc[0], startRow);
              result[1] = new ResultPoint(loc[1], startRow);
              found = true;
              break;
            }
          }
          let stopRow = startRow + 1;
          if (found) {
            let skippedRowCount = 0;
            let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
            for (; stopRow < height; stopRow++) {
              const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
              if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {
                previousRowLoc = loc;
                skippedRowCount = 0;
              } else {
                if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {
                  break;
                } else {
                  skippedRowCount++;
                }
              }
            }
            stopRow -= skippedRowCount + 1;
            result[2] = new ResultPoint(previousRowLoc[0], stopRow);
            result[3] = new ResultPoint(previousRowLoc[1], stopRow);
          }
          if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {
            Arrays.fill(result, null);
          }
          return result;
        }
        /**
         * @param matrix row of black/white values to search
         * @param column x position to start search
         * @param row y position to start search
         * @param width the number of pixels to search on this row
         * @param pattern pattern of counts of number of black and white pixels that are
         *                 being searched for as a pattern
         * @param counters array of counters, as long as pattern, to re-use
         * @return start/end horizontal offset of guard pattern, as an array of two ints.
         */
        static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {
          Arrays.fillWithin(counters, 0, counters.length, 0);
          let patternStart = column;
          let pixelDrift = 0;
          while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {
            patternStart--;
          }
          let x2 = patternStart;
          let counterPosition = 0;
          let patternLength = pattern.length;
          for (let isWhite = whiteFirst; x2 < width; x2++) {
            let pixel = matrix.get(x2, row);
            if (pixel !== isWhite) {
              counters[counterPosition]++;
            } else {
              if (counterPosition === patternLength - 1) {
                if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                  return new Int32Array([patternStart, x2]);
                }
                patternStart += counters[0] + counters[1];
                System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                counters[counterPosition - 1] = 0;
                counters[counterPosition] = 0;
                counterPosition--;
              } else {
                counterPosition++;
              }
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          if (counterPosition === patternLength - 1 && Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
            return new Int32Array([patternStart, x2 - 1]);
          }
          return null;
        }
        /**
         * Determines how closely a set of observed counts of runs of black/white
         * values matches a given target pattern. This is reported as the ratio of
         * the total variance from the expected pattern proportions across all
         * pattern elements, to the length of the pattern.
         *
         * @param counters observed counters
         * @param pattern expected pattern
         * @param maxIndividualVariance The most any counter can differ before we give up
         * @return ratio of total variance between counters and pattern compared to total pattern size
         */
        static patternMatchVariance(counters, pattern, maxIndividualVariance) {
          let numCounters = counters.length;
          let total = 0;
          let patternLength = 0;
          for (let i3 = 0; i3 < numCounters; i3++) {
            total += counters[i3];
            patternLength += pattern[i3];
          }
          if (total < patternLength) {
            return (
              /*Float.POSITIVE_INFINITY*/
              Infinity
            );
          }
          let unitBarWidth = total / patternLength;
          maxIndividualVariance *= unitBarWidth;
          let totalVariance = 0;
          for (let x2 = 0; x2 < numCounters; x2++) {
            let counter = counters[x2];
            let scaledPattern = pattern[x2] * unitBarWidth;
            let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
            if (variance > maxIndividualVariance) {
              return (
                /*Float.POSITIVE_INFINITY*/
                Infinity
              );
            }
            totalVariance += variance;
          }
          return totalVariance / total;
        }
      }
      Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
      Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
      Detector$3.MAX_AVG_VARIANCE = 0.42;
      Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;
      Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
      Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
      Detector$3.MAX_PIXEL_DRIFT = 3;
      Detector$3.MAX_PATTERN_DRIFT = 5;
      Detector$3.SKIPPED_ROW_COUNT_MAX = 25;
      Detector$3.ROW_STEP = 5;
      Detector$3.BARCODE_MIN_HEIGHT = 10;
      class ModulusPoly {
        constructor(field, coefficients) {
          if (coefficients.length === 0) {
            throw new IllegalArgumentException();
          }
          this.field = field;
          let coefficientsLength = (
            /*int*/
            coefficients.length
          );
          if (coefficientsLength > 1 && coefficients[0] === 0) {
            let firstNonZero = (
              /*int*/
              1
            );
            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
              firstNonZero++;
            }
            if (firstNonZero === coefficientsLength) {
              this.coefficients = new Int32Array([0]);
            } else {
              this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
              System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
            }
          } else {
            this.coefficients = coefficients;
          }
        }
        getCoefficients() {
          return this.coefficients;
        }
        /**
         * @return degree of this polynomial
         */
        getDegree() {
          return this.coefficients.length - 1;
        }
        /**
         * @return true iff this polynomial is the monomial "0"
         */
        isZero() {
          return this.coefficients[0] === 0;
        }
        /**
         * @return coefficient of x^degree term in this polynomial
         */
        getCoefficient(degree) {
          return this.coefficients[this.coefficients.length - 1 - degree];
        }
        /**
         * @return evaluation of this polynomial at a given point
         */
        evaluateAt(a2) {
          if (a2 === 0) {
            return this.getCoefficient(0);
          }
          if (a2 === 1) {
            let sum = (
              /*int*/
              0
            );
            for (let coefficient of this.coefficients) {
              sum = this.field.add(sum, coefficient);
            }
            return sum;
          }
          let result = (
            /*int*/
            this.coefficients[0]
          );
          let size = (
            /*int*/
            this.coefficients.length
          );
          for (let i3 = 1; i3 < size; i3++) {
            result = this.field.add(this.field.multiply(a2, result), this.coefficients[i3]);
          }
          return result;
        }
        add(other) {
          if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
          }
          if (this.isZero()) {
            return other;
          }
          if (other.isZero()) {
            return this;
          }
          let smallerCoefficients = this.coefficients;
          let largerCoefficients = other.coefficients;
          if (smallerCoefficients.length > largerCoefficients.length) {
            let temp = smallerCoefficients;
            smallerCoefficients = largerCoefficients;
            largerCoefficients = temp;
          }
          let sumDiff = new Int32Array(largerCoefficients.length);
          let lengthDiff = (
            /*int*/
            largerCoefficients.length - smallerCoefficients.length
          );
          System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
          for (let i3 = lengthDiff; i3 < largerCoefficients.length; i3++) {
            sumDiff[i3] = this.field.add(smallerCoefficients[i3 - lengthDiff], largerCoefficients[i3]);
          }
          return new ModulusPoly(this.field, sumDiff);
        }
        subtract(other) {
          if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
          }
          if (other.isZero()) {
            return this;
          }
          return this.add(other.negative());
        }
        multiply(other) {
          if (other instanceof ModulusPoly) {
            return this.multiplyOther(other);
          }
          return this.multiplyScalar(other);
        }
        multiplyOther(other) {
          if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
          }
          if (this.isZero() || other.isZero()) {
            return new ModulusPoly(this.field, new Int32Array([0]));
          }
          let aCoefficients = this.coefficients;
          let aLength = (
            /*int*/
            aCoefficients.length
          );
          let bCoefficients = other.coefficients;
          let bLength = (
            /*int*/
            bCoefficients.length
          );
          let product = new Int32Array(aLength + bLength - 1);
          for (let i3 = 0; i3 < aLength; i3++) {
            let aCoeff = (
              /*int*/
              aCoefficients[i3]
            );
            for (let j2 = 0; j2 < bLength; j2++) {
              product[i3 + j2] = this.field.add(product[i3 + j2], this.field.multiply(aCoeff, bCoefficients[j2]));
            }
          }
          return new ModulusPoly(this.field, product);
        }
        negative() {
          let size = (
            /*int*/
            this.coefficients.length
          );
          let negativeCoefficients = new Int32Array(size);
          for (let i3 = 0; i3 < size; i3++) {
            negativeCoefficients[i3] = this.field.subtract(0, this.coefficients[i3]);
          }
          return new ModulusPoly(this.field, negativeCoefficients);
        }
        multiplyScalar(scalar) {
          if (scalar === 0) {
            return new ModulusPoly(this.field, new Int32Array([0]));
          }
          if (scalar === 1) {
            return this;
          }
          let size = (
            /*int*/
            this.coefficients.length
          );
          let product = new Int32Array(size);
          for (let i3 = 0; i3 < size; i3++) {
            product[i3] = this.field.multiply(this.coefficients[i3], scalar);
          }
          return new ModulusPoly(this.field, product);
        }
        multiplyByMonomial(degree, coefficient) {
          if (degree < 0) {
            throw new IllegalArgumentException();
          }
          if (coefficient === 0) {
            return new ModulusPoly(this.field, new Int32Array([0]));
          }
          let size = (
            /*int*/
            this.coefficients.length
          );
          let product = new Int32Array(size + degree);
          for (let i3 = 0; i3 < size; i3++) {
            product[i3] = this.field.multiply(this.coefficients[i3], coefficient);
          }
          return new ModulusPoly(this.field, product);
        }
        /*
          ModulusPoly[] divide(other: ModulusPoly) {
            if (!field.equals(other.field)) {
              throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
            }
            if (other.isZero()) {
              throw new IllegalArgumentException("Divide by 0");
            }
        
            let quotient: ModulusPoly = field.getZero();
            let remainder: ModulusPoly = this;
        
            let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());
            let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);
        
            while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
              let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();
              let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
              let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);
              let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);
              quotient = quotient.add(iterationQuotient);
              remainder = remainder.subtract(term);
            }
        
            return new ModulusPoly[] { quotient, remainder };
          }
          */
        // @Override
        toString() {
          let result = new StringBuilder(
            /*8 * this.getDegree()*/
          );
          for (let degree = this.getDegree(); degree >= 0; degree--) {
            let coefficient = (
              /*int*/
              this.getCoefficient(degree)
            );
            if (coefficient !== 0) {
              if (coefficient < 0) {
                result.append(" - ");
                coefficient = -coefficient;
              } else {
                if (result.length() > 0) {
                  result.append(" + ");
                }
              }
              if (degree === 0 || coefficient !== 1) {
                result.append(coefficient);
              }
              if (degree !== 0) {
                if (degree === 1) {
                  result.append("x");
                } else {
                  result.append("x^");
                  result.append(degree);
                }
              }
            }
          }
          return result.toString();
        }
      }
      class ModulusBase {
        add(a2, b2) {
          return (a2 + b2) % this.modulus;
        }
        subtract(a2, b2) {
          return (this.modulus + a2 - b2) % this.modulus;
        }
        exp(a2) {
          return this.expTable[a2];
        }
        log(a2) {
          if (a2 === 0) {
            throw new IllegalArgumentException();
          }
          return this.logTable[a2];
        }
        inverse(a2) {
          if (a2 === 0) {
            throw new ArithmeticException();
          }
          return this.expTable[this.modulus - this.logTable[a2] - 1];
        }
        multiply(a2, b2) {
          if (a2 === 0 || b2 === 0) {
            return 0;
          }
          return this.expTable[(this.logTable[a2] + this.logTable[b2]) % (this.modulus - 1)];
        }
        getSize() {
          return this.modulus;
        }
        equals(o2) {
          return o2 === this;
        }
      }
      class ModulusGF extends ModulusBase {
        // private /*final*/ modulus: /*int*/ number;
        constructor(modulus, generator) {
          super();
          this.modulus = modulus;
          this.expTable = new Int32Array(modulus);
          this.logTable = new Int32Array(modulus);
          let x2 = (
            /*int*/
            1
          );
          for (let i3 = 0; i3 < modulus; i3++) {
            this.expTable[i3] = x2;
            x2 = x2 * generator % modulus;
          }
          for (let i3 = 0; i3 < modulus - 1; i3++) {
            this.logTable[this.expTable[i3]] = i3;
          }
          this.zero = new ModulusPoly(this, new Int32Array([0]));
          this.one = new ModulusPoly(this, new Int32Array([1]));
        }
        getZero() {
          return this.zero;
        }
        getOne() {
          return this.one;
        }
        buildMonomial(degree, coefficient) {
          if (degree < 0) {
            throw new IllegalArgumentException();
          }
          if (coefficient === 0) {
            return this.zero;
          }
          let coefficients = new Int32Array(degree + 1);
          coefficients[0] = coefficient;
          return new ModulusPoly(this, coefficients);
        }
      }
      ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);
      class ErrorCorrection {
        constructor() {
          this.field = ModulusGF.PDF417_GF;
        }
        /**
         * @param received received codewords
         * @param numECCodewords number of those codewords used for EC
         * @param erasures location of erasures
         * @return number of errors
         * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors
         */
        decode(received, numECCodewords, erasures) {
          let poly = new ModulusPoly(this.field, received);
          let S2 = new Int32Array(numECCodewords);
          let error = false;
          for (let i3 = numECCodewords; i3 > 0; i3--) {
            let evaluation = poly.evaluateAt(this.field.exp(i3));
            S2[numECCodewords - i3] = evaluation;
            if (evaluation !== 0) {
              error = true;
            }
          }
          if (!error) {
            return 0;
          }
          let knownErrors = this.field.getOne();
          if (erasures != null) {
            for (const erasure of erasures) {
              let b2 = this.field.exp(received.length - 1 - erasure);
              let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b2), 1]));
              knownErrors = knownErrors.multiply(term);
            }
          }
          let syndrome = new ModulusPoly(this.field, S2);
          let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
          let sigma = sigmaOmega[0];
          let omega = sigmaOmega[1];
          let errorLocations = this.findErrorLocations(sigma);
          let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
          for (let i3 = 0; i3 < errorLocations.length; i3++) {
            let position = received.length - 1 - this.field.log(errorLocations[i3]);
            if (position < 0) {
              throw ChecksumException.getChecksumInstance();
            }
            received[position] = this.field.subtract(received[position], errorMagnitudes[i3]);
          }
          return errorLocations.length;
        }
        /**
         *
         * @param ModulusPoly
         * @param a
         * @param ModulusPoly
         * @param b
         * @param int
         * @param R
         * @throws ChecksumException
         */
        runEuclideanAlgorithm(a2, b2, R2) {
          if (a2.getDegree() < b2.getDegree()) {
            let temp = a2;
            a2 = b2;
            b2 = temp;
          }
          let rLast = a2;
          let r = b2;
          let tLast = this.field.getZero();
          let t2 = this.field.getOne();
          while (r.getDegree() >= Math.round(R2 / 2)) {
            let rLastLast = rLast;
            let tLastLast = tLast;
            rLast = r;
            tLast = t2;
            if (rLast.isZero()) {
              throw ChecksumException.getChecksumInstance();
            }
            r = rLastLast;
            let q2 = this.field.getZero();
            let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
            let dltInverse = this.field.inverse(denominatorLeadingTerm);
            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
              let degreeDiff = r.getDegree() - rLast.getDegree();
              let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
              q2 = q2.add(this.field.buildMonomial(degreeDiff, scale));
              r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t2 = q2.multiply(tLast).subtract(tLastLast).negative();
          }
          let sigmaTildeAtZero = t2.getCoefficient(0);
          if (sigmaTildeAtZero === 0) {
            throw ChecksumException.getChecksumInstance();
          }
          let inverse = this.field.inverse(sigmaTildeAtZero);
          let sigma = t2.multiply(inverse);
          let omega = r.multiply(inverse);
          return [sigma, omega];
        }
        /**
         *
         * @param errorLocator
         * @throws ChecksumException
         */
        findErrorLocations(errorLocator) {
          let numErrors = errorLocator.getDegree();
          let result = new Int32Array(numErrors);
          let e = 0;
          for (let i3 = 1; i3 < this.field.getSize() && e < numErrors; i3++) {
            if (errorLocator.evaluateAt(i3) === 0) {
              result[e] = this.field.inverse(i3);
              e++;
            }
          }
          if (e !== numErrors) {
            throw ChecksumException.getChecksumInstance();
          }
          return result;
        }
        findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {
          let errorLocatorDegree = errorLocator.getDegree();
          let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
          for (let i3 = 1; i3 <= errorLocatorDegree; i3++) {
            formalDerivativeCoefficients[errorLocatorDegree - i3] = this.field.multiply(i3, errorLocator.getCoefficient(i3));
          }
          let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);
          let s2 = errorLocations.length;
          let result = new Int32Array(s2);
          for (let i3 = 0; i3 < s2; i3++) {
            let xiInverse = this.field.inverse(errorLocations[i3]);
            let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
            let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
            result[i3] = this.field.multiply(numerator, denominator);
          }
          return result;
        }
      }
      class BoundingBox {
        constructor(image, topLeft, bottomLeft, topRight, bottomRight) {
          if (image instanceof BoundingBox) {
            this.constructor_2(image);
          } else {
            this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
          }
        }
        /**
         *
         * @param image
         * @param topLeft
         * @param bottomLeft
         * @param topRight
         * @param bottomRight
         *
         * @throws NotFoundException
         */
        constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {
          const leftUnspecified = topLeft == null || bottomLeft == null;
          const rightUnspecified = topRight == null || bottomRight == null;
          if (leftUnspecified && rightUnspecified) {
            throw new NotFoundException();
          }
          if (leftUnspecified) {
            topLeft = new ResultPoint(0, topRight.getY());
            bottomLeft = new ResultPoint(0, bottomRight.getY());
          } else if (rightUnspecified) {
            topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());
            bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());
          }
          this.image = image;
          this.topLeft = topLeft;
          this.bottomLeft = bottomLeft;
          this.topRight = topRight;
          this.bottomRight = bottomRight;
          this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
          this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
          this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
          this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
        }
        constructor_2(boundingBox) {
          this.image = boundingBox.image;
          this.topLeft = boundingBox.getTopLeft();
          this.bottomLeft = boundingBox.getBottomLeft();
          this.topRight = boundingBox.getTopRight();
          this.bottomRight = boundingBox.getBottomRight();
          this.minX = boundingBox.getMinX();
          this.maxX = boundingBox.getMaxX();
          this.minY = boundingBox.getMinY();
          this.maxY = boundingBox.getMaxY();
        }
        /**
         * @throws NotFoundException
         */
        static merge(leftBox, rightBox) {
          if (leftBox == null) {
            return rightBox;
          }
          if (rightBox == null) {
            return leftBox;
          }
          return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
        }
        /**
         * @throws NotFoundException
         */
        addMissingRows(missingStartRows, missingEndRows, isLeft) {
          let newTopLeft = this.topLeft;
          let newBottomLeft = this.bottomLeft;
          let newTopRight = this.topRight;
          let newBottomRight = this.bottomRight;
          if (missingStartRows > 0) {
            let top = isLeft ? this.topLeft : this.topRight;
            let newMinY = Math.trunc(top.getY() - missingStartRows);
            if (newMinY < 0) {
              newMinY = 0;
            }
            let newTop = new ResultPoint(top.getX(), newMinY);
            if (isLeft) {
              newTopLeft = newTop;
            } else {
              newTopRight = newTop;
            }
          }
          if (missingEndRows > 0) {
            let bottom = isLeft ? this.bottomLeft : this.bottomRight;
            let newMaxY = Math.trunc(bottom.getY() + missingEndRows);
            if (newMaxY >= this.image.getHeight()) {
              newMaxY = this.image.getHeight() - 1;
            }
            let newBottom = new ResultPoint(bottom.getX(), newMaxY);
            if (isLeft) {
              newBottomLeft = newBottom;
            } else {
              newBottomRight = newBottom;
            }
          }
          return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
        }
        getMinX() {
          return this.minX;
        }
        getMaxX() {
          return this.maxX;
        }
        getMinY() {
          return this.minY;
        }
        getMaxY() {
          return this.maxY;
        }
        getTopLeft() {
          return this.topLeft;
        }
        getTopRight() {
          return this.topRight;
        }
        getBottomLeft() {
          return this.bottomLeft;
        }
        getBottomRight() {
          return this.bottomRight;
        }
      }
      class BarcodeMetadata {
        constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
          this.columnCount = columnCount;
          this.errorCorrectionLevel = errorCorrectionLevel;
          this.rowCountUpperPart = rowCountUpperPart;
          this.rowCountLowerPart = rowCountLowerPart;
          this.rowCount = rowCountUpperPart + rowCountLowerPart;
        }
        getColumnCount() {
          return this.columnCount;
        }
        getErrorCorrectionLevel() {
          return this.errorCorrectionLevel;
        }
        getRowCount() {
          return this.rowCount;
        }
        getRowCountUpperPart() {
          return this.rowCountUpperPart;
        }
        getRowCountLowerPart() {
          return this.rowCountLowerPart;
        }
      }
      class Formatter {
        constructor() {
          this.buffer = "";
        }
        /**
         *
         * @see https://stackoverflow.com/a/13439711/4367683
         *
         * @param str
         * @param arr
         */
        static form(str, arr) {
          let i3 = -1;
          function callback(exp, p0, p1, p2, p3, p4) {
            if (exp === "%%")
              return "%";
            if (arr[++i3] === void 0)
              return void 0;
            exp = p2 ? parseInt(p2.substr(1)) : void 0;
            let base = p3 ? parseInt(p3.substr(1)) : void 0;
            let val;
            switch (p4) {
              case "s":
                val = arr[i3];
                break;
              case "c":
                val = arr[i3][0];
                break;
              case "f":
                val = parseFloat(arr[i3]).toFixed(exp);
                break;
              case "p":
                val = parseFloat(arr[i3]).toPrecision(exp);
                break;
              case "e":
                val = parseFloat(arr[i3]).toExponential(exp);
                break;
              case "x":
                val = parseInt(arr[i3]).toString(base ? base : 16);
                break;
              case "d":
                val = parseFloat(parseInt(arr[i3], base ? base : 10).toPrecision(exp)).toFixed(0);
                break;
            }
            val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
            let size = parseInt(p1);
            let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
            while (val.length < size)
              val = p0 !== void 0 ? val + ch : ch + val;
            return val;
          }
          let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
          return str.replace(regex, callback);
        }
        /**
         *
         * @param append The new string to append.
         * @param args Argumets values to be formated.
         */
        format(append, ...args) {
          this.buffer += Formatter.form(append, args);
        }
        /**
         * Returns the Formatter string value.
         */
        toString() {
          return this.buffer;
        }
      }
      class DetectionResultColumn {
        constructor(boundingBox) {
          this.boundingBox = new BoundingBox(boundingBox);
          this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
        }
        /*final*/
        getCodewordNearby(imageRow) {
          let codeword = this.getCodeword(imageRow);
          if (codeword != null) {
            return codeword;
          }
          for (let i3 = 1; i3 < DetectionResultColumn.MAX_NEARBY_DISTANCE; i3++) {
            let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i3;
            if (nearImageRow >= 0) {
              codeword = this.codewords[nearImageRow];
              if (codeword != null) {
                return codeword;
              }
            }
            nearImageRow = this.imageRowToCodewordIndex(imageRow) + i3;
            if (nearImageRow < this.codewords.length) {
              codeword = this.codewords[nearImageRow];
              if (codeword != null) {
                return codeword;
              }
            }
          }
          return null;
        }
        /*final int*/
        imageRowToCodewordIndex(imageRow) {
          return imageRow - this.boundingBox.getMinY();
        }
        /*final void*/
        setCodeword(imageRow, codeword) {
          this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
        }
        /*final*/
        getCodeword(imageRow) {
          return this.codewords[this.imageRowToCodewordIndex(imageRow)];
        }
        /*final*/
        getBoundingBox() {
          return this.boundingBox;
        }
        /*final*/
        getCodewords() {
          return this.codewords;
        }
        // @Override
        toString() {
          const formatter = new Formatter();
          let row = 0;
          for (const codeword of this.codewords) {
            if (codeword == null) {
              formatter.format("%3d:    |   %n", row++);
              continue;
            }
            formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
          }
          return formatter.toString();
        }
      }
      DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;
      class BarcodeValue {
        constructor() {
          this.values = /* @__PURE__ */ new Map();
        }
        /**
         * Add an occurrence of a value
         */
        setValue(value2) {
          value2 = Math.trunc(value2);
          let confidence = this.values.get(value2);
          if (confidence == null) {
            confidence = 0;
          }
          confidence++;
          this.values.set(value2, confidence);
        }
        /**
         * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.
         * @return an array of int, containing the values with the highest occurrence, or null, if no value was set
         */
        getValue() {
          let maxConfidence = -1;
          let result = new Array();
          for (const [key, value2] of this.values.entries()) {
            const entry = {
              getKey: () => key,
              getValue: () => value2
            };
            if (entry.getValue() > maxConfidence) {
              maxConfidence = entry.getValue();
              result = [];
              result.push(entry.getKey());
            } else if (entry.getValue() === maxConfidence) {
              result.push(entry.getKey());
            }
          }
          return PDF417Common.toIntArray(result);
        }
        getConfidence(value2) {
          return this.values.get(value2);
        }
      }
      class DetectionResultRowIndicatorColumn extends DetectionResultColumn {
        constructor(boundingBox, isLeft) {
          super(boundingBox);
          this._isLeft = isLeft;
        }
        setRowNumbers() {
          for (let codeword of this.getCodewords()) {
            if (codeword != null) {
              codeword.setRowNumberAsRowIndicatorColumn();
            }
          }
        }
        // TODO implement properly
        // TODO maybe we should add missing codewords to store the correct row number to make
        // finding row numbers for other columns easier
        // use row height count to make detection of invalid row numbers more reliable
        adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {
          let codewords = this.getCodewords();
          this.setRowNumbers();
          this.removeIncorrectCodewords(codewords, barcodeMetadata);
          let boundingBox = this.getBoundingBox();
          let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
          let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
          let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
          let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
          let barcodeRow = -1;
          let maxRowHeight = 1;
          let currentRowHeight = 0;
          for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            let codeword = codewords[codewordsRow];
            let rowDifference = codeword.getRowNumber() - barcodeRow;
            if (rowDifference === 0) {
              currentRowHeight++;
            } else if (rowDifference === 1) {
              maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
              currentRowHeight = 1;
              barcodeRow = codeword.getRowNumber();
            } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
              codewords[codewordsRow] = null;
            } else {
              let checkedRows;
              if (maxRowHeight > 2) {
                checkedRows = (maxRowHeight - 2) * rowDifference;
              } else {
                checkedRows = rowDifference;
              }
              let closePreviousCodewordFound = checkedRows >= codewordsRow;
              for (let i3 = 1; i3 <= checkedRows && !closePreviousCodewordFound; i3++) {
                closePreviousCodewordFound = codewords[codewordsRow - i3] != null;
              }
              if (closePreviousCodewordFound) {
                codewords[codewordsRow] = null;
              } else {
                barcodeRow = codeword.getRowNumber();
                currentRowHeight = 1;
              }
            }
          }
        }
        getRowHeights() {
          let barcodeMetadata = this.getBarcodeMetadata();
          if (barcodeMetadata == null) {
            return null;
          }
          this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
          let result = new Int32Array(barcodeMetadata.getRowCount());
          for (let codeword of this.getCodewords()) {
            if (codeword != null) {
              let rowNumber = codeword.getRowNumber();
              if (rowNumber >= result.length) {
                continue;
              }
              result[rowNumber]++;
            }
          }
          return result;
        }
        // TODO maybe we should add missing codewords to store the correct row number to make
        // finding row numbers for other columns easier
        // use row height count to make detection of invalid row numbers more reliable
        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {
          let boundingBox = this.getBoundingBox();
          let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
          let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
          let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
          let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
          let codewords = this.getCodewords();
          let barcodeRow = -1;
          for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            let codeword = codewords[codewordsRow];
            codeword.setRowNumberAsRowIndicatorColumn();
            let rowDifference = codeword.getRowNumber() - barcodeRow;
            if (rowDifference === 0)
              ;
            else if (rowDifference === 1) {
              barcodeRow = codeword.getRowNumber();
            } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
              codewords[codewordsRow] = null;
            } else {
              barcodeRow = codeword.getRowNumber();
            }
          }
        }
        getBarcodeMetadata() {
          let codewords = this.getCodewords();
          let barcodeColumnCount = new BarcodeValue();
          let barcodeRowCountUpperPart = new BarcodeValue();
          let barcodeRowCountLowerPart = new BarcodeValue();
          let barcodeECLevel = new BarcodeValue();
          for (let codeword of codewords) {
            if (codeword == null) {
              continue;
            }
            codeword.setRowNumberAsRowIndicatorColumn();
            let rowIndicatorValue = codeword.getValue() % 30;
            let codewordRowNumber = codeword.getRowNumber();
            if (!this._isLeft) {
              codewordRowNumber += 2;
            }
            switch (codewordRowNumber % 3) {
              case 0:
                barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
                break;
              case 1:
                barcodeECLevel.setValue(rowIndicatorValue / 3);
                barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
                break;
              case 2:
                barcodeColumnCount.setValue(rowIndicatorValue + 1);
                break;
            }
          }
          if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {
            return null;
          }
          let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
          this.removeIncorrectCodewords(codewords, barcodeMetadata);
          return barcodeMetadata;
        }
        removeIncorrectCodewords(codewords, barcodeMetadata) {
          for (let codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
            let codeword = codewords[codewordRow];
            if (codewords[codewordRow] == null) {
              continue;
            }
            let rowIndicatorValue = codeword.getValue() % 30;
            let codewordRowNumber = codeword.getRowNumber();
            if (codewordRowNumber > barcodeMetadata.getRowCount()) {
              codewords[codewordRow] = null;
              continue;
            }
            if (!this._isLeft) {
              codewordRowNumber += 2;
            }
            switch (codewordRowNumber % 3) {
              case 0:
                if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                  codewords[codewordRow] = null;
                }
                break;
              case 1:
                if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                  codewords[codewordRow] = null;
                }
                break;
              case 2:
                if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                  codewords[codewordRow] = null;
                }
                break;
            }
          }
        }
        isLeft() {
          return this._isLeft;
        }
        // @Override
        toString() {
          return "IsLeft: " + this._isLeft + "\n" + super.toString();
        }
      }
      class DetectionResult {
        constructor(barcodeMetadata, boundingBox) {
          this.ADJUST_ROW_NUMBER_SKIP = 2;
          this.barcodeMetadata = barcodeMetadata;
          this.barcodeColumnCount = barcodeMetadata.getColumnCount();
          this.boundingBox = boundingBox;
          this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
        }
        getDetectionResultColumns() {
          this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
          this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
          let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;
          let previousUnadjustedCount;
          do {
            previousUnadjustedCount = unadjustedCodewordCount;
            unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
          } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
          return this.detectionResultColumns;
        }
        adjustIndicatorColumnRowNumbers(detectionResultColumn) {
          if (detectionResultColumn != null) {
            detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
          }
        }
        // TODO ensure that no detected codewords with unknown row number are left
        // we should be able to estimate the row height and use it as a hint for the row number
        // we should also fill the rows top to bottom and bottom to top
        /**
         * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords
         * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers
         */
        adjustRowNumbersAndGetCount() {
          let unadjustedCount = this.adjustRowNumbersByRow();
          if (unadjustedCount === 0) {
            return 0;
          }
          for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
            let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
            for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
              if (codewords[codewordsRow] == null) {
                continue;
              }
              if (!codewords[codewordsRow].hasValidRowNumber()) {
                this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
              }
            }
          }
          return unadjustedCount;
        }
        adjustRowNumbersByRow() {
          this.adjustRowNumbersFromBothRI();
          let unadjustedCount = this.adjustRowNumbersFromLRI();
          return unadjustedCount + this.adjustRowNumbersFromRRI();
        }
        adjustRowNumbersFromBothRI() {
          if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
            return;
          }
          let LRIcodewords = this.detectionResultColumns[0].getCodewords();
          let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
          for (let codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
            if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
              for (let barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
                let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword == null) {
                  continue;
                }
                codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
                if (!codeword.hasValidRowNumber()) {
                  this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
                }
              }
            }
          }
        }
        adjustRowNumbersFromRRI() {
          if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
            return 0;
          }
          let unadjustedCount = 0;
          let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
          for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
            let invalidRowCounts = 0;
            for (let barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
              let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword != null) {
                invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                if (!codeword.hasValidRowNumber()) {
                  unadjustedCount++;
                }
              }
            }
          }
          return unadjustedCount;
        }
        adjustRowNumbersFromLRI() {
          if (this.detectionResultColumns[0] == null) {
            return 0;
          }
          let unadjustedCount = 0;
          let codewords = this.detectionResultColumns[0].getCodewords();
          for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
            let invalidRowCounts = 0;
            for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
              let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword != null) {
                invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                if (!codeword.hasValidRowNumber()) {
                  unadjustedCount++;
                }
              }
            }
          }
          return unadjustedCount;
        }
        static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {
          if (codeword == null) {
            return invalidRowCounts;
          }
          if (!codeword.hasValidRowNumber()) {
            if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
              codeword.setRowNumber(rowIndicatorRowNumber);
              invalidRowCounts = 0;
            } else {
              ++invalidRowCounts;
            }
          }
          return invalidRowCounts;
        }
        adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {
          if (!this.detectionResultColumns[barcodeColumn - 1]) {
            return;
          }
          let codeword = codewords[codewordsRow];
          let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
          let nextColumnCodewords = previousColumnCodewords;
          if (this.detectionResultColumns[barcodeColumn + 1] != null) {
            nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
          }
          let otherCodewords = new Array(14);
          otherCodewords[2] = previousColumnCodewords[codewordsRow];
          otherCodewords[3] = nextColumnCodewords[codewordsRow];
          if (codewordsRow > 0) {
            otherCodewords[0] = codewords[codewordsRow - 1];
            otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
            otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
          }
          if (codewordsRow > 1) {
            otherCodewords[8] = codewords[codewordsRow - 2];
            otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
            otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
          }
          if (codewordsRow < codewords.length - 1) {
            otherCodewords[1] = codewords[codewordsRow + 1];
            otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
            otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
          }
          if (codewordsRow < codewords.length - 2) {
            otherCodewords[9] = codewords[codewordsRow + 2];
            otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
            otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
          }
          for (let otherCodeword of otherCodewords) {
            if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
              return;
            }
          }
        }
        /**
         * @return true, if row number was adjusted, false otherwise
         */
        static adjustRowNumber(codeword, otherCodeword) {
          if (otherCodeword == null) {
            return false;
          }
          if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
            codeword.setRowNumber(otherCodeword.getRowNumber());
            return true;
          }
          return false;
        }
        getBarcodeColumnCount() {
          return this.barcodeColumnCount;
        }
        getBarcodeRowCount() {
          return this.barcodeMetadata.getRowCount();
        }
        getBarcodeECLevel() {
          return this.barcodeMetadata.getErrorCorrectionLevel();
        }
        setBoundingBox(boundingBox) {
          this.boundingBox = boundingBox;
        }
        getBoundingBox() {
          return this.boundingBox;
        }
        setDetectionResultColumn(barcodeColumn, detectionResultColumn) {
          this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
        }
        getDetectionResultColumn(barcodeColumn) {
          return this.detectionResultColumns[barcodeColumn];
        }
        // @Override
        toString() {
          let rowIndicatorColumn = this.detectionResultColumns[0];
          if (rowIndicatorColumn == null) {
            rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
          }
          let formatter = new Formatter();
          for (let codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
            formatter.format("CW %3d:", codewordsRow);
            for (let barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
              if (this.detectionResultColumns[barcodeColumn] == null) {
                formatter.format("    |   ");
                continue;
              }
              let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword == null) {
                formatter.format("    |   ");
                continue;
              }
              formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
            }
            formatter.format("%n");
          }
          return formatter.toString();
        }
      }
      class Codeword {
        constructor(startX, endX, bucket, value2) {
          this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
          this.startX = Math.trunc(startX);
          this.endX = Math.trunc(endX);
          this.bucket = Math.trunc(bucket);
          this.value = Math.trunc(value2);
        }
        hasValidRowNumber() {
          return this.isValidRowNumber(this.rowNumber);
        }
        isValidRowNumber(rowNumber) {
          return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
        }
        setRowNumberAsRowIndicatorColumn() {
          this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
        }
        getWidth() {
          return this.endX - this.startX;
        }
        getStartX() {
          return this.startX;
        }
        getEndX() {
          return this.endX;
        }
        getBucket() {
          return this.bucket;
        }
        getValue() {
          return this.value;
        }
        getRowNumber() {
          return this.rowNumber;
        }
        setRowNumber(rowNumber) {
          this.rowNumber = rowNumber;
        }
        //   @Override
        toString() {
          return this.rowNumber + "|" + this.value;
        }
      }
      Codeword.BARCODE_ROW_UNKNOWN = -1;
      class PDF417CodewordDecoder {
        /* @note
         * this action have to be performed before first use of class
         * - static constructor
         * working with 32bit float (based from Java logic)
        */
        static initialize() {
          for (let i3 = 0; i3 < PDF417Common.SYMBOL_TABLE.length; i3++) {
            let currentSymbol = PDF417Common.SYMBOL_TABLE[i3];
            let currentBit = currentSymbol & 1;
            for (let j2 = 0; j2 < PDF417Common.BARS_IN_MODULE; j2++) {
              let size = 0;
              while ((currentSymbol & 1) === currentBit) {
                size += 1;
                currentSymbol >>= 1;
              }
              currentBit = currentSymbol & 1;
              if (!PDF417CodewordDecoder.RATIOS_TABLE[i3]) {
                PDF417CodewordDecoder.RATIOS_TABLE[i3] = new Array(PDF417Common.BARS_IN_MODULE);
              }
              PDF417CodewordDecoder.RATIOS_TABLE[i3][PDF417Common.BARS_IN_MODULE - j2 - 1] = Math.fround(size / PDF417Common.MODULES_IN_CODEWORD);
            }
          }
          this.bSymbolTableReady = true;
        }
        static getDecodedValue(moduleBitCount) {
          let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
          if (decodedValue !== -1) {
            return decodedValue;
          }
          return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
        }
        static sampleBitCounts(moduleBitCount) {
          let bitCountSum = MathUtils.sum(moduleBitCount);
          let result = new Int32Array(PDF417Common.BARS_IN_MODULE);
          let bitCountIndex = 0;
          let sumPreviousBits = 0;
          for (let i3 = 0; i3 < PDF417Common.MODULES_IN_CODEWORD; i3++) {
            let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) + i3 * bitCountSum / PDF417Common.MODULES_IN_CODEWORD;
            if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
              sumPreviousBits += moduleBitCount[bitCountIndex];
              bitCountIndex++;
            }
            result[bitCountIndex]++;
          }
          return result;
        }
        static getDecodedCodewordValue(moduleBitCount) {
          let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
          return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
        }
        static getBitValue(moduleBitCount) {
          let result = (
            /*long*/
            0
          );
          for (let i3 = 0; i3 < moduleBitCount.length; i3++) {
            for (let bit = 0; bit < moduleBitCount[i3]; bit++) {
              result = result << 1 | (i3 % 2 === 0 ? 1 : 0);
            }
          }
          return Math.trunc(result);
        }
        // working with 32bit float (as in Java)
        static getClosestDecodedValue(moduleBitCount) {
          let bitCountSum = MathUtils.sum(moduleBitCount);
          let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);
          if (bitCountSum > 1) {
            for (let i3 = 0; i3 < bitCountRatios.length; i3++) {
              bitCountRatios[i3] = Math.fround(moduleBitCount[i3] / bitCountSum);
            }
          }
          let bestMatchError = Float.MAX_VALUE;
          let bestMatch = -1;
          if (!this.bSymbolTableReady) {
            PDF417CodewordDecoder.initialize();
          }
          for (let j2 = 0; j2 < PDF417CodewordDecoder.RATIOS_TABLE.length; j2++) {
            let error = 0;
            let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j2];
            for (let k2 = 0; k2 < PDF417Common.BARS_IN_MODULE; k2++) {
              let diff = Math.fround(ratioTableRow[k2] - bitCountRatios[k2]);
              error += Math.fround(diff * diff);
              if (error >= bestMatchError) {
                break;
              }
            }
            if (error < bestMatchError) {
              bestMatchError = error;
              bestMatch = PDF417Common.SYMBOL_TABLE[j2];
            }
          }
          return bestMatch;
        }
      }
      PDF417CodewordDecoder.bSymbolTableReady = false;
      PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map((x2) => x2 = new Array(PDF417Common.BARS_IN_MODULE));
      class PDF417ResultMetadata {
        constructor() {
          this.segmentCount = -1;
          this.fileSize = -1;
          this.timestamp = -1;
          this.checksum = -1;
        }
        /**
         * The Segment ID represents the segment of the whole file distributed over different symbols.
         *
         * @return File segment index
         */
        getSegmentIndex() {
          return this.segmentIndex;
        }
        setSegmentIndex(segmentIndex) {
          this.segmentIndex = segmentIndex;
        }
        /**
         * Is the same for each related PDF417 symbol
         *
         * @return File ID
         */
        getFileId() {
          return this.fileId;
        }
        setFileId(fileId) {
          this.fileId = fileId;
        }
        /**
         * @return always null
         * @deprecated use dedicated already parsed fields
         */
        //   @Deprecated
        getOptionalData() {
          return this.optionalData;
        }
        /**
         * @param optionalData old optional data format as int array
         * @deprecated parse and use new fields
         */
        //   @Deprecated
        setOptionalData(optionalData) {
          this.optionalData = optionalData;
        }
        /**
         * @return true if it is the last segment
         */
        isLastSegment() {
          return this.lastSegment;
        }
        setLastSegment(lastSegment) {
          this.lastSegment = lastSegment;
        }
        /**
         * @return count of segments, -1 if not set
         */
        getSegmentCount() {
          return this.segmentCount;
        }
        setSegmentCount(segmentCount) {
          this.segmentCount = segmentCount;
        }
        getSender() {
          return this.sender || null;
        }
        setSender(sender) {
          this.sender = sender;
        }
        getAddressee() {
          return this.addressee || null;
        }
        setAddressee(addressee) {
          this.addressee = addressee;
        }
        /**
         * Filename of the encoded file
         *
         * @return filename
         */
        getFileName() {
          return this.fileName;
        }
        setFileName(fileName) {
          this.fileName = fileName;
        }
        /**
         * filesize in bytes of the encoded file
         *
         * @return filesize in bytes, -1 if not set
         */
        getFileSize() {
          return this.fileSize;
        }
        setFileSize(fileSize) {
          this.fileSize = fileSize;
        }
        /**
         * 16-bit CRC checksum using CCITT-16
         *
         * @return crc checksum, -1 if not set
         */
        getChecksum() {
          return this.checksum;
        }
        setChecksum(checksum) {
          this.checksum = checksum;
        }
        /**
         * unix epock timestamp, elapsed seconds since 1970-01-01
         *
         * @return elapsed seconds, -1 if not set
         */
        getTimestamp() {
          return this.timestamp;
        }
        setTimestamp(timestamp) {
          this.timestamp = timestamp;
        }
      }
      class Long {
        /**
         * Parses a string to a number, since JS has no really Int64.
         *
         * @param num Numeric string.
         * @param radix Destination radix.
         */
        static parseLong(num, radix = void 0) {
          return parseInt(num, radix);
        }
      }
      class NullPointerException extends Exception {
      }
      NullPointerException.kind = "NullPointerException";
      class OutputStream {
        /**
         * Writes <code>b.length</code> bytes from the specified byte array
         * to this output stream. The general contract for <code>write(b)</code>
         * is that it should have exactly the same effect as the call
         * <code>write(b, 0, b.length)</code>.
         *
         * @param      b   the data.
         * @exception  IOException  if an I/O error occurs.
         * @see        java.io.OutputStream#write(byte[], int, int)
         */
        writeBytes(b2) {
          this.writeBytesOffset(b2, 0, b2.length);
        }
        /**
         * Writes <code>len</code> bytes from the specified byte array
         * starting at offset <code>off</code> to this output stream.
         * The general contract for <code>write(b, off, len)</code> is that
         * some of the bytes in the array <code>b</code> are written to the
         * output stream in order; element <code>b[off]</code> is the first
         * byte written and <code>b[off+len-1]</code> is the last byte written
         * by this operation.
         * <p>
         * The <code>write</code> method of <code>OutputStream</code> calls
         * the write method of one argument on each of the bytes to be
         * written out. Subclasses are encouraged to override this method and
         * provide a more efficient implementation.
         * <p>
         * If <code>b</code> is <code>null</code>, a
         * <code>NullPointerException</code> is thrown.
         * <p>
         * If <code>off</code> is negative, or <code>len</code> is negative, or
         * <code>off+len</code> is greater than the length of the array
         * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.
         *
         * @param      b     the data.
         * @param      off   the start offset in the data.
         * @param      len   the number of bytes to write.
         * @exception  IOException  if an I/O error occurs. In particular,
         *             an <code>IOException</code> is thrown if the output
         *             stream is closed.
         */
        writeBytesOffset(b2, off, len) {
          if (b2 == null) {
            throw new NullPointerException();
          } else if (off < 0 || off > b2.length || len < 0 || off + len > b2.length || off + len < 0) {
            throw new IndexOutOfBoundsException();
          } else if (len === 0) {
            return;
          }
          for (let i3 = 0; i3 < len; i3++) {
            this.write(b2[off + i3]);
          }
        }
        /**
         * Flushes this output stream and forces any buffered output bytes
         * to be written out. The general contract of <code>flush</code> is
         * that calling it is an indication that, if any bytes previously
         * written have been buffered by the implementation of the output
         * stream, such bytes should immediately be written to their
         * intended destination.
         * <p>
         * If the intended destination of this stream is an abstraction provided by
         * the underlying operating system, for example a file, then flushing the
         * stream guarantees only that bytes previously written to the stream are
         * passed to the operating system for writing; it does not guarantee that
         * they are actually written to a physical device such as a disk drive.
         * <p>
         * The <code>flush</code> method of <code>OutputStream</code> does nothing.
         *
         * @exception  IOException  if an I/O error occurs.
         */
        flush() {
        }
        /**
         * Closes this output stream and releases any system resources
         * associated with this stream. The general contract of <code>close</code>
         * is that it closes the output stream. A closed stream cannot perform
         * output operations and cannot be reopened.
         * <p>
         * The <code>close</code> method of <code>OutputStream</code> does nothing.
         *
         * @exception  IOException  if an I/O error occurs.
         */
        close() {
        }
      }
      class OutOfMemoryError extends Exception {
      }
      class ByteArrayOutputStream extends OutputStream {
        /**
         * Creates a new byte array output stream. The buffer capacity is
         * initially 32 bytes, though its size increases if necessary.
         */
        // public constructor() {
        //     this(32);
        // }
        /**
         * Creates a new byte array output stream, with a buffer capacity of
         * the specified size, in bytes.
         *
         * @param   size   the initial size.
         * @exception  IllegalArgumentException if size is negative.
         */
        constructor(size = 32) {
          super();
          this.count = 0;
          if (size < 0) {
            throw new IllegalArgumentException("Negative initial size: " + size);
          }
          this.buf = new Uint8Array(size);
        }
        /**
         * Increases the capacity if necessary to ensure that it can hold
         * at least the number of elements specified by the minimum
         * capacity argument.
         *
         * @param minCapacity the desired minimum capacity
         * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is
         * interpreted as a request for the unsatisfiably large capacity
         * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.
         */
        ensureCapacity(minCapacity) {
          if (minCapacity - this.buf.length > 0)
            this.grow(minCapacity);
        }
        /**
         * Increases the capacity to ensure that it can hold at least the
         * number of elements specified by the minimum capacity argument.
         *
         * @param minCapacity the desired minimum capacity
         */
        grow(minCapacity) {
          let oldCapacity = this.buf.length;
          let newCapacity = oldCapacity << 1;
          if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
          if (newCapacity < 0) {
            if (minCapacity < 0)
              throw new OutOfMemoryError();
            newCapacity = Integer.MAX_VALUE;
          }
          this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);
        }
        /**
         * Writes the specified byte to this byte array output stream.
         *
         * @param   b   the byte to be written.
         */
        write(b2) {
          this.ensureCapacity(this.count + 1);
          this.buf[this.count] = /*(byte)*/
          b2;
          this.count += 1;
        }
        /**
         * Writes <code>len</code> bytes from the specified byte array
         * starting at offset <code>off</code> to this byte array output stream.
         *
         * @param   b     the data.
         * @param   off   the start offset in the data.
         * @param   len   the number of bytes to write.
         */
        writeBytesOffset(b2, off, len) {
          if (off < 0 || off > b2.length || len < 0 || off + len - b2.length > 0) {
            throw new IndexOutOfBoundsException();
          }
          this.ensureCapacity(this.count + len);
          System.arraycopy(b2, off, this.buf, this.count, len);
          this.count += len;
        }
        /**
         * Writes the complete contents of this byte array output stream to
         * the specified output stream argument, as if by calling the output
         * stream's write method using <code>out.write(buf, 0, count)</code>.
         *
         * @param      out   the output stream to which to write the data.
         * @exception  IOException  if an I/O error occurs.
         */
        writeTo(out) {
          out.writeBytesOffset(this.buf, 0, this.count);
        }
        /**
         * Resets the <code>count</code> field of this byte array output
         * stream to zero, so that all currently accumulated output in the
         * output stream is discarded. The output stream can be used again,
         * reusing the already allocated buffer space.
         *
         * @see     java.io.ByteArrayInputStream#count
         */
        reset() {
          this.count = 0;
        }
        /**
         * Creates a newly allocated byte array. Its size is the current
         * size of this output stream and the valid contents of the buffer
         * have been copied into it.
         *
         * @return  the current contents of this output stream, as a byte array.
         * @see     java.io.ByteArrayOutputStream#size()
         */
        toByteArray() {
          return Arrays.copyOfUint8Array(this.buf, this.count);
        }
        /**
         * Returns the current size of the buffer.
         *
         * @return  the value of the <code>count</code> field, which is the number
         *          of valid bytes in this output stream.
         * @see     java.io.ByteArrayOutputStream#count
         */
        size() {
          return this.count;
        }
        toString(param) {
          if (!param) {
            return this.toString_void();
          }
          if (typeof param === "string") {
            return this.toString_string(param);
          }
          return this.toString_number(param);
        }
        /**
         * Converts the buffer's contents into a string decoding bytes using the
         * platform's default character set. The length of the new <tt>String</tt>
         * is a function of the character set, and hence may not be equal to the
         * size of the buffer.
         *
         * <p> This method always replaces malformed-input and unmappable-character
         * sequences with the default replacement string for the platform's
         * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
         * class should be used when more control over the decoding process is
         * required.
         *
         * @return String decoded from the buffer's contents.
         * @since  JDK1.1
         */
        toString_void() {
          return new String(
            this.buf
            /*, 0, this.count*/
          ).toString();
        }
        /**
         * Converts the buffer's contents into a string by decoding the bytes using
         * the specified {@link java.nio.charset.Charset charsetName}. The length of
         * the new <tt>String</tt> is a function of the charset, and hence may not be
         * equal to the length of the byte array.
         *
         * <p> This method always replaces malformed-input and unmappable-character
         * sequences with this charset's default replacement string. The {@link
         * java.nio.charset.CharsetDecoder} class should be used when more control
         * over the decoding process is required.
         *
         * @param  charsetName  the name of a supported
         *              {@linkplain java.nio.charset.Charset </code>charset<code>}
         * @return String decoded from the buffer's contents.
         * @exception  UnsupportedEncodingException
         *             If the named charset is not supported
         * @since   JDK1.1
         */
        toString_string(charsetName) {
          return new String(
            this.buf
            /*, 0, this.count, charsetName*/
          ).toString();
        }
        /**
         * Creates a newly allocated string. Its size is the current size of
         * the output stream and the valid contents of the buffer have been
         * copied into it. Each character <i>c</i> in the resulting string is
         * constructed from the corresponding element <i>b</i> in the byte
         * array such that:
         * <blockquote><pre>
         *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
         * </pre></blockquote>
         *
         * @deprecated This method does not properly convert bytes into characters.
         * As of JDK&nbsp;1.1, the preferred way to do this is via the
         * <code>toString(String enc)</code> method, which takes an encoding-name
         * argument, or the <code>toString()</code> method, which uses the
         * platform's default character encoding.
         *
         * @param      hibyte    the high byte of each resulting Unicode character.
         * @return     the current contents of the output stream, as a string.
         * @see        java.io.ByteArrayOutputStream#size()
         * @see        java.io.ByteArrayOutputStream#toString(String)
         * @see        java.io.ByteArrayOutputStream#toString()
         */
        // @Deprecated
        toString_number(hibyte) {
          return new String(
            this.buf
            /*, hibyte, 0, this.count*/
          ).toString();
        }
        /**
         * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
         * this class can be called after the stream has been closed without
         * generating an <tt>IOException</tt>.
         * <p>
         *
         * @throws IOException
         */
        close() {
        }
      }
      var Mode$2;
      (function(Mode2) {
        Mode2[Mode2["ALPHA"] = 0] = "ALPHA";
        Mode2[Mode2["LOWER"] = 1] = "LOWER";
        Mode2[Mode2["MIXED"] = 2] = "MIXED";
        Mode2[Mode2["PUNCT"] = 3] = "PUNCT";
        Mode2[Mode2["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
        Mode2[Mode2["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
      })(Mode$2 || (Mode$2 = {}));
      function getBigIntConstructor() {
        if (typeof window !== "undefined") {
          return window["BigInt"] || null;
        }
        if (typeof global !== "undefined") {
          return global["BigInt"] || null;
        }
        if (typeof self !== "undefined") {
          return self["BigInt"] || null;
        }
        throw new Error("Can't search globals for BigInt!");
      }
      let BigInteger;
      function createBigInt(num) {
        if (typeof BigInteger === "undefined") {
          BigInteger = getBigIntConstructor();
        }
        if (BigInteger === null) {
          throw new Error("BigInt is not supported!");
        }
        return BigInteger(num);
      }
      function getEXP900() {
        let EXP900 = [];
        EXP900[0] = createBigInt(1);
        let nineHundred = createBigInt(900);
        EXP900[1] = nineHundred;
        for (let i3 = 2; i3 < 16; i3++) {
          EXP900[i3] = EXP900[i3 - 1] * nineHundred;
        }
        return EXP900;
      }
      class DecodedBitStreamParser$2 {
        //   private DecodedBitStreamParser() {
        // }
        /**
         *
         * @param codewords
         * @param ecLevel
         *
         * @throws FormatException
         */
        static decode(codewords, ecLevel) {
          let result = new StringBuilder("");
          let encoding = CharacterSetECI.ISO8859_1;
          result.enableDecoding(encoding);
          let codeIndex = 1;
          let code = codewords[codeIndex++];
          let resultMetadata = new PDF417ResultMetadata();
          while (codeIndex < codewords[0]) {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
                break;
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);
                break;
              case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                result.append(
                  /*(char)*/
                  codewords[codeIndex++]
                );
                break;
              case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);
                break;
              case DecodedBitStreamParser$2.ECI_CHARSET:
                let charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
                break;
              case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
                codeIndex += 2;
                break;
              case DecodedBitStreamParser$2.ECI_USER_DEFINED:
                codeIndex++;
                break;
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);
                break;
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                throw new FormatException();
              default:
                codeIndex--;
                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
                break;
            }
            if (codeIndex < codewords.length) {
              code = codewords[codeIndex++];
            } else {
              throw FormatException.getFormatInstance();
            }
          }
          if (result.length() === 0) {
            throw FormatException.getFormatInstance();
          }
          let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
          decoderResult.setOther(resultMetadata);
          return decoderResult;
        }
        /**
         *
         * @param int
         * @param param1
         * @param codewords
         * @param int
         * @param codeIndex
         * @param PDF417ResultMetadata
         * @param resultMetadata
         *
         * @throws FormatException
         */
        // @SuppressWarnings("deprecation")
        static decodeMacroBlock(codewords, codeIndex, resultMetadata) {
          if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
            throw FormatException.getFormatInstance();
          }
          let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
          for (let i3 = 0; i3 < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i3++, codeIndex++) {
            segmentIndexArray[i3] = codewords[codeIndex];
          }
          resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
          let fileId = new StringBuilder();
          codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);
          resultMetadata.setFileId(fileId.toString());
          let optionalFieldsStart = -1;
          if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
            optionalFieldsStart = codeIndex + 1;
          }
          while (codeIndex < codewords[0]) {
            switch (codewords[codeIndex]) {
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                codeIndex++;
                switch (codewords[codeIndex]) {
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                    let fileName = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);
                    resultMetadata.setFileName(fileName.toString());
                    break;
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                    let sender = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);
                    resultMetadata.setSender(sender.toString());
                    break;
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                    let addressee = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);
                    resultMetadata.setAddressee(addressee.toString());
                    break;
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                    let segmentCount = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);
                    resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                    break;
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                    let timestamp = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);
                    resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                    break;
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                    let checksum = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);
                    resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                    break;
                  case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                    let fileSize = new StringBuilder();
                    codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);
                    resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                    break;
                  default:
                    throw FormatException.getFormatInstance();
                }
                break;
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex++;
                resultMetadata.setLastSegment(true);
                break;
              default:
                throw FormatException.getFormatInstance();
            }
          }
          if (optionalFieldsStart !== -1) {
            let optionalFieldsLength = codeIndex - optionalFieldsStart;
            if (resultMetadata.isLastSegment()) {
              optionalFieldsLength--;
            }
            resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
          }
          return codeIndex;
        }
        /**
         * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
         * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
         * well as selected control characters.
         *
         * @param codewords The array of codewords (data + error)
         * @param codeIndex The current index into the codeword array.
         * @param result    The decoded data is appended to the result.
         * @return The next index into the codeword array.
         */
        static textCompaction(codewords, codeIndex, result) {
          let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
          let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
          let index = 0;
          let end = false;
          while (codeIndex < codewords[0] && !end) {
            let code = codewords[codeIndex++];
            if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
              textCompactionData[index] = code / 30;
              textCompactionData[index + 1] = code % 30;
              index += 2;
            } else {
              switch (code) {
                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                  break;
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  codeIndex--;
                  end = true;
                  break;
                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                  textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                  code = codewords[codeIndex++];
                  byteCompactionData[index] = code;
                  index++;
                  break;
              }
            }
          }
          DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
          return codeIndex;
        }
        /**
         * The Text Compaction mode includes all the printable ASCII characters
         * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
         * (9: e), LF or line feed (10: e), and CR or carriage
         * return (13: e). The Text Compaction mode also includes various latch
         * and shift characters which are used exclusively within the mode. The Text
         * Compaction mode encodes up to 2 characters per codeword. The compaction rules
         * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
         * switches are defined in 5.4.2.3.
         *
         * @param textCompactionData The text compaction data.
         * @param byteCompactionData The byte compaction data if there
         *                           was a mode shift.
         * @param length             The size of the text compaction and byte compaction data.
         * @param result             The decoded data is appended to the result.
         */
        static decodeTextCompaction(textCompactionData, byteCompactionData, length2, result) {
          let subMode = Mode$2.ALPHA;
          let priorToShiftMode = Mode$2.ALPHA;
          let i3 = 0;
          while (i3 < length2) {
            let subModeCh = textCompactionData[i3];
            let ch = (
              /*char*/
              ""
            );
            switch (subMode) {
              case Mode$2.ALPHA:
                if (subModeCh < 26) {
                  ch = /*(char)('A' + subModeCh) */
                  String.fromCharCode(65 + subModeCh);
                } else {
                  switch (subModeCh) {
                    case 26:
                      ch = " ";
                      break;
                    case DecodedBitStreamParser$2.LL:
                      subMode = Mode$2.LOWER;
                      break;
                    case DecodedBitStreamParser$2.ML:
                      subMode = Mode$2.MIXED;
                      break;
                    case DecodedBitStreamParser$2.PS:
                      priorToShiftMode = subMode;
                      subMode = Mode$2.PUNCT_SHIFT;
                      break;
                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                      result.append(
                        /*(char)*/
                        byteCompactionData[i3]
                      );
                      break;
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      subMode = Mode$2.ALPHA;
                      break;
                  }
                }
                break;
              case Mode$2.LOWER:
                if (subModeCh < 26) {
                  ch = /*(char)('a' + subModeCh)*/
                  String.fromCharCode(97 + subModeCh);
                } else {
                  switch (subModeCh) {
                    case 26:
                      ch = " ";
                      break;
                    case DecodedBitStreamParser$2.AS:
                      priorToShiftMode = subMode;
                      subMode = Mode$2.ALPHA_SHIFT;
                      break;
                    case DecodedBitStreamParser$2.ML:
                      subMode = Mode$2.MIXED;
                      break;
                    case DecodedBitStreamParser$2.PS:
                      priorToShiftMode = subMode;
                      subMode = Mode$2.PUNCT_SHIFT;
                      break;
                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                      result.append(
                        /*(char)*/
                        byteCompactionData[i3]
                      );
                      break;
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      subMode = Mode$2.ALPHA;
                      break;
                  }
                }
                break;
              case Mode$2.MIXED:
                if (subModeCh < DecodedBitStreamParser$2.PL) {
                  ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
                } else {
                  switch (subModeCh) {
                    case DecodedBitStreamParser$2.PL:
                      subMode = Mode$2.PUNCT;
                      break;
                    case 26:
                      ch = " ";
                      break;
                    case DecodedBitStreamParser$2.LL:
                      subMode = Mode$2.LOWER;
                      break;
                    case DecodedBitStreamParser$2.AL:
                      subMode = Mode$2.ALPHA;
                      break;
                    case DecodedBitStreamParser$2.PS:
                      priorToShiftMode = subMode;
                      subMode = Mode$2.PUNCT_SHIFT;
                      break;
                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                      result.append(
                        /*(char)*/
                        byteCompactionData[i3]
                      );
                      break;
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      subMode = Mode$2.ALPHA;
                      break;
                  }
                }
                break;
              case Mode$2.PUNCT:
                if (subModeCh < DecodedBitStreamParser$2.PAL) {
                  ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                } else {
                  switch (subModeCh) {
                    case DecodedBitStreamParser$2.PAL:
                      subMode = Mode$2.ALPHA;
                      break;
                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                      result.append(
                        /*(char)*/
                        byteCompactionData[i3]
                      );
                      break;
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      subMode = Mode$2.ALPHA;
                      break;
                  }
                }
                break;
              case Mode$2.ALPHA_SHIFT:
                subMode = priorToShiftMode;
                if (subModeCh < 26) {
                  ch = /*(char)('A' + subModeCh)*/
                  String.fromCharCode(65 + subModeCh);
                } else {
                  switch (subModeCh) {
                    case 26:
                      ch = " ";
                      break;
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      subMode = Mode$2.ALPHA;
                      break;
                  }
                }
                break;
              case Mode$2.PUNCT_SHIFT:
                subMode = priorToShiftMode;
                if (subModeCh < DecodedBitStreamParser$2.PAL) {
                  ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                } else {
                  switch (subModeCh) {
                    case DecodedBitStreamParser$2.PAL:
                      subMode = Mode$2.ALPHA;
                      break;
                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                      result.append(
                        /*(char)*/
                        byteCompactionData[i3]
                      );
                      break;
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                      subMode = Mode$2.ALPHA;
                      break;
                  }
                }
                break;
            }
            if (ch !== "") {
              result.append(ch);
            }
            i3++;
          }
        }
        /**
         * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
         * This includes all ASCII characters value 0 to 127 inclusive and provides for international
         * character set support.
         *
         * @param mode      The byte compaction mode i.e. 901 or 924
         * @param codewords The array of codewords (data + error)
         * @param encoding  Currently active character encoding
         * @param codeIndex The current index into the codeword array.
         * @param result    The decoded data is appended to the result.
         * @return The next index into the codeword array.
         */
        static byteCompaction(mode, codewords, encoding, codeIndex, result) {
          let decodedBytes = new ByteArrayOutputStream();
          let count = 0;
          let value2 = (
            /*long*/
            0
          );
          let end = false;
          switch (mode) {
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              let byteCompactedCodewords = new Int32Array(6);
              let nextCode = codewords[codeIndex++];
              while (codeIndex < codewords[0] && !end) {
                byteCompactedCodewords[count++] = nextCode;
                value2 = 900 * value2 + nextCode;
                nextCode = codewords[codeIndex++];
                switch (nextCode) {
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end = true;
                    break;
                  default:
                    if (count % 5 === 0 && count > 0) {
                      for (let j2 = 0; j2 < 6; ++j2) {
                        decodedBytes.write(
                          /*(byte)*/
                          Number(createBigInt(value2) >> createBigInt(8 * (5 - j2)))
                        );
                      }
                      value2 = 0;
                      count = 0;
                    }
                    break;
                }
              }
              if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                byteCompactedCodewords[count++] = nextCode;
              }
              for (let i3 = 0; i3 < count; i3++) {
                decodedBytes.write(
                  /*(byte)*/
                  byteCompactedCodewords[i3]
                );
              }
              break;
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              while (codeIndex < codewords[0] && !end) {
                let code = codewords[codeIndex++];
                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                  count++;
                  value2 = 900 * value2 + code;
                } else {
                  switch (code) {
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                      codeIndex--;
                      end = true;
                      break;
                  }
                }
                if (count % 5 === 0 && count > 0) {
                  for (let j2 = 0; j2 < 6; ++j2) {
                    decodedBytes.write(
                      /*(byte)*/
                      Number(createBigInt(value2) >> createBigInt(8 * (5 - j2)))
                    );
                  }
                  value2 = 0;
                  count = 0;
                }
              }
              break;
          }
          result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
          return codeIndex;
        }
        /**
         * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
         *
         * @param codewords The array of codewords (data + error)
         * @param codeIndex The current index into the codeword array.
         * @param result    The decoded data is appended to the result.
         * @return The next index into the codeword array.
         *
         * @throws FormatException
         */
        static numericCompaction(codewords, codeIndex, result) {
          let count = 0;
          let end = false;
          let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
          while (codeIndex < codewords[0] && !end) {
            let code = codewords[codeIndex++];
            if (codeIndex === codewords[0]) {
              end = true;
            }
            if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
              numericCodewords[count] = code;
              count++;
            } else {
              switch (code) {
                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  codeIndex--;
                  end = true;
                  break;
              }
            }
            if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
              result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));
              count = 0;
            }
          }
          return codeIndex;
        }
        /**
         * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
         *
         * @param codewords The array of codewords
         * @param count     The number of codewords
         * @return The decoded string representing the Numeric data.
         *
         * EXAMPLE
         * Encode the fifteen digit numeric string 000213298174000
         * Prefix the numeric string with a 1 and set the initial value of
         * t = 1 000 213 298 174 000
         * Calculate codeword 0
         * d0 = 1 000 213 298 174 000 mod 900 = 200
         *
         * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
         * Calculate codeword 1
         * d1 = 1 111 348 109 082 mod 900 = 282
         *
         * t = 1 111 348 109 082 div 900 = 1 234 831 232
         * Calculate codeword 2
         * d2 = 1 234 831 232 mod 900 = 632
         *
         * t = 1 234 831 232 div 900 = 1 372 034
         * Calculate codeword 3
         * d3 = 1 372 034 mod 900 = 434
         *
         * t = 1 372 034 div 900 = 1 524
         * Calculate codeword 4
         * d4 = 1 524 mod 900 = 624
         *
         * t = 1 524 div 900 = 1
         * Calculate codeword 5
         * d5 = 1 mod 900 = 1
         * t = 1 div 900 = 0
         * Codeword sequence is: 1, 624, 434, 632, 282, 200
         *
         * Decode the above codewords involves
         *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
         * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
         *
         * Remove leading 1 =>  Result is 000213298174000
         *
         * @throws FormatException
         */
        static decodeBase900toBase10(codewords, count) {
          let result = createBigInt(0);
          for (let i3 = 0; i3 < count; i3++) {
            result += DecodedBitStreamParser$2.EXP900[count - i3 - 1] * createBigInt(codewords[i3]);
          }
          let resultString = result.toString();
          if (resultString.charAt(0) !== "1") {
            throw new FormatException();
          }
          return resultString.substring(1);
        }
      }
      DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;
      DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;
      DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;
      DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;
      DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;
      DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;
      DecodedBitStreamParser$2.ECI_CHARSET = 927;
      DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
      DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
      DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;
      DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
      DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
      DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
      DecodedBitStreamParser$2.PL = 25;
      DecodedBitStreamParser$2.LL = 27;
      DecodedBitStreamParser$2.AS = 27;
      DecodedBitStreamParser$2.ML = 28;
      DecodedBitStreamParser$2.AL = 28;
      DecodedBitStreamParser$2.PS = 29;
      DecodedBitStreamParser$2.PAL = 29;
      DecodedBitStreamParser$2.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
      DecodedBitStreamParser$2.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
      DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];
      DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
      class PDF417ScanningDecoder {
        constructor() {
        }
        /**
         * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
         *
         * columns. That way width can be deducted from the pattern column.
         * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider
         * than it should be. This can happen if the scanner used a bad blackpoint.
         *
         * @param BitMatrix
         * @param image
         * @param ResultPoint
         * @param imageTopLeft
         * @param ResultPoint
         * @param imageBottomLeft
         * @param ResultPoint
         * @param imageTopRight
         * @param ResultPoint
         * @param imageBottomRight
         * @param int
         * @param minCodewordWidth
         * @param int
         * @param maxCodewordWidth
         *
         * @throws NotFoundException
         * @throws FormatException
         * @throws ChecksumException
         */
        static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
          let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
          let leftRowIndicatorColumn = null;
          let rightRowIndicatorColumn = null;
          let detectionResult;
          for (let firstPass = true; ; firstPass = false) {
            if (imageTopLeft != null) {
              leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
            }
            if (imageTopRight != null) {
              rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
            }
            detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
            if (detectionResult == null) {
              throw NotFoundException.getNotFoundInstance();
            }
            let resultBox = detectionResult.getBoundingBox();
            if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
              boundingBox = resultBox;
            } else {
              break;
            }
          }
          detectionResult.setBoundingBox(boundingBox);
          let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
          detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
          detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
          let leftToRight = leftRowIndicatorColumn != null;
          for (let barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
            let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
            if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */
            void 0) {
              continue;
            }
            let detectionResultColumn;
            if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
              detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
            } else {
              detectionResultColumn = new DetectionResultColumn(boundingBox);
            }
            detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
            let startColumn = -1;
            let previousStartColumn = startColumn;
            for (let imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
              startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
              if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
                if (previousStartColumn === -1) {
                  continue;
                }
                startColumn = previousStartColumn;
              }
              let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
              if (codeword != null) {
                detectionResultColumn.setCodeword(imageRow, codeword);
                previousStartColumn = startColumn;
                minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
                maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
              }
            }
          }
          return PDF417ScanningDecoder.createDecoderResult(detectionResult);
        }
        /**
         *
         * @param leftRowIndicatorColumn
         * @param rightRowIndicatorColumn
         *
         * @throws NotFoundException
         */
        static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {
          if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
            return null;
          }
          let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
          if (barcodeMetadata == null) {
            return null;
          }
          let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
          return new DetectionResult(barcodeMetadata, boundingBox);
        }
        /**
         *
         * @param rowIndicatorColumn
         *
         * @throws NotFoundException
         */
        static adjustBoundingBox(rowIndicatorColumn) {
          if (rowIndicatorColumn == null) {
            return null;
          }
          let rowHeights = rowIndicatorColumn.getRowHeights();
          if (rowHeights == null) {
            return null;
          }
          let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
          let missingStartRows = 0;
          for (let rowHeight of rowHeights) {
            missingStartRows += maxRowHeight - rowHeight;
            if (rowHeight > 0) {
              break;
            }
          }
          let codewords = rowIndicatorColumn.getCodewords();
          for (let row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
            missingStartRows--;
          }
          let missingEndRows = 0;
          for (let row = rowHeights.length - 1; row >= 0; row--) {
            missingEndRows += maxRowHeight - rowHeights[row];
            if (rowHeights[row] > 0) {
              break;
            }
          }
          for (let row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
            missingEndRows--;
          }
          return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
        }
        static getMax(values) {
          let maxValue = -1;
          for (let value2 of values) {
            maxValue = Math.max(maxValue, value2);
          }
          return maxValue;
        }
        static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {
          let leftBarcodeMetadata;
          if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
            return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
          }
          let rightBarcodeMetadata;
          if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
            return leftBarcodeMetadata;
          }
          if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
            return null;
          }
          return leftBarcodeMetadata;
        }
        static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
          let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
          for (let i3 = 0; i3 < 2; i3++) {
            let increment = i3 === 0 ? 1 : -1;
            let startColumn = Math.trunc(Math.trunc(startPoint.getX()));
            for (let imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
              let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
              if (codeword != null) {
                rowIndicatorColumn.setCodeword(imageRow, codeword);
                if (leftToRight) {
                  startColumn = codeword.getStartX();
                } else {
                  startColumn = codeword.getEndX();
                }
              }
            }
          }
          return rowIndicatorColumn;
        }
        /**
         *
         * @param detectionResult
         * @param BarcodeValue
         * @param param2
         * @param param3
         * @param barcodeMatrix
         *
         * @throws NotFoundException
         */
        static adjustCodewordCount(detectionResult, barcodeMatrix) {
          let barcodeMatrix01 = barcodeMatrix[0][1];
          let numberOfCodewords = barcodeMatrix01.getValue();
          let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
          if (numberOfCodewords.length === 0) {
            if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
              throw NotFoundException.getNotFoundInstance();
            }
            barcodeMatrix01.setValue(calculatedNumberOfCodewords);
          } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
            barcodeMatrix01.setValue(calculatedNumberOfCodewords);
          }
        }
        /**
         *
         * @param detectionResult
         *
         * @throws FormatException
         * @throws ChecksumException
         * @throws NotFoundException
         */
        static createDecoderResult(detectionResult) {
          let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
          PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
          let erasures = new Array();
          let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
          let ambiguousIndexValuesList = (
            /*List<int[]>*/
            []
          );
          let ambiguousIndexesList = (
            /*Collection<Integer>*/
            new Array()
          );
          for (let row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
            for (let column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
              let values = barcodeMatrix[row][column + 1].getValue();
              let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
              if (values.length === 0) {
                erasures.push(codewordIndex);
              } else if (values.length === 1) {
                codewords[codewordIndex] = values[0];
              } else {
                ambiguousIndexesList.push(codewordIndex);
                ambiguousIndexValuesList.push(values);
              }
            }
          }
          let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
          for (let i3 = 0; i3 < ambiguousIndexValues.length; i3++) {
            ambiguousIndexValues[i3] = ambiguousIndexValuesList[i3];
          }
          return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
        }
        /**
         * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
         * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
         * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
         * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
         * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
         * so decoding the normal barcodes is not affected by this.
         *
         * @param erasureArray contains the indexes of erasures
         * @param ambiguousIndexes array with the indexes that have more than one most likely value
         * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must
         * be the same length as the ambiguousIndexes array
         *
         * @throws FormatException
         * @throws ChecksumException
         */
        static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
          let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
          let tries = 100;
          while (tries-- > 0) {
            for (let i3 = 0; i3 < ambiguousIndexCount.length; i3++) {
              codewords[ambiguousIndexes[i3]] = ambiguousIndexValues[i3][ambiguousIndexCount[i3]];
            }
            try {
              return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
            } catch (err) {
              let ignored = err instanceof ChecksumException;
              if (!ignored) {
                throw err;
              }
            }
            if (ambiguousIndexCount.length === 0) {
              throw ChecksumException.getChecksumInstance();
            }
            for (let i3 = 0; i3 < ambiguousIndexCount.length; i3++) {
              if (ambiguousIndexCount[i3] < ambiguousIndexValues[i3].length - 1) {
                ambiguousIndexCount[i3]++;
                break;
              } else {
                ambiguousIndexCount[i3] = 0;
                if (i3 === ambiguousIndexCount.length - 1) {
                  throw ChecksumException.getChecksumInstance();
                }
              }
            }
          }
          throw ChecksumException.getChecksumInstance();
        }
        static createBarcodeMatrix(detectionResult) {
          let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));
          for (let row = 0; row < barcodeMatrix.length; row++) {
            for (let column2 = 0; column2 < barcodeMatrix[row].length; column2++) {
              barcodeMatrix[row][column2] = new BarcodeValue();
            }
          }
          let column = 0;
          for (let detectionResultColumn of detectionResult.getDetectionResultColumns()) {
            if (detectionResultColumn != null) {
              for (let codeword of detectionResultColumn.getCodewords()) {
                if (codeword != null) {
                  let rowNumber = codeword.getRowNumber();
                  if (rowNumber >= 0) {
                    if (rowNumber >= barcodeMatrix.length) {
                      continue;
                    }
                    barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                  }
                }
              }
            }
            column++;
          }
          return barcodeMatrix;
        }
        static isValidBarcodeColumn(detectionResult, barcodeColumn) {
          return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
        }
        static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {
          let offset = leftToRight ? 1 : -1;
          let codeword = null;
          if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
          }
          if (codeword != null) {
            return leftToRight ? codeword.getEndX() : codeword.getStartX();
          }
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
          if (codeword != null) {
            return leftToRight ? codeword.getStartX() : codeword.getEndX();
          }
          if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
          }
          if (codeword != null) {
            return leftToRight ? codeword.getEndX() : codeword.getStartX();
          }
          let skippedColumns = 0;
          while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
            barcodeColumn -= offset;
            for (let previousRowCodeword of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {
              if (previousRowCodeword != null) {
                return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
              }
            }
            skippedColumns++;
          }
          return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
        }
        static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
          startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
          let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
          if (moduleBitCount == null) {
            return null;
          }
          let endColumn;
          let codewordBitCount = MathUtils.sum(moduleBitCount);
          if (leftToRight) {
            endColumn = startColumn + codewordBitCount;
          } else {
            for (let i3 = 0; i3 < moduleBitCount.length / 2; i3++) {
              let tmpCount = moduleBitCount[i3];
              moduleBitCount[i3] = moduleBitCount[moduleBitCount.length - 1 - i3];
              moduleBitCount[moduleBitCount.length - 1 - i3] = tmpCount;
            }
            endColumn = startColumn;
            startColumn = endColumn - codewordBitCount;
          }
          if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
            return null;
          }
          let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
          let codeword = PDF417Common.getCodeword(decodedValue);
          if (codeword === -1) {
            return null;
          }
          return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
        }
        static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
          let imageColumn = startColumn;
          let moduleBitCount = new Int32Array(8);
          let moduleNumber = 0;
          let increment = leftToRight ? 1 : -1;
          let previousPixelValue = leftToRight;
          while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
            if (image.get(imageColumn, imageRow) === previousPixelValue) {
              moduleBitCount[moduleNumber]++;
              imageColumn += increment;
            } else {
              moduleNumber++;
              previousPixelValue = !previousPixelValue;
            }
          }
          if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
            return moduleBitCount;
          }
          return null;
        }
        static getNumberOfECCodeWords(barcodeECLevel) {
          return 2 << barcodeECLevel;
        }
        static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
          let correctedStartColumn = codewordStartColumn;
          let increment = leftToRight ? -1 : 1;
          for (let i3 = 0; i3 < 2; i3++) {
            while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
              if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
                return codewordStartColumn;
              }
              correctedStartColumn += increment;
            }
            increment = -increment;
            leftToRight = !leftToRight;
          }
          return correctedStartColumn;
        }
        static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {
          return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
        }
        /**
         * @throws FormatException,
         * @throws ChecksumException
         */
        static decodeCodewords(codewords, ecLevel, erasures) {
          if (codewords.length === 0) {
            throw FormatException.getFormatInstance();
          }
          let numECCodewords = 1 << ecLevel + 1;
          let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
          PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
          let decoderResult = DecodedBitStreamParser$2.decode(codewords, "" + ecLevel);
          decoderResult.setErrorsCorrected(correctedErrorsCount);
          decoderResult.setErasures(erasures.length);
          return decoderResult;
        }
        /**
         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
         * correct the errors in-place.</p>
         *
         * @param codewords   data and error correction codewords
         * @param erasures positions of any known erasures
         * @param numECCodewords number of error correction codewords that are available in codewords
         * @throws ChecksumException if error correction fails
         */
        static correctErrors(codewords, erasures, numECCodewords) {
          if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
            throw ChecksumException.getChecksumInstance();
          }
          return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
        }
        /**
         * Verify that all is OK with the codeword array.
         * @throws FormatException
         */
        static verifyCodewordCount(codewords, numECCodewords) {
          if (codewords.length < 4) {
            throw FormatException.getFormatInstance();
          }
          let numberOfCodewords = codewords[0];
          if (numberOfCodewords > codewords.length) {
            throw FormatException.getFormatInstance();
          }
          if (numberOfCodewords === 0) {
            if (numECCodewords < codewords.length) {
              codewords[0] = codewords.length - numECCodewords;
            } else {
              throw FormatException.getFormatInstance();
            }
          }
        }
        static getBitCountForCodeword(codeword) {
          let result = new Int32Array(8);
          let previousValue = 0;
          let i3 = result.length - 1;
          while (true) {
            if ((codeword & 1) !== previousValue) {
              previousValue = codeword & 1;
              i3--;
              if (i3 < 0) {
                break;
              }
            }
            result[i3]++;
            codeword >>= 1;
          }
          return result;
        }
        static getCodewordBucketNumber(codeword) {
          if (codeword instanceof Int32Array) {
            return this.getCodewordBucketNumber_Int32Array(codeword);
          }
          return this.getCodewordBucketNumber_number(codeword);
        }
        static getCodewordBucketNumber_number(codeword) {
          return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
        }
        static getCodewordBucketNumber_Int32Array(moduleBitCount) {
          return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
        }
        static toString(barcodeMatrix) {
          let formatter = new Formatter();
          for (let row = 0; row < barcodeMatrix.length; row++) {
            formatter.format("Row %2d: ", row);
            for (let column = 0; column < barcodeMatrix[row].length; column++) {
              let barcodeValue = barcodeMatrix[row][column];
              if (barcodeValue.getValue().length === 0) {
                formatter.format("        ", null);
              } else {
                formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
              }
            }
            formatter.format("%n");
          }
          return formatter.toString();
        }
      }
      PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
      PDF417ScanningDecoder.MAX_ERRORS = 3;
      PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
      PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();
      class PDF417Reader {
        // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);
        /**
         * Locates and decodes a PDF417 code in an image.
         *
         * @return a String representing the content encoded by the PDF417 code
         * @throws NotFoundException if a PDF417 code cannot be found,
         * @throws FormatException if a PDF417 cannot be decoded
         * @throws ChecksumException
         */
        // @Override
        decode(image, hints = null) {
          let result = PDF417Reader.decode(image, hints, false);
          if (result == null || result.length === 0 || result[0] == null) {
            throw NotFoundException.getNotFoundInstance();
          }
          return result[0];
        }
        /**
         *
         * @param BinaryBitmap
         * @param image
         * @throws NotFoundException
         */
        //   @Override
        decodeMultiple(image, hints = null) {
          try {
            return PDF417Reader.decode(image, hints, true);
          } catch (ignored) {
            if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
              throw NotFoundException.getNotFoundInstance();
            }
            throw ignored;
          }
        }
        /**
         *
         * @param image
         * @param hints
         * @param multiple
         *
         * @throws NotFoundException
         * @throws FormatExceptionß
         * @throws ChecksumException
         */
        static decode(image, hints, multiple) {
          const results = new Array();
          const detectorResult = Detector$3.detectMultiple(image, hints, multiple);
          for (const points of detectorResult.getPoints()) {
            const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
            const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.PDF_417);
            result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
            const pdf417ResultMetadata = decoderResult.getOther();
            if (pdf417ResultMetadata != null) {
              result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
            }
            results.push(result);
          }
          return results.map((x2) => x2);
        }
        static getMaxWidth(p1, p2) {
          if (p1 == null || p2 == null) {
            return 0;
          }
          return Math.trunc(Math.abs(p1.getX() - p2.getX()));
        }
        static getMinWidth(p1, p2) {
          if (p1 == null || p2 == null) {
            return Integer.MAX_VALUE;
          }
          return Math.trunc(Math.abs(p1.getX() - p2.getX()));
        }
        static getMaxCodewordWidth(p2) {
          return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p2[0], p2[4]), PDF417Reader.getMaxWidth(p2[6], p2[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p2[1], p2[5]), PDF417Reader.getMaxWidth(p2[7], p2[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
        }
        static getMinCodewordWidth(p2) {
          return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p2[0], p2[4]), PDF417Reader.getMinWidth(p2[6], p2[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p2[1], p2[5]), PDF417Reader.getMinWidth(p2[7], p2[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
        }
        // @Override
        reset() {
        }
      }
      class ReaderException extends Exception {
      }
      ReaderException.kind = "ReaderException";
      class MultiFormatReader2 {
        /**
         * Creates an instance of this class
         * 
         * @param {Boolean} verbose if 'true' logs will be dumped to console, otherwise hidden.
         * @param hints The hints to use, clearing the previous state.
         */
        constructor(verbose, hints) {
          this.verbose = verbose === true;
          if (hints) {
            this.setHints(hints);
          }
        }
        /**
         * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
         * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
         * Use setHints() followed by decodeWithState() for continuous scan applications.
         *
         * @param image The pixel data to decode
         * @return The contents of the image
         *
         * @throws NotFoundException Any errors which occurred
         */
        /*@Override*/
        // public decode(image: BinaryBitmap): Result {
        //   setHints(null)
        //   return decodeInternal(image)
        // }
        /**
         * Decode an image using the hints provided. Does not honor existing state.
         *
         * @param image The pixel data to decode
         * @param hints The hints to use, clearing the previous state.
         * @return The contents of the image
         *
         * @throws NotFoundException Any errors which occurred
         */
        /*@Override*/
        decode(image, hints) {
          if (hints) {
            this.setHints(hints);
          }
          return this.decodeInternal(image);
        }
        /**
         * Decode an image using the state set up by calling setHints() previously. Continuous scan
         * clients will get a <b>large</b> speed increase by using this instead of decode().
         *
         * @param image The pixel data to decode
         * @return The contents of the image
         *
         * @throws NotFoundException Any errors which occurred
         */
        decodeWithState(image) {
          if (this.readers === null || this.readers === void 0) {
            this.setHints(null);
          }
          return this.decodeInternal(image);
        }
        /**
         * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
         * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
         * is important for performance in continuous scan clients.
         *
         * @param hints The set of hints to use for subsequent calls to decode(image)
         */
        setHints(hints) {
          this.hints = hints;
          const tryHarder = !isNullOrUndefined2(hints) && hints.get(DecodeHintType$1.TRY_HARDER) === true;
          const formats = isNullOrUndefined2(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
          const readers = new Array();
          if (!isNullOrUndefined2(formats)) {
            const addOneDReader = formats.some((f2) => {
              return f2 === BarcodeFormat$1.UPC_A || f2 === BarcodeFormat$1.UPC_E || f2 === BarcodeFormat$1.EAN_13 || f2 === BarcodeFormat$1.EAN_8 || f2 === BarcodeFormat$1.CODABAR || f2 === BarcodeFormat$1.CODE_39 || f2 === BarcodeFormat$1.CODE_93 || f2 === BarcodeFormat$1.CODE_128 || f2 === BarcodeFormat$1.ITF || f2 === BarcodeFormat$1.RSS_14 || f2 === BarcodeFormat$1.RSS_EXPANDED;
            });
            if (addOneDReader && !tryHarder) {
              readers.push(new MultiFormatOneDReader(hints, this.verbose));
            }
            if (formats.includes(BarcodeFormat$1.QR_CODE)) {
              readers.push(new QRCodeReader());
            }
            if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
              readers.push(new DataMatrixReader());
            }
            if (formats.includes(BarcodeFormat$1.AZTEC)) {
              readers.push(new AztecReader());
            }
            if (formats.includes(BarcodeFormat$1.PDF_417)) {
              readers.push(new PDF417Reader());
            }
            if (addOneDReader && tryHarder) {
              readers.push(new MultiFormatOneDReader(hints, this.verbose));
            }
          }
          if (readers.length === 0) {
            if (!tryHarder) {
              readers.push(new MultiFormatOneDReader(hints, this.verbose));
            }
            readers.push(new QRCodeReader());
            readers.push(new DataMatrixReader());
            readers.push(new AztecReader());
            readers.push(new PDF417Reader());
            if (tryHarder) {
              readers.push(new MultiFormatOneDReader(hints, this.verbose));
            }
          }
          this.readers = readers;
        }
        /*@Override*/
        reset() {
          if (this.readers !== null) {
            for (const reader of this.readers) {
              reader.reset();
            }
          }
        }
        /**
         * @throws NotFoundException
         */
        decodeInternal(image) {
          if (this.readers === null) {
            throw new ReaderException("No readers where selected, nothing can be read.");
          }
          for (const reader of this.readers) {
            try {
              return reader.decode(image, this.hints);
            } catch (ex) {
              if (ex instanceof ReaderException) {
                continue;
              }
            }
          }
          throw new NotFoundException("No MultiFormat Readers were able to detect the code.");
        }
      }
      class BrowserMultiFormatReader extends BrowserCodeReader {
        constructor(hints = null, timeBetweenScansMillis = 500) {
          const reader = new MultiFormatReader2();
          reader.setHints(hints);
          super(reader, timeBetweenScansMillis);
        }
        /**
         * Overwrite decodeBitmap to call decodeWithState, which will pay
         * attention to the hints set in the constructor function
         */
        decodeBitmap(binaryBitmap) {
          return this.reader.decodeWithState(binaryBitmap);
        }
      }
      class BrowserPDF417Reader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserPDF417Reader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         */
        constructor(timeBetweenScansMillis = 500) {
          super(new PDF417Reader(), timeBetweenScansMillis);
        }
      }
      class BrowserQRCodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserQRCodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         */
        constructor(timeBetweenScansMillis = 500) {
          super(new QRCodeReader(), timeBetweenScansMillis);
        }
      }
      var EncodeHintType;
      (function(EncodeHintType2) {
        EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
        EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
        EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
        EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 3] = "MIN_SIZE";
        EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 4] = "MAX_SIZE";
        EncodeHintType2[EncodeHintType2["MARGIN"] = 5] = "MARGIN";
        EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
        EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
        EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
        EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
        EncodeHintType2[EncodeHintType2["QR_VERSION"] = 10] = "QR_VERSION";
      })(EncodeHintType || (EncodeHintType = {}));
      var EncodeHintType$1 = EncodeHintType;
      class ReedSolomonEncoder {
        /**
         * A reed solomon error-correcting encoding constructor is created by
         * passing as Galois Field with of size equal to the number of code
         * words (symbols) in the alphabet (the number of values in each
         * element of arrays that are encoded/decoded).
         * @param field A galois field with a number of elements equal to the size
         * of the alphabet of symbols to encode.
         */
        constructor(field) {
          this.field = field;
          this.cachedGenerators = [];
          this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));
        }
        buildGenerator(degree) {
          const cachedGenerators = this.cachedGenerators;
          if (degree >= cachedGenerators.length) {
            let lastGenerator = cachedGenerators[cachedGenerators.length - 1];
            const field = this.field;
            for (let d2 = cachedGenerators.length; d2 <= degree; d2++) {
              const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d2 - 1 + field.getGeneratorBase())])));
              cachedGenerators.push(nextGenerator);
              lastGenerator = nextGenerator;
            }
          }
          return cachedGenerators[degree];
        }
        /**
         * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders
         * to detect and correct errors that may have been introduced when the resulting
         * data is stored or transmitted.</p>
         *
         * @param toEncode array used for both and output. Caller initializes the array with
         * the code words (symbols) to be encoded followed by empty elements allocated to make
         * space for error-correction code words in the encoded output. The array contains
         * the encdoded output when encode returns. Code words are encoded as numbers from
         * 0 to n-1, where n is the number of possible code words (symbols), as determined
         * by the size of the Galois Field passed in the constructor of this object.
         * @param ecBytes the number of elements reserved in the array (first parameter)
         * to store error-correction code words. Thus, the number of code words (symbols)
         * to encode in the first parameter is thus toEncode.length - ecBytes.
         * Note, the use of "bytes" in the name of this parameter is misleading, as there may
         * be more or fewer than 256 symbols being encoded, as determined by the number of
         * elements in the Galois Field passed as a constructor to this object.
         * @throws IllegalArgumentException thrown in response to validation errros.
         */
        encode(toEncode, ecBytes) {
          if (ecBytes === 0) {
            throw new IllegalArgumentException("No error correction bytes");
          }
          const dataBytes = toEncode.length - ecBytes;
          if (dataBytes <= 0) {
            throw new IllegalArgumentException("No data bytes provided");
          }
          const generator = this.buildGenerator(ecBytes);
          const infoCoefficients = new Int32Array(dataBytes);
          System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
          let info = new GenericGFPoly(this.field, infoCoefficients);
          info = info.multiplyByMonomial(ecBytes, 1);
          const remainder = info.divide(generator)[1];
          const coefficients = remainder.getCoefficients();
          const numZeroCoefficients = ecBytes - coefficients.length;
          for (let i3 = 0; i3 < numZeroCoefficients; i3++) {
            toEncode[dataBytes + i3] = 0;
          }
          System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
        }
      }
      class MaskUtil {
        constructor() {
        }
        /**
         * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
         * give penalty to them. Example: 00000 or 11111.
         */
        static applyMaskPenaltyRule1(matrix) {
          return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
        }
        /**
         * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
         * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
         * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
         */
        static applyMaskPenaltyRule2(matrix) {
          let penalty = 0;
          const array = matrix.getArray();
          const width = matrix.getWidth();
          const height = matrix.getHeight();
          for (let y2 = 0; y2 < height - 1; y2++) {
            const arrayY = array[y2];
            for (let x2 = 0; x2 < width - 1; x2++) {
              const value2 = arrayY[x2];
              if (value2 === arrayY[x2 + 1] && value2 === array[y2 + 1][x2] && value2 === array[y2 + 1][x2 + 1]) {
                penalty++;
              }
            }
          }
          return MaskUtil.N2 * penalty;
        }
        /**
         * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
         * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
         * find patterns like 000010111010000, we give penalty once.
         */
        static applyMaskPenaltyRule3(matrix) {
          let numPenalties = 0;
          const array = matrix.getArray();
          const width = matrix.getWidth();
          const height = matrix.getHeight();
          for (let y2 = 0; y2 < height; y2++) {
            for (let x2 = 0; x2 < width; x2++) {
              const arrayY = array[y2];
              if (x2 + 6 < width && arrayY[x2] === 1 && arrayY[x2 + 1] === 0 && arrayY[x2 + 2] === 1 && arrayY[x2 + 3] === 1 && arrayY[x2 + 4] === 1 && arrayY[x2 + 5] === 0 && arrayY[x2 + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x2 - 4, x2) || MaskUtil.isWhiteHorizontal(arrayY, x2 + 7, x2 + 11))) {
                numPenalties++;
              }
              if (y2 + 6 < height && array[y2][x2] === 1 && array[y2 + 1][x2] === 0 && array[y2 + 2][x2] === 1 && array[y2 + 3][x2] === 1 && array[y2 + 4][x2] === 1 && array[y2 + 5][x2] === 0 && array[y2 + 6][x2] === 1 && (MaskUtil.isWhiteVertical(array, x2, y2 - 4, y2) || MaskUtil.isWhiteVertical(array, x2, y2 + 7, y2 + 11))) {
                numPenalties++;
              }
            }
          }
          return numPenalties * MaskUtil.N3;
        }
        static isWhiteHorizontal(rowArray, from2, to) {
          from2 = Math.max(from2, 0);
          to = Math.min(to, rowArray.length);
          for (let i3 = from2; i3 < to; i3++) {
            if (rowArray[i3] === 1) {
              return false;
            }
          }
          return true;
        }
        static isWhiteVertical(array, col, from2, to) {
          from2 = Math.max(from2, 0);
          to = Math.min(to, array.length);
          for (let i3 = from2; i3 < to; i3++) {
            if (array[i3][col] === 1) {
              return false;
            }
          }
          return true;
        }
        /**
         * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
         * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
         */
        static applyMaskPenaltyRule4(matrix) {
          let numDarkCells = 0;
          const array = matrix.getArray();
          const width = matrix.getWidth();
          const height = matrix.getHeight();
          for (let y2 = 0; y2 < height; y2++) {
            const arrayY = array[y2];
            for (let x2 = 0; x2 < width; x2++) {
              if (arrayY[x2] === 1) {
                numDarkCells++;
              }
            }
          }
          const numTotalCells = matrix.getHeight() * matrix.getWidth();
          const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
          return fivePercentVariances * MaskUtil.N4;
        }
        /**
         * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
         * pattern conditions.
         */
        static getDataMaskBit(maskPattern, x2, y2) {
          let intermediate;
          let temp;
          switch (maskPattern) {
            case 0:
              intermediate = y2 + x2 & 1;
              break;
            case 1:
              intermediate = y2 & 1;
              break;
            case 2:
              intermediate = x2 % 3;
              break;
            case 3:
              intermediate = (y2 + x2) % 3;
              break;
            case 4:
              intermediate = Math.floor(y2 / 2) + Math.floor(x2 / 3) & 1;
              break;
            case 5:
              temp = y2 * x2;
              intermediate = (temp & 1) + temp % 3;
              break;
            case 6:
              temp = y2 * x2;
              intermediate = (temp & 1) + temp % 3 & 1;
              break;
            case 7:
              temp = y2 * x2;
              intermediate = temp % 3 + (y2 + x2 & 1) & 1;
              break;
            default:
              throw new IllegalArgumentException("Invalid mask pattern: " + maskPattern);
          }
          return intermediate === 0;
        }
        /**
         * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
         * vertical and horizontal orders respectively.
         */
        static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {
          let penalty = 0;
          const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
          const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
          const array = matrix.getArray();
          for (let i3 = 0; i3 < iLimit; i3++) {
            let numSameBitCells = 0;
            let prevBit = -1;
            for (let j2 = 0; j2 < jLimit; j2++) {
              const bit = isHorizontal ? array[i3][j2] : array[j2][i3];
              if (bit === prevBit) {
                numSameBitCells++;
              } else {
                if (numSameBitCells >= 5) {
                  penalty += MaskUtil.N1 + (numSameBitCells - 5);
                }
                numSameBitCells = 1;
                prevBit = bit;
              }
            }
            if (numSameBitCells >= 5) {
              penalty += MaskUtil.N1 + (numSameBitCells - 5);
            }
          }
          return penalty;
        }
      }
      MaskUtil.N1 = 3;
      MaskUtil.N2 = 3;
      MaskUtil.N3 = 40;
      MaskUtil.N4 = 10;
      class ByteMatrix {
        constructor(width, height) {
          this.width = width;
          this.height = height;
          const bytes = new Array(height);
          for (let i3 = 0; i3 !== height; i3++) {
            bytes[i3] = new Uint8Array(width);
          }
          this.bytes = bytes;
        }
        getHeight() {
          return this.height;
        }
        getWidth() {
          return this.width;
        }
        get(x2, y2) {
          return this.bytes[y2][x2];
        }
        /**
         * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
         */
        getArray() {
          return this.bytes;
        }
        // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside
        setNumber(x2, y2, value2) {
          this.bytes[y2][x2] = value2;
        }
        // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {
        //   bytes[y][x] = (byte) value
        // }
        setBoolean(x2, y2, value2) {
          this.bytes[y2][x2] = /*(byte) */
          value2 ? 1 : 0;
        }
        clear(value2) {
          for (const aByte of this.bytes) {
            Arrays.fill(aByte, value2);
          }
        }
        equals(o2) {
          if (!(o2 instanceof ByteMatrix)) {
            return false;
          }
          const other = o2;
          if (this.width !== other.width) {
            return false;
          }
          if (this.height !== other.height) {
            return false;
          }
          for (let y2 = 0, height = this.height; y2 < height; ++y2) {
            const bytesY = this.bytes[y2];
            const otherBytesY = other.bytes[y2];
            for (let x2 = 0, width = this.width; x2 < width; ++x2) {
              if (bytesY[x2] !== otherBytesY[x2]) {
                return false;
              }
            }
          }
          return true;
        }
        /*@Override*/
        toString() {
          const result = new StringBuilder();
          for (let y2 = 0, height = this.height; y2 < height; ++y2) {
            const bytesY = this.bytes[y2];
            for (let x2 = 0, width = this.width; x2 < width; ++x2) {
              switch (bytesY[x2]) {
                case 0:
                  result.append(" 0");
                  break;
                case 1:
                  result.append(" 1");
                  break;
                default:
                  result.append("  ");
                  break;
              }
            }
            result.append("\n");
          }
          return result.toString();
        }
      }
      class QRCode {
        constructor() {
          this.maskPattern = -1;
        }
        getMode() {
          return this.mode;
        }
        getECLevel() {
          return this.ecLevel;
        }
        getVersion() {
          return this.version;
        }
        getMaskPattern() {
          return this.maskPattern;
        }
        getMatrix() {
          return this.matrix;
        }
        /*@Override*/
        toString() {
          const result = new StringBuilder();
          result.append("<<\n");
          result.append(" mode: ");
          result.append(this.mode ? this.mode.toString() : "null");
          result.append("\n ecLevel: ");
          result.append(this.ecLevel ? this.ecLevel.toString() : "null");
          result.append("\n version: ");
          result.append(this.version ? this.version.toString() : "null");
          result.append("\n maskPattern: ");
          result.append(this.maskPattern.toString());
          if (this.matrix) {
            result.append("\n matrix:\n");
            result.append(this.matrix.toString());
          } else {
            result.append("\n matrix: null\n");
          }
          result.append(">>\n");
          return result.toString();
        }
        setMode(value2) {
          this.mode = value2;
        }
        setECLevel(value2) {
          this.ecLevel = value2;
        }
        setVersion(version) {
          this.version = version;
        }
        setMaskPattern(value2) {
          this.maskPattern = value2;
        }
        setMatrix(value2) {
          this.matrix = value2;
        }
        // Check if "mask_pattern" is valid.
        static isValidMaskPattern(maskPattern) {
          return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
        }
      }
      QRCode.NUM_MASK_PATTERNS = 8;
      class WriterException extends Exception {
      }
      WriterException.kind = "WriterException";
      class MatrixUtil {
        constructor() {
        }
        // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).
        //
        // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
        // with the ByteMatrix initialized all to zero.
        static clearMatrix(matrix) {
          matrix.clear(
            /*(byte) */
            /*-1*/
            255
          );
        }
        // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
        // success, store the result in "matrix" and return true.
        static buildMatrix(dataBits, ecLevel, version, maskPattern, matrix) {
          MatrixUtil.clearMatrix(matrix);
          MatrixUtil.embedBasicPatterns(version, matrix);
          MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
          MatrixUtil.maybeEmbedVersionInfo(version, matrix);
          MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
        }
        // Embed basic patterns. On success, modify the matrix and return true.
        // The basic patterns are:
        // - Position detection patterns
        // - Timing patterns
        // - Dark dot at the left bottom corner
        // - Position adjustment patterns, if need be
        static embedBasicPatterns(version, matrix) {
          MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
          MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
          MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);
          MatrixUtil.embedTimingPatterns(matrix);
        }
        // Embed type information. On success, modify the matrix.
        static embedTypeInfo(ecLevel, maskPattern, matrix) {
          const typeInfoBits = new BitArray();
          MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
          for (let i3 = 0, size = typeInfoBits.getSize(); i3 < size; ++i3) {
            const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i3);
            const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i3];
            const x1 = coordinates[0];
            const y1 = coordinates[1];
            matrix.setBoolean(x1, y1, bit);
            if (i3 < 8) {
              const x2 = matrix.getWidth() - i3 - 1;
              const y2 = 8;
              matrix.setBoolean(x2, y2, bit);
            } else {
              const x2 = 8;
              const y2 = matrix.getHeight() - 7 + (i3 - 8);
              matrix.setBoolean(x2, y2, bit);
            }
          }
        }
        // Embed version information if need be. On success, modify the matrix and return true.
        // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
        static maybeEmbedVersionInfo(version, matrix) {
          if (version.getVersionNumber() < 7) {
            return;
          }
          const versionInfoBits = new BitArray();
          MatrixUtil.makeVersionInfoBits(version, versionInfoBits);
          let bitIndex = 6 * 3 - 1;
          for (let i3 = 0; i3 < 6; ++i3) {
            for (let j2 = 0; j2 < 3; ++j2) {
              const bit = versionInfoBits.get(bitIndex);
              bitIndex--;
              matrix.setBoolean(i3, matrix.getHeight() - 11 + j2, bit);
              matrix.setBoolean(matrix.getHeight() - 11 + j2, i3, bit);
            }
          }
        }
        // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
        // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).
        // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
        static embedDataBits(dataBits, maskPattern, matrix) {
          let bitIndex = 0;
          let direction = -1;
          let x2 = matrix.getWidth() - 1;
          let y2 = matrix.getHeight() - 1;
          while (x2 > 0) {
            if (x2 === 6) {
              x2 -= 1;
            }
            while (y2 >= 0 && y2 < matrix.getHeight()) {
              for (let i3 = 0; i3 < 2; ++i3) {
                const xx = x2 - i3;
                if (!MatrixUtil.isEmpty(matrix.get(xx, y2))) {
                  continue;
                }
                let bit;
                if (bitIndex < dataBits.getSize()) {
                  bit = dataBits.get(bitIndex);
                  ++bitIndex;
                } else {
                  bit = false;
                }
                if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y2)) {
                  bit = !bit;
                }
                matrix.setBoolean(xx, y2, bit);
              }
              y2 += direction;
            }
            direction = -direction;
            y2 += direction;
            x2 -= 2;
          }
          if (bitIndex !== dataBits.getSize()) {
            throw new WriterException("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
          }
        }
        // Return the position of the most significant bit set (one: to) in the "value". The most
        // significant bit is position 32. If there is no bit set, return 0. Examples:
        // - findMSBSet(0) => 0
        // - findMSBSet(1) => 1
        // - findMSBSet(255) => 8
        static findMSBSet(value2) {
          return 32 - Integer.numberOfLeadingZeros(value2);
        }
        // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
        // code is used for encoding type information and version information.
        // Example: Calculation of version information of 7.
        // f(x) is created from 7.
        //   - 7 = 000111 in 6 bits
        //   - f(x) = x^2 + x^1 + x^0
        // g(x) is given by the standard (p. 67)
        //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
        // Multiply f(x) by x^(18 - 6)
        //   - f'(x) = f(x) * x^(18 - 6)
        //   - f'(x) = x^14 + x^13 + x^12
        // Calculate the remainder of f'(x) / g(x)
        //         x^2
        //         __________________________________________________
        //   g(x) )x^14 + x^13 + x^12
        //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
        //         --------------------------------------------------
        //                              x^11 + x^10 + x^7 + x^4 + x^2
        //
        // The remainder is x^11 + x^10 + x^7 + x^4 + x^2
        // Encode it in binary: 110010010100
        // The return value is 0xc94 (1100 1001 0100)
        //
        // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
        // operations. We don't care if coefficients are positive or negative.
        static calculateBCHCode(value2, poly) {
          if (poly === 0) {
            throw new IllegalArgumentException("0 polynomial");
          }
          const msbSetInPoly = MatrixUtil.findMSBSet(poly);
          value2 <<= msbSetInPoly - 1;
          while (MatrixUtil.findMSBSet(value2) >= msbSetInPoly) {
            value2 ^= poly << MatrixUtil.findMSBSet(value2) - msbSetInPoly;
          }
          return value2;
        }
        // Make bit vector of type information. On success, store the result in "bits" and return true.
        // Encode error correction level and mask pattern. See 8.9 of
        // JISX0510:2004 (p.45) for details.
        static makeTypeInfoBits(ecLevel, maskPattern, bits2) {
          if (!QRCode.isValidMaskPattern(maskPattern)) {
            throw new WriterException("Invalid mask pattern");
          }
          const typeInfo = ecLevel.getBits() << 3 | maskPattern;
          bits2.appendBits(typeInfo, 5);
          const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
          bits2.appendBits(bchCode, 10);
          const maskBits = new BitArray();
          maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
          bits2.xor(maskBits);
          if (bits2.getSize() !== 15) {
            throw new WriterException("should not happen but we got: " + bits2.getSize());
          }
        }
        // Make bit vector of version information. On success, store the result in "bits" and return true.
        // See 8.10 of JISX0510:2004 (p.45) for details.
        static makeVersionInfoBits(version, bits2) {
          bits2.appendBits(version.getVersionNumber(), 6);
          const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
          bits2.appendBits(bchCode, 12);
          if (bits2.getSize() !== 18) {
            throw new WriterException("should not happen but we got: " + bits2.getSize());
          }
        }
        // Check if "value" is empty.
        static isEmpty(value2) {
          return value2 === 255;
        }
        static embedTimingPatterns(matrix) {
          for (let i3 = 8; i3 < matrix.getWidth() - 8; ++i3) {
            const bit = (i3 + 1) % 2;
            if (MatrixUtil.isEmpty(matrix.get(i3, 6))) {
              matrix.setNumber(i3, 6, bit);
            }
            if (MatrixUtil.isEmpty(matrix.get(6, i3))) {
              matrix.setNumber(6, i3, bit);
            }
          }
        }
        // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
        static embedDarkDotAtLeftBottomCorner(matrix) {
          if (matrix.get(8, matrix.getHeight() - 8) === 0) {
            throw new WriterException();
          }
          matrix.setNumber(8, matrix.getHeight() - 8, 1);
        }
        static embedHorizontalSeparationPattern(xStart, yStart, matrix) {
          for (let x2 = 0; x2 < 8; ++x2) {
            if (!MatrixUtil.isEmpty(matrix.get(xStart + x2, yStart))) {
              throw new WriterException();
            }
            matrix.setNumber(xStart + x2, yStart, 0);
          }
        }
        static embedVerticalSeparationPattern(xStart, yStart, matrix) {
          for (let y2 = 0; y2 < 7; ++y2) {
            if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y2))) {
              throw new WriterException();
            }
            matrix.setNumber(xStart, yStart + y2, 0);
          }
        }
        static embedPositionAdjustmentPattern(xStart, yStart, matrix) {
          for (let y2 = 0; y2 < 5; ++y2) {
            const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y2];
            for (let x2 = 0; x2 < 5; ++x2) {
              matrix.setNumber(xStart + x2, yStart + y2, patternY[x2]);
            }
          }
        }
        static embedPositionDetectionPattern(xStart, yStart, matrix) {
          for (let y2 = 0; y2 < 7; ++y2) {
            const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y2];
            for (let x2 = 0; x2 < 7; ++x2) {
              matrix.setNumber(xStart + x2, yStart + y2, patternY[x2]);
            }
          }
        }
        // Embed position detection patterns and surrounding vertical/horizontal separators.
        static embedPositionDetectionPatternsAndSeparators(matrix) {
          const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
          MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
          MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
          MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
          const hspWidth = 8;
          MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
          MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
          MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
          const vspSize = 7;
          MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
          MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
          MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
        }
        // Embed position adjustment patterns if need be.
        static maybeEmbedPositionAdjustmentPatterns(version, matrix) {
          if (version.getVersionNumber() < 2) {
            return;
          }
          const index = version.getVersionNumber() - 1;
          const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
          for (let i3 = 0, length2 = coordinates.length; i3 !== length2; i3++) {
            const y2 = coordinates[i3];
            if (y2 >= 0) {
              for (let j2 = 0; j2 !== length2; j2++) {
                const x2 = coordinates[j2];
                if (x2 >= 0 && MatrixUtil.isEmpty(matrix.get(x2, y2))) {
                  MatrixUtil.embedPositionAdjustmentPattern(x2 - 2, y2 - 2, matrix);
                }
              }
            }
          }
        }
      }
      MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1, 1, 1])
      ]);
      MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1])
      ]);
      MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
        Int32Array.from([6, 30, 58, 86, 114, 142, 170])
      ]);
      MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
        Int32Array.from([8, 0]),
        Int32Array.from([8, 1]),
        Int32Array.from([8, 2]),
        Int32Array.from([8, 3]),
        Int32Array.from([8, 4]),
        Int32Array.from([8, 5]),
        Int32Array.from([8, 7]),
        Int32Array.from([8, 8]),
        Int32Array.from([7, 8]),
        Int32Array.from([5, 8]),
        Int32Array.from([4, 8]),
        Int32Array.from([3, 8]),
        Int32Array.from([2, 8]),
        Int32Array.from([1, 8]),
        Int32Array.from([0, 8])
      ]);
      MatrixUtil.VERSION_INFO_POLY = 7973;
      MatrixUtil.TYPE_INFO_POLY = 1335;
      MatrixUtil.TYPE_INFO_MASK_PATTERN = 21522;
      class BlockPair {
        constructor(dataBytes, errorCorrectionBytes) {
          this.dataBytes = dataBytes;
          this.errorCorrectionBytes = errorCorrectionBytes;
        }
        getDataBytes() {
          return this.dataBytes;
        }
        getErrorCorrectionBytes() {
          return this.errorCorrectionBytes;
        }
      }
      class Encoder2 {
        // TYPESCRIPTPORT: changed to UTF8, the default for js
        constructor() {
        }
        // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
        // Basically it applies four rules and summate all penalties.
        static calculateMaskPenalty(matrix) {
          return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);
        }
        /**
         * @param content text to encode
         * @param ecLevel error correction level to use
         * @return {@link QRCode} representing the encoded QR code
         * @throws WriterException if encoding can't succeed, because of for example invalid content
         *   or configuration
         */
        // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {
        //   return encode(content, ecLevel, null)
        // }
        static encode(content, ecLevel, hints = null) {
          let encoding = Encoder2.DEFAULT_BYTE_MODE_ENCODING;
          const hasEncodingHint = hints !== null && void 0 !== hints.get(EncodeHintType$1.CHARACTER_SET);
          if (hasEncodingHint) {
            encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
          }
          const mode = this.chooseMode(content, encoding);
          const headerBits = new BitArray();
          if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder2.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
            const eci = CharacterSetECI.getCharacterSetECIByName(encoding);
            if (eci !== void 0) {
              this.appendECI(eci, headerBits);
            }
          }
          this.appendModeInfo(mode, headerBits);
          const dataBits = new BitArray();
          this.appendBytes(content, mode, dataBits, encoding);
          let version;
          if (hints !== null && void 0 !== hints.get(EncodeHintType$1.QR_VERSION)) {
            const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
            version = Version$1.getVersionForNumber(versionNumber);
            const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
            if (!this.willFit(bitsNeeded, version, ecLevel)) {
              throw new WriterException("Data too big for requested version");
            }
          } else {
            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
          }
          const headerAndDataBits = new BitArray();
          headerAndDataBits.appendBitArray(headerBits);
          const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
          this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
          headerAndDataBits.appendBitArray(dataBits);
          const ecBlocks = version.getECBlocksForLevel(ecLevel);
          const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
          this.terminateBits(numDataBytes, headerAndDataBits);
          const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
          const qrCode = new QRCode();
          qrCode.setECLevel(ecLevel);
          qrCode.setMode(mode);
          qrCode.setVersion(version);
          const dimension = version.getDimensionForVersion();
          const matrix = new ByteMatrix(dimension, dimension);
          const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
          qrCode.setMaskPattern(maskPattern);
          MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
          qrCode.setMatrix(matrix);
          return qrCode;
        }
        /**
         * Decides the smallest version of QR code that will contain all of the provided data.
         *
         * @throws WriterException if the data cannot fit in any version
         */
        static recommendVersion(ecLevel, mode, headerBits, dataBits) {
          const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
          const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
          const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
          return this.chooseVersion(bitsNeeded, ecLevel);
        }
        static calculateBitsNeeded(mode, headerBits, dataBits, version) {
          return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
        }
        /**
         * @return the code point of the table used in alphanumeric mode or
         *  -1 if there is no corresponding code in the table.
         */
        static getAlphanumericCode(code) {
          if (code < Encoder2.ALPHANUMERIC_TABLE.length) {
            return Encoder2.ALPHANUMERIC_TABLE[code];
          }
          return -1;
        }
        // public static chooseMode(content: string): Mode {
        //   return chooseMode(content, null);
        // }
        /**
         * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
         * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
         */
        static chooseMode(content, encoding = null) {
          if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
            return Mode$1.KANJI;
          }
          let hasNumeric = false;
          let hasAlphanumeric = false;
          for (let i3 = 0, length2 = content.length; i3 < length2; ++i3) {
            const c2 = content.charAt(i3);
            if (Encoder2.isDigit(c2)) {
              hasNumeric = true;
            } else if (this.getAlphanumericCode(c2.charCodeAt(0)) !== -1) {
              hasAlphanumeric = true;
            } else {
              return Mode$1.BYTE;
            }
          }
          if (hasAlphanumeric) {
            return Mode$1.ALPHANUMERIC;
          }
          if (hasNumeric) {
            return Mode$1.NUMERIC;
          }
          return Mode$1.BYTE;
        }
        static isOnlyDoubleByteKanji(content) {
          let bytes;
          try {
            bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
          } catch (ignored) {
            return false;
          }
          const length2 = bytes.length;
          if (length2 % 2 !== 0) {
            return false;
          }
          for (let i3 = 0; i3 < length2; i3 += 2) {
            const byte1 = bytes[i3] & 255;
            if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
              return false;
            }
          }
          return true;
        }
        static chooseMaskPattern(bits2, ecLevel, version, matrix) {
          let minPenalty = Number.MAX_SAFE_INTEGER;
          let bestMaskPattern = -1;
          for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
            MatrixUtil.buildMatrix(bits2, ecLevel, version, maskPattern, matrix);
            let penalty = this.calculateMaskPenalty(matrix);
            if (penalty < minPenalty) {
              minPenalty = penalty;
              bestMaskPattern = maskPattern;
            }
          }
          return bestMaskPattern;
        }
        static chooseVersion(numInputBits, ecLevel) {
          for (let versionNum = 1; versionNum <= 40; versionNum++) {
            const version = Version$1.getVersionForNumber(versionNum);
            if (Encoder2.willFit(numInputBits, version, ecLevel)) {
              return version;
            }
          }
          throw new WriterException("Data too big");
        }
        /**
         * @return true if the number of input bits will fit in a code with the specified version and
         * error correction level.
         */
        static willFit(numInputBits, version, ecLevel) {
          const numBytes = version.getTotalCodewords();
          const ecBlocks = version.getECBlocksForLevel(ecLevel);
          const numEcBytes = ecBlocks.getTotalECCodewords();
          const numDataBytes = numBytes - numEcBytes;
          const totalInputBytes = (numInputBits + 7) / 8;
          return numDataBytes >= totalInputBytes;
        }
        /**
         * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
         */
        static terminateBits(numDataBytes, bits2) {
          const capacity = numDataBytes * 8;
          if (bits2.getSize() > capacity) {
            throw new WriterException("data bits cannot fit in the QR Code" + bits2.getSize() + " > " + capacity);
          }
          for (let i3 = 0; i3 < 4 && bits2.getSize() < capacity; ++i3) {
            bits2.appendBit(false);
          }
          const numBitsInLastByte = bits2.getSize() & 7;
          if (numBitsInLastByte > 0) {
            for (let i3 = numBitsInLastByte; i3 < 8; i3++) {
              bits2.appendBit(false);
            }
          }
          const numPaddingBytes = numDataBytes - bits2.getSizeInBytes();
          for (let i3 = 0; i3 < numPaddingBytes; ++i3) {
            bits2.appendBits((i3 & 1) === 0 ? 236 : 17, 8);
          }
          if (bits2.getSize() !== capacity) {
            throw new WriterException("Bits size does not equal capacity");
          }
        }
        /**
         * Get number of data bytes and number of error correction bytes for block id "blockID". Store
         * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
         * JISX0510:2004 (p.30)
         */
        static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
          if (blockID >= numRSBlocks) {
            throw new WriterException("Block ID too large");
          }
          const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
          const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
          const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
          const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
          const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
          const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
          const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
          const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
          if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
            throw new WriterException("EC bytes mismatch");
          }
          if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
            throw new WriterException("RS blocks mismatch");
          }
          if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
            throw new WriterException("Total bytes mismatch");
          }
          if (blockID < numRsBlocksInGroup1) {
            numDataBytesInBlock[0] = numDataBytesInGroup1;
            numECBytesInBlock[0] = numEcBytesInGroup1;
          } else {
            numDataBytesInBlock[0] = numDataBytesInGroup2;
            numECBytesInBlock[0] = numEcBytesInGroup2;
          }
        }
        /**
         * Interleave "bits" with corresponding error correction bytes. On success, store the result in
         * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
         */
        static interleaveWithECBytes(bits2, numTotalBytes, numDataBytes, numRSBlocks) {
          if (bits2.getSizeInBytes() !== numDataBytes) {
            throw new WriterException("Number of bits and data bytes does not match");
          }
          let dataBytesOffset = 0;
          let maxNumDataBytes = 0;
          let maxNumEcBytes = 0;
          const blocks = new Array();
          for (let i3 = 0; i3 < numRSBlocks; ++i3) {
            const numDataBytesInBlock = new Int32Array(1);
            const numEcBytesInBlock = new Int32Array(1);
            Encoder2.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i3, numDataBytesInBlock, numEcBytesInBlock);
            const size = numDataBytesInBlock[0];
            const dataBytes = new Uint8Array(size);
            bits2.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
            const ecBytes = Encoder2.generateECBytes(dataBytes, numEcBytesInBlock[0]);
            blocks.push(new BlockPair(dataBytes, ecBytes));
            maxNumDataBytes = Math.max(maxNumDataBytes, size);
            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
            dataBytesOffset += numDataBytesInBlock[0];
          }
          if (numDataBytes !== dataBytesOffset) {
            throw new WriterException("Data bytes does not match offset");
          }
          const result = new BitArray();
          for (let i3 = 0; i3 < maxNumDataBytes; ++i3) {
            for (const block of blocks) {
              const dataBytes = block.getDataBytes();
              if (i3 < dataBytes.length) {
                result.appendBits(dataBytes[i3], 8);
              }
            }
          }
          for (let i3 = 0; i3 < maxNumEcBytes; ++i3) {
            for (const block of blocks) {
              const ecBytes = block.getErrorCorrectionBytes();
              if (i3 < ecBytes.length) {
                result.appendBits(ecBytes[i3], 8);
              }
            }
          }
          if (numTotalBytes !== result.getSizeInBytes()) {
            throw new WriterException("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
          }
          return result;
        }
        static generateECBytes(dataBytes, numEcBytesInBlock) {
          const numDataBytes = dataBytes.length;
          const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
          for (let i3 = 0; i3 < numDataBytes; i3++) {
            toEncode[i3] = dataBytes[i3] & 255;
          }
          new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
          const ecBytes = new Uint8Array(numEcBytesInBlock);
          for (let i3 = 0; i3 < numEcBytesInBlock; i3++) {
            ecBytes[i3] = /*(byte) */
            toEncode[numDataBytes + i3];
          }
          return ecBytes;
        }
        /**
         * Append mode info. On success, store the result in "bits".
         */
        static appendModeInfo(mode, bits2) {
          bits2.appendBits(mode.getBits(), 4);
        }
        /**
         * Append length info. On success, store the result in "bits".
         */
        static appendLengthInfo(numLetters, version, mode, bits2) {
          const numBits = mode.getCharacterCountBits(version);
          if (numLetters >= 1 << numBits) {
            throw new WriterException(numLetters + " is bigger than " + ((1 << numBits) - 1));
          }
          bits2.appendBits(numLetters, numBits);
        }
        /**
         * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
         */
        static appendBytes(content, mode, bits2, encoding) {
          switch (mode) {
            case Mode$1.NUMERIC:
              Encoder2.appendNumericBytes(content, bits2);
              break;
            case Mode$1.ALPHANUMERIC:
              Encoder2.appendAlphanumericBytes(content, bits2);
              break;
            case Mode$1.BYTE:
              Encoder2.append8BitBytes(content, bits2, encoding);
              break;
            case Mode$1.KANJI:
              Encoder2.appendKanjiBytes(content, bits2);
              break;
            default:
              throw new WriterException("Invalid mode: " + mode);
          }
        }
        static getDigit(singleCharacter) {
          return singleCharacter.charCodeAt(0) - 48;
        }
        static isDigit(singleCharacter) {
          const cn = Encoder2.getDigit(singleCharacter);
          return cn >= 0 && cn <= 9;
        }
        static appendNumericBytes(content, bits2) {
          const length2 = content.length;
          let i3 = 0;
          while (i3 < length2) {
            const num1 = Encoder2.getDigit(content.charAt(i3));
            if (i3 + 2 < length2) {
              const num2 = Encoder2.getDigit(content.charAt(i3 + 1));
              const num3 = Encoder2.getDigit(content.charAt(i3 + 2));
              bits2.appendBits(num1 * 100 + num2 * 10 + num3, 10);
              i3 += 3;
            } else if (i3 + 1 < length2) {
              const num2 = Encoder2.getDigit(content.charAt(i3 + 1));
              bits2.appendBits(num1 * 10 + num2, 7);
              i3 += 2;
            } else {
              bits2.appendBits(num1, 4);
              i3++;
            }
          }
        }
        static appendAlphanumericBytes(content, bits2) {
          const length2 = content.length;
          let i3 = 0;
          while (i3 < length2) {
            const code1 = Encoder2.getAlphanumericCode(content.charCodeAt(i3));
            if (code1 === -1) {
              throw new WriterException();
            }
            if (i3 + 1 < length2) {
              const code2 = Encoder2.getAlphanumericCode(content.charCodeAt(i3 + 1));
              if (code2 === -1) {
                throw new WriterException();
              }
              bits2.appendBits(code1 * 45 + code2, 11);
              i3 += 2;
            } else {
              bits2.appendBits(code1, 6);
              i3++;
            }
          }
        }
        static append8BitBytes(content, bits2, encoding) {
          let bytes;
          try {
            bytes = StringEncoding.encode(content, encoding);
          } catch (uee) {
            throw new WriterException(uee);
          }
          for (let i3 = 0, length2 = bytes.length; i3 !== length2; i3++) {
            const b2 = bytes[i3];
            bits2.appendBits(b2, 8);
          }
        }
        /**
         * @throws WriterException
         */
        static appendKanjiBytes(content, bits2) {
          let bytes;
          try {
            bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
          } catch (uee) {
            throw new WriterException(uee);
          }
          const length2 = bytes.length;
          for (let i3 = 0; i3 < length2; i3 += 2) {
            const byte1 = bytes[i3] & 255;
            const byte2 = bytes[i3 + 1] & 255;
            const code = byte1 << 8 & 4294967295 | byte2;
            let subtracted = -1;
            if (code >= 33088 && code <= 40956) {
              subtracted = code - 33088;
            } else if (code >= 57408 && code <= 60351) {
              subtracted = code - 49472;
            }
            if (subtracted === -1) {
              throw new WriterException("Invalid byte sequence");
            }
            const encoded = (subtracted >> 8) * 192 + (subtracted & 255);
            bits2.appendBits(encoded, 13);
          }
        }
        static appendECI(eci, bits2) {
          bits2.appendBits(Mode$1.ECI.getBits(), 4);
          bits2.appendBits(eci.getValue(), 8);
        }
      }
      Encoder2.ALPHANUMERIC_TABLE = Int32Array.from([
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        36,
        -1,
        -1,
        -1,
        37,
        38,
        -1,
        -1,
        -1,
        -1,
        39,
        40,
        -1,
        41,
        42,
        43,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        44,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        -1,
        -1,
        -1,
        -1,
        -1
      ]);
      Encoder2.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName();
      class BrowserQRCodeSvgWriter {
        /**
         * Writes and renders a QRCode SVG element.
         *
         * @param contents
         * @param width
         * @param height
         * @param hints
         */
        write(contents, width, height, hints = null) {
          if (contents.length === 0) {
            throw new IllegalArgumentException("Found empty contents");
          }
          if (width < 0 || height < 0) {
            throw new IllegalArgumentException("Requested dimensions are too small: " + width + "x" + height);
          }
          let errorCorrectionLevel = ErrorCorrectionLevel.L;
          let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
          if (hints !== null) {
            if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
              errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
            }
            if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
              quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
            }
          }
          const code = Encoder2.encode(contents, errorCorrectionLevel, hints);
          return this.renderResult(code, width, height, quietZone);
        }
        /**
         * Renders the result and then appends it to the DOM.
         */
        writeToDom(containerElement, contents, width, height, hints = null) {
          if (typeof containerElement === "string") {
            containerElement = document.querySelector(containerElement);
          }
          const svgElement = this.write(contents, width, height, hints);
          if (containerElement)
            containerElement.appendChild(svgElement);
        }
        /**
         * Note that the input matrix uses 0 == white, 1 == black.
         * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
         */
        renderResult(code, width, height, quietZone) {
          const input = code.getMatrix();
          if (input === null) {
            throw new IllegalStateException();
          }
          const inputWidth = input.getWidth();
          const inputHeight = input.getHeight();
          const qrWidth = inputWidth + quietZone * 2;
          const qrHeight = inputHeight + quietZone * 2;
          const outputWidth = Math.max(width, qrWidth);
          const outputHeight = Math.max(height, qrHeight);
          const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
          const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
          const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
          const svgElement = this.createSVGElement(outputWidth, outputHeight);
          for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
            for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
              if (input.get(inputX, inputY) === 1) {
                const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
                svgElement.appendChild(svgRectElement);
              }
            }
          }
          return svgElement;
        }
        /**
         * Creates a SVG element.
         *
         * @param w SVG's width attribute
         * @param h SVG's height attribute
         */
        createSVGElement(w2, h2) {
          const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "svg");
          svgElement.setAttributeNS(null, "height", w2.toString());
          svgElement.setAttributeNS(null, "width", h2.toString());
          return svgElement;
        }
        /**
         * Creates a SVG rect element.
         *
         * @param x Element's x coordinate
         * @param y Element's y coordinate
         * @param w Element's width attribute
         * @param h Element's height attribute
         */
        createSvgRectElement(x2, y2, w2, h2) {
          const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "rect");
          rect.setAttributeNS(null, "x", x2.toString());
          rect.setAttributeNS(null, "y", y2.toString());
          rect.setAttributeNS(null, "height", w2.toString());
          rect.setAttributeNS(null, "width", h2.toString());
          rect.setAttributeNS(null, "fill", "#000000");
          return rect;
        }
      }
      BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
      BrowserQRCodeSvgWriter.SVG_NS = "http://www.w3.org/2000/svg";
      class QRCodeWriter {
        /*@Override*/
        // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix
        //     /*throws WriterException */ {
        //   return encode(contents, format, width, height, null)
        // }
        /*@Override*/
        encode(contents, format, width, height, hints) {
          if (contents.length === 0) {
            throw new IllegalArgumentException("Found empty contents");
          }
          if (format !== BarcodeFormat$1.QR_CODE) {
            throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format);
          }
          if (width < 0 || height < 0) {
            throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);
          }
          let errorCorrectionLevel = ErrorCorrectionLevel.L;
          let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
          if (hints !== null) {
            if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
              errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
            }
            if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
              quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
            }
          }
          const code = Encoder2.encode(contents, errorCorrectionLevel, hints);
          return QRCodeWriter.renderResult(code, width, height, quietZone);
        }
        // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses
        // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
        static renderResult(code, width, height, quietZone) {
          const input = code.getMatrix();
          if (input === null) {
            throw new IllegalStateException();
          }
          const inputWidth = input.getWidth();
          const inputHeight = input.getHeight();
          const qrWidth = inputWidth + quietZone * 2;
          const qrHeight = inputHeight + quietZone * 2;
          const outputWidth = Math.max(width, qrWidth);
          const outputHeight = Math.max(height, qrHeight);
          const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
          const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
          const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
          const output = new BitMatrix(outputWidth, outputHeight);
          for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
            for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
              if (input.get(inputX, inputY) === 1) {
                output.setRegion(outputX, outputY, multiple, multiple);
              }
            }
          }
          return output;
        }
      }
      QRCodeWriter.QUIET_ZONE_SIZE = 4;
      class MultiFormatWriter {
        /*@Override*/
        // public encode(contents: string,
        //                         format: BarcodeFormat,
        //                         width: number /*int*/,
        //                         height: number /*int*/): BitMatrix /*throws WriterException */ {
        //   return encode(contents, format, width, height, null)
        // }
        /*@Override*/
        encode(contents, format, width, height, hints) {
          let writer;
          switch (format) {
            case BarcodeFormat$1.QR_CODE:
              writer = new QRCodeWriter();
              break;
            default:
              throw new IllegalArgumentException("No encoder available for format " + format);
          }
          return writer.encode(contents, format, width, height, hints);
        }
      }
      class PlanarYUVLuminanceSource extends LuminanceSource {
        constructor(yuvData, dataWidth, dataHeight, left, top, width, height, reverseHorizontal) {
          super(width, height);
          this.yuvData = yuvData;
          this.dataWidth = dataWidth;
          this.dataHeight = dataHeight;
          this.left = left;
          this.top = top;
          if (left + width > dataWidth || top + height > dataHeight) {
            throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
          }
          if (reverseHorizontal) {
            this.reverseHorizontal(width, height);
          }
        }
        /*@Override*/
        getRow(y2, row) {
          if (y2 < 0 || y2 >= this.getHeight()) {
            throw new IllegalArgumentException("Requested row is outside the image: " + y2);
          }
          const width = this.getWidth();
          if (row === null || row === void 0 || row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          const offset = (y2 + this.top) * this.dataWidth + this.left;
          System.arraycopy(this.yuvData, offset, row, 0, width);
          return row;
        }
        /*@Override*/
        getMatrix() {
          const width = this.getWidth();
          const height = this.getHeight();
          if (width === this.dataWidth && height === this.dataHeight) {
            return this.yuvData;
          }
          const area = width * height;
          const matrix = new Uint8ClampedArray(area);
          let inputOffset = this.top * this.dataWidth + this.left;
          if (width === this.dataWidth) {
            System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
            return matrix;
          }
          for (let y2 = 0; y2 < height; y2++) {
            const outputOffset = y2 * width;
            System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
            inputOffset += this.dataWidth;
          }
          return matrix;
        }
        /*@Override*/
        isCropSupported() {
          return true;
        }
        /*@Override*/
        crop(left, top, width, height) {
          return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
        }
        renderThumbnail() {
          const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          const pixels = new Int32Array(width * height);
          const yuv = this.yuvData;
          let inputOffset = this.top * this.dataWidth + this.left;
          for (let y2 = 0; y2 < height; y2++) {
            const outputOffset = y2 * width;
            for (let x2 = 0; x2 < width; x2++) {
              const grey = yuv[inputOffset + x2 * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 255;
              pixels[outputOffset + x2] = 4278190080 | grey * 65793;
            }
            inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
          }
          return pixels;
        }
        /**
         * @return width of image from {@link #renderThumbnail()}
         */
        getThumbnailWidth() {
          return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        /**
         * @return height of image from {@link #renderThumbnail()}
         */
        getThumbnailHeight() {
          return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        reverseHorizontal(width, height) {
          const yuvData = this.yuvData;
          for (let y2 = 0, rowStart = this.top * this.dataWidth + this.left; y2 < height; y2++, rowStart += this.dataWidth) {
            const middle = rowStart + width / 2;
            for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
              const temp = yuvData[x1];
              yuvData[x1] = yuvData[x2];
              yuvData[x2] = temp;
            }
          }
        }
        invert() {
          return new InvertedLuminanceSource(this);
        }
      }
      PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
      class RGBLuminanceSource extends LuminanceSource {
        constructor(luminances, width, height, dataWidth, dataHeight, left, top) {
          super(width, height);
          this.dataWidth = dataWidth;
          this.dataHeight = dataHeight;
          this.left = left;
          this.top = top;
          if (luminances.BYTES_PER_ELEMENT === 4) {
            const size = width * height;
            const luminancesUint8Array = new Uint8ClampedArray(size);
            for (let offset = 0; offset < size; offset++) {
              const pixel = luminances[offset];
              const r = pixel >> 16 & 255;
              const g2 = pixel >> 7 & 510;
              const b2 = pixel & 255;
              luminancesUint8Array[offset] = /*(byte) */
              (r + g2 + b2) / 4 & 255;
            }
            this.luminances = luminancesUint8Array;
          } else {
            this.luminances = luminances;
          }
          if (void 0 === dataWidth) {
            this.dataWidth = width;
          }
          if (void 0 === dataHeight) {
            this.dataHeight = height;
          }
          if (void 0 === left) {
            this.left = 0;
          }
          if (void 0 === top) {
            this.top = 0;
          }
          if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {
            throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
          }
        }
        /*@Override*/
        getRow(y2, row) {
          if (y2 < 0 || y2 >= this.getHeight()) {
            throw new IllegalArgumentException("Requested row is outside the image: " + y2);
          }
          const width = this.getWidth();
          if (row === null || row === void 0 || row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          const offset = (y2 + this.top) * this.dataWidth + this.left;
          System.arraycopy(this.luminances, offset, row, 0, width);
          return row;
        }
        /*@Override*/
        getMatrix() {
          const width = this.getWidth();
          const height = this.getHeight();
          if (width === this.dataWidth && height === this.dataHeight) {
            return this.luminances;
          }
          const area = width * height;
          const matrix = new Uint8ClampedArray(area);
          let inputOffset = this.top * this.dataWidth + this.left;
          if (width === this.dataWidth) {
            System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
            return matrix;
          }
          for (let y2 = 0; y2 < height; y2++) {
            const outputOffset = y2 * width;
            System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
            inputOffset += this.dataWidth;
          }
          return matrix;
        }
        /*@Override*/
        isCropSupported() {
          return true;
        }
        /*@Override*/
        crop(left, top, width, height) {
          return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
        }
        invert() {
          return new InvertedLuminanceSource(this);
        }
      }
      class Charset extends CharacterSetECI {
        static forName(name) {
          return this.getCharacterSetECIByName(name);
        }
      }
      class StandardCharsets {
      }
      StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;
      class AztecCode {
        /**
         * @return {@code true} if compact instead of full mode
         */
        isCompact() {
          return this.compact;
        }
        setCompact(compact) {
          this.compact = compact;
        }
        /**
         * @return size in pixels (width and height)
         */
        getSize() {
          return this.size;
        }
        setSize(size) {
          this.size = size;
        }
        /**
         * @return number of levels
         */
        getLayers() {
          return this.layers;
        }
        setLayers(layers) {
          this.layers = layers;
        }
        /**
         * @return number of data codewords
         */
        getCodeWords() {
          return this.codeWords;
        }
        setCodeWords(codeWords) {
          this.codeWords = codeWords;
        }
        /**
         * @return the symbol image
         */
        getMatrix() {
          return this.matrix;
        }
        setMatrix(matrix) {
          this.matrix = matrix;
        }
      }
      class Collections {
        /**
         * The singletonList(T) method is used to return an immutable list containing only the specified object.
         */
        static singletonList(item) {
          return [item];
        }
        /**
         * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.
         */
        static min(collection, comparator) {
          return collection.sort(comparator)[0];
        }
      }
      class Token {
        constructor(previous) {
          this.previous = previous;
        }
        getPrevious() {
          return this.previous;
        }
      }
      class SimpleToken extends Token {
        constructor(previous, value2, bitCount) {
          super(previous);
          this.value = value2;
          this.bitCount = bitCount;
        }
        /**
         * @Override
         */
        appendTo(bitArray, text) {
          bitArray.appendBits(this.value, this.bitCount);
        }
        add(value2, bitCount) {
          return new SimpleToken(this, value2, bitCount);
        }
        addBinaryShift(start, byteCount) {
          console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
          return new SimpleToken(this, start, byteCount);
        }
        /**
         * @Override
         */
        toString() {
          let value2 = this.value & (1 << this.bitCount) - 1;
          value2 |= 1 << this.bitCount;
          return "<" + Integer.toBinaryString(value2 | 1 << this.bitCount).substring(1) + ">";
        }
      }
      class BinaryShiftToken extends SimpleToken {
        constructor(previous, binaryShiftStart, binaryShiftByteCount) {
          super(previous, 0, 0);
          this.binaryShiftStart = binaryShiftStart;
          this.binaryShiftByteCount = binaryShiftByteCount;
        }
        /**
         * @Override
         */
        appendTo(bitArray, text) {
          for (let i3 = 0; i3 < this.binaryShiftByteCount; i3++) {
            if (i3 === 0 || i3 === 31 && this.binaryShiftByteCount <= 62) {
              bitArray.appendBits(31, 5);
              if (this.binaryShiftByteCount > 62) {
                bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
              } else if (i3 === 0) {
                bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
              } else {
                bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
              }
            }
            bitArray.appendBits(text[this.binaryShiftStart + i3], 8);
          }
        }
        addBinaryShift(start, byteCount) {
          return new BinaryShiftToken(this, start, byteCount);
        }
        /**
         * @Override
         */
        toString() {
          return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
        }
      }
      function addBinaryShift(token, start, byteCount) {
        return new BinaryShiftToken(token, start, byteCount);
      }
      function add(token, value2, bitCount) {
        return new SimpleToken(token, value2, bitCount);
      }
      const MODE_NAMES = [
        "UPPER",
        "LOWER",
        "DIGIT",
        "MIXED",
        "PUNCT"
      ];
      const MODE_UPPER = 0;
      const MODE_LOWER = 1;
      const MODE_DIGIT = 2;
      const MODE_MIXED = 3;
      const MODE_PUNCT = 4;
      const EMPTY_TOKEN = new SimpleToken(null, 0, 0);
      const LATCH_TABLE = [
        Int32Array.from([
          0,
          (5 << 16) + 28,
          (5 << 16) + 30,
          (5 << 16) + 29,
          (10 << 16) + (29 << 5) + 30
          // UPPER -> MIXED -> PUNCT
        ]),
        Int32Array.from([
          (9 << 16) + (30 << 4) + 14,
          0,
          (5 << 16) + 30,
          (5 << 16) + 29,
          (10 << 16) + (29 << 5) + 30
          // LOWER -> MIXED -> PUNCT
        ]),
        Int32Array.from([
          (4 << 16) + 14,
          (9 << 16) + (14 << 5) + 28,
          0,
          (9 << 16) + (14 << 5) + 29,
          (14 << 16) + (14 << 10) + (29 << 5) + 30
          // DIGIT -> UPPER -> MIXED -> PUNCT
        ]),
        Int32Array.from([
          (5 << 16) + 29,
          (5 << 16) + 28,
          (10 << 16) + (29 << 5) + 30,
          0,
          (5 << 16) + 30
          // MIXED -> PUNCT
        ]),
        Int32Array.from([
          (5 << 16) + 31,
          (10 << 16) + (31 << 5) + 28,
          (10 << 16) + (31 << 5) + 30,
          (10 << 16) + (31 << 5) + 29,
          0
        ])
      ];
      function static_SHIFT_TABLE(SHIFT_TABLE2) {
        for (let table of SHIFT_TABLE2) {
          Arrays.fill(table, -1);
        }
        SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
        SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
        SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
        SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
        SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
        SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
        return SHIFT_TABLE2;
      }
      const SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6));
      class State {
        constructor(token, mode, binaryBytes, bitCount) {
          this.token = token;
          this.mode = mode;
          this.binaryShiftByteCount = binaryBytes;
          this.bitCount = bitCount;
        }
        getMode() {
          return this.mode;
        }
        getToken() {
          return this.token;
        }
        getBinaryShiftByteCount() {
          return this.binaryShiftByteCount;
        }
        getBitCount() {
          return this.bitCount;
        }
        // Create a new state representing this state with a latch to a (not
        // necessary different) mode, and then a code.
        latchAndAppend(mode, value2) {
          let bitCount = this.bitCount;
          let token = this.token;
          if (mode !== this.mode) {
            let latch = LATCH_TABLE[this.mode][mode];
            token = add(token, latch & 65535, latch >> 16);
            bitCount += latch >> 16;
          }
          let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
          token = add(token, value2, latchModeBitCount);
          return new State(token, mode, 0, bitCount + latchModeBitCount);
        }
        // Create a new state representing this state, with a temporary shift
        // to a different mode to output a single value.
        shiftAndAppend(mode, value2) {
          let token = this.token;
          let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
          token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
          token = add(token, value2, 5);
          return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
        }
        // Create a new state representing this state, but an additional character
        // output in Binary Shift mode.
        addBinaryShiftChar(index) {
          let token = this.token;
          let mode = this.mode;
          let bitCount = this.bitCount;
          if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
            let latch = LATCH_TABLE[mode][MODE_UPPER];
            token = add(token, latch & 65535, latch >> 16);
            bitCount += latch >> 16;
            mode = MODE_UPPER;
          }
          let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
          let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
          if (result.binaryShiftByteCount === 2047 + 31) {
            result = result.endBinaryShift(index + 1);
          }
          return result;
        }
        // Create the state identical to this one, but we are no longer in
        // Binary Shift mode.
        endBinaryShift(index) {
          if (this.binaryShiftByteCount === 0) {
            return this;
          }
          let token = this.token;
          token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
          return new State(token, this.mode, 0, this.bitCount);
        }
        // Returns true if "this" state is better (equal: or) to be in than "that"
        // state under all possible circumstances.
        isBetterThanOrEqualTo(other) {
          let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
          if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
            newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);
          } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
            newModeBitCount += 10;
          }
          return newModeBitCount <= other.bitCount;
        }
        toBitArray(text) {
          let symbols = [];
          for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
            symbols.unshift(token);
          }
          let bitArray = new BitArray();
          for (const symbol of symbols) {
            symbol.appendTo(bitArray, text);
          }
          return bitArray;
        }
        /**
         * @Override
         */
        toString() {
          return StringUtils.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
        }
        static calculateBinaryShiftCost(state) {
          if (state.binaryShiftByteCount > 62) {
            return 21;
          }
          if (state.binaryShiftByteCount > 31) {
            return 20;
          }
          if (state.binaryShiftByteCount > 0) {
            return 10;
          }
          return 0;
        }
      }
      State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);
      function static_CHAR_MAP(CHAR_MAP2) {
        const spaceCharCode = StringUtils.getCharCode(" ");
        const pointCharCode = StringUtils.getCharCode(".");
        const commaCharCode = StringUtils.getCharCode(",");
        CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
        const zUpperCharCode = StringUtils.getCharCode("Z");
        const aUpperCharCode = StringUtils.getCharCode("A");
        for (let c2 = aUpperCharCode; c2 <= zUpperCharCode; c2++) {
          CHAR_MAP2[MODE_UPPER][c2] = c2 - aUpperCharCode + 2;
        }
        CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
        const zLowerCharCode = StringUtils.getCharCode("z");
        const aLowerCharCode = StringUtils.getCharCode("a");
        for (let c2 = aLowerCharCode; c2 <= zLowerCharCode; c2++) {
          CHAR_MAP2[MODE_LOWER][c2] = c2 - aLowerCharCode + 2;
        }
        CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
        const nineCharCode = StringUtils.getCharCode("9");
        const zeroCharCode = StringUtils.getCharCode("0");
        for (let c2 = zeroCharCode; c2 <= nineCharCode; c2++) {
          CHAR_MAP2[MODE_DIGIT][c2] = c2 - zeroCharCode + 2;
        }
        CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
        CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
        const mixedTable = [
          "\0",
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "\x07",
          "\b",
          "	",
          "\n",
          "\v",
          "\f",
          "\r",
          "\x1B",
          "",
          "",
          "",
          "",
          "@",
          "\\",
          "^",
          "_",
          "`",
          "|",
          "~",
          "\x7F"
        ];
        for (let i3 = 0; i3 < mixedTable.length; i3++) {
          CHAR_MAP2[MODE_MIXED][StringUtils.getCharCode(mixedTable[i3])] = i3;
        }
        const punctTable = [
          "\0",
          "\r",
          "\0",
          "\0",
          "\0",
          "\0",
          "!",
          "'",
          "#",
          "$",
          "%",
          "&",
          "'",
          "(",
          ")",
          "*",
          "+",
          ",",
          "-",
          ".",
          "/",
          ":",
          ";",
          "<",
          "=",
          ">",
          "?",
          "[",
          "]",
          "{",
          "}"
        ];
        for (let i3 = 0; i3 < punctTable.length; i3++) {
          if (StringUtils.getCharCode(punctTable[i3]) > 0) {
            CHAR_MAP2[MODE_PUNCT][StringUtils.getCharCode(punctTable[i3])] = i3;
          }
        }
        return CHAR_MAP2;
      }
      const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));
      class HighLevelEncoder {
        constructor(text) {
          this.text = text;
        }
        /**
         * @return text represented by this encoder encoded as a {@link BitArray}
         */
        encode() {
          const spaceCharCode = StringUtils.getCharCode(" ");
          const lineBreakCharCode = StringUtils.getCharCode("\n");
          let states = Collections.singletonList(State.INITIAL_STATE);
          for (let index = 0; index < this.text.length; index++) {
            let pairCode;
            let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
            switch (this.text[index]) {
              case StringUtils.getCharCode("\r"):
                pairCode = nextChar === lineBreakCharCode ? 2 : 0;
                break;
              case StringUtils.getCharCode("."):
                pairCode = nextChar === spaceCharCode ? 3 : 0;
                break;
              case StringUtils.getCharCode(","):
                pairCode = nextChar === spaceCharCode ? 4 : 0;
                break;
              case StringUtils.getCharCode(":"):
                pairCode = nextChar === spaceCharCode ? 5 : 0;
                break;
              default:
                pairCode = 0;
            }
            if (pairCode > 0) {
              states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);
              index++;
            } else {
              states = this.updateStateListForChar(states, index);
            }
          }
          const minState = Collections.min(states, (a2, b2) => {
            return a2.getBitCount() - b2.getBitCount();
          });
          return minState.toBitArray(this.text);
        }
        // We update a set of states for a new character by updating each state
        // for the new character, merging the results, and then removing the
        // non-optimal states.
        updateStateListForChar(states, index) {
          const result = [];
          for (let state of states) {
            this.updateStateForChar(state, index, result);
          }
          return HighLevelEncoder.simplifyStates(result);
        }
        // Return a set of states that represent the possible ways of updating this
        // state for the next character.  The resulting set of states are added to
        // the "result" list.
        updateStateForChar(state, index, result) {
          let ch = this.text[index] & 255;
          let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
          let stateNoBinary = null;
          for (let mode = 0; mode <= MODE_PUNCT; mode++) {
            let charInMode = CHAR_MAP[mode][ch];
            if (charInMode > 0) {
              if (stateNoBinary == null) {
                stateNoBinary = state.endBinaryShift(index);
              }
              if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
                const latchState = stateNoBinary.latchAndAppend(mode, charInMode);
                result.push(latchState);
              }
              if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
                const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
                result.push(shiftState);
              }
            }
          }
          if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {
            let binaryState = state.addBinaryShiftChar(index);
            result.push(binaryState);
          }
        }
        static updateStateListForPair(states, index, pairCode) {
          const result = [];
          for (let state of states) {
            this.updateStateForPair(state, index, pairCode, result);
          }
          return this.simplifyStates(result);
        }
        static updateStateForPair(state, index, pairCode, result) {
          let stateNoBinary = state.endBinaryShift(index);
          result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
          if (state.getMode() !== MODE_PUNCT) {
            result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
          }
          if (pairCode === 3 || pairCode === 4) {
            let digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
            result.push(digitState);
          }
          if (state.getBinaryShiftByteCount() > 0) {
            let binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);
            result.push(binaryState);
          }
        }
        static simplifyStates(states) {
          let result = [];
          for (const newState of states) {
            let add2 = true;
            for (const oldState of result) {
              if (oldState.isBetterThanOrEqualTo(newState)) {
                add2 = false;
                break;
              }
              if (newState.isBetterThanOrEqualTo(oldState)) {
                result = result.filter((x2) => x2 !== oldState);
              }
            }
            if (add2) {
              result.push(newState);
            }
          }
          return result;
        }
      }
      class Encoder$1 {
        constructor() {
        }
        /**
         * Encodes the given binary content as an Aztec symbol
         *
         * @param data input data string
         * @return Aztec symbol matrix with metadata
         */
        static encodeBytes(data) {
          return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);
        }
        /**
         * Encodes the given binary content as an Aztec symbol
         *
         * @param data input data string
         * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,
         *                      a minimum of 23% + 3 words is recommended)
         * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers
         * @return Aztec symbol matrix with metadata
         */
        static encode(data, minECCPercent, userSpecifiedLayers) {
          let bits2 = new HighLevelEncoder(data).encode();
          let eccBits = Integer.truncDivision(bits2.getSize() * minECCPercent, 100) + 11;
          let totalSizeBits = bits2.getSize() + eccBits;
          let compact;
          let layers;
          let totalBitsInLayer;
          let wordSize;
          let stuffedBits;
          if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {
            compact = userSpecifiedLayers < 0;
            layers = Math.abs(userSpecifiedLayers);
            if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {
              throw new IllegalArgumentException(StringUtils.format("Illegal value %s for layers", userSpecifiedLayers));
            }
            totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
            wordSize = Encoder$1.WORD_SIZE[layers];
            let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
            stuffedBits = Encoder$1.stuffBits(bits2, wordSize);
            if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
              throw new IllegalArgumentException("Data to large for user specified layer");
            }
            if (compact && stuffedBits.getSize() > wordSize * 64) {
              throw new IllegalArgumentException("Data to large for user specified layer");
            }
          } else {
            wordSize = 0;
            stuffedBits = null;
            for (let i3 = 0; ; i3++) {
              if (i3 > Encoder$1.MAX_NB_BITS) {
                throw new IllegalArgumentException("Data too large for an Aztec code");
              }
              compact = i3 <= 3;
              layers = compact ? i3 + 1 : i3;
              totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
              if (totalSizeBits > totalBitsInLayer) {
                continue;
              }
              if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {
                wordSize = Encoder$1.WORD_SIZE[layers];
                stuffedBits = Encoder$1.stuffBits(bits2, wordSize);
              }
              let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
              if (compact && stuffedBits.getSize() > wordSize * 64) {
                continue;
              }
              if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
                break;
              }
            }
          }
          let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
          let messageSizeInWords = stuffedBits.getSize() / wordSize;
          let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);
          let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
          let alignmentMap = new Int32Array(baseMatrixSize);
          let matrixSize;
          if (compact) {
            matrixSize = baseMatrixSize;
            for (let i3 = 0; i3 < alignmentMap.length; i3++) {
              alignmentMap[i3] = i3;
            }
          } else {
            matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
            let origCenter = Integer.truncDivision(baseMatrixSize, 2);
            let center = Integer.truncDivision(matrixSize, 2);
            for (let i3 = 0; i3 < origCenter; i3++) {
              let newOffset = i3 + Integer.truncDivision(i3, 15);
              alignmentMap[origCenter - i3 - 1] = center - newOffset - 1;
              alignmentMap[origCenter + i3] = center + newOffset + 1;
            }
          }
          let matrix = new BitMatrix(matrixSize);
          for (let i3 = 0, rowOffset = 0; i3 < layers; i3++) {
            let rowSize = (layers - i3) * 4 + (compact ? 9 : 12);
            for (let j2 = 0; j2 < rowSize; j2++) {
              let columnOffset = j2 * 2;
              for (let k2 = 0; k2 < 2; k2++) {
                if (messageBits.get(rowOffset + columnOffset + k2)) {
                  matrix.set(alignmentMap[i3 * 2 + k2], alignmentMap[i3 * 2 + j2]);
                }
                if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k2)) {
                  matrix.set(alignmentMap[i3 * 2 + j2], alignmentMap[baseMatrixSize - 1 - i3 * 2 - k2]);
                }
                if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k2)) {
                  matrix.set(alignmentMap[baseMatrixSize - 1 - i3 * 2 - k2], alignmentMap[baseMatrixSize - 1 - i3 * 2 - j2]);
                }
                if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k2)) {
                  matrix.set(alignmentMap[baseMatrixSize - 1 - i3 * 2 - j2], alignmentMap[i3 * 2 + k2]);
                }
              }
            }
            rowOffset += rowSize * 8;
          }
          Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);
          if (compact) {
            Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
          } else {
            Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
            for (let i3 = 0, j2 = 0; i3 < Integer.truncDivision(baseMatrixSize, 2) - 1; i3 += 15, j2 += 16) {
              for (let k2 = Integer.truncDivision(matrixSize, 2) & 1; k2 < matrixSize; k2 += 2) {
                matrix.set(Integer.truncDivision(matrixSize, 2) - j2, k2);
                matrix.set(Integer.truncDivision(matrixSize, 2) + j2, k2);
                matrix.set(k2, Integer.truncDivision(matrixSize, 2) - j2);
                matrix.set(k2, Integer.truncDivision(matrixSize, 2) + j2);
              }
            }
          }
          let aztec = new AztecCode();
          aztec.setCompact(compact);
          aztec.setSize(matrixSize);
          aztec.setLayers(layers);
          aztec.setCodeWords(messageSizeInWords);
          aztec.setMatrix(matrix);
          return aztec;
        }
        static drawBullsEye(matrix, center, size) {
          for (let i3 = 0; i3 < size; i3 += 2) {
            for (let j2 = center - i3; j2 <= center + i3; j2++) {
              matrix.set(j2, center - i3);
              matrix.set(j2, center + i3);
              matrix.set(center - i3, j2);
              matrix.set(center + i3, j2);
            }
          }
          matrix.set(center - size, center - size);
          matrix.set(center - size + 1, center - size);
          matrix.set(center - size, center - size + 1);
          matrix.set(center + size, center - size);
          matrix.set(center + size, center - size + 1);
          matrix.set(center + size, center + size - 1);
        }
        static generateModeMessage(compact, layers, messageSizeInWords) {
          let modeMessage = new BitArray();
          if (compact) {
            modeMessage.appendBits(layers - 1, 2);
            modeMessage.appendBits(messageSizeInWords - 1, 6);
            modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);
          } else {
            modeMessage.appendBits(layers - 1, 5);
            modeMessage.appendBits(messageSizeInWords - 1, 11);
            modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);
          }
          return modeMessage;
        }
        static drawModeMessage(matrix, compact, matrixSize, modeMessage) {
          let center = Integer.truncDivision(matrixSize, 2);
          if (compact) {
            for (let i3 = 0; i3 < 7; i3++) {
              let offset = center - 3 + i3;
              if (modeMessage.get(i3)) {
                matrix.set(offset, center - 5);
              }
              if (modeMessage.get(i3 + 7)) {
                matrix.set(center + 5, offset);
              }
              if (modeMessage.get(20 - i3)) {
                matrix.set(offset, center + 5);
              }
              if (modeMessage.get(27 - i3)) {
                matrix.set(center - 5, offset);
              }
            }
          } else {
            for (let i3 = 0; i3 < 10; i3++) {
              let offset = center - 5 + i3 + Integer.truncDivision(i3, 5);
              if (modeMessage.get(i3)) {
                matrix.set(offset, center - 7);
              }
              if (modeMessage.get(i3 + 10)) {
                matrix.set(center + 7, offset);
              }
              if (modeMessage.get(29 - i3)) {
                matrix.set(offset, center + 7);
              }
              if (modeMessage.get(39 - i3)) {
                matrix.set(center - 7, offset);
              }
            }
          }
        }
        static generateCheckWords(bitArray, totalBits, wordSize) {
          let messageSizeInWords = bitArray.getSize() / wordSize;
          let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));
          let totalWords = Integer.truncDivision(totalBits, wordSize);
          let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);
          rs.encode(messageWords, totalWords - messageSizeInWords);
          let startPad = totalBits % wordSize;
          let messageBits = new BitArray();
          messageBits.appendBits(0, startPad);
          for (const messageWord of Array.from(messageWords)) {
            messageBits.appendBits(messageWord, wordSize);
          }
          return messageBits;
        }
        static bitsToWords(stuffedBits, wordSize, totalWords) {
          let message = new Int32Array(totalWords);
          let i3;
          let n2;
          for (i3 = 0, n2 = stuffedBits.getSize() / wordSize; i3 < n2; i3++) {
            let value2 = 0;
            for (let j2 = 0; j2 < wordSize; j2++) {
              value2 |= stuffedBits.get(i3 * wordSize + j2) ? 1 << wordSize - j2 - 1 : 0;
            }
            message[i3] = value2;
          }
          return message;
        }
        static getGF(wordSize) {
          switch (wordSize) {
            case 4:
              return GenericGF.AZTEC_PARAM;
            case 6:
              return GenericGF.AZTEC_DATA_6;
            case 8:
              return GenericGF.AZTEC_DATA_8;
            case 10:
              return GenericGF.AZTEC_DATA_10;
            case 12:
              return GenericGF.AZTEC_DATA_12;
            default:
              throw new IllegalArgumentException("Unsupported word size " + wordSize);
          }
        }
        static stuffBits(bits2, wordSize) {
          let out = new BitArray();
          let n2 = bits2.getSize();
          let mask = (1 << wordSize) - 2;
          for (let i3 = 0; i3 < n2; i3 += wordSize) {
            let word = 0;
            for (let j2 = 0; j2 < wordSize; j2++) {
              if (i3 + j2 >= n2 || bits2.get(i3 + j2)) {
                word |= 1 << wordSize - 1 - j2;
              }
            }
            if ((word & mask) === mask) {
              out.appendBits(word & mask, wordSize);
              i3--;
            } else if ((word & mask) === 0) {
              out.appendBits(word | 1, wordSize);
              i3--;
            } else {
              out.appendBits(word, wordSize);
            }
          }
          return out;
        }
        static totalBitsInLayer(layers, compact) {
          return ((compact ? 88 : 112) + 16 * layers) * layers;
        }
      }
      Encoder$1.DEFAULT_EC_PERCENT = 33;
      Encoder$1.DEFAULT_AZTEC_LAYERS = 0;
      Encoder$1.MAX_NB_BITS = 32;
      Encoder$1.MAX_NB_BITS_COMPACT = 4;
      Encoder$1.WORD_SIZE = Int32Array.from([
        4,
        6,
        6,
        8,
        8,
        8,
        8,
        8,
        8,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        12,
        12,
        12,
        12,
        12,
        12,
        12,
        12,
        12,
        12
      ]);
      class AztecWriter {
        // @Override
        encode(contents, format, width, height) {
          return this.encodeWithHints(contents, format, width, height, null);
        }
        // @Override
        encodeWithHints(contents, format, width, height, hints) {
          let charset = StandardCharsets.ISO_8859_1;
          let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
          let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
          if (hints != null) {
            if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
              charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
            }
            if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
              eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
            }
            if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
              layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
            }
          }
          return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
        }
        static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {
          if (format !== BarcodeFormat$1.AZTEC) {
            throw new IllegalArgumentException("Can only encode AZTEC, but got " + format);
          }
          let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
          return AztecWriter.renderResult(aztec, width, height);
        }
        static renderResult(code, width, height) {
          let input = code.getMatrix();
          if (input == null) {
            throw new IllegalStateException();
          }
          let inputWidth = input.getWidth();
          let inputHeight = input.getHeight();
          let outputWidth = Math.max(width, inputWidth);
          let outputHeight = Math.max(height, inputHeight);
          let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
          let leftPadding = (outputWidth - inputWidth * multiple) / 2;
          let topPadding = (outputHeight - inputHeight * multiple) / 2;
          let output = new BitMatrix(outputWidth, outputHeight);
          for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
            for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
              if (input.get(inputX, inputY)) {
                output.setRegion(outputX, outputY, multiple, multiple);
              }
            }
          }
          return output;
        }
      }
      exports2.AbstractExpandedDecoder = AbstractExpandedDecoder;
      exports2.ArgumentException = ArgumentException;
      exports2.ArithmeticException = ArithmeticException;
      exports2.AztecCode = AztecCode;
      exports2.AztecCodeReader = AztecReader;
      exports2.AztecCodeWriter = AztecWriter;
      exports2.AztecDecoder = Decoder2;
      exports2.AztecDetector = Detector;
      exports2.AztecDetectorResult = AztecDetectorResult;
      exports2.AztecEncoder = Encoder$1;
      exports2.AztecHighLevelEncoder = HighLevelEncoder;
      exports2.AztecPoint = Point;
      exports2.BarcodeFormat = BarcodeFormat$1;
      exports2.Binarizer = Binarizer;
      exports2.BinaryBitmap = BinaryBitmap2;
      exports2.BitArray = BitArray;
      exports2.BitMatrix = BitMatrix;
      exports2.BitSource = BitSource;
      exports2.BrowserAztecCodeReader = BrowserAztecCodeReader;
      exports2.BrowserBarcodeReader = BrowserBarcodeReader;
      exports2.BrowserCodeReader = BrowserCodeReader;
      exports2.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
      exports2.BrowserMultiFormatReader = BrowserMultiFormatReader;
      exports2.BrowserPDF417Reader = BrowserPDF417Reader;
      exports2.BrowserQRCodeReader = BrowserQRCodeReader;
      exports2.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
      exports2.CharacterSetECI = CharacterSetECI;
      exports2.ChecksumException = ChecksumException;
      exports2.Code128Reader = Code128Reader;
      exports2.Code39Reader = Code39Reader;
      exports2.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;
      exports2.DataMatrixReader = DataMatrixReader;
      exports2.DecodeHintType = DecodeHintType$1;
      exports2.DecoderResult = DecoderResult;
      exports2.DefaultGridSampler = DefaultGridSampler;
      exports2.DetectorResult = DetectorResult;
      exports2.EAN13Reader = EAN13Reader;
      exports2.EncodeHintType = EncodeHintType$1;
      exports2.Exception = Exception;
      exports2.FormatException = FormatException;
      exports2.GenericGF = GenericGF;
      exports2.GenericGFPoly = GenericGFPoly;
      exports2.GlobalHistogramBinarizer = GlobalHistogramBinarizer;
      exports2.GridSampler = GridSampler;
      exports2.GridSamplerInstance = GridSamplerInstance;
      exports2.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource2;
      exports2.HybridBinarizer = HybridBinarizer2;
      exports2.ITFReader = ITFReader;
      exports2.IllegalArgumentException = IllegalArgumentException;
      exports2.IllegalStateException = IllegalStateException;
      exports2.InvertedLuminanceSource = InvertedLuminanceSource;
      exports2.LuminanceSource = LuminanceSource;
      exports2.MathUtils = MathUtils;
      exports2.MultiFormatOneDReader = MultiFormatOneDReader;
      exports2.MultiFormatReader = MultiFormatReader2;
      exports2.MultiFormatWriter = MultiFormatWriter;
      exports2.NotFoundException = NotFoundException;
      exports2.OneDReader = OneDReader;
      exports2.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;
      exports2.PDF417DecoderErrorCorrection = ErrorCorrection;
      exports2.PDF417Reader = PDF417Reader;
      exports2.PDF417ResultMetadata = PDF417ResultMetadata;
      exports2.PerspectiveTransform = PerspectiveTransform;
      exports2.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;
      exports2.QRCodeByteMatrix = ByteMatrix;
      exports2.QRCodeDataMask = DataMask;
      exports2.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;
      exports2.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;
      exports2.QRCodeDecoderFormatInformation = FormatInformation;
      exports2.QRCodeEncoder = Encoder2;
      exports2.QRCodeEncoderQRCode = QRCode;
      exports2.QRCodeMaskUtil = MaskUtil;
      exports2.QRCodeMatrixUtil = MatrixUtil;
      exports2.QRCodeMode = Mode$1;
      exports2.QRCodeReader = QRCodeReader;
      exports2.QRCodeVersion = Version$1;
      exports2.QRCodeWriter = QRCodeWriter;
      exports2.RGBLuminanceSource = RGBLuminanceSource;
      exports2.RSS14Reader = RSS14Reader;
      exports2.RSSExpandedReader = RSSExpandedReader;
      exports2.ReaderException = ReaderException;
      exports2.ReedSolomonDecoder = ReedSolomonDecoder;
      exports2.ReedSolomonEncoder = ReedSolomonEncoder;
      exports2.ReedSolomonException = ReedSolomonException;
      exports2.Result = Result;
      exports2.ResultMetadataType = ResultMetadataType$1;
      exports2.ResultPoint = ResultPoint;
      exports2.StringUtils = StringUtils;
      exports2.UnsupportedOperationException = UnsupportedOperationException;
      exports2.VideoInputDevice = VideoInputDevice;
      exports2.WhiteRectangleDetector = WhiteRectangleDetector;
      exports2.WriterException = WriterException;
      exports2.ZXingArrays = Arrays;
      exports2.ZXingCharset = Charset;
      exports2.ZXingInteger = Integer;
      exports2.ZXingStandardCharsets = StandardCharsets;
      exports2.ZXingStringBuilder = StringBuilder;
      exports2.ZXingStringEncoding = StringEncoding;
      exports2.ZXingSystem = System;
      exports2.createAbstractExpandedDecoder = createDecoder;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/jsbarcode/bin/barcodes/Barcode.js
var require_Barcode = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/Barcode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Barcode = function Barcode2(data, options) {
      _classCallCheck(this, Barcode2);
      this.data = data;
      this.text = options.text || data;
      this.options = options;
    };
    exports.default = Barcode;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE39/index.js
var require_CODE39 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CODE39 = void 0;
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var CODE39 = function(_Barcode) {
      _inherits(CODE392, _Barcode);
      function CODE392(data, options) {
        _classCallCheck(this, CODE392);
        data = data.toUpperCase();
        if (options.mod43) {
          data += getCharacter(mod43checksum(data));
        }
        return _possibleConstructorReturn(this, (CODE392.__proto__ || Object.getPrototypeOf(CODE392)).call(this, data, options));
      }
      _createClass(CODE392, [{
        key: "encode",
        value: function encode3() {
          var result = getEncoding("*");
          for (var i3 = 0; i3 < this.data.length; i3++) {
            result += getEncoding(this.data[i3]) + "0";
          }
          result += getEncoding("*");
          return {
            data: result,
            text: this.text
          };
        }
      }, {
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9A-Z\-\.\ \$\/\+\%]+$/) !== -1;
        }
      }]);
      return CODE392;
    }(_Barcode3.default);
    var characters = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "-", ".", " ", "$", "/", "+", "%", "*"];
    var encodings = [20957, 29783, 23639, 30485, 20951, 29813, 23669, 20855, 29789, 23645, 29975, 23831, 30533, 22295, 30149, 24005, 21623, 29981, 23837, 22301, 30023, 23879, 30545, 22343, 30161, 24017, 21959, 30065, 23921, 22385, 29015, 18263, 29141, 17879, 29045, 18293, 17783, 29021, 18269, 17477, 17489, 17681, 20753, 35770];
    function getEncoding(character) {
      return getBinary(characterValue(character));
    }
    function getBinary(characterValue2) {
      return encodings[characterValue2].toString(2);
    }
    function getCharacter(characterValue2) {
      return characters[characterValue2];
    }
    function characterValue(character) {
      return characters.indexOf(character);
    }
    function mod43checksum(data) {
      var checksum = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        checksum += characterValue(data[i3]);
      }
      checksum = checksum % 43;
      return checksum;
    }
    exports.CODE39 = CODE39;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/constants.js
var require_constants = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _SET_BY_CODE;
    function _defineProperty(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    var SET_A = exports.SET_A = 0;
    var SET_B = exports.SET_B = 1;
    var SET_C = exports.SET_C = 2;
    var SHIFT = exports.SHIFT = 98;
    var START_A = exports.START_A = 103;
    var START_B = exports.START_B = 104;
    var START_C = exports.START_C = 105;
    var MODULO = exports.MODULO = 103;
    var STOP = exports.STOP = 106;
    var FNC1 = exports.FNC1 = 207;
    var SET_BY_CODE = exports.SET_BY_CODE = (_SET_BY_CODE = {}, _defineProperty(_SET_BY_CODE, START_A, SET_A), _defineProperty(_SET_BY_CODE, START_B, SET_B), _defineProperty(_SET_BY_CODE, START_C, SET_C), _SET_BY_CODE);
    var SWAP = exports.SWAP = {
      101: SET_A,
      100: SET_B,
      99: SET_C
    };
    var A_START_CHAR = exports.A_START_CHAR = String.fromCharCode(208);
    var B_START_CHAR = exports.B_START_CHAR = String.fromCharCode(209);
    var C_START_CHAR = exports.C_START_CHAR = String.fromCharCode(210);
    var A_CHARS = exports.A_CHARS = "[\0-_\xC8-\xCF]";
    var B_CHARS = exports.B_CHARS = "[ -\x7F\xC8-\xCF]";
    var C_CHARS = exports.C_CHARS = "(\xCF*[0-9]{2}\xCF*)";
    var BARS = exports.BARS = [11011001100, 11001101100, 11001100110, 10010011e3, 10010001100, 10001001100, 10011001e3, 10011000100, 10001100100, 11001001e3, 11001000100, 11000100100, 10110011100, 10011011100, 10011001110, 10111001100, 10011101100, 10011100110, 11001110010, 11001011100, 11001001110, 11011100100, 11001110100, 11101101110, 11101001100, 11100101100, 11100100110, 11101100100, 11100110100, 11100110010, 11011011e3, 11011000110, 11000110110, 10100011e3, 10001011e3, 10001000110, 10110001e3, 10001101e3, 10001100010, 11010001e3, 11000101e3, 11000100010, 10110111e3, 10110001110, 10001101110, 10111011e3, 10111000110, 10001110110, 11101110110, 11010001110, 11000101110, 11011101e3, 11011100010, 11011101110, 11101011e3, 11101000110, 11100010110, 11101101e3, 11101100010, 11100011010, 11101111010, 11001000010, 11110001010, 1010011e4, 10100001100, 1001011e4, 10010000110, 10000101100, 10000100110, 1011001e4, 10110000100, 1001101e4, 10011000010, 10000110100, 10000110010, 11000010010, 1100101e4, 11110111010, 11000010100, 10001111010, 10100111100, 10010111100, 10010011110, 10111100100, 10011110100, 10011110010, 11110100100, 11110010100, 11110010010, 11011011110, 11011110110, 11110110110, 10101111e3, 10100011110, 10001011110, 10111101e3, 10111100010, 11110101e3, 11110100010, 10111011110, 10111101110, 11101011110, 11110101110, 11010000100, 1101001e4, 11010011100, 1100011101011];
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/CODE128.js
var require_CODE128 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/CODE128.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var CODE128 = function(_Barcode) {
      _inherits(CODE1282, _Barcode);
      function CODE1282(data, options) {
        _classCallCheck(this, CODE1282);
        var _this = _possibleConstructorReturn(this, (CODE1282.__proto__ || Object.getPrototypeOf(CODE1282)).call(this, data.substring(1), options));
        _this.bytes = data.split("").map(function(char) {
          return char.charCodeAt(0);
        });
        return _this;
      }
      _createClass(CODE1282, [{
        key: "valid",
        value: function valid() {
          return /^[\x00-\x7F\xC8-\xD3]+$/.test(this.data);
        }
        // The public encoding function
      }, {
        key: "encode",
        value: function encode3() {
          var bytes = this.bytes;
          var startIndex = bytes.shift() - 105;
          var startSet = _constants.SET_BY_CODE[startIndex];
          if (startSet === void 0) {
            throw new RangeError("The encoding does not start with a start character.");
          }
          if (this.shouldEncodeAsEan128() === true) {
            bytes.unshift(_constants.FNC1);
          }
          var encodingResult = CODE1282.next(bytes, 1, startSet);
          return {
            text: this.text === this.data ? this.text.replace(/[^\x20-\x7E]/g, "") : this.text,
            data: (
              // Add the start bits
              CODE1282.getBar(startIndex) + // Add the encoded bits
              encodingResult.result + // Add the checksum
              CODE1282.getBar((encodingResult.checksum + startIndex) % _constants.MODULO) + // Add the end bits
              CODE1282.getBar(_constants.STOP)
            )
          };
        }
        // GS1-128/EAN-128
      }, {
        key: "shouldEncodeAsEan128",
        value: function shouldEncodeAsEan128() {
          var isEAN128 = this.options.ean128 || false;
          if (typeof isEAN128 === "string") {
            isEAN128 = isEAN128.toLowerCase() === "true";
          }
          return isEAN128;
        }
        // Get a bar symbol by index
      }], [{
        key: "getBar",
        value: function getBar(index) {
          return _constants.BARS[index] ? _constants.BARS[index].toString() : "";
        }
        // Correct an index by a set and shift it from the bytes array
      }, {
        key: "correctIndex",
        value: function correctIndex(bytes, set) {
          if (set === _constants.SET_A) {
            var charCode = bytes.shift();
            return charCode < 32 ? charCode + 64 : charCode - 32;
          } else if (set === _constants.SET_B) {
            return bytes.shift() - 32;
          } else {
            return (bytes.shift() - 48) * 10 + bytes.shift() - 48;
          }
        }
      }, {
        key: "next",
        value: function next(bytes, pos, set) {
          if (!bytes.length) {
            return { result: "", checksum: 0 };
          }
          var nextCode = void 0, index = void 0;
          if (bytes[0] >= 200) {
            index = bytes.shift() - 105;
            var nextSet = _constants.SWAP[index];
            if (nextSet !== void 0) {
              nextCode = CODE1282.next(bytes, pos + 1, nextSet);
            } else {
              if ((set === _constants.SET_A || set === _constants.SET_B) && index === _constants.SHIFT) {
                bytes[0] = set === _constants.SET_A ? bytes[0] > 95 ? bytes[0] - 96 : bytes[0] : bytes[0] < 32 ? bytes[0] + 96 : bytes[0];
              }
              nextCode = CODE1282.next(bytes, pos + 1, set);
            }
          } else {
            index = CODE1282.correctIndex(bytes, set);
            nextCode = CODE1282.next(bytes, pos + 1, set);
          }
          var enc = CODE1282.getBar(index);
          var weight = index * pos;
          return {
            result: enc + nextCode.result,
            checksum: weight + nextCode.checksum
          };
        }
      }]);
      return CODE1282;
    }(_Barcode3.default);
    exports.default = CODE128;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/auto.js
var require_auto = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/auto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _constants = require_constants();
    var matchSetALength = function matchSetALength2(string) {
      return string.match(new RegExp("^" + _constants.A_CHARS + "*"))[0].length;
    };
    var matchSetBLength = function matchSetBLength2(string) {
      return string.match(new RegExp("^" + _constants.B_CHARS + "*"))[0].length;
    };
    var matchSetC = function matchSetC2(string) {
      return string.match(new RegExp("^" + _constants.C_CHARS + "*"))[0];
    };
    function autoSelectFromAB(string, isA) {
      var ranges = isA ? _constants.A_CHARS : _constants.B_CHARS;
      var untilC = string.match(new RegExp("^(" + ranges + "+?)(([0-9]{2}){2,})([^0-9]|$)"));
      if (untilC) {
        return untilC[1] + String.fromCharCode(204) + autoSelectFromC(string.substring(untilC[1].length));
      }
      var chars2 = string.match(new RegExp("^" + ranges + "+"))[0];
      if (chars2.length === string.length) {
        return string;
      }
      return chars2 + String.fromCharCode(isA ? 205 : 206) + autoSelectFromAB(string.substring(chars2.length), !isA);
    }
    function autoSelectFromC(string) {
      var cMatch = matchSetC(string);
      var length2 = cMatch.length;
      if (length2 === string.length) {
        return string;
      }
      string = string.substring(length2);
      var isA = matchSetALength(string) >= matchSetBLength(string);
      return cMatch + String.fromCharCode(isA ? 206 : 205) + autoSelectFromAB(string, isA);
    }
    exports.default = function(string) {
      var newString = void 0;
      var cLength = matchSetC(string).length;
      if (cLength >= 2) {
        newString = _constants.C_START_CHAR + autoSelectFromC(string);
      } else {
        var isA = matchSetALength(string) > matchSetBLength(string);
        newString = (isA ? _constants.A_START_CHAR : _constants.B_START_CHAR) + autoSelectFromAB(string, isA);
      }
      return newString.replace(
        /[\xCD\xCE]([^])[\xCD\xCE]/,
        // Any sequence between 205 and 206 characters
        function(match, char) {
          return String.fromCharCode(203) + char;
        }
      );
    };
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/CODE128_AUTO.js
var require_CODE128_AUTO = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/CODE128_AUTO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _CODE2 = require_CODE128();
    var _CODE3 = _interopRequireDefault(_CODE2);
    var _auto = require_auto();
    var _auto2 = _interopRequireDefault(_auto);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var CODE128AUTO = function(_CODE) {
      _inherits(CODE128AUTO2, _CODE);
      function CODE128AUTO2(data, options) {
        _classCallCheck(this, CODE128AUTO2);
        if (/^[\x00-\x7F\xC8-\xD3]+$/.test(data)) {
          var _this = _possibleConstructorReturn(this, (CODE128AUTO2.__proto__ || Object.getPrototypeOf(CODE128AUTO2)).call(this, (0, _auto2.default)(data), options));
        } else {
          var _this = _possibleConstructorReturn(this, (CODE128AUTO2.__proto__ || Object.getPrototypeOf(CODE128AUTO2)).call(this, data, options));
        }
        return _possibleConstructorReturn(_this);
      }
      return CODE128AUTO2;
    }(_CODE3.default);
    exports.default = CODE128AUTO;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/CODE128A.js
var require_CODE128A = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/CODE128A.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _CODE2 = require_CODE128();
    var _CODE3 = _interopRequireDefault(_CODE2);
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var CODE128A = function(_CODE) {
      _inherits(CODE128A2, _CODE);
      function CODE128A2(string, options) {
        _classCallCheck(this, CODE128A2);
        return _possibleConstructorReturn(this, (CODE128A2.__proto__ || Object.getPrototypeOf(CODE128A2)).call(this, _constants.A_START_CHAR + string, options));
      }
      _createClass(CODE128A2, [{
        key: "valid",
        value: function valid() {
          return new RegExp("^" + _constants.A_CHARS + "+$").test(this.data);
        }
      }]);
      return CODE128A2;
    }(_CODE3.default);
    exports.default = CODE128A;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/CODE128B.js
var require_CODE128B = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/CODE128B.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _CODE2 = require_CODE128();
    var _CODE3 = _interopRequireDefault(_CODE2);
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var CODE128B = function(_CODE) {
      _inherits(CODE128B2, _CODE);
      function CODE128B2(string, options) {
        _classCallCheck(this, CODE128B2);
        return _possibleConstructorReturn(this, (CODE128B2.__proto__ || Object.getPrototypeOf(CODE128B2)).call(this, _constants.B_START_CHAR + string, options));
      }
      _createClass(CODE128B2, [{
        key: "valid",
        value: function valid() {
          return new RegExp("^" + _constants.B_CHARS + "+$").test(this.data);
        }
      }]);
      return CODE128B2;
    }(_CODE3.default);
    exports.default = CODE128B;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/CODE128C.js
var require_CODE128C = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/CODE128C.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _CODE2 = require_CODE128();
    var _CODE3 = _interopRequireDefault(_CODE2);
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var CODE128C = function(_CODE) {
      _inherits(CODE128C2, _CODE);
      function CODE128C2(string, options) {
        _classCallCheck(this, CODE128C2);
        return _possibleConstructorReturn(this, (CODE128C2.__proto__ || Object.getPrototypeOf(CODE128C2)).call(this, _constants.C_START_CHAR + string, options));
      }
      _createClass(CODE128C2, [{
        key: "valid",
        value: function valid() {
          return new RegExp("^" + _constants.C_CHARS + "+$").test(this.data);
        }
      }]);
      return CODE128C2;
    }(_CODE3.default);
    exports.default = CODE128C;
  }
});

// node_modules/jsbarcode/bin/barcodes/CODE128/index.js
var require_CODE1282 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/CODE128/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CODE128C = exports.CODE128B = exports.CODE128A = exports.CODE128 = void 0;
    var _CODE128_AUTO = require_CODE128_AUTO();
    var _CODE128_AUTO2 = _interopRequireDefault(_CODE128_AUTO);
    var _CODE128A = require_CODE128A();
    var _CODE128A2 = _interopRequireDefault(_CODE128A);
    var _CODE128B = require_CODE128B();
    var _CODE128B2 = _interopRequireDefault(_CODE128B);
    var _CODE128C = require_CODE128C();
    var _CODE128C2 = _interopRequireDefault(_CODE128C);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.CODE128 = _CODE128_AUTO2.default;
    exports.CODE128A = _CODE128A2.default;
    exports.CODE128B = _CODE128B2.default;
    exports.CODE128C = _CODE128C2.default;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/constants.js
var require_constants2 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var SIDE_BIN = exports.SIDE_BIN = "101";
    var MIDDLE_BIN = exports.MIDDLE_BIN = "01010";
    var BINARIES = exports.BINARIES = {
      "L": [
        // The L (left) type of encoding
        "0001101",
        "0011001",
        "0010011",
        "0111101",
        "0100011",
        "0110001",
        "0101111",
        "0111011",
        "0110111",
        "0001011"
      ],
      "G": [
        // The G type of encoding
        "0100111",
        "0110011",
        "0011011",
        "0100001",
        "0011101",
        "0111001",
        "0000101",
        "0010001",
        "0001001",
        "0010111"
      ],
      "R": [
        // The R (right) type of encoding
        "1110010",
        "1100110",
        "1101100",
        "1000010",
        "1011100",
        "1001110",
        "1010000",
        "1000100",
        "1001000",
        "1110100"
      ],
      "O": [
        // The O (odd) encoding for UPC-E
        "0001101",
        "0011001",
        "0010011",
        "0111101",
        "0100011",
        "0110001",
        "0101111",
        "0111011",
        "0110111",
        "0001011"
      ],
      "E": [
        // The E (even) encoding for UPC-E
        "0100111",
        "0110011",
        "0011011",
        "0100001",
        "0011101",
        "0111001",
        "0000101",
        "0010001",
        "0001001",
        "0010111"
      ]
    };
    var EAN2_STRUCTURE = exports.EAN2_STRUCTURE = ["LL", "LG", "GL", "GG"];
    var EAN5_STRUCTURE = exports.EAN5_STRUCTURE = ["GGLLL", "GLGLL", "GLLGL", "GLLLG", "LGGLL", "LLGGL", "LLLGG", "LGLGL", "LGLLG", "LLGLG"];
    var EAN13_STRUCTURE = exports.EAN13_STRUCTURE = ["LLLLLL", "LLGLGG", "LLGGLG", "LLGGGL", "LGLLGG", "LGGLLG", "LGGGLL", "LGLGLG", "LGLGGL", "LGGLGL"];
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/encoder.js
var require_encoder = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _constants = require_constants2();
    var encode3 = function encode4(data, structure, separator) {
      var encoded = data.split("").map(function(val, idx) {
        return _constants.BINARIES[structure[idx]];
      }).map(function(val, idx) {
        return val ? val[data[idx]] : "";
      });
      if (separator) {
        var last = data.length - 1;
        encoded = encoded.map(function(val, idx) {
          return idx < last ? val + separator : val;
        });
      }
      return encoded.join("");
    };
    exports.default = encode3;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN.js
var require_EAN = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _constants = require_constants2();
    var _encoder = require_encoder();
    var _encoder2 = _interopRequireDefault(_encoder);
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var EAN = function(_Barcode) {
      _inherits(EAN2, _Barcode);
      function EAN2(data, options) {
        _classCallCheck(this, EAN2);
        var _this = _possibleConstructorReturn(this, (EAN2.__proto__ || Object.getPrototypeOf(EAN2)).call(this, data, options));
        _this.fontSize = !options.flat && options.fontSize > options.width * 10 ? options.width * 10 : options.fontSize;
        _this.guardHeight = options.height + _this.fontSize / 2 + options.textMargin;
        return _this;
      }
      _createClass(EAN2, [{
        key: "encode",
        value: function encode3() {
          return this.options.flat ? this.encodeFlat() : this.encodeGuarded();
        }
      }, {
        key: "leftText",
        value: function leftText(from2, to) {
          return this.text.substr(from2, to);
        }
      }, {
        key: "leftEncode",
        value: function leftEncode(data, structure) {
          return (0, _encoder2.default)(data, structure);
        }
      }, {
        key: "rightText",
        value: function rightText(from2, to) {
          return this.text.substr(from2, to);
        }
      }, {
        key: "rightEncode",
        value: function rightEncode(data, structure) {
          return (0, _encoder2.default)(data, structure);
        }
      }, {
        key: "encodeGuarded",
        value: function encodeGuarded() {
          var textOptions = { fontSize: this.fontSize };
          var guardOptions = { height: this.guardHeight };
          return [{ data: _constants.SIDE_BIN, options: guardOptions }, { data: this.leftEncode(), text: this.leftText(), options: textOptions }, { data: _constants.MIDDLE_BIN, options: guardOptions }, { data: this.rightEncode(), text: this.rightText(), options: textOptions }, { data: _constants.SIDE_BIN, options: guardOptions }];
        }
      }, {
        key: "encodeFlat",
        value: function encodeFlat() {
          var data = [_constants.SIDE_BIN, this.leftEncode(), _constants.MIDDLE_BIN, this.rightEncode(), _constants.SIDE_BIN];
          return {
            data: data.join(""),
            text: this.text
          };
        }
      }]);
      return EAN2;
    }(_Barcode3.default);
    exports.default = EAN;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN13.js
var require_EAN13 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN13.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _get = function get(object, property, receiver) {
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === void 0) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return void 0;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === void 0) {
          return void 0;
        }
        return getter.call(receiver);
      }
    };
    var _constants = require_constants2();
    var _EAN2 = require_EAN();
    var _EAN3 = _interopRequireDefault(_EAN2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var checksum = function checksum2(number) {
      var res = number.substr(0, 12).split("").map(function(n2) {
        return +n2;
      }).reduce(function(sum, a2, idx) {
        return idx % 2 ? sum + a2 * 3 : sum + a2;
      }, 0);
      return (10 - res % 10) % 10;
    };
    var EAN13 = function(_EAN) {
      _inherits(EAN132, _EAN);
      function EAN132(data, options) {
        _classCallCheck(this, EAN132);
        if (data.search(/^[0-9]{12}$/) !== -1) {
          data += checksum(data);
        }
        var _this = _possibleConstructorReturn(this, (EAN132.__proto__ || Object.getPrototypeOf(EAN132)).call(this, data, options));
        _this.lastChar = options.lastChar;
        return _this;
      }
      _createClass(EAN132, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]{13}$/) !== -1 && +this.data[12] === checksum(this.data);
        }
      }, {
        key: "leftText",
        value: function leftText() {
          return _get(EAN132.prototype.__proto__ || Object.getPrototypeOf(EAN132.prototype), "leftText", this).call(this, 1, 6);
        }
      }, {
        key: "leftEncode",
        value: function leftEncode() {
          var data = this.data.substr(1, 6);
          var structure = _constants.EAN13_STRUCTURE[this.data[0]];
          return _get(EAN132.prototype.__proto__ || Object.getPrototypeOf(EAN132.prototype), "leftEncode", this).call(this, data, structure);
        }
      }, {
        key: "rightText",
        value: function rightText() {
          return _get(EAN132.prototype.__proto__ || Object.getPrototypeOf(EAN132.prototype), "rightText", this).call(this, 7, 6);
        }
      }, {
        key: "rightEncode",
        value: function rightEncode() {
          var data = this.data.substr(7, 6);
          return _get(EAN132.prototype.__proto__ || Object.getPrototypeOf(EAN132.prototype), "rightEncode", this).call(this, data, "RRRRRR");
        }
        // The "standard" way of printing EAN13 barcodes with guard bars
      }, {
        key: "encodeGuarded",
        value: function encodeGuarded() {
          var data = _get(EAN132.prototype.__proto__ || Object.getPrototypeOf(EAN132.prototype), "encodeGuarded", this).call(this);
          if (this.options.displayValue) {
            data.unshift({
              data: "000000000000",
              text: this.text.substr(0, 1),
              options: { textAlign: "left", fontSize: this.fontSize }
            });
            if (this.options.lastChar) {
              data.push({
                data: "00"
              });
              data.push({
                data: "00000",
                text: this.options.lastChar,
                options: { fontSize: this.fontSize }
              });
            }
          }
          return data;
        }
      }]);
      return EAN132;
    }(_EAN3.default);
    exports.default = EAN13;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN8.js
var require_EAN8 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _get = function get(object, property, receiver) {
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === void 0) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return void 0;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === void 0) {
          return void 0;
        }
        return getter.call(receiver);
      }
    };
    var _EAN2 = require_EAN();
    var _EAN3 = _interopRequireDefault(_EAN2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var checksum = function checksum2(number) {
      var res = number.substr(0, 7).split("").map(function(n2) {
        return +n2;
      }).reduce(function(sum, a2, idx) {
        return idx % 2 ? sum + a2 : sum + a2 * 3;
      }, 0);
      return (10 - res % 10) % 10;
    };
    var EAN8 = function(_EAN) {
      _inherits(EAN82, _EAN);
      function EAN82(data, options) {
        _classCallCheck(this, EAN82);
        if (data.search(/^[0-9]{7}$/) !== -1) {
          data += checksum(data);
        }
        return _possibleConstructorReturn(this, (EAN82.__proto__ || Object.getPrototypeOf(EAN82)).call(this, data, options));
      }
      _createClass(EAN82, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]{8}$/) !== -1 && +this.data[7] === checksum(this.data);
        }
      }, {
        key: "leftText",
        value: function leftText() {
          return _get(EAN82.prototype.__proto__ || Object.getPrototypeOf(EAN82.prototype), "leftText", this).call(this, 0, 4);
        }
      }, {
        key: "leftEncode",
        value: function leftEncode() {
          var data = this.data.substr(0, 4);
          return _get(EAN82.prototype.__proto__ || Object.getPrototypeOf(EAN82.prototype), "leftEncode", this).call(this, data, "LLLL");
        }
      }, {
        key: "rightText",
        value: function rightText() {
          return _get(EAN82.prototype.__proto__ || Object.getPrototypeOf(EAN82.prototype), "rightText", this).call(this, 4, 4);
        }
      }, {
        key: "rightEncode",
        value: function rightEncode() {
          var data = this.data.substr(4, 4);
          return _get(EAN82.prototype.__proto__ || Object.getPrototypeOf(EAN82.prototype), "rightEncode", this).call(this, data, "RRRR");
        }
      }]);
      return EAN82;
    }(_EAN3.default);
    exports.default = EAN8;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN5.js
var require_EAN5 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _constants = require_constants2();
    var _encoder = require_encoder();
    var _encoder2 = _interopRequireDefault(_encoder);
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var checksum = function checksum2(data) {
      var result = data.split("").map(function(n2) {
        return +n2;
      }).reduce(function(sum, a2, idx) {
        return idx % 2 ? sum + a2 * 9 : sum + a2 * 3;
      }, 0);
      return result % 10;
    };
    var EAN5 = function(_Barcode) {
      _inherits(EAN52, _Barcode);
      function EAN52(data, options) {
        _classCallCheck(this, EAN52);
        return _possibleConstructorReturn(this, (EAN52.__proto__ || Object.getPrototypeOf(EAN52)).call(this, data, options));
      }
      _createClass(EAN52, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]{5}$/) !== -1;
        }
      }, {
        key: "encode",
        value: function encode3() {
          var structure = _constants.EAN5_STRUCTURE[checksum(this.data)];
          return {
            data: "1011" + (0, _encoder2.default)(this.data, structure, "01"),
            text: this.text
          };
        }
      }]);
      return EAN52;
    }(_Barcode3.default);
    exports.default = EAN5;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN2.js
var require_EAN2 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/EAN2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _constants = require_constants2();
    var _encoder = require_encoder();
    var _encoder2 = _interopRequireDefault(_encoder);
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var EAN2 = function(_Barcode) {
      _inherits(EAN22, _Barcode);
      function EAN22(data, options) {
        _classCallCheck(this, EAN22);
        return _possibleConstructorReturn(this, (EAN22.__proto__ || Object.getPrototypeOf(EAN22)).call(this, data, options));
      }
      _createClass(EAN22, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]{2}$/) !== -1;
        }
      }, {
        key: "encode",
        value: function encode3() {
          var structure = _constants.EAN2_STRUCTURE[parseInt(this.data) % 4];
          return {
            // Start bits + Encode the two digits with 01 in between
            data: "1011" + (0, _encoder2.default)(this.data, structure, "01"),
            text: this.text
          };
        }
      }]);
      return EAN22;
    }(_Barcode3.default);
    exports.default = EAN2;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/UPC.js
var require_UPC = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/UPC.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    exports.checksum = checksum;
    var _encoder = require_encoder();
    var _encoder2 = _interopRequireDefault(_encoder);
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var UPC = function(_Barcode) {
      _inherits(UPC2, _Barcode);
      function UPC2(data, options) {
        _classCallCheck(this, UPC2);
        if (data.search(/^[0-9]{11}$/) !== -1) {
          data += checksum(data);
        }
        var _this = _possibleConstructorReturn(this, (UPC2.__proto__ || Object.getPrototypeOf(UPC2)).call(this, data, options));
        _this.displayValue = options.displayValue;
        if (options.fontSize > options.width * 10) {
          _this.fontSize = options.width * 10;
        } else {
          _this.fontSize = options.fontSize;
        }
        _this.guardHeight = options.height + _this.fontSize / 2 + options.textMargin;
        return _this;
      }
      _createClass(UPC2, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]{12}$/) !== -1 && this.data[11] == checksum(this.data);
        }
      }, {
        key: "encode",
        value: function encode3() {
          if (this.options.flat) {
            return this.flatEncoding();
          } else {
            return this.guardedEncoding();
          }
        }
      }, {
        key: "flatEncoding",
        value: function flatEncoding() {
          var result = "";
          result += "101";
          result += (0, _encoder2.default)(this.data.substr(0, 6), "LLLLLL");
          result += "01010";
          result += (0, _encoder2.default)(this.data.substr(6, 6), "RRRRRR");
          result += "101";
          return {
            data: result,
            text: this.text
          };
        }
      }, {
        key: "guardedEncoding",
        value: function guardedEncoding() {
          var result = [];
          if (this.displayValue) {
            result.push({
              data: "00000000",
              text: this.text.substr(0, 1),
              options: { textAlign: "left", fontSize: this.fontSize }
            });
          }
          result.push({
            data: "101" + (0, _encoder2.default)(this.data[0], "L"),
            options: { height: this.guardHeight }
          });
          result.push({
            data: (0, _encoder2.default)(this.data.substr(1, 5), "LLLLL"),
            text: this.text.substr(1, 5),
            options: { fontSize: this.fontSize }
          });
          result.push({
            data: "01010",
            options: { height: this.guardHeight }
          });
          result.push({
            data: (0, _encoder2.default)(this.data.substr(6, 5), "RRRRR"),
            text: this.text.substr(6, 5),
            options: { fontSize: this.fontSize }
          });
          result.push({
            data: (0, _encoder2.default)(this.data[11], "R") + "101",
            options: { height: this.guardHeight }
          });
          if (this.displayValue) {
            result.push({
              data: "00000000",
              text: this.text.substr(11, 1),
              options: { textAlign: "right", fontSize: this.fontSize }
            });
          }
          return result;
        }
      }]);
      return UPC2;
    }(_Barcode3.default);
    function checksum(number) {
      var result = 0;
      var i3;
      for (i3 = 1; i3 < 11; i3 += 2) {
        result += parseInt(number[i3]);
      }
      for (i3 = 0; i3 < 11; i3 += 2) {
        result += parseInt(number[i3]) * 3;
      }
      return (10 - result % 10) % 10;
    }
    exports.default = UPC;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/UPCE.js
var require_UPCE = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/UPCE.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _encoder = require_encoder();
    var _encoder2 = _interopRequireDefault(_encoder);
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    var _UPC = require_UPC();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var EXPANSIONS = ["XX00000XXX", "XX10000XXX", "XX20000XXX", "XXX00000XX", "XXXX00000X", "XXXXX00005", "XXXXX00006", "XXXXX00007", "XXXXX00008", "XXXXX00009"];
    var PARITIES = [["EEEOOO", "OOOEEE"], ["EEOEOO", "OOEOEE"], ["EEOOEO", "OOEEOE"], ["EEOOOE", "OOEEEO"], ["EOEEOO", "OEOOEE"], ["EOOEEO", "OEEOOE"], ["EOOOEE", "OEEEOO"], ["EOEOEO", "OEOEOE"], ["EOEOOE", "OEOEEO"], ["EOOEOE", "OEEOEO"]];
    var UPCE = function(_Barcode) {
      _inherits(UPCE2, _Barcode);
      function UPCE2(data, options) {
        _classCallCheck(this, UPCE2);
        var _this = _possibleConstructorReturn(this, (UPCE2.__proto__ || Object.getPrototypeOf(UPCE2)).call(this, data, options));
        _this.isValid = false;
        if (data.search(/^[0-9]{6}$/) !== -1) {
          _this.middleDigits = data;
          _this.upcA = expandToUPCA(data, "0");
          _this.text = options.text || "" + _this.upcA[0] + data + _this.upcA[_this.upcA.length - 1];
          _this.isValid = true;
        } else if (data.search(/^[01][0-9]{7}$/) !== -1) {
          _this.middleDigits = data.substring(1, data.length - 1);
          _this.upcA = expandToUPCA(_this.middleDigits, data[0]);
          if (_this.upcA[_this.upcA.length - 1] === data[data.length - 1]) {
            _this.isValid = true;
          } else {
            return _possibleConstructorReturn(_this);
          }
        } else {
          return _possibleConstructorReturn(_this);
        }
        _this.displayValue = options.displayValue;
        if (options.fontSize > options.width * 10) {
          _this.fontSize = options.width * 10;
        } else {
          _this.fontSize = options.fontSize;
        }
        _this.guardHeight = options.height + _this.fontSize / 2 + options.textMargin;
        return _this;
      }
      _createClass(UPCE2, [{
        key: "valid",
        value: function valid() {
          return this.isValid;
        }
      }, {
        key: "encode",
        value: function encode3() {
          if (this.options.flat) {
            return this.flatEncoding();
          } else {
            return this.guardedEncoding();
          }
        }
      }, {
        key: "flatEncoding",
        value: function flatEncoding() {
          var result = "";
          result += "101";
          result += this.encodeMiddleDigits();
          result += "010101";
          return {
            data: result,
            text: this.text
          };
        }
      }, {
        key: "guardedEncoding",
        value: function guardedEncoding() {
          var result = [];
          if (this.displayValue) {
            result.push({
              data: "00000000",
              text: this.text[0],
              options: { textAlign: "left", fontSize: this.fontSize }
            });
          }
          result.push({
            data: "101",
            options: { height: this.guardHeight }
          });
          result.push({
            data: this.encodeMiddleDigits(),
            text: this.text.substring(1, 7),
            options: { fontSize: this.fontSize }
          });
          result.push({
            data: "010101",
            options: { height: this.guardHeight }
          });
          if (this.displayValue) {
            result.push({
              data: "00000000",
              text: this.text[7],
              options: { textAlign: "right", fontSize: this.fontSize }
            });
          }
          return result;
        }
      }, {
        key: "encodeMiddleDigits",
        value: function encodeMiddleDigits() {
          var numberSystem = this.upcA[0];
          var checkDigit = this.upcA[this.upcA.length - 1];
          var parity = PARITIES[parseInt(checkDigit)][parseInt(numberSystem)];
          return (0, _encoder2.default)(this.middleDigits, parity);
        }
      }]);
      return UPCE2;
    }(_Barcode3.default);
    function expandToUPCA(middleDigits, numberSystem) {
      var lastUpcE = parseInt(middleDigits[middleDigits.length - 1]);
      var expansion = EXPANSIONS[lastUpcE];
      var result = "";
      var digitIndex = 0;
      for (var i3 = 0; i3 < expansion.length; i3++) {
        var c2 = expansion[i3];
        if (c2 === "X") {
          result += middleDigits[digitIndex++];
        } else {
          result += c2;
        }
      }
      result = "" + numberSystem + result;
      return "" + result + (0, _UPC.checksum)(result);
    }
    exports.default = UPCE;
  }
});

// node_modules/jsbarcode/bin/barcodes/EAN_UPC/index.js
var require_EAN_UPC = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/EAN_UPC/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UPCE = exports.UPC = exports.EAN2 = exports.EAN5 = exports.EAN8 = exports.EAN13 = void 0;
    var _EAN = require_EAN13();
    var _EAN2 = _interopRequireDefault(_EAN);
    var _EAN3 = require_EAN8();
    var _EAN4 = _interopRequireDefault(_EAN3);
    var _EAN5 = require_EAN5();
    var _EAN6 = _interopRequireDefault(_EAN5);
    var _EAN7 = require_EAN2();
    var _EAN8 = _interopRequireDefault(_EAN7);
    var _UPC = require_UPC();
    var _UPC2 = _interopRequireDefault(_UPC);
    var _UPCE = require_UPCE();
    var _UPCE2 = _interopRequireDefault(_UPCE);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.EAN13 = _EAN2.default;
    exports.EAN8 = _EAN4.default;
    exports.EAN5 = _EAN6.default;
    exports.EAN2 = _EAN8.default;
    exports.UPC = _UPC2.default;
    exports.UPCE = _UPCE2.default;
  }
});

// node_modules/jsbarcode/bin/barcodes/ITF/constants.js
var require_constants3 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/ITF/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var START_BIN = exports.START_BIN = "1010";
    var END_BIN = exports.END_BIN = "11101";
    var BINARIES = exports.BINARIES = ["00110", "10001", "01001", "11000", "00101", "10100", "01100", "00011", "10010", "01010"];
  }
});

// node_modules/jsbarcode/bin/barcodes/ITF/ITF.js
var require_ITF = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/ITF/ITF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _constants = require_constants3();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ITF = function(_Barcode) {
      _inherits(ITF2, _Barcode);
      function ITF2() {
        _classCallCheck(this, ITF2);
        return _possibleConstructorReturn(this, (ITF2.__proto__ || Object.getPrototypeOf(ITF2)).apply(this, arguments));
      }
      _createClass(ITF2, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^([0-9]{2})+$/) !== -1;
        }
      }, {
        key: "encode",
        value: function encode3() {
          var _this2 = this;
          var encoded = this.data.match(/.{2}/g).map(function(pair) {
            return _this2.encodePair(pair);
          }).join("");
          return {
            data: _constants.START_BIN + encoded + _constants.END_BIN,
            text: this.text
          };
        }
        // Calculate the data of a number pair
      }, {
        key: "encodePair",
        value: function encodePair(pair) {
          var second = _constants.BINARIES[pair[1]];
          return _constants.BINARIES[pair[0]].split("").map(function(first, idx) {
            return (first === "1" ? "111" : "1") + (second[idx] === "1" ? "000" : "0");
          }).join("");
        }
      }]);
      return ITF2;
    }(_Barcode3.default);
    exports.default = ITF;
  }
});

// node_modules/jsbarcode/bin/barcodes/ITF/ITF14.js
var require_ITF14 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/ITF/ITF14.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _ITF2 = require_ITF();
    var _ITF3 = _interopRequireDefault(_ITF2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var checksum = function checksum2(data) {
      var res = data.substr(0, 13).split("").map(function(num) {
        return parseInt(num, 10);
      }).reduce(function(sum, n2, idx) {
        return sum + n2 * (3 - idx % 2 * 2);
      }, 0);
      return Math.ceil(res / 10) * 10 - res;
    };
    var ITF14 = function(_ITF) {
      _inherits(ITF142, _ITF);
      function ITF142(data, options) {
        _classCallCheck(this, ITF142);
        if (data.search(/^[0-9]{13}$/) !== -1) {
          data += checksum(data);
        }
        return _possibleConstructorReturn(this, (ITF142.__proto__ || Object.getPrototypeOf(ITF142)).call(this, data, options));
      }
      _createClass(ITF142, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]{14}$/) !== -1 && +this.data[13] === checksum(this.data);
        }
      }]);
      return ITF142;
    }(_ITF3.default);
    exports.default = ITF14;
  }
});

// node_modules/jsbarcode/bin/barcodes/ITF/index.js
var require_ITF2 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/ITF/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ITF14 = exports.ITF = void 0;
    var _ITF = require_ITF();
    var _ITF2 = _interopRequireDefault(_ITF);
    var _ITF3 = require_ITF14();
    var _ITF4 = _interopRequireDefault(_ITF3);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.ITF = _ITF2.default;
    exports.ITF14 = _ITF4.default;
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/MSI.js
var require_MSI = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/MSI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MSI = function(_Barcode) {
      _inherits(MSI2, _Barcode);
      function MSI2(data, options) {
        _classCallCheck(this, MSI2);
        return _possibleConstructorReturn(this, (MSI2.__proto__ || Object.getPrototypeOf(MSI2)).call(this, data, options));
      }
      _createClass(MSI2, [{
        key: "encode",
        value: function encode3() {
          var ret = "110";
          for (var i3 = 0; i3 < this.data.length; i3++) {
            var digit = parseInt(this.data[i3]);
            var bin = digit.toString(2);
            bin = addZeroes(bin, 4 - bin.length);
            for (var b2 = 0; b2 < bin.length; b2++) {
              ret += bin[b2] == "0" ? "100" : "110";
            }
          }
          ret += "1001";
          return {
            data: ret,
            text: this.text
          };
        }
      }, {
        key: "valid",
        value: function valid() {
          return this.data.search(/^[0-9]+$/) !== -1;
        }
      }]);
      return MSI2;
    }(_Barcode3.default);
    function addZeroes(number, n2) {
      for (var i3 = 0; i3 < n2; i3++) {
        number = "0" + number;
      }
      return number;
    }
    exports.default = MSI;
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/checksums.js
var require_checksums = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/checksums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mod10 = mod10;
    exports.mod11 = mod11;
    function mod10(number) {
      var sum = 0;
      for (var i3 = 0; i3 < number.length; i3++) {
        var n2 = parseInt(number[i3]);
        if ((i3 + number.length) % 2 === 0) {
          sum += n2;
        } else {
          sum += n2 * 2 % 10 + Math.floor(n2 * 2 / 10);
        }
      }
      return (10 - sum % 10) % 10;
    }
    function mod11(number) {
      var sum = 0;
      var weights = [2, 3, 4, 5, 6, 7];
      for (var i3 = 0; i3 < number.length; i3++) {
        var n2 = parseInt(number[number.length - 1 - i3]);
        sum += weights[i3 % weights.length] * n2;
      }
      return (11 - sum % 11) % 11;
    }
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/MSI10.js
var require_MSI10 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/MSI10.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _MSI2 = require_MSI();
    var _MSI3 = _interopRequireDefault(_MSI2);
    var _checksums = require_checksums();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MSI10 = function(_MSI) {
      _inherits(MSI102, _MSI);
      function MSI102(data, options) {
        _classCallCheck(this, MSI102);
        return _possibleConstructorReturn(this, (MSI102.__proto__ || Object.getPrototypeOf(MSI102)).call(this, data + (0, _checksums.mod10)(data), options));
      }
      return MSI102;
    }(_MSI3.default);
    exports.default = MSI10;
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/MSI11.js
var require_MSI11 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/MSI11.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _MSI2 = require_MSI();
    var _MSI3 = _interopRequireDefault(_MSI2);
    var _checksums = require_checksums();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MSI11 = function(_MSI) {
      _inherits(MSI112, _MSI);
      function MSI112(data, options) {
        _classCallCheck(this, MSI112);
        return _possibleConstructorReturn(this, (MSI112.__proto__ || Object.getPrototypeOf(MSI112)).call(this, data + (0, _checksums.mod11)(data), options));
      }
      return MSI112;
    }(_MSI3.default);
    exports.default = MSI11;
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/MSI1010.js
var require_MSI1010 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/MSI1010.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _MSI2 = require_MSI();
    var _MSI3 = _interopRequireDefault(_MSI2);
    var _checksums = require_checksums();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MSI1010 = function(_MSI) {
      _inherits(MSI10102, _MSI);
      function MSI10102(data, options) {
        _classCallCheck(this, MSI10102);
        data += (0, _checksums.mod10)(data);
        data += (0, _checksums.mod10)(data);
        return _possibleConstructorReturn(this, (MSI10102.__proto__ || Object.getPrototypeOf(MSI10102)).call(this, data, options));
      }
      return MSI10102;
    }(_MSI3.default);
    exports.default = MSI1010;
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/MSI1110.js
var require_MSI1110 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/MSI1110.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _MSI2 = require_MSI();
    var _MSI3 = _interopRequireDefault(_MSI2);
    var _checksums = require_checksums();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var MSI1110 = function(_MSI) {
      _inherits(MSI11102, _MSI);
      function MSI11102(data, options) {
        _classCallCheck(this, MSI11102);
        data += (0, _checksums.mod11)(data);
        data += (0, _checksums.mod10)(data);
        return _possibleConstructorReturn(this, (MSI11102.__proto__ || Object.getPrototypeOf(MSI11102)).call(this, data, options));
      }
      return MSI11102;
    }(_MSI3.default);
    exports.default = MSI1110;
  }
});

// node_modules/jsbarcode/bin/barcodes/MSI/index.js
var require_MSI2 = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/MSI/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MSI1110 = exports.MSI1010 = exports.MSI11 = exports.MSI10 = exports.MSI = void 0;
    var _MSI = require_MSI();
    var _MSI2 = _interopRequireDefault(_MSI);
    var _MSI3 = require_MSI10();
    var _MSI4 = _interopRequireDefault(_MSI3);
    var _MSI5 = require_MSI11();
    var _MSI6 = _interopRequireDefault(_MSI5);
    var _MSI7 = require_MSI1010();
    var _MSI8 = _interopRequireDefault(_MSI7);
    var _MSI9 = require_MSI1110();
    var _MSI10 = _interopRequireDefault(_MSI9);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.MSI = _MSI2.default;
    exports.MSI10 = _MSI4.default;
    exports.MSI11 = _MSI6.default;
    exports.MSI1010 = _MSI8.default;
    exports.MSI1110 = _MSI10.default;
  }
});

// node_modules/jsbarcode/bin/barcodes/pharmacode/index.js
var require_pharmacode = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/pharmacode/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pharmacode = void 0;
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var pharmacode = function(_Barcode) {
      _inherits(pharmacode2, _Barcode);
      function pharmacode2(data, options) {
        _classCallCheck(this, pharmacode2);
        var _this = _possibleConstructorReturn(this, (pharmacode2.__proto__ || Object.getPrototypeOf(pharmacode2)).call(this, data, options));
        _this.number = parseInt(data, 10);
        return _this;
      }
      _createClass(pharmacode2, [{
        key: "encode",
        value: function encode3() {
          var z2 = this.number;
          var result = "";
          while (!isNaN(z2) && z2 != 0) {
            if (z2 % 2 === 0) {
              result = "11100" + result;
              z2 = (z2 - 2) / 2;
            } else {
              result = "100" + result;
              z2 = (z2 - 1) / 2;
            }
          }
          result = result.slice(0, -2);
          return {
            data: result,
            text: this.text
          };
        }
      }, {
        key: "valid",
        value: function valid() {
          return this.number >= 3 && this.number <= 131070;
        }
      }]);
      return pharmacode2;
    }(_Barcode3.default);
    exports.pharmacode = pharmacode;
  }
});

// node_modules/jsbarcode/bin/barcodes/codabar/index.js
var require_codabar = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/codabar/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codabar = void 0;
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var codabar = function(_Barcode) {
      _inherits(codabar2, _Barcode);
      function codabar2(data, options) {
        _classCallCheck(this, codabar2);
        if (data.search(/^[0-9\-\$\:\.\+\/]+$/) === 0) {
          data = "A" + data + "A";
        }
        var _this = _possibleConstructorReturn(this, (codabar2.__proto__ || Object.getPrototypeOf(codabar2)).call(this, data.toUpperCase(), options));
        _this.text = _this.options.text || _this.text.replace(/[A-D]/g, "");
        return _this;
      }
      _createClass(codabar2, [{
        key: "valid",
        value: function valid() {
          return this.data.search(/^[A-D][0-9\-\$\:\.\+\/]+[A-D]$/) !== -1;
        }
      }, {
        key: "encode",
        value: function encode3() {
          var result = [];
          var encodings = this.getEncodings();
          for (var i3 = 0; i3 < this.data.length; i3++) {
            result.push(encodings[this.data.charAt(i3)]);
            if (i3 !== this.data.length - 1) {
              result.push("0");
            }
          }
          return {
            text: this.text,
            data: result.join("")
          };
        }
      }, {
        key: "getEncodings",
        value: function getEncodings() {
          return {
            "0": "101010011",
            "1": "101011001",
            "2": "101001011",
            "3": "110010101",
            "4": "101101001",
            "5": "110101001",
            "6": "100101011",
            "7": "100101101",
            "8": "100110101",
            "9": "110100101",
            "-": "101001101",
            "$": "101100101",
            ":": "1101011011",
            "/": "1101101011",
            ".": "1101101101",
            "+": "1011011011",
            "A": "1011001001",
            "B": "1001001011",
            "C": "1010010011",
            "D": "1010011001"
          };
        }
      }]);
      return codabar2;
    }(_Barcode3.default);
    exports.codabar = codabar;
  }
});

// node_modules/jsbarcode/bin/barcodes/GenericBarcode/index.js
var require_GenericBarcode = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/GenericBarcode/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GenericBarcode = void 0;
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Barcode2 = require_Barcode();
    var _Barcode3 = _interopRequireDefault(_Barcode2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var GenericBarcode = function(_Barcode) {
      _inherits(GenericBarcode2, _Barcode);
      function GenericBarcode2(data, options) {
        _classCallCheck(this, GenericBarcode2);
        return _possibleConstructorReturn(this, (GenericBarcode2.__proto__ || Object.getPrototypeOf(GenericBarcode2)).call(this, data, options));
      }
      _createClass(GenericBarcode2, [{
        key: "encode",
        value: function encode3() {
          return {
            data: "10101010101010101010101010101010101010101",
            text: this.text
          };
        }
        // Resturn true/false if the string provided is valid for this encoder
      }, {
        key: "valid",
        value: function valid() {
          return true;
        }
      }]);
      return GenericBarcode2;
    }(_Barcode3.default);
    exports.GenericBarcode = GenericBarcode;
  }
});

// node_modules/jsbarcode/bin/barcodes/index.js
var require_barcodes = __commonJS({
  "node_modules/jsbarcode/bin/barcodes/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _CODE = require_CODE39();
    var _CODE2 = require_CODE1282();
    var _EAN_UPC = require_EAN_UPC();
    var _ITF = require_ITF2();
    var _MSI = require_MSI2();
    var _pharmacode = require_pharmacode();
    var _codabar = require_codabar();
    var _GenericBarcode = require_GenericBarcode();
    exports.default = {
      CODE39: _CODE.CODE39,
      CODE128: _CODE2.CODE128,
      CODE128A: _CODE2.CODE128A,
      CODE128B: _CODE2.CODE128B,
      CODE128C: _CODE2.CODE128C,
      EAN13: _EAN_UPC.EAN13,
      EAN8: _EAN_UPC.EAN8,
      EAN5: _EAN_UPC.EAN5,
      EAN2: _EAN_UPC.EAN2,
      UPC: _EAN_UPC.UPC,
      UPCE: _EAN_UPC.UPCE,
      ITF14: _ITF.ITF14,
      ITF: _ITF.ITF,
      MSI: _MSI.MSI,
      MSI10: _MSI.MSI10,
      MSI11: _MSI.MSI11,
      MSI1010: _MSI.MSI1010,
      MSI1110: _MSI.MSI1110,
      pharmacode: _pharmacode.pharmacode,
      codabar: _codabar.codabar,
      GenericBarcode: _GenericBarcode.GenericBarcode
    };
  }
});

// node_modules/jsbarcode/bin/help/merge.js
var require_merge = __commonJS({
  "node_modules/jsbarcode/bin/help/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _extends = Object.assign || function(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    exports.default = function(old, replaceObj) {
      return _extends({}, old, replaceObj);
    };
  }
});

// node_modules/jsbarcode/bin/help/linearizeEncodings.js
var require_linearizeEncodings = __commonJS({
  "node_modules/jsbarcode/bin/help/linearizeEncodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = linearizeEncodings;
    function linearizeEncodings(encodings) {
      var linearEncodings = [];
      function nextLevel(encoded) {
        if (Array.isArray(encoded)) {
          for (var i3 = 0; i3 < encoded.length; i3++) {
            nextLevel(encoded[i3]);
          }
        } else {
          encoded.text = encoded.text || "";
          encoded.data = encoded.data || "";
          linearEncodings.push(encoded);
        }
      }
      nextLevel(encodings);
      return linearEncodings;
    }
  }
});

// node_modules/jsbarcode/bin/help/fixOptions.js
var require_fixOptions = __commonJS({
  "node_modules/jsbarcode/bin/help/fixOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = fixOptions;
    function fixOptions(options) {
      options.marginTop = options.marginTop || options.margin;
      options.marginBottom = options.marginBottom || options.margin;
      options.marginRight = options.marginRight || options.margin;
      options.marginLeft = options.marginLeft || options.margin;
      return options;
    }
  }
});

// node_modules/jsbarcode/bin/help/optionsFromStrings.js
var require_optionsFromStrings = __commonJS({
  "node_modules/jsbarcode/bin/help/optionsFromStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = optionsFromStrings;
    function optionsFromStrings(options) {
      var intOptions = ["width", "height", "textMargin", "fontSize", "margin", "marginTop", "marginBottom", "marginLeft", "marginRight"];
      for (var intOption in intOptions) {
        if (intOptions.hasOwnProperty(intOption)) {
          intOption = intOptions[intOption];
          if (typeof options[intOption] === "string") {
            options[intOption] = parseInt(options[intOption], 10);
          }
        }
      }
      if (typeof options["displayValue"] === "string") {
        options["displayValue"] = options["displayValue"] != "false";
      }
      return options;
    }
  }
});

// node_modules/jsbarcode/bin/options/defaults.js
var require_defaults = __commonJS({
  "node_modules/jsbarcode/bin/options/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var defaults = {
      width: 2,
      height: 100,
      format: "auto",
      displayValue: true,
      fontOptions: "",
      font: "monospace",
      text: void 0,
      textAlign: "center",
      textPosition: "bottom",
      textMargin: 2,
      fontSize: 20,
      background: "#ffffff",
      lineColor: "#000000",
      margin: 10,
      marginTop: void 0,
      marginBottom: void 0,
      marginLeft: void 0,
      marginRight: void 0,
      valid: function valid() {
      }
    };
    exports.default = defaults;
  }
});

// node_modules/jsbarcode/bin/help/getOptionsFromElement.js
var require_getOptionsFromElement = __commonJS({
  "node_modules/jsbarcode/bin/help/getOptionsFromElement.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _optionsFromStrings = require_optionsFromStrings();
    var _optionsFromStrings2 = _interopRequireDefault(_optionsFromStrings);
    var _defaults = require_defaults();
    var _defaults2 = _interopRequireDefault(_defaults);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getOptionsFromElement(element) {
      var options = {};
      for (var property in _defaults2.default) {
        if (_defaults2.default.hasOwnProperty(property)) {
          if (element.hasAttribute("jsbarcode-" + property.toLowerCase())) {
            options[property] = element.getAttribute("jsbarcode-" + property.toLowerCase());
          }
          if (element.hasAttribute("data-" + property.toLowerCase())) {
            options[property] = element.getAttribute("data-" + property.toLowerCase());
          }
        }
      }
      options["value"] = element.getAttribute("jsbarcode-value") || element.getAttribute("data-value");
      options = (0, _optionsFromStrings2.default)(options);
      return options;
    }
    exports.default = getOptionsFromElement;
  }
});

// node_modules/jsbarcode/bin/renderers/shared.js
var require_shared = __commonJS({
  "node_modules/jsbarcode/bin/renderers/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getTotalWidthOfEncodings = exports.calculateEncodingAttributes = exports.getBarcodePadding = exports.getEncodingHeight = exports.getMaximumHeightOfEncodings = void 0;
    var _merge = require_merge();
    var _merge2 = _interopRequireDefault(_merge);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getEncodingHeight(encoding, options) {
      return options.height + (options.displayValue && encoding.text.length > 0 ? options.fontSize + options.textMargin : 0) + options.marginTop + options.marginBottom;
    }
    function getBarcodePadding(textWidth, barcodeWidth, options) {
      if (options.displayValue && barcodeWidth < textWidth) {
        if (options.textAlign == "center") {
          return Math.floor((textWidth - barcodeWidth) / 2);
        } else if (options.textAlign == "left") {
          return 0;
        } else if (options.textAlign == "right") {
          return Math.floor(textWidth - barcodeWidth);
        }
      }
      return 0;
    }
    function calculateEncodingAttributes(encodings, barcodeOptions, context) {
      for (var i3 = 0; i3 < encodings.length; i3++) {
        var encoding = encodings[i3];
        var options = (0, _merge2.default)(barcodeOptions, encoding.options);
        var textWidth;
        if (options.displayValue) {
          textWidth = messureText(encoding.text, options, context);
        } else {
          textWidth = 0;
        }
        var barcodeWidth = encoding.data.length * options.width;
        encoding.width = Math.ceil(Math.max(textWidth, barcodeWidth));
        encoding.height = getEncodingHeight(encoding, options);
        encoding.barcodePadding = getBarcodePadding(textWidth, barcodeWidth, options);
      }
    }
    function getTotalWidthOfEncodings(encodings) {
      var totalWidth = 0;
      for (var i3 = 0; i3 < encodings.length; i3++) {
        totalWidth += encodings[i3].width;
      }
      return totalWidth;
    }
    function getMaximumHeightOfEncodings(encodings) {
      var maxHeight = 0;
      for (var i3 = 0; i3 < encodings.length; i3++) {
        if (encodings[i3].height > maxHeight) {
          maxHeight = encodings[i3].height;
        }
      }
      return maxHeight;
    }
    function messureText(string, options, context) {
      var ctx;
      if (context) {
        ctx = context;
      } else if (typeof document !== "undefined") {
        ctx = document.createElement("canvas").getContext("2d");
      } else {
        return 0;
      }
      ctx.font = options.fontOptions + " " + options.fontSize + "px " + options.font;
      var measureTextResult = ctx.measureText(string);
      if (!measureTextResult) {
        return 0;
      }
      var size = measureTextResult.width;
      return size;
    }
    exports.getMaximumHeightOfEncodings = getMaximumHeightOfEncodings;
    exports.getEncodingHeight = getEncodingHeight;
    exports.getBarcodePadding = getBarcodePadding;
    exports.calculateEncodingAttributes = calculateEncodingAttributes;
    exports.getTotalWidthOfEncodings = getTotalWidthOfEncodings;
  }
});

// node_modules/jsbarcode/bin/renderers/canvas.js
var require_canvas = __commonJS({
  "node_modules/jsbarcode/bin/renderers/canvas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _merge = require_merge();
    var _merge2 = _interopRequireDefault(_merge);
    var _shared = require_shared();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var CanvasRenderer = function() {
      function CanvasRenderer2(canvas, encodings, options) {
        _classCallCheck(this, CanvasRenderer2);
        this.canvas = canvas;
        this.encodings = encodings;
        this.options = options;
      }
      _createClass(CanvasRenderer2, [{
        key: "render",
        value: function render() {
          if (!this.canvas.getContext) {
            throw new Error("The browser does not support canvas.");
          }
          this.prepareCanvas();
          for (var i3 = 0; i3 < this.encodings.length; i3++) {
            var encodingOptions = (0, _merge2.default)(this.options, this.encodings[i3].options);
            this.drawCanvasBarcode(encodingOptions, this.encodings[i3]);
            this.drawCanvasText(encodingOptions, this.encodings[i3]);
            this.moveCanvasDrawing(this.encodings[i3]);
          }
          this.restoreCanvas();
        }
      }, {
        key: "prepareCanvas",
        value: function prepareCanvas() {
          var ctx = this.canvas.getContext("2d");
          ctx.save();
          (0, _shared.calculateEncodingAttributes)(this.encodings, this.options, ctx);
          var totalWidth = (0, _shared.getTotalWidthOfEncodings)(this.encodings);
          var maxHeight = (0, _shared.getMaximumHeightOfEncodings)(this.encodings);
          this.canvas.width = totalWidth + this.options.marginLeft + this.options.marginRight;
          this.canvas.height = maxHeight;
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          if (this.options.background) {
            ctx.fillStyle = this.options.background;
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          }
          ctx.translate(this.options.marginLeft, 0);
        }
      }, {
        key: "drawCanvasBarcode",
        value: function drawCanvasBarcode(options, encoding) {
          var ctx = this.canvas.getContext("2d");
          var binary = encoding.data;
          var yFrom;
          if (options.textPosition == "top") {
            yFrom = options.marginTop + options.fontSize + options.textMargin;
          } else {
            yFrom = options.marginTop;
          }
          ctx.fillStyle = options.lineColor;
          for (var b2 = 0; b2 < binary.length; b2++) {
            var x2 = b2 * options.width + encoding.barcodePadding;
            if (binary[b2] === "1") {
              ctx.fillRect(x2, yFrom, options.width, options.height);
            } else if (binary[b2]) {
              ctx.fillRect(x2, yFrom, options.width, options.height * binary[b2]);
            }
          }
        }
      }, {
        key: "drawCanvasText",
        value: function drawCanvasText(options, encoding) {
          var ctx = this.canvas.getContext("2d");
          var font = options.fontOptions + " " + options.fontSize + "px " + options.font;
          if (options.displayValue) {
            var x2, y2;
            if (options.textPosition == "top") {
              y2 = options.marginTop + options.fontSize - options.textMargin;
            } else {
              y2 = options.height + options.textMargin + options.marginTop + options.fontSize;
            }
            ctx.font = font;
            if (options.textAlign == "left" || encoding.barcodePadding > 0) {
              x2 = 0;
              ctx.textAlign = "left";
            } else if (options.textAlign == "right") {
              x2 = encoding.width - 1;
              ctx.textAlign = "right";
            } else {
              x2 = encoding.width / 2;
              ctx.textAlign = "center";
            }
            ctx.fillText(encoding.text, x2, y2);
          }
        }
      }, {
        key: "moveCanvasDrawing",
        value: function moveCanvasDrawing(encoding) {
          var ctx = this.canvas.getContext("2d");
          ctx.translate(encoding.width, 0);
        }
      }, {
        key: "restoreCanvas",
        value: function restoreCanvas() {
          var ctx = this.canvas.getContext("2d");
          ctx.restore();
        }
      }]);
      return CanvasRenderer2;
    }();
    exports.default = CanvasRenderer;
  }
});

// node_modules/jsbarcode/bin/renderers/svg.js
var require_svg = __commonJS({
  "node_modules/jsbarcode/bin/renderers/svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _merge = require_merge();
    var _merge2 = _interopRequireDefault(_merge);
    var _shared = require_shared();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var svgns = "http://www.w3.org/2000/svg";
    var SVGRenderer = function() {
      function SVGRenderer2(svg, encodings, options) {
        _classCallCheck(this, SVGRenderer2);
        this.svg = svg;
        this.encodings = encodings;
        this.options = options;
        this.document = options.xmlDocument || document;
      }
      _createClass(SVGRenderer2, [{
        key: "render",
        value: function render() {
          var currentX = this.options.marginLeft;
          this.prepareSVG();
          for (var i3 = 0; i3 < this.encodings.length; i3++) {
            var encoding = this.encodings[i3];
            var encodingOptions = (0, _merge2.default)(this.options, encoding.options);
            var group = this.createGroup(currentX, encodingOptions.marginTop, this.svg);
            this.setGroupOptions(group, encodingOptions);
            this.drawSvgBarcode(group, encodingOptions, encoding);
            this.drawSVGText(group, encodingOptions, encoding);
            currentX += encoding.width;
          }
        }
      }, {
        key: "prepareSVG",
        value: function prepareSVG() {
          while (this.svg.firstChild) {
            this.svg.removeChild(this.svg.firstChild);
          }
          (0, _shared.calculateEncodingAttributes)(this.encodings, this.options);
          var totalWidth = (0, _shared.getTotalWidthOfEncodings)(this.encodings);
          var maxHeight = (0, _shared.getMaximumHeightOfEncodings)(this.encodings);
          var width = totalWidth + this.options.marginLeft + this.options.marginRight;
          this.setSvgAttributes(width, maxHeight);
          if (this.options.background) {
            this.drawRect(0, 0, width, maxHeight, this.svg).setAttribute("style", "fill:" + this.options.background + ";");
          }
        }
      }, {
        key: "drawSvgBarcode",
        value: function drawSvgBarcode(parent, options, encoding) {
          var binary = encoding.data;
          var yFrom;
          if (options.textPosition == "top") {
            yFrom = options.fontSize + options.textMargin;
          } else {
            yFrom = 0;
          }
          var barWidth = 0;
          var x2 = 0;
          for (var b2 = 0; b2 < binary.length; b2++) {
            x2 = b2 * options.width + encoding.barcodePadding;
            if (binary[b2] === "1") {
              barWidth++;
            } else if (barWidth > 0) {
              this.drawRect(x2 - options.width * barWidth, yFrom, options.width * barWidth, options.height, parent);
              barWidth = 0;
            }
          }
          if (barWidth > 0) {
            this.drawRect(x2 - options.width * (barWidth - 1), yFrom, options.width * barWidth, options.height, parent);
          }
        }
      }, {
        key: "drawSVGText",
        value: function drawSVGText(parent, options, encoding) {
          var textElem = this.document.createElementNS(svgns, "text");
          if (options.displayValue) {
            var x2, y2;
            textElem.setAttribute("style", "font:" + options.fontOptions + " " + options.fontSize + "px " + options.font);
            if (options.textPosition == "top") {
              y2 = options.fontSize - options.textMargin;
            } else {
              y2 = options.height + options.textMargin + options.fontSize;
            }
            if (options.textAlign == "left" || encoding.barcodePadding > 0) {
              x2 = 0;
              textElem.setAttribute("text-anchor", "start");
            } else if (options.textAlign == "right") {
              x2 = encoding.width - 1;
              textElem.setAttribute("text-anchor", "end");
            } else {
              x2 = encoding.width / 2;
              textElem.setAttribute("text-anchor", "middle");
            }
            textElem.setAttribute("x", x2);
            textElem.setAttribute("y", y2);
            textElem.appendChild(this.document.createTextNode(encoding.text));
            parent.appendChild(textElem);
          }
        }
      }, {
        key: "setSvgAttributes",
        value: function setSvgAttributes(width, height) {
          var svg = this.svg;
          svg.setAttribute("width", width + "px");
          svg.setAttribute("height", height + "px");
          svg.setAttribute("x", "0px");
          svg.setAttribute("y", "0px");
          svg.setAttribute("viewBox", "0 0 " + width + " " + height);
          svg.setAttribute("xmlns", svgns);
          svg.setAttribute("version", "1.1");
          svg.setAttribute("style", "transform: translate(0,0)");
        }
      }, {
        key: "createGroup",
        value: function createGroup(x2, y2, parent) {
          var group = this.document.createElementNS(svgns, "g");
          group.setAttribute("transform", "translate(" + x2 + ", " + y2 + ")");
          parent.appendChild(group);
          return group;
        }
      }, {
        key: "setGroupOptions",
        value: function setGroupOptions(group, options) {
          group.setAttribute("style", "fill:" + options.lineColor + ";");
        }
      }, {
        key: "drawRect",
        value: function drawRect(x2, y2, width, height, parent) {
          var rect = this.document.createElementNS(svgns, "rect");
          rect.setAttribute("x", x2);
          rect.setAttribute("y", y2);
          rect.setAttribute("width", width);
          rect.setAttribute("height", height);
          parent.appendChild(rect);
          return rect;
        }
      }]);
      return SVGRenderer2;
    }();
    exports.default = SVGRenderer;
  }
});

// node_modules/jsbarcode/bin/renderers/object.js
var require_object = __commonJS({
  "node_modules/jsbarcode/bin/renderers/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ObjectRenderer = function() {
      function ObjectRenderer2(object, encodings, options) {
        _classCallCheck(this, ObjectRenderer2);
        this.object = object;
        this.encodings = encodings;
        this.options = options;
      }
      _createClass(ObjectRenderer2, [{
        key: "render",
        value: function render() {
          this.object.encodings = this.encodings;
        }
      }]);
      return ObjectRenderer2;
    }();
    exports.default = ObjectRenderer;
  }
});

// node_modules/jsbarcode/bin/renderers/index.js
var require_renderers = __commonJS({
  "node_modules/jsbarcode/bin/renderers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _canvas = require_canvas();
    var _canvas2 = _interopRequireDefault(_canvas);
    var _svg = require_svg();
    var _svg2 = _interopRequireDefault(_svg);
    var _object = require_object();
    var _object2 = _interopRequireDefault(_object);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = { CanvasRenderer: _canvas2.default, SVGRenderer: _svg2.default, ObjectRenderer: _object2.default };
  }
});

// node_modules/jsbarcode/bin/exceptions/exceptions.js
var require_exceptions = __commonJS({
  "node_modules/jsbarcode/bin/exceptions/exceptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var InvalidInputException = function(_Error) {
      _inherits(InvalidInputException2, _Error);
      function InvalidInputException2(symbology, input) {
        _classCallCheck(this, InvalidInputException2);
        var _this = _possibleConstructorReturn(this, (InvalidInputException2.__proto__ || Object.getPrototypeOf(InvalidInputException2)).call(this));
        _this.name = "InvalidInputException";
        _this.symbology = symbology;
        _this.input = input;
        _this.message = '"' + _this.input + '" is not a valid input for ' + _this.symbology;
        return _this;
      }
      return InvalidInputException2;
    }(Error);
    var InvalidElementException = function(_Error2) {
      _inherits(InvalidElementException2, _Error2);
      function InvalidElementException2() {
        _classCallCheck(this, InvalidElementException2);
        var _this2 = _possibleConstructorReturn(this, (InvalidElementException2.__proto__ || Object.getPrototypeOf(InvalidElementException2)).call(this));
        _this2.name = "InvalidElementException";
        _this2.message = "Not supported type to render on";
        return _this2;
      }
      return InvalidElementException2;
    }(Error);
    var NoElementException = function(_Error3) {
      _inherits(NoElementException2, _Error3);
      function NoElementException2() {
        _classCallCheck(this, NoElementException2);
        var _this3 = _possibleConstructorReturn(this, (NoElementException2.__proto__ || Object.getPrototypeOf(NoElementException2)).call(this));
        _this3.name = "NoElementException";
        _this3.message = "No element to render on.";
        return _this3;
      }
      return NoElementException2;
    }(Error);
    exports.InvalidInputException = InvalidInputException;
    exports.InvalidElementException = InvalidElementException;
    exports.NoElementException = NoElementException;
  }
});

// node_modules/jsbarcode/bin/help/getRenderProperties.js
var require_getRenderProperties = __commonJS({
  "node_modules/jsbarcode/bin/help/getRenderProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _getOptionsFromElement = require_getOptionsFromElement();
    var _getOptionsFromElement2 = _interopRequireDefault(_getOptionsFromElement);
    var _renderers = require_renderers();
    var _renderers2 = _interopRequireDefault(_renderers);
    var _exceptions = require_exceptions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getRenderProperties(element) {
      if (typeof element === "string") {
        return querySelectedRenderProperties(element);
      } else if (Array.isArray(element)) {
        var returnArray = [];
        for (var i3 = 0; i3 < element.length; i3++) {
          returnArray.push(getRenderProperties(element[i3]));
        }
        return returnArray;
      } else if (typeof HTMLCanvasElement !== "undefined" && element instanceof HTMLImageElement) {
        return newCanvasRenderProperties(element);
      } else if (element && element.nodeName && element.nodeName.toLowerCase() === "svg" || typeof SVGElement !== "undefined" && element instanceof SVGElement) {
        return {
          element,
          options: (0, _getOptionsFromElement2.default)(element),
          renderer: _renderers2.default.SVGRenderer
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && element instanceof HTMLCanvasElement) {
        return {
          element,
          options: (0, _getOptionsFromElement2.default)(element),
          renderer: _renderers2.default.CanvasRenderer
        };
      } else if (element && element.getContext) {
        return {
          element,
          renderer: _renderers2.default.CanvasRenderer
        };
      } else if (element && (typeof element === "undefined" ? "undefined" : _typeof2(element)) === "object" && !element.nodeName) {
        return {
          element,
          renderer: _renderers2.default.ObjectRenderer
        };
      } else {
        throw new _exceptions.InvalidElementException();
      }
    }
    function querySelectedRenderProperties(string) {
      var selector = document.querySelectorAll(string);
      if (selector.length === 0) {
        return void 0;
      } else {
        var returnArray = [];
        for (var i3 = 0; i3 < selector.length; i3++) {
          returnArray.push(getRenderProperties(selector[i3]));
        }
        return returnArray;
      }
    }
    function newCanvasRenderProperties(imgElement) {
      var canvas = document.createElement("canvas");
      return {
        element: canvas,
        options: (0, _getOptionsFromElement2.default)(imgElement),
        renderer: _renderers2.default.CanvasRenderer,
        afterRender: function afterRender() {
          imgElement.setAttribute("src", canvas.toDataURL());
        }
      };
    }
    exports.default = getRenderProperties;
  }
});

// node_modules/jsbarcode/bin/exceptions/ErrorHandler.js
var require_ErrorHandler = __commonJS({
  "node_modules/jsbarcode/bin/exceptions/ErrorHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ErrorHandler = function() {
      function ErrorHandler2(api) {
        _classCallCheck(this, ErrorHandler2);
        this.api = api;
      }
      _createClass(ErrorHandler2, [{
        key: "handleCatch",
        value: function handleCatch(e) {
          if (e.name === "InvalidInputException") {
            if (this.api._options.valid !== this.api._defaults.valid) {
              this.api._options.valid(false);
            } else {
              throw e.message;
            }
          } else {
            throw e;
          }
          this.api.render = function() {
          };
        }
      }, {
        key: "wrapBarcodeCall",
        value: function wrapBarcodeCall(func) {
          try {
            var result = func.apply(void 0, arguments);
            this.api._options.valid(true);
            return result;
          } catch (e) {
            this.handleCatch(e);
            return this.api;
          }
        }
      }]);
      return ErrorHandler2;
    }();
    exports.default = ErrorHandler;
  }
});

// node_modules/jsbarcode/bin/JsBarcode.js
var require_JsBarcode = __commonJS({
  "node_modules/jsbarcode/bin/JsBarcode.js"(exports, module) {
    "use strict";
    var _barcodes = require_barcodes();
    var _barcodes2 = _interopRequireDefault(_barcodes);
    var _merge = require_merge();
    var _merge2 = _interopRequireDefault(_merge);
    var _linearizeEncodings = require_linearizeEncodings();
    var _linearizeEncodings2 = _interopRequireDefault(_linearizeEncodings);
    var _fixOptions = require_fixOptions();
    var _fixOptions2 = _interopRequireDefault(_fixOptions);
    var _getRenderProperties = require_getRenderProperties();
    var _getRenderProperties2 = _interopRequireDefault(_getRenderProperties);
    var _optionsFromStrings = require_optionsFromStrings();
    var _optionsFromStrings2 = _interopRequireDefault(_optionsFromStrings);
    var _ErrorHandler = require_ErrorHandler();
    var _ErrorHandler2 = _interopRequireDefault(_ErrorHandler);
    var _exceptions = require_exceptions();
    var _defaults = require_defaults();
    var _defaults2 = _interopRequireDefault(_defaults);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var API = function API2() {
    };
    var JsBarcode = function JsBarcode2(element, text, options) {
      var api = new API();
      if (typeof element === "undefined") {
        throw Error("No element to render on was provided.");
      }
      api._renderProperties = (0, _getRenderProperties2.default)(element);
      api._encodings = [];
      api._options = _defaults2.default;
      api._errorHandler = new _ErrorHandler2.default(api);
      if (typeof text !== "undefined") {
        options = options || {};
        if (!options.format) {
          options.format = autoSelectBarcode();
        }
        api.options(options)[options.format](text, options).render();
      }
      return api;
    };
    JsBarcode.getModule = function(name2) {
      return _barcodes2.default[name2];
    };
    for (name in _barcodes2.default) {
      if (_barcodes2.default.hasOwnProperty(name)) {
        registerBarcode(_barcodes2.default, name);
      }
    }
    var name;
    function registerBarcode(barcodes, name2) {
      API.prototype[name2] = API.prototype[name2.toUpperCase()] = API.prototype[name2.toLowerCase()] = function(text, options) {
        var api = this;
        return api._errorHandler.wrapBarcodeCall(function() {
          options.text = typeof options.text === "undefined" ? void 0 : "" + options.text;
          var newOptions = (0, _merge2.default)(api._options, options);
          newOptions = (0, _optionsFromStrings2.default)(newOptions);
          var Encoder2 = barcodes[name2];
          var encoded = encode3(text, Encoder2, newOptions);
          api._encodings.push(encoded);
          return api;
        });
      };
    }
    function encode3(text, Encoder2, options) {
      text = "" + text;
      var encoder = new Encoder2(text, options);
      if (!encoder.valid()) {
        throw new _exceptions.InvalidInputException(encoder.constructor.name, text);
      }
      var encoded = encoder.encode();
      encoded = (0, _linearizeEncodings2.default)(encoded);
      for (var i3 = 0; i3 < encoded.length; i3++) {
        encoded[i3].options = (0, _merge2.default)(options, encoded[i3].options);
      }
      return encoded;
    }
    function autoSelectBarcode() {
      if (_barcodes2.default["CODE128"]) {
        return "CODE128";
      }
      return Object.keys(_barcodes2.default)[0];
    }
    API.prototype.options = function(options) {
      this._options = (0, _merge2.default)(this._options, options);
      return this;
    };
    API.prototype.blank = function(size) {
      var zeroes = new Array(size + 1).join("0");
      this._encodings.push({ data: zeroes });
      return this;
    };
    API.prototype.init = function() {
      if (!this._renderProperties) {
        return;
      }
      if (!Array.isArray(this._renderProperties)) {
        this._renderProperties = [this._renderProperties];
      }
      var renderProperty;
      for (var i3 in this._renderProperties) {
        renderProperty = this._renderProperties[i3];
        var options = (0, _merge2.default)(this._options, renderProperty.options);
        if (options.format == "auto") {
          options.format = autoSelectBarcode();
        }
        this._errorHandler.wrapBarcodeCall(function() {
          var text = options.value;
          var Encoder2 = _barcodes2.default[options.format.toUpperCase()];
          var encoded = encode3(text, Encoder2, options);
          render(renderProperty, encoded, options);
        });
      }
    };
    API.prototype.render = function() {
      if (!this._renderProperties) {
        throw new _exceptions.NoElementException();
      }
      if (Array.isArray(this._renderProperties)) {
        for (var i3 = 0; i3 < this._renderProperties.length; i3++) {
          render(this._renderProperties[i3], this._encodings, this._options);
        }
      } else {
        render(this._renderProperties, this._encodings, this._options);
      }
      return this;
    };
    API.prototype._defaults = _defaults2.default;
    function render(renderProperties, encodings, options) {
      encodings = (0, _linearizeEncodings2.default)(encodings);
      for (var i3 = 0; i3 < encodings.length; i3++) {
        encodings[i3].options = (0, _merge2.default)(options, encodings[i3].options);
        (0, _fixOptions2.default)(encodings[i3].options);
      }
      (0, _fixOptions2.default)(options);
      var Renderer = renderProperties.renderer;
      var renderer = new Renderer(renderProperties.element, encodings, options);
      renderer.render();
      if (renderProperties.afterRender) {
        renderProperties.afterRender();
      }
    }
    if (typeof window !== "undefined") {
      window.JsBarcode = JsBarcode;
    }
    if (typeof jQuery !== "undefined") {
      jQuery.fn.JsBarcode = function(content, options) {
        var elementArray = [];
        jQuery(this).each(function() {
          elementArray.push(this);
        });
        return JsBarcode(elementArray, content, options);
      };
    }
    module.exports = JsBarcode;
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f2) {
      if (typeof f2 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f2;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from2(value2, defaultValue) {
      if (exports.isValid(value2)) {
        return value2;
      }
      try {
        return fromString(value2);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length2) {
        for (let i3 = 0; i3 < length2; i3++) {
          this.putBit((num >>> length2 - i3 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value2, reserved) {
      const index = row * this.size + col;
      this.data[index] = value2;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value2) {
      this.data[row * this.size + col] ^= value2;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i3 = 1; i3 < posCount - 1; i3++) {
        positions[i3] = positions[i3 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;
      for (let i3 = 0; i3 < posLength; i3++) {
        for (let j2 = 0; j2 < posLength; j2++) {
          if (i3 === 0 && j2 === 0 || // top-left
          i3 === 0 && j2 === posLength - 1 || // bottom-left
          i3 === posLength - 1 && j2 === 0) {
            continue;
          }
          coords.push([pos[i3], pos[j2]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from2(value2) {
      return exports.isValid(value2) ? parseInt(value2, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i3 = 0; i3 < modulesCount; i3++)
        darkCount += data.data[i3];
      const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k2 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i3, j2) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i3 + j2) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i3 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j2 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i3 + j2) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i3 / 2) + Math.floor(j2 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i3 * j2 % 2 + i3 * j2 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i3 * j2 % 2 + i3 * j2 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i3 * j2 % 3 + (i3 + j2) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p2 = 0; p2 < numPatterns; p2++) {
        setupFormatFunc(p2);
        exports.applyMask(p2, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p2, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p2;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x2 = 1;
      for (let i3 = 0; i3 < 255; i3++) {
        EXP_TABLE[i3] = x2;
        LOG_TABLE[x2] = i3;
        x2 <<= 1;
        if (x2 & 256) {
          x2 ^= 285;
        }
      }
      for (let i3 = 255; i3 < 512; i3++) {
        EXP_TABLE[i3] = EXP_TABLE[i3 - 255];
      }
    })();
    exports.log = function log(n2) {
      if (n2 < 1)
        throw new Error("log(" + n2 + ")");
      return LOG_TABLE[n2];
    };
    exports.exp = function exp(n2) {
      return EXP_TABLE[n2];
    };
    exports.mul = function mul(x2, y2) {
      if (x2 === 0 || y2 === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i3 = 0; i3 < p1.length; i3++) {
        for (let j2 = 0; j2 < p2.length; j2++) {
          coeff[i3 + j2] ^= GF.mul(p1[i3], p2[j2]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i3 = 0; i3 < divisor.length; i3++) {
          result[i3] ^= GF.mul(divisor[i3], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i3 = 0; i3 < degree; i3++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i3)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode3(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString3(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from2(value2, defaultValue) {
      if (exports.isValid(value2)) {
        return value2;
      }
      try {
        return fromString(value2);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from2(value2, defaultValue) {
      if (VersionCheck.isValid(value2)) {
        return parseInt(value2, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d2 = version << 12;
      while (Utils.getBCHDigit(d2) - G18_BCH >= 0) {
        d2 ^= G18 << Utils.getBCHDigit(d2) - G18_BCH;
      }
      return version << 12 | d2;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d2 = data << 10;
      while (Utils.getBCHDigit(d2) - G15_BCH >= 0) {
        d2 ^= G15 << Utils.getBCHDigit(d2) - G15_BCH;
      }
      return (data << 10 | d2) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i3, group, value2;
      for (i3 = 0; i3 + 3 <= this.data.length; i3 += 3) {
        group = this.data.substr(i3, 3);
        value2 = parseInt(group, 10);
        bitBuffer.put(value2, 10);
      }
      const remainingNum = this.data.length - i3;
      if (remainingNum > 0) {
        group = this.data.substr(i3);
        value2 = parseInt(group, 10);
        bitBuffer.put(value2, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i3;
      for (i3 = 0; i3 + 2 <= this.data.length; i3 += 2) {
        let value2 = ALPHA_NUM_CHARS.indexOf(this.data[i3]) * 45;
        value2 += ALPHA_NUM_CHARS.indexOf(this.data[i3 + 1]);
        bitBuffer.put(value2, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i3]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/encode-utf8/index.js
var require_encode_utf8 = __commonJS({
  "node_modules/encode-utf8/index.js"(exports, module) {
    "use strict";
    module.exports = function encodeUtf8(input) {
      var result = [];
      var size = input.length;
      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);
        if (point >= 55296 && point <= 56319 && size > index + 1) {
          var second = input.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            point = (point - 55296) * 1024 + second - 56320 + 65536;
            index += 1;
          }
        }
        if (point < 128) {
          result.push(point);
          continue;
        }
        if (point < 2048) {
          result.push(point >> 6 | 192);
          result.push(point & 63 | 128);
          continue;
        }
        if (point < 55296 || point >= 57344 && point < 65536) {
          result.push(point >> 12 | 224);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        if (point >= 65536 && point <= 1114111) {
          result.push(point >> 18 | 240);
          result.push(point >> 12 & 63 | 128);
          result.push(point >> 6 & 63 | 128);
          result.push(point & 63 | 128);
          continue;
        }
        result.push(239, 191, 189);
      }
      return new Uint8Array(result).buffer;
    };
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var encodeUtf8 = require_encode_utf8();
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        data = encodeUtf8(data);
      }
      this.data = new Uint8Array(data);
    }
    ByteData.getBitsLength = function getBitsLength(length2) {
      return length2 * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i3 = 0, l2 = this.data.length; i3 < l2; i3++) {
        bitBuffer.put(this.data[i3], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length2) {
      return length2 * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i3;
      for (i3 = 0; i3 < this.data.length; i3++) {
        let value2 = Utils.toSJIS(this.data[i3]);
        if (value2 >= 33088 && value2 <= 40956) {
          value2 -= 33088;
        } else if (value2 >= 57408 && value2 <= 60351) {
          value2 -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i3] + "\nMake sure your charset is UTF-8"
          );
        }
        value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
        bitBuffer.put(value2, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s2, d2) {
        var predecessors = {};
        var costs = {};
        costs[s2] = 0;
        var open2 = dijkstra.PriorityQueue.make();
        open2.push(s2, 0);
        var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open2.empty()) {
          closest = open2.pop();
          u2 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u2] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open2.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u2;
              }
            }
          }
        }
        if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
          var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
        var nodes = [];
        var u2 = d2;
        var predecessor;
        while (u2) {
          nodes.push(u2);
          predecessor = predecessors[u2];
          u2 = predecessors[u2];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s2, d2) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s2, d2);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d2
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T2 = dijkstra.PriorityQueue, t2 = {}, key;
          opts = opts || {};
          for (key in T2) {
            if (T2.hasOwnProperty(key)) {
              t2[key] = T2[key];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T2.default_sorter;
          return t2;
        },
        default_sorter: function(a2, b2) {
          return a2.cost - b2.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value2, cost) {
          var item = { value: value2, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module !== "undefined") {
      module.exports = dijkstra;
    }
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i3 = 0; i3 < segs.length; i3++) {
        const seg = segs[i3];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i3 = 0; i3 < nodes.length; i3++) {
        const nodeGroup = nodes[i3];
        const currentNodeIds = [];
        for (let j2 = 0; j2 < nodeGroup.length; j2++) {
          const node = nodeGroup[j2];
          const key = "" + i3 + j2;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
            const prevNodeId = prevNodeIds[n2];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
        graph[prevNodeIds[n2]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i3 = 1; i3 < path.length - 1; i3++) {
        optimizedSegs.push(graph.table[path[i3]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);
      for (let i3 = 0; i3 < pos.length; i3++) {
        const row = pos[i3][0];
        const col = pos[i3][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r)
            continue;
          for (let c2 = -1; c2 <= 7; c2++) {
            if (col + c2 <= -1 || size <= col + c2)
              continue;
            if (r >= 0 && r <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c2 >= 2 && c2 <= 4) {
              matrix.set(row + r, col + c2, true, true);
            } else {
              matrix.set(row + r, col + c2, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value2 = r % 2 === 0;
        matrix.set(r, 6, value2, true);
        matrix.set(6, r, value2, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i3 = 0; i3 < pos.length; i3++) {
        const row = pos[i3][0];
        const col = pos[i3][1];
        for (let r = -2; r <= 2; r++) {
          for (let c2 = -2; c2 <= 2; c2++) {
            if (r === -2 || r === 2 || c2 === -2 || c2 === 2 || r === 0 && c2 === 0) {
              matrix.set(row + r, col + c2, true, true);
            } else {
              matrix.set(row + r, col + c2, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits2 = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i3 = 0; i3 < 18; i3++) {
        row = Math.floor(i3 / 3);
        col = i3 % 3 + size - 8 - 3;
        mod = (bits2 >> i3 & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits2 = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i3, mod;
      for (i3 = 0; i3 < 15; i3++) {
        mod = (bits2 >> i3 & 1) === 1;
        if (i3 < 6) {
          matrix.set(i3, 8, mod, true);
        } else if (i3 < 8) {
          matrix.set(i3 + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i3, 8, mod, true);
        }
        if (i3 < 8) {
          matrix.set(8, size - i3 - 1, mod, true);
        } else if (i3 < 9) {
          matrix.set(8, 15 - i3 - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i3 - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c2 = 0; c2 < 2; c2++) {
            if (!matrix.isReserved(row, col - c2)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c2, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i3 = 0; i3 < remainingByte; i3++) {
        buffer.put(i3 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
        const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b2] = buffer.slice(offset, offset + dataSize);
        ecData[b2] = rs.encode(dcData[b2]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i3, r;
      for (i3 = 0; i3 < maxDataSize; i3++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i3 < dcData[r].length) {
            data[index++] = dcData[r][i3];
          }
        }
      }
      for (i3 = 0; i3 < ecCount; i3++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i3];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
          return [c2, c2];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i3 = 0; i3 < symbolSize; i3++) {
        for (let j2 = 0; j2 < symbolSize; j2++) {
          let posDst = (i3 * symbolSize + j2) * 4;
          let pxColor = opts.color.light;
          if (i3 >= scaledMargin && j2 >= scaledMargin && i3 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i3 - scaledMargin) / scale);
            const jSrc = Math.floor((j2 - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas2 = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x2, y2) {
      let str = cmd + x2;
      if (typeof y2 !== "undefined")
        str += " " + y2;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i3 = 0; i3 < data.length; i3++) {
        const col = Math.floor(i3 % size);
        const row = Math.floor(i3 / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i3]) {
          lineLength++;
          if (!(i3 > 0 && col > 0 && data[i3 - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i3 + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode = require_qrcode();
    var CanvasRenderer = require_canvas2();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        });
      }
      try {
        const data = QRCode.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }
    exports.create = QRCode.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _2, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i3 = 0; i3 < chars.length; i3++) {
  lookup[chars.charCodeAt(i3)] = i3;
}
var decode = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i3 = 0; i3 < len; i3 += 4) {
    encoded1 = lookup[base64.charCodeAt(i3)];
    encoded2 = lookup[base64.charCodeAt(i3 + 1)];
    encoded3 = lookup[base64.charCodeAt(i3 + 2)];
    encoded4 = lookup[base64.charCodeAt(i3 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i3) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i3] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i3 = 0; i3 < encodedPackets.length; i3++) {
    const decodedPacket = decodePacket(encodedPackets[i3], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j2 = 0;
  for (let i3 = 0; i3 < size; i3++) {
    buffer[i3] = chunks[0][j2++];
    if (j2 === chunks[0].length) {
      chunks.shift();
      j2 = 0;
    }
  }
  if (chunks.length && j2 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j2);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n2 = view.getUint32(0);
          if (n2 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/index.mjs
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i3 = 0; i3 < callbacks.length; i3++) {
    cb = callbacks[i3];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i3, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i3 = 1; i3 < arguments.length; i3++) {
    args[i3 - 1] = arguments[i3];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i3 = 0, len = callbacks.length; i3 < len; ++i3) {
      callbacks[i3].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globalThis.browser.js
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k2) => {
    if (obj.hasOwnProperty(k2)) {
      acc[k2] = obj[k2];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length2 = 0;
  for (let i3 = 0, l2 = str.length; i3 < l2; i3++) {
    c2 = str.charCodeAt(i3);
    if (c2 < 128) {
      length2 += 1;
    } else if (c2 < 2048) {
      length2 += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length2 += 3;
    } else {
      i3++;
      length2 += 4;
    }
  }
  return length2;
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i3 in obj) {
    if (obj.hasOwnProperty(i3)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i3) + "=" + encodeURIComponent(obj[i3]);
    }
  }
  return str;
}
function decode2(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i3 = 0, l2 = pairs.length; i3 < l2; i3++) {
    let pair = pairs[i3].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};

// node_modules/engine.io-client/build/esm/contrib/yeast.js
var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var length = 64;
var map2 = {};
var seed = 0;
var i = 0;
var prev;
function encode2(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode2(+/* @__PURE__ */ new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode2(seed++);
}
for (; i < length; i++)
  map2[alphabet[i]] = i;

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function createCookieJar() {
}

// node_modules/engine.io-client/build/esm/transports/polling.js
function empty() {
}
var hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
var Polling = class extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class _Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var _a2;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i3 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i3)) {
              xhr.setRequestHeader(i3, this.opts.extraHeaders[i3]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a3;
        if (xhr.readyState === 3) {
          (_a3 = this.opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(xhr);
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = _Request.requestsCount++;
      _Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete _Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i3 in Request.requests) {
    if (Request.requests.hasOwnProperty(i3)) {
      Request.requests[i3].abort();
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var usingBrowserWebSocket = true;
var defaultBinaryType = "arraybuffer";

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var WS = class extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i3 = 0; i3 < packets.length; i3++) {
      const packet = packets[i3];
      const lastPacket = i3 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        const opts = {};
        if (!usingBrowserWebSocket) {
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          if (this.opts.perMessageDeflate) {
            const len = (
              // @ts-ignore
              "string" === typeof data ? Buffer.byteLength(data) : data.length
            );
            if (len < this.opts.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          } else {
            this.ws.send(data, opts);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
};

// node_modules/engine.io-client/build/esm/transports/webtransport.js
var WT = class extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this.writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i3 = 0; i3 < packets.length; i3++) {
      const packet = packets[i3];
      const lastPacket = i3 === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a2;
    (_a2 = this.transport) === null || _a2 === void 0 ? void 0 : _a2.close();
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 2e3) {
    throw "URI too long";
  }
  const src = str, b2 = str.indexOf("["), e = str.indexOf("]");
  if (b2 != -1 && e != -1) {
    str = str.substring(0, b2) + str.substring(b2, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m2 = re.exec(str || ""), uri = {}, i3 = 14;
  while (i3--) {
    uri[parts[i3]] = m2[i3] || "";
  }
  if (b2 != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

// node_modules/engine.io-client/build/esm/socket.js
var Socket = class _Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode2(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new transports[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && _Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    _Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          _Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    _Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i3 = 0;
      const l2 = this.upgrades.length;
      for (; i3 < l2; i3++) {
        this.probe(this.upgrades[i3]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i3 = 0; i3 < this.writeBuffer.length; i3++) {
      const data = this.writeBuffer[i3].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i3 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i3);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(err) {
    _Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i3 = 0;
    const j2 = upgrades.length;
    for (; i3 < j2; i3++) {
      if (~this.transports.indexOf(upgrades[i3]))
        filteredUpgrades.push(upgrades[i3]);
    }
    return filteredUpgrades;
  }
};
Socket.protocol = protocol;

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i3 = 0, l2 = obj.length; i3 < l2; i3++) {
      if (hasBinary(obj[i3])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i3 = 0; i3 < data.length; i3++) {
      newData[i3] = _deconstructPacket(data[i3], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i3 = 0; i3 < data.length; i3++) {
      data[i3] = _reconstructPacket(data[i3], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
var Decoder = class _Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i3 = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i3 + 1;
      while (str.charAt(++i3) !== "-" && i3 != str.length) {
      }
      const buf = str.substring(start, i3);
      if (buf != Number(buf) || str.charAt(i3) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i3 + 1)) {
      const start = i3 + 1;
      while (++i3) {
        const c2 = str.charAt(i3);
        if ("," === c2)
          break;
        if (i3 === str.length)
          break;
      }
      p2.nsp = str.substring(start, i3);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i3 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i3 + 1;
      while (++i3) {
        const c2 = str.charAt(i3);
        if (null == c2 || Number(c2) != c2) {
          --i3;
          break;
        }
        if (i3 === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i3 + 1));
    }
    if (str.charAt(++i3)) {
      const payload = this.tryParse(str.substr(i3));
      if (_Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) {
    } else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a2;
    const timeout = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer2 = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i3 = 0; i3 < this.sendBuffer.length; i3++) {
        if (this.sendBuffer[i3].id === id) {
          this.sendBuffer.splice(i3, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer2);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i3 = 0; i3 < listeners.length; i3++) {
        if (listener === listeners[i3]) {
          listeners.splice(i3, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i3 = 0; i3 < listeners.length; i3++) {
        if (listener === listeners[i3]) {
          listeners.splice(i3, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a2;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a2;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer2 = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer2.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer2);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i3 = 0; i3 < encodedPackets.length; i3++) {
      this.engine.write(encodedPackets[i3], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay2 = this.backoff.duration();
      this._reconnecting = true;
      const timer2 = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay2);
      if (this.opts.autoUnref) {
        timer2.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer2);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// src/app/modules/dashboard/services/inventory/inventory.service.ts
var _InventoryService = class _InventoryService {
  constructor() {
    this.inventories = [];
    this.inventories$ = new Subject();
    this.isLoading = false;
    this.isLoading$ = new Subject();
  }
  onListener() {
    return this.inventories$.asObservable();
  }
  onIsLoadingListener() {
    return this.isLoading$.asObservable();
  }
  setIsLoading(isLoading) {
    this.isLoading = isLoading;
    this.isLoading$.next(isLoading);
  }
  getIsLoading() {
    return this.isLoading;
  }
  assign(item) {
    this.inventories = item;
    this.inventories$.next(this.inventories.slice());
  }
  getAll() {
    return this.inventories.slice();
  }
  getTableData() {
    return this.inventories.map((inventory, i3) => ({
      no: i3 + 1,
      id: inventory.id,
      track: inventory.track,
      image: inventory.image,
      code: inventory.code,
      category: inventory.Category.name,
      status: inventory.Status.name,
      fund: inventory.Fund.name,
      location: inventory.Location.name,
      description: inventory.description
    })).slice();
  }
  getById(id) {
    return this.inventories.find((item) => item.id === id);
  }
  getByCode(code) {
    return this.inventories.find((item) => item.code === code);
  }
  getByTrack(track) {
    return this.inventories.find((item) => item.track === track);
  }
  getTableDataWithCode(code) {
    return this.inventories.filter((item) => item.code === code).map((item, i3) => ({
      no: i3 + 1,
      id: item.id,
      track: item.track,
      image: item.image,
      code: item.code,
      category: item.Category.name,
      status: item.Status.name,
      fund: item.Fund.name,
      location: item.Location.name,
      description: item.description
    })).slice();
  }
  create(item) {
    this.inventories.push(item);
    this.inventories$.next(this.inventories.slice());
  }
  update(id, item) {
    const index = this.inventories.findIndex((inventory) => inventory.id === id);
    if (index !== -1) {
      this.inventories[index] = __spreadValues(__spreadValues({}, this.inventories[index]), item);
      this.inventories$.next(this.inventories.slice());
    }
  }
  getUseDate(date) {
    const now = /* @__PURE__ */ new Date();
    let yearDiff = now.getFullYear() - date.getFullYear();
    let monthDiff = now.getMonth() - date.getMonth();
    if (monthDiff < 0) {
      yearDiff--;
      monthDiff += 12;
    }
    return `${yearDiff} \u0E1B\u0E35 ${monthDiff} \u0E40\u0E14\u0E37\u0E2D\u0E19`;
  }
};
_InventoryService.\u0275fac = function InventoryService_Factory(t2) {
  return new (t2 || _InventoryService)();
};
_InventoryService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _InventoryService, factory: _InventoryService.\u0275fac, providedIn: "root" });
var InventoryService = _InventoryService;

// src/app/modules/dashboard/socket-io/socket-inventory.service.ts
var _SocketInventoryService = class _SocketInventoryService {
  constructor(inventoryService) {
    this.inventoryService = inventoryService;
  }
  initializeSocketIO(socketIO) {
    this.socketIO = socketIO;
    if (!this.socketIO)
      return;
    this.socketIO.on("inventory:create", (item) => {
      this.inventoryService.create(item);
    });
    this.socketIO.on("inventory:update", (id, item) => {
      this.inventoryService.update(id, item);
    });
  }
  create(item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("inventory:create", item);
  }
  update(id, item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("inventory:update", id, item);
  }
};
_SocketInventoryService.\u0275fac = function SocketInventoryService_Factory(t2) {
  return new (t2 || _SocketInventoryService)(\u0275\u0275inject(InventoryService));
};
_SocketInventoryService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketInventoryService, factory: _SocketInventoryService.\u0275fac, providedIn: "root" });
var SocketInventoryService = _SocketInventoryService;

// src/app/modules/dashboard/services/log/log.service.ts
var _LogService = class _LogService {
  constructor() {
    this.logs = [];
    this.logs$ = new Subject();
  }
  onListener() {
    return this.logs$.asObservable();
  }
  assign(item) {
    this.logs = item;
    this.logs$.next(this.logs.slice());
  }
  getAll() {
    return this.logs.slice();
  }
  getTableData() {
    return this.logs.map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  getByCode(code) {
    return this.logs.filter((item) => item.code === code).map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  getById(id) {
    return this.logs.find((log) => log.id === id);
  }
  create(item) {
    this.logs.push(item);
    this.logs$.next(this.logs.slice());
  }
};
_LogService.\u0275fac = function LogService_Factory(t2) {
  return new (t2 || _LogService)();
};
_LogService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LogService, factory: _LogService.\u0275fac, providedIn: "root" });
var LogService = _LogService;

// src/app/modules/dashboard/socket-io/socket-log.service.ts
var _SocketLogService = class _SocketLogService {
  constructor(logService) {
    this.logService = logService;
  }
  initializeSocketIO(socketIO) {
    this.socketIO = socketIO;
    if (!this.socketIO)
      return;
    this.socketIO.on("log:create", (item) => {
      this.logService.create(item);
    });
  }
  create(item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("log:create", item);
  }
};
_SocketLogService.\u0275fac = function SocketLogService_Factory(t2) {
  return new (t2 || _SocketLogService)(\u0275\u0275inject(LogService));
};
_SocketLogService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketLogService, factory: _SocketLogService.\u0275fac, providedIn: "root" });
var SocketLogService = _SocketLogService;

// src/app/modules/dashboard/services/category/category.service.ts
var _CategoryService = class _CategoryService {
  constructor() {
    this.categories = [];
    this.categories$ = new Subject();
  }
  onListener() {
    return this.categories$.asObservable();
  }
  assign(items) {
    this.categories = items;
    this.categories$.next(this.categories.slice());
  }
  getAll() {
    return this.categories.slice();
  }
  getTableData() {
    return this.categories.map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  getActiveNames() {
    return this.categories.filter((item) => item.active).map((item) => item.name).slice();
  }
  getActiveDetails() {
    return this.categories.filter((item) => item.active).map((item) => ({ id: item.id, name: item.name })).slice();
  }
  create(item) {
    this.categories.push(item);
    this.categories$.next(this.categories.slice());
  }
  update(id, item) {
    const index = this.categories.findIndex((item2) => item2.id === id);
    if (index !== -1) {
      this.categories[index] = __spreadValues(__spreadValues({}, this.categories[index]), item);
      this.categories$.next(this.categories.slice());
    }
  }
  delete(id) {
    const index = this.categories.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.categories.splice(index, 1);
      this.categories$.next(this.categories.slice());
    }
  }
};
_CategoryService.\u0275fac = function CategoryService_Factory(t2) {
  return new (t2 || _CategoryService)();
};
_CategoryService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _CategoryService, factory: _CategoryService.\u0275fac, providedIn: "root" });
var CategoryService = _CategoryService;

// src/app/modules/dashboard/socket-io/socket-category.service.ts
var _SocketCategoryService = class _SocketCategoryService {
  constructor(categotyService) {
    this.categotyService = categotyService;
  }
  initializeSocketIO(socketIO) {
    this.socketIO = socketIO;
    if (!this.socketIO)
      return;
    this.socketIO.on("category:create", (item) => {
      this.categotyService.create(item);
    });
    this.socketIO.on("category:update", (id, item) => {
      this.categotyService.update(id, item);
    });
    this.socketIO.on("category:delete", (id) => {
      this.categotyService.delete(id);
    });
  }
  create(item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("category:create", item);
  }
  update(id, item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("category:update", id, item);
  }
  delete(id) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("category:delete", id);
  }
};
_SocketCategoryService.\u0275fac = function SocketCategoryService_Factory(t2) {
  return new (t2 || _SocketCategoryService)(\u0275\u0275inject(CategoryService));
};
_SocketCategoryService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketCategoryService, factory: _SocketCategoryService.\u0275fac, providedIn: "root" });
var SocketCategoryService = _SocketCategoryService;

// src/app/modules/dashboard/services/status/status.service.ts
var _StatusService = class _StatusService {
  constructor() {
    this.statuses = [];
    this.statuses$ = new Subject();
  }
  onListener() {
    return this.statuses$.asObservable();
  }
  assign(items) {
    this.statuses = items;
    this.statuses$.next(this.statuses.slice());
  }
  getAll() {
    return this.statuses.slice();
  }
  getTableData() {
    return this.statuses.map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  getActiveNames() {
    return this.statuses.filter((item) => item.active).map((item) => item.name).slice();
  }
  getActiveDetails() {
    return this.statuses.filter((item) => item.active).map((item) => ({ id: item.id, name: item.name })).slice();
  }
  create(item) {
    this.statuses.push(item);
    this.statuses$.next(this.statuses.slice());
  }
  update(id, item) {
    const index = this.statuses.findIndex((item2) => item2.id === id);
    if (index !== -1) {
      this.statuses[index] = __spreadValues(__spreadValues({}, this.statuses[index]), item);
      this.statuses$.next(this.statuses.slice());
    }
  }
  delete(id) {
    const index = this.statuses.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.statuses.splice(index, 1);
      this.statuses$.next(this.statuses.slice());
    }
  }
};
_StatusService.\u0275fac = function StatusService_Factory(t2) {
  return new (t2 || _StatusService)();
};
_StatusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _StatusService, factory: _StatusService.\u0275fac, providedIn: "root" });
var StatusService = _StatusService;

// src/app/modules/dashboard/socket-io/socket-status.service.ts
var _SocketStatusService = class _SocketStatusService {
  constructor(statusService) {
    this.statusService = statusService;
  }
  initializeSocketIO(socketIO) {
    this.socketIO = socketIO;
    if (!this.socketIO)
      return;
    this.socketIO.on("status:create", (item) => {
      this.statusService.create(item);
    });
    this.socketIO.on("status:update", (id, item) => {
      this.statusService.update(id, item);
    });
    this.socketIO.on("status:delete", (id) => {
      this.statusService.delete(id);
    });
  }
  create(item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("status:create", item);
  }
  update(id, item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("status:update", id, item);
  }
  delete(id) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("status:delete", id);
  }
};
_SocketStatusService.\u0275fac = function SocketStatusService_Factory(t2) {
  return new (t2 || _SocketStatusService)(\u0275\u0275inject(StatusService));
};
_SocketStatusService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketStatusService, factory: _SocketStatusService.\u0275fac, providedIn: "root" });
var SocketStatusService = _SocketStatusService;

// src/app/modules/dashboard/services/fund/fund.service.ts
var _FundService = class _FundService {
  constructor() {
    this.funds = [];
    this.funds$ = new Subject();
  }
  onListener() {
    return this.funds$.asObservable();
  }
  assign(items) {
    this.funds = items;
    this.funds$.next(this.funds.slice());
  }
  getAll() {
    return this.funds.slice();
  }
  getTableData() {
    return this.funds.map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  getActiveNames() {
    return this.funds.filter((item) => item.active).map((item) => item.name).slice();
  }
  getActiveDetails() {
    return this.funds.filter((item) => item.active).map((item) => ({ id: item.id, name: item.name })).slice();
  }
  create(item) {
    this.funds.push(item);
    this.funds$.next(this.funds.slice());
  }
  update(id, item) {
    const index = this.funds.findIndex((item2) => item2.id === id);
    if (index !== -1) {
      this.funds[index] = __spreadValues(__spreadValues({}, this.funds[index]), item);
      this.funds$.next(this.funds.slice());
    }
  }
  delete(id) {
    const index = this.funds.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.funds.splice(index, 1);
      this.funds$.next(this.funds.slice());
    }
  }
};
_FundService.\u0275fac = function FundService_Factory(t2) {
  return new (t2 || _FundService)();
};
_FundService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FundService, factory: _FundService.\u0275fac, providedIn: "root" });
var FundService = _FundService;

// src/app/modules/dashboard/socket-io/socket-fund.service.ts
var _SocketFundService = class _SocketFundService {
  constructor(fundService) {
    this.fundService = fundService;
  }
  initializeSocketIO(socketIO) {
    this.socketIO = socketIO;
    if (!this.socketIO)
      return;
    this.socketIO.on("fund:create", (item) => {
      this.fundService.create(item);
    });
    this.socketIO.on("fund:update", (id, item) => {
      this.fundService.update(id, item);
    });
    this.socketIO.on("fund:delete", (id) => {
      this.fundService.delete(id);
    });
  }
  create(item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("fund:create", item);
  }
  update(id, item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("fund:update", id, item);
  }
  delete(id) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("fund:delete", id);
  }
};
_SocketFundService.\u0275fac = function SocketFundService_Factory(t2) {
  return new (t2 || _SocketFundService)(\u0275\u0275inject(FundService));
};
_SocketFundService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketFundService, factory: _SocketFundService.\u0275fac, providedIn: "root" });
var SocketFundService = _SocketFundService;

// src/app/modules/dashboard/services/location/location.service.ts
var _LocationService = class _LocationService {
  constructor() {
    this.locations = [];
    this.locations$ = new Subject();
  }
  onListener() {
    return this.locations$.asObservable();
  }
  assign(items) {
    this.locations = items;
    this.locations$.next(this.locations.slice());
  }
  getAll() {
    return this.locations.slice();
  }
  getTableData() {
    return this.locations.map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  getActiveNames() {
    return this.locations.filter((item) => item.active).map((item) => item.name).slice();
  }
  getActiveDetails() {
    return this.locations.filter((item) => item.active).map((item) => ({ id: item.id, name: item.name })).slice();
  }
  create(item) {
    this.locations.push(item);
    this.locations$.next(this.locations.slice());
  }
  update(id, item) {
    const index = this.locations.findIndex((item2) => item2.id === id);
    if (index !== -1) {
      this.locations[index] = __spreadValues(__spreadValues({}, this.locations[index]), item);
      this.locations$.next(this.locations.slice());
    }
  }
  delete(id) {
    const index = this.locations.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.locations.splice(index, 1);
      this.locations$.next(this.locations.slice());
    }
  }
};
_LocationService.\u0275fac = function LocationService_Factory(t2) {
  return new (t2 || _LocationService)();
};
_LocationService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LocationService, factory: _LocationService.\u0275fac, providedIn: "root" });
var LocationService = _LocationService;

// src/app/modules/dashboard/socket-io/socket-location.service.ts
var _SocketLocationService = class _SocketLocationService {
  constructor(locationService) {
    this.locationService = locationService;
  }
  initializeSocketIO(socketIO) {
    this.socketIO = socketIO;
    if (!this.socketIO)
      return;
    this.socketIO.on("location:create", (item) => {
      this.locationService.create(item);
    });
    this.socketIO.on("location:update", (id, item) => {
      this.locationService.update(id, item);
    });
    this.socketIO.on("location:delete", (id) => {
      this.locationService.delete(id);
    });
  }
  create(item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("location:create", item);
  }
  update(id, item) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("location:update", id, item);
  }
  delete(id) {
    if (!this.socketIO)
      return;
    this.socketIO.emit("location:delete", id);
  }
};
_SocketLocationService.\u0275fac = function SocketLocationService_Factory(t2) {
  return new (t2 || _SocketLocationService)(\u0275\u0275inject(LocationService));
};
_SocketLocationService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketLocationService, factory: _SocketLocationService.\u0275fac, providedIn: "root" });
var SocketLocationService = _SocketLocationService;

// src/app/modules/dashboard/socket-io/socket-io.service.ts
var _SocketIoService = class _SocketIoService {
  constructor(socketInventoryService, socketLogService, socketCategoryService, socketStatusService, socketFundService, socketLocationService) {
    this.socketInventoryService = socketInventoryService;
    this.socketLogService = socketLogService;
    this.socketCategoryService = socketCategoryService;
    this.socketStatusService = socketStatusService;
    this.socketFundService = socketFundService;
    this.socketLocationService = socketLocationService;
    this.url = environment.localhost;
  }
  setupSocketConnection() {
    this.socketIO = lookup2(this.url, {
      reconnection: false
    });
    if (!this.socketIO)
      return;
    this.socketInventoryService.initializeSocketIO(this.socketIO);
    this.socketLogService.initializeSocketIO(this.socketIO);
    this.socketCategoryService.initializeSocketIO(this.socketIO);
    this.socketStatusService.initializeSocketIO(this.socketIO);
    this.socketFundService.initializeSocketIO(this.socketIO);
    this.socketLocationService.initializeSocketIO(this.socketIO);
  }
  disconnect() {
    if (!this.socketIO)
      return;
    this.socketIO.close();
  }
};
_SocketIoService.\u0275fac = function SocketIoService_Factory(t2) {
  return new (t2 || _SocketIoService)(\u0275\u0275inject(SocketInventoryService), \u0275\u0275inject(SocketLogService), \u0275\u0275inject(SocketCategoryService), \u0275\u0275inject(SocketStatusService), \u0275\u0275inject(SocketFundService), \u0275\u0275inject(SocketLocationService));
};
_SocketIoService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SocketIoService, factory: _SocketIoService.\u0275fac, providedIn: "root" });
var SocketIoService = _SocketIoService;

// src/app/modules/dashboard/layouts/toolbar/toolbar.component.ts
function ToolbarComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const profile_r2 = ctx;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2("", profile_r2.firstname, " ", profile_r2.lastname, "");
  }
}
var _ToolbarComponent = class _ToolbarComponent {
  constructor() {
    this.menuToggle = new EventEmitter();
    this.profileService = inject(ProfileService);
    this.authService = inject(AuthApiService);
    this.themeService = inject(ThemeService);
    this.title = "";
  }
  ngOnInit() {
    this.profile$ = this.profileService.onListener();
    this.isDarkTheme = this.themeService.getTheme();
  }
  onMenuToggle() {
    this.menuToggle.emit();
  }
  onLogout() {
    this.authService.logout().subscribe();
  }
  onSwitchTheme(event) {
    event.stopPropagation();
    this.themeService.setTheme(this.isDarkTheme);
  }
};
_ToolbarComponent.\u0275fac = function ToolbarComponent_Factory(t2) {
  return new (t2 || _ToolbarComponent)();
};
_ToolbarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ToolbarComponent, selectors: [["app-toolbar"]], outputs: { menuToggle: "menuToggle" }, decls: 36, vars: 6, consts: [["menu", "matMenu"], ["color", "primary"], ["type", "button", "aria-label", "Toggle sidenav", "mat-icon-button", "", 3, "click"], ["aria-label", "Side nav toggle icon"], [1, "toolbar-box"], [1, "toolbar-right"], ["mat-icon-button", "", 3, "matMenuTriggerFor"], ["mat-menu-item", "", "routerLink", "/profile"], ["mat-menu-item", "", "routerLink", "/password"], ["type", "button", "mat-menu-item", ""], [2, "margin-left", "50px", 3, "ngModelChange", "click", "ngModel"], ["type", "button", "mat-menu-item", "", 3, "click"], ["color", "warn"], [2, "color", "#f44336"]], template: function ToolbarComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-toolbar", 1)(1, "button", 2);
    \u0275\u0275listener("click", function ToolbarComponent_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onMenuToggle());
    });
    \u0275\u0275elementStart(2, "mat-icon", 3);
    \u0275\u0275text(3, "menu");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "div", 4)(5, "span");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 5);
    \u0275\u0275template(8, ToolbarComponent_Conditional_8_Template, 2, 2, "span");
    \u0275\u0275pipe(9, "async");
    \u0275\u0275elementStart(10, "button", 6)(11, "mat-icon");
    \u0275\u0275text(12, "more_vert");
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275elementStart(13, "mat-menu", null, 0)(15, "a", 7)(16, "mat-icon");
    \u0275\u0275text(17, "person");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "span");
    \u0275\u0275text(19, "\u0E42\u0E1B\u0E23\u0E44\u0E1F\u0E25\u0E4C");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "a", 8)(21, "mat-icon");
    \u0275\u0275text(22, "lock");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "span");
    \u0275\u0275text(24, "\u0E40\u0E1B\u0E25\u0E35\u0E48\u0E22\u0E19\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(25, "button", 9)(26, "mat-icon");
    \u0275\u0275text(27, "dark_mode");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "span");
    \u0275\u0275text(29, "\u0E18\u0E35\u0E21\u0E21\u0E37\u0E14");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "mat-slide-toggle", 10);
    \u0275\u0275twoWayListener("ngModelChange", function ToolbarComponent_Template_mat_slide_toggle_ngModelChange_30_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.isDarkTheme, $event) || (ctx.isDarkTheme = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("click", function ToolbarComponent_Template_mat_slide_toggle_click_30_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSwitchTheme($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(31, "button", 11);
    \u0275\u0275listener("click", function ToolbarComponent_Template_button_click_31_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onLogout());
    });
    \u0275\u0275elementStart(32, "mat-icon", 12);
    \u0275\u0275text(33, "logout");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(34, "span", 13);
    \u0275\u0275text(35, "\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E23\u0E30\u0E1A\u0E1A");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    let tmp_2_0;
    const menu_r3 = \u0275\u0275reference(14);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(8, (tmp_2_0 = \u0275\u0275pipeBind1(9, 4, ctx.profile$)) ? 8 : -1, tmp_2_0);
    \u0275\u0275advance(2);
    \u0275\u0275property("matMenuTriggerFor", menu_r3);
    \u0275\u0275advance(20);
    \u0275\u0275twoWayProperty("ngModel", ctx.isDarkTheme);
  }
}, dependencies: [RouterLink, NgControlStatus, MatToolbar, MatIconButton, MatIcon, MatMenu, MatMenuItem, MatMenuTrigger, MatSlideToggle, NgModel, AsyncPipe], styles: ["\n\n.toolbar-box[_ngcontent-%COMP%] {\n  display: flex;\n  justify-content: space-between;\n  width: 100%;\n  align-items: center;\n}\n.toolbar-box[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n  text-transform: capitalize;\n}\n.toolbar-box[_ngcontent-%COMP%]   .toolbar-right[_ngcontent-%COMP%] {\n  display: flex;\n  gap: 10px;\n  align-items: center;\n}\n/*# sourceMappingURL=toolbar.component.css.map */"] });
var ToolbarComponent = _ToolbarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ToolbarComponent, { className: "ToolbarComponent", filePath: "src\\app\\modules\\dashboard\\layouts\\toolbar\\toolbar.component.ts", lineNumber: 20 });
})();

// src/app/modules/dashboard/services/print/print.service.ts
var _PrintService = class _PrintService {
  constructor() {
    this.inventories = [];
    this.inventories$ = new Subject();
  }
  onListener() {
    return this.inventories$.asObservable();
  }
  getAll() {
    return this.inventories.slice();
  }
  getById(id) {
    return this.inventories.find((item) => item.id === id);
  }
  getByCode(code) {
    return this.inventories.find((item) => item.code === code);
  }
  getByTrack(track) {
    return this.inventories.find((item) => item.track === track);
  }
  create(item) {
    this.inventories.push(item);
    this.inventories$.next(this.inventories.slice());
  }
  updateCount(id, count) {
    const index = this.inventories.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.inventories[index].printCount = count;
      this.inventories$.next(this.inventories.slice());
    }
  }
  incrementCount(id) {
    const index = this.inventories.findIndex((item) => item.id === id);
    if (index === -1)
      return;
    if (this.inventories[index].printCount >= 100)
      return;
    this.inventories[index].printCount += 1;
    this.inventories$.next(this.inventories.slice());
  }
  decrementCount(id) {
    const index = this.inventories.findIndex((item) => item.id === id);
    if (index === -1)
      return;
    if (this.inventories[index].printCount <= 1)
      return;
    this.inventories[index].printCount -= 1;
    this.inventories$.next(this.inventories.slice());
  }
  delete(id) {
    const index = this.inventories.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.inventories.splice(index, 1);
      this.inventories$.next(this.inventories.slice());
    }
  }
  reset() {
    this.inventories = [];
    this.inventories$.next(this.inventories.slice());
  }
};
_PrintService.\u0275fac = function PrintService_Factory(t2) {
  return new (t2 || _PrintService)();
};
_PrintService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _PrintService, factory: _PrintService.\u0275fac, providedIn: "root" });
var PrintService = _PrintService;

// src/app/modules/dashboard/layouts/sidenav/sidenav.component.ts
function SidenavComponent_Conditional_41_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-accordion")(1, "mat-expansion-panel", 15)(2, "mat-expansion-panel-header")(3, "div", 7)(4, "mat-icon", 8);
    \u0275\u0275text(5, "settings");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 16);
    \u0275\u0275text(7, "\u0E15\u0E31\u0E49\u0E07\u0E04\u0E48\u0E32");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "mat-nav-list")(9, "a", 17)(10, "div", 7)(11, "mat-icon", 8);
    \u0275\u0275text(12, "manage_accounts");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 9);
    \u0275\u0275text(14, "\u0E1A\u0E31\u0E0D\u0E0A\u0E35\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(15, "a", 18)(16, "div", 7)(17, "mat-icon", 8);
    \u0275\u0275text(18, "list_alt");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "div", 9);
    \u0275\u0275text(20, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(21, "a", 19)(22, "div", 7)(23, "mat-icon", 8);
    \u0275\u0275text(24, "dataset");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(25, "div", 9);
    \u0275\u0275text(26, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(27, "a", 20)(28, "div", 7)(29, "mat-icon", 8);
    \u0275\u0275text(30, "text_snippet");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "div", 9);
    \u0275\u0275text(32, "\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(33, "a", 21)(34, "div", 7)(35, "mat-icon", 8);
    \u0275\u0275text(36, "home_work");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(37, "div", 9);
    \u0275\u0275text(38, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classProp("mat-elevation-z0", true);
    \u0275\u0275property("expanded", ctx_r0.isExpanded);
  }
}
var _SidenavComponent = class _SidenavComponent {
  constructor() {
    this.subscription = new Subscription();
    this.router = inject(Router);
    this.profileService = inject(ProfileService);
    this.printService = inject(PrintService);
    this.isExpanded = false;
    this.isAdmin = false;
    this.isBadge = false;
  }
  ngOnInit() {
    this.isExpanded = this.router.url.includes("setting");
    this.isAdmin = this.profileService.isAdmin();
    this.subscription = this.printService.onListener().subscribe((parcel) => {
      this.badge = parcel.length;
      if (this.badge > 0)
        this.isBadge = true;
      else
        this.isBadge = false;
    });
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
_SidenavComponent.\u0275fac = function SidenavComponent_Factory(t2) {
  return new (t2 || _SidenavComponent)();
};
_SidenavComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _SidenavComponent, selectors: [["app-sidenav"]], decls: 42, vars: 3, consts: [[1, "toolbar-box"], [1, "toolbar-logo"], ["src", "assets/images/logo-ms-bsru.png", "alt", "logo"], [1, "toolbar-text"], [1, "line-1"], [1, "line-2"], ["mat-list-item", "", "routerLink", "/scan", "routerLinkActive", "link-active"], [1, "link-box"], ["matListIcon", ""], ["mat-line", ""], ["mat-list-item", "", "routerLink", "/inventory", "routerLinkActive", "link-active"], ["mat-list-item", "", "routerLink", "/print", "routerLinkActive", "link-active"], ["matListIcon", "", "matBadgeSize", "medium", "matBadgeColor", "accent", "aria-hidden", "false", 3, "matBadge", "matBadgeHidden"], ["mat-list-item", "", "routerLink", "/log", "routerLinkActive", "link-active"], ["mat-list-item", "", "routerLink", "/inventory-check", "routerLinkActive", "link-active"], [3, "expanded"], ["mat-line", "", 2, "font-size", "16px"], ["mat-list-item", "", "routerLink", "/setting/user", "routerLinkActive", "link-active"], ["mat-list-item", "", "routerLink", "/setting/category", "routerLinkActive", "link-active"], ["mat-list-item", "", "routerLink", "/setting/status", "routerLinkActive", "link-active"], ["mat-list-item", "", "routerLink", "/setting/fund", "routerLinkActive", "link-active"], ["mat-list-item", "", "routerLink", "/setting/location", "routerLinkActive", "link-active"]], template: function SidenavComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-toolbar")(1, "div", 0)(2, "div", 1);
    \u0275\u0275element(3, "img", 2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 3)(5, "span", 4);
    \u0275\u0275text(6, "BSRU");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "span", 5);
    \u0275\u0275text(8, "\u0E04\u0E13\u0E30\u0E27\u0E34\u0E17\u0E22\u0E32\u0E01\u0E32\u0E23\u0E08\u0E31\u0E14\u0E01\u0E32\u0E23");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(9, "mat-nav-list")(10, "a", 6)(11, "div", 7)(12, "mat-icon", 8);
    \u0275\u0275text(13, "qr_code_scanner");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "div", 9);
    \u0275\u0275text(15, "\u0E2A\u0E41\u0E01\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(16, "a", 10)(17, "div", 7)(18, "mat-icon", 8);
    \u0275\u0275text(19, "list_alt");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "div", 9);
    \u0275\u0275text(21, "\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(22, "a", 11)(23, "div", 7)(24, "mat-icon", 12);
    \u0275\u0275text(25, "print");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "div", 9);
    \u0275\u0275text(27, "\u0E1E\u0E34\u0E21\u0E1E\u0E4C");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(28, "a", 13)(29, "div", 7)(30, "mat-icon", 8);
    \u0275\u0275text(31, "history");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(32, "div", 9);
    \u0275\u0275text(33, "\u0E1B\u0E23\u0E30\u0E27\u0E31\u0E15\u0E34");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(34, "a", 14)(35, "div", 7)(36, "mat-icon", 8);
    \u0275\u0275text(37, "fact_check");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(38, "div", 9);
    \u0275\u0275text(39, "\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(40, "mat-divider");
    \u0275\u0275template(41, SidenavComponent_Conditional_41_Template, 39, 3, "mat-accordion");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(24);
    \u0275\u0275property("matBadge", ctx.badge)("matBadgeHidden", !ctx.isBadge);
    \u0275\u0275advance(17);
    \u0275\u0275conditional(41, ctx.isAdmin ? 41 : -1);
  }
}, dependencies: [RouterLink, RouterLinkActive, MatToolbar, MatIcon, MatNavList, MatListItem, MatDivider, MatAccordion, MatExpansionPanel, MatExpansionPanelHeader, MatBadge], styles: ["\n\nmat-nav-list[_ngcontent-%COMP%] {\n  padding: 0;\n}\n.link-box[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  transition: 0.3s;\n  padding-block: 10px;\n}\n.link-active[_ngcontent-%COMP%] {\n  background-color: #ff9800;\n}\na[_ngcontent-%COMP%] {\n  transition: all 0.3s;\n}\nmat-expansion-panel-header[_ngcontent-%COMP%] {\n  padding: 0 16px;\n}\n  .mat-expansion-panel-body {\n  padding: 0 !important;\n}\n  .mat-expansion-panel-body a {\n  padding-left: 24px;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-box[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 10px;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-box[_ngcontent-%COMP%]   .toolbar-logo[_ngcontent-%COMP%] {\n  border-radius: 50%;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-box[_ngcontent-%COMP%]   .toolbar-logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  width: 40px;\n  height: 40px;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-box[_ngcontent-%COMP%]   .toolbar-text[_ngcontent-%COMP%] {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-box[_ngcontent-%COMP%]   .toolbar-text[_ngcontent-%COMP%]   .line-1[_ngcontent-%COMP%] {\n  position: absolute;\n  top: -25px;\n  letter-spacing: 4px;\n  font-weight: 800;\n}\nmat-toolbar[_ngcontent-%COMP%]   .toolbar-box[_ngcontent-%COMP%]   .toolbar-text[_ngcontent-%COMP%]   .line-2[_ngcontent-%COMP%] {\n  position: absolute;\n  top: -4px;\n  font-size: 0.75rem;\n  font-weight: 600;\n}\n.line-2[_ngcontent-%COMP%] {\n  color: #757575;\n}\n.dark-theme[_nghost-%COMP%]   .link-active[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .link-active[_ngcontent-%COMP%] {\n  background-color: #ff5722;\n}\n.dark-theme[_nghost-%COMP%]   .line-2[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .line-2[_ngcontent-%COMP%] {\n  color: #c7c7c7;\n}\n/*# sourceMappingURL=sidenav.component.css.map */"] });
var SidenavComponent = _SidenavComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(SidenavComponent, { className: "SidenavComponent", filePath: "src\\app\\modules\\dashboard\\layouts\\sidenav\\sidenav.component.ts", lineNumber: 12 });
})();

// src/app/modules/dashboard/dashboard.component.ts
var _c0 = ["sidenav"];
var _DashboardComponent = class _DashboardComponent {
  constructor() {
    this.subscription = new Subscription();
    this.router = inject(Router);
    this.breakpointObserver = inject(BreakpointObserver);
    this.socketIoService = inject(SocketIoService);
    this.isHandset$ = this.breakpointObserver.observe(Breakpoints.Handset).pipe(map((result) => result.matches), shareReplay());
  }
  ngOnInit() {
    this.subscription = this.router.events.pipe(withLatestFrom(this.isHandset$), filter(([event, isHandset]) => isHandset && event instanceof NavigationEnd)).subscribe(() => this.sidenav.close());
    this.socketIoService.setupSocketConnection();
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.socketIoService.disconnect();
  }
};
_DashboardComponent.\u0275fac = function DashboardComponent_Factory(t2) {
  return new (t2 || _DashboardComponent)();
};
_DashboardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _DashboardComponent, selectors: [["app-dashboard"]], viewQuery: function DashboardComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c0, 7);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sidenav = _t2.first);
  }
}, decls: 11, vars: 9, consts: [["sidenav", ""], [1, "sidenav-container"], ["fixedInViewport", "", 1, "sidenav", 3, "mode", "opened"], [3, "menuToggle"]], template: function DashboardComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-sidenav-container", 1)(1, "mat-sidenav", 2, 0);
    \u0275\u0275pipe(3, "async");
    \u0275\u0275pipe(4, "async");
    \u0275\u0275pipe(5, "async");
    \u0275\u0275element(6, "app-sidenav");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "mat-sidenav-content")(8, "app-toolbar", 3);
    \u0275\u0275listener("menuToggle", function DashboardComponent_Template_app_toolbar_menuToggle_8_listener() {
      \u0275\u0275restoreView(_r1);
      const sidenav_r2 = \u0275\u0275reference(2);
      return \u0275\u0275resetView(sidenav_r2.toggle());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "main");
    \u0275\u0275element(10, "router-outlet");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("mode", \u0275\u0275pipeBind1(3, 3, ctx.isHandset$) ? "over" : "side")("opened", \u0275\u0275pipeBind1(4, 5, ctx.isHandset$) === false);
    \u0275\u0275attribute("role", \u0275\u0275pipeBind1(5, 7, ctx.isHandset$) ? "dialog" : "navigation");
  }
}, dependencies: [RouterOutlet, MatSidenav, MatSidenavContainer, MatSidenavContent, ToolbarComponent, SidenavComponent, AsyncPipe], styles: ["\n\n.sidenav-container[_ngcontent-%COMP%] {\n  height: 100%;\n}\n.sidenav[_ngcontent-%COMP%] {\n  width: 200px;\n}\n.sidenav[_ngcontent-%COMP%]   .mat-toolbar[_ngcontent-%COMP%] {\n  background: inherit;\n}\n.mat-toolbar.mat-primary[_ngcontent-%COMP%] {\n  position: sticky;\n  top: 0;\n  z-index: 1;\n}\nmain[_ngcontent-%COMP%] {\n  margin: 15px;\n  min-height: calc(100vh - 100px);\n}\n/*# sourceMappingURL=dashboard.component.css.map */"] });
var DashboardComponent = _DashboardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(DashboardComponent, { className: "DashboardComponent", filePath: "src\\app\\modules\\dashboard\\dashboard.component.ts", lineNumber: 14 });
})();

// src/app/modules/dashboard/services/profile/profile-api.service.ts
var _ProfileApiService = class _ProfileApiService {
  constructor(http, profileService, toastService) {
    this.http = http;
    this.profileService = profileService;
    this.toastService = toastService;
    this.apiUrl = environment.apiUrl + "profile";
  }
  get() {
    return this.http.get(this.apiUrl).pipe(tap((profile) => this.profileService.assign(profile)));
  }
  update(payload) {
    return this.http.patch(this.apiUrl, payload).pipe(tap((res) => {
      this.profileService.update(payload);
      this.toastService.success("", res.message);
    }));
  }
  changePassword(payload) {
    return this.http.post(`${this.apiUrl}/change-password`, payload).pipe(tap((res) => this.toastService.success("", res.message)));
  }
};
_ProfileApiService.\u0275fac = function ProfileApiService_Factory(t2) {
  return new (t2 || _ProfileApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(ProfileService), \u0275\u0275inject(ToastNotificationService));
};
_ProfileApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ProfileApiService, factory: _ProfileApiService.\u0275fac, providedIn: "root" });
var ProfileApiService = _ProfileApiService;

// src/app/modules/dashboard/guards/dashboard.guard.ts
var dashboardGuard = (childRoute, state) => {
  const loadingScreenService = inject(LoadingScreenService);
  const tokenService = inject(TokenService);
  const toastService = inject(ToastNotificationService);
  const authService = inject(AuthApiService);
  const profileService = inject(ProfileService);
  const profileApiService = inject(ProfileApiService);
  const profile = profileService.get();
  const accessToken = tokenService.getAccessToken();
  if (accessToken && profile)
    return true;
  loadingScreenService.setIsLoading(true);
  if (!accessToken || accessToken === "undefined")
    return authService.logout().pipe(map(() => false));
  if (!profile)
    return profileApiService.get().pipe(map(() => {
      loadingScreenService.setIsLoading(false);
      return true;
    }));
  toastService.error("500", "Internal Server Error!");
  return authService.logout().pipe(map(() => false));
};

// src/app/modules/dashboard/guards/admin.guard.ts
var adminGuard = (childRoute, state) => {
  const router = inject(Router);
  const profileService = inject(ProfileService);
  const isAdmin = profileService.isAdmin();
  if (!isAdmin) {
    router.navigate(["/scan"]);
    return false;
  }
  return true;
};

// src/app/modules/dashboard/services/scan/scan-api.service.ts
var _ScanApiService = class _ScanApiService {
  constructor(http) {
    this.http = http;
    this.apiUrl = environment.apiUrl + "inventory";
  }
  getByCode(code) {
    return this.http.get(`${this.apiUrl}/code/${code}`);
  }
  getByTrack(track) {
    return this.http.get(`${this.apiUrl}/track/${track}`);
  }
};
_ScanApiService.\u0275fac = function ScanApiService_Factory(t2) {
  return new (t2 || _ScanApiService)(\u0275\u0275inject(HttpClient));
};
_ScanApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ScanApiService, factory: _ScanApiService.\u0275fac, providedIn: "root" });
var ScanApiService = _ScanApiService;

// node_modules/html5-qrcode/esm/core.js
var Html5QrcodeSupportedFormats;
(function(Html5QrcodeSupportedFormats2) {
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["QR_CODE"] = 0] = "QR_CODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["AZTEC"] = 1] = "AZTEC";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODABAR"] = 2] = "CODABAR";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_39"] = 3] = "CODE_39";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_93"] = 4] = "CODE_93";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_128"] = 5] = "CODE_128";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["DATA_MATRIX"] = 6] = "DATA_MATRIX";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["MAXICODE"] = 7] = "MAXICODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["ITF"] = 8] = "ITF";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_13"] = 9] = "EAN_13";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_8"] = 10] = "EAN_8";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["PDF_417"] = 11] = "PDF_417";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_14"] = 12] = "RSS_14";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_A"] = 14] = "UPC_A";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_E"] = 15] = "UPC_E";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));
var html5QrcodeSupportedFormatsTextMap = /* @__PURE__ */ new Map([
  [Html5QrcodeSupportedFormats.QR_CODE, "QR_CODE"],
  [Html5QrcodeSupportedFormats.AZTEC, "AZTEC"],
  [Html5QrcodeSupportedFormats.CODABAR, "CODABAR"],
  [Html5QrcodeSupportedFormats.CODE_39, "CODE_39"],
  [Html5QrcodeSupportedFormats.CODE_93, "CODE_93"],
  [Html5QrcodeSupportedFormats.CODE_128, "CODE_128"],
  [Html5QrcodeSupportedFormats.DATA_MATRIX, "DATA_MATRIX"],
  [Html5QrcodeSupportedFormats.MAXICODE, "MAXICODE"],
  [Html5QrcodeSupportedFormats.ITF, "ITF"],
  [Html5QrcodeSupportedFormats.EAN_13, "EAN_13"],
  [Html5QrcodeSupportedFormats.EAN_8, "EAN_8"],
  [Html5QrcodeSupportedFormats.PDF_417, "PDF_417"],
  [Html5QrcodeSupportedFormats.RSS_14, "RSS_14"],
  [Html5QrcodeSupportedFormats.RSS_EXPANDED, "RSS_EXPANDED"],
  [Html5QrcodeSupportedFormats.UPC_A, "UPC_A"],
  [Html5QrcodeSupportedFormats.UPC_E, "UPC_E"],
  [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, "UPC_EAN_EXTENSION"]
]);
var DecodedTextType;
(function(DecodedTextType2) {
  DecodedTextType2[DecodedTextType2["UNKNOWN"] = 0] = "UNKNOWN";
  DecodedTextType2[DecodedTextType2["URL"] = 1] = "URL";
})(DecodedTextType || (DecodedTextType = {}));
function isValidHtml5QrcodeSupportedFormats(format) {
  return Object.values(Html5QrcodeSupportedFormats).includes(format);
}
var Html5QrcodeScanType;
(function(Html5QrcodeScanType2) {
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_CAMERA"] = 0] = "SCAN_TYPE_CAMERA";
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_FILE"] = 1] = "SCAN_TYPE_FILE";
})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));
var Html5QrcodeConstants = function() {
  function Html5QrcodeConstants2() {
  }
  Html5QrcodeConstants2.GITHUB_PROJECT_URL = "https://github.com/mebjas/html5-qrcode";
  Html5QrcodeConstants2.SCAN_DEFAULT_FPS = 2;
  Html5QrcodeConstants2.DEFAULT_DISABLE_FLIP = false;
  Html5QrcodeConstants2.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;
  Html5QrcodeConstants2.DEFAULT_SUPPORTED_SCAN_TYPE = [
    Html5QrcodeScanType.SCAN_TYPE_CAMERA,
    Html5QrcodeScanType.SCAN_TYPE_FILE
  ];
  return Html5QrcodeConstants2;
}();
var QrcodeResultFormat = function() {
  function QrcodeResultFormat2(format, formatName) {
    this.format = format;
    this.formatName = formatName;
  }
  QrcodeResultFormat2.prototype.toString = function() {
    return this.formatName;
  };
  QrcodeResultFormat2.create = function(format) {
    if (!html5QrcodeSupportedFormatsTextMap.has(format)) {
      throw "".concat(format, " not in html5QrcodeSupportedFormatsTextMap");
    }
    return new QrcodeResultFormat2(format, html5QrcodeSupportedFormatsTextMap.get(format));
  };
  return QrcodeResultFormat2;
}();
var Html5QrcodeResultFactory = function() {
  function Html5QrcodeResultFactory2() {
  }
  Html5QrcodeResultFactory2.createFromText = function(decodedText) {
    var qrcodeResult = {
      text: decodedText
    };
    return {
      decodedText,
      result: qrcodeResult
    };
  };
  Html5QrcodeResultFactory2.createFromQrcodeResult = function(qrcodeResult) {
    return {
      decodedText: qrcodeResult.text,
      result: qrcodeResult
    };
  };
  return Html5QrcodeResultFactory2;
}();
var Html5QrcodeErrorTypes;
(function(Html5QrcodeErrorTypes2) {
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["UNKWOWN_ERROR"] = 0] = "UNKWOWN_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["IMPLEMENTATION_ERROR"] = 1] = "IMPLEMENTATION_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["NO_CODE_FOUND_ERROR"] = 2] = "NO_CODE_FOUND_ERROR";
})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));
var Html5QrcodeErrorFactory = function() {
  function Html5QrcodeErrorFactory2() {
  }
  Html5QrcodeErrorFactory2.createFrom = function(error) {
    return {
      errorMessage: error,
      type: Html5QrcodeErrorTypes.UNKWOWN_ERROR
    };
  };
  return Html5QrcodeErrorFactory2;
}();
var BaseLoggger = function() {
  function BaseLoggger2(verbose) {
    this.verbose = verbose;
  }
  BaseLoggger2.prototype.log = function(message) {
    if (this.verbose) {
      console.log(message);
    }
  };
  BaseLoggger2.prototype.warn = function(message) {
    if (this.verbose) {
      console.warn(message);
    }
  };
  BaseLoggger2.prototype.logError = function(message, isExperimental) {
    if (this.verbose || isExperimental === true) {
      console.error(message);
    }
  };
  BaseLoggger2.prototype.logErrors = function(errors) {
    if (errors.length === 0) {
      throw "Logger#logError called without arguments";
    }
    if (this.verbose) {
      console.error(errors);
    }
  };
  return BaseLoggger2;
}();
function isNullOrUndefined(obj) {
  return typeof obj === "undefined" || obj === null;
}
function clip(value2, minValue, maxValue) {
  if (value2 > maxValue) {
    return maxValue;
  }
  if (value2 < minValue) {
    return minValue;
  }
  return value2;
}

// node_modules/html5-qrcode/esm/strings.js
var Html5QrcodeStrings = function() {
  function Html5QrcodeStrings2() {
  }
  Html5QrcodeStrings2.codeParseError = function(exception) {
    return "QR code parse error, error = ".concat(exception);
  };
  Html5QrcodeStrings2.errorGettingUserMedia = function(error) {
    return "Error getting userMedia, error = ".concat(error);
  };
  Html5QrcodeStrings2.onlyDeviceSupportedError = function() {
    return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string).";
  };
  Html5QrcodeStrings2.cameraStreamingNotSupported = function() {
    return "Camera streaming not supported by the browser.";
  };
  Html5QrcodeStrings2.unableToQuerySupportedDevices = function() {
    return "Unable to query supported devices, unknown error.";
  };
  Html5QrcodeStrings2.insecureContextCameraQueryError = function() {
    return "Camera access is only supported in secure context like https or localhost.";
  };
  Html5QrcodeStrings2.scannerPaused = function() {
    return "Scanner paused";
  };
  return Html5QrcodeStrings2;
}();
var Html5QrcodeScannerStrings = function() {
  function Html5QrcodeScannerStrings2() {
  }
  Html5QrcodeScannerStrings2.scanningStatus = function() {
    return "Scanning";
  };
  Html5QrcodeScannerStrings2.idleStatus = function() {
    return "Idle";
  };
  Html5QrcodeScannerStrings2.errorStatus = function() {
    return "Error";
  };
  Html5QrcodeScannerStrings2.permissionStatus = function() {
    return "Permission";
  };
  Html5QrcodeScannerStrings2.noCameraFoundErrorStatus = function() {
    return "No Cameras";
  };
  Html5QrcodeScannerStrings2.lastMatch = function(decodedText) {
    return "Last Match: ".concat(decodedText);
  };
  Html5QrcodeScannerStrings2.codeScannerTitle = function() {
    return "Code Scanner";
  };
  Html5QrcodeScannerStrings2.cameraPermissionTitle = function() {
    return "Request Camera Permissions";
  };
  Html5QrcodeScannerStrings2.cameraPermissionRequesting = function() {
    return "Requesting camera permissions...";
  };
  Html5QrcodeScannerStrings2.noCameraFound = function() {
    return "No camera found";
  };
  Html5QrcodeScannerStrings2.scanButtonStopScanningText = function() {
    return "Stop Scanning";
  };
  Html5QrcodeScannerStrings2.scanButtonStartScanningText = function() {
    return "Start Scanning";
  };
  Html5QrcodeScannerStrings2.torchOnButton = function() {
    return "Switch On Torch";
  };
  Html5QrcodeScannerStrings2.torchOffButton = function() {
    return "Switch Off Torch";
  };
  Html5QrcodeScannerStrings2.torchOnFailedMessage = function() {
    return "Failed to turn on torch";
  };
  Html5QrcodeScannerStrings2.torchOffFailedMessage = function() {
    return "Failed to turn off torch";
  };
  Html5QrcodeScannerStrings2.scanButtonScanningStarting = function() {
    return "Launching Camera...";
  };
  Html5QrcodeScannerStrings2.textIfCameraScanSelected = function() {
    return "Scan an Image File";
  };
  Html5QrcodeScannerStrings2.textIfFileScanSelected = function() {
    return "Scan using camera directly";
  };
  Html5QrcodeScannerStrings2.selectCamera = function() {
    return "Select Camera";
  };
  Html5QrcodeScannerStrings2.fileSelectionChooseImage = function() {
    return "Choose Image";
  };
  Html5QrcodeScannerStrings2.fileSelectionChooseAnother = function() {
    return "Choose Another";
  };
  Html5QrcodeScannerStrings2.fileSelectionNoImageSelected = function() {
    return "No image choosen";
  };
  Html5QrcodeScannerStrings2.anonymousCameraPrefix = function() {
    return "Anonymous Camera";
  };
  Html5QrcodeScannerStrings2.dragAndDropMessage = function() {
    return "Or drop an image to scan";
  };
  Html5QrcodeScannerStrings2.dragAndDropMessageOnlyImages = function() {
    return "Or drop an image to scan (other files not supported)";
  };
  Html5QrcodeScannerStrings2.zoom = function() {
    return "zoom";
  };
  Html5QrcodeScannerStrings2.loadingImage = function() {
    return "Loading image...";
  };
  Html5QrcodeScannerStrings2.cameraScanAltText = function() {
    return "Camera based scan";
  };
  Html5QrcodeScannerStrings2.fileScanAltText = function() {
    return "Fule based scan";
  };
  return Html5QrcodeScannerStrings2;
}();
var LibraryInfoStrings = function() {
  function LibraryInfoStrings2() {
  }
  LibraryInfoStrings2.poweredBy = function() {
    return "Powered by ";
  };
  LibraryInfoStrings2.reportIssues = function() {
    return "Report issues";
  };
  return LibraryInfoStrings2;
}();

// node_modules/html5-qrcode/esm/utils.js
var VideoConstraintsUtil = function() {
  function VideoConstraintsUtil2() {
  }
  VideoConstraintsUtil2.isMediaStreamConstraintsValid = function(videoConstraints, logger) {
    if (typeof videoConstraints !== "object") {
      var typeofVideoConstraints = typeof videoConstraints;
      logger.logError("videoConstraints should be of type object, the " + "object passed is of type ".concat(typeofVideoConstraints, "."), true);
      return false;
    }
    var bannedKeys = [
      "autoGainControl",
      "channelCount",
      "echoCancellation",
      "latency",
      "noiseSuppression",
      "sampleRate",
      "sampleSize",
      "volume"
    ];
    var bannedkeysSet = new Set(bannedKeys);
    var keysInVideoConstraints = Object.keys(videoConstraints);
    for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {
      var key = keysInVideoConstraints_1[_i];
      if (bannedkeysSet.has(key)) {
        logger.logError("".concat(key, " is not supported videoConstaints."), true);
        return false;
      }
    }
    return true;
  };
  return VideoConstraintsUtil2;
}();

// node_modules/html5-qrcode/esm/zxing-html5-qrcode-decoder.js
var ZXing = __toESM(require_zxing_js_umd());
var ZXingHtml5QrcodeDecoder = function() {
  function ZXingHtml5QrcodeDecoder2(requestedFormats, verbose, logger) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, ZXing.BarcodeFormat.QR_CODE],
      [Html5QrcodeSupportedFormats.AZTEC, ZXing.BarcodeFormat.AZTEC],
      [Html5QrcodeSupportedFormats.CODABAR, ZXing.BarcodeFormat.CODABAR],
      [Html5QrcodeSupportedFormats.CODE_39, ZXing.BarcodeFormat.CODE_39],
      [Html5QrcodeSupportedFormats.CODE_93, ZXing.BarcodeFormat.CODE_93],
      [
        Html5QrcodeSupportedFormats.CODE_128,
        ZXing.BarcodeFormat.CODE_128
      ],
      [
        Html5QrcodeSupportedFormats.DATA_MATRIX,
        ZXing.BarcodeFormat.DATA_MATRIX
      ],
      [
        Html5QrcodeSupportedFormats.MAXICODE,
        ZXing.BarcodeFormat.MAXICODE
      ],
      [Html5QrcodeSupportedFormats.ITF, ZXing.BarcodeFormat.ITF],
      [Html5QrcodeSupportedFormats.EAN_13, ZXing.BarcodeFormat.EAN_13],
      [Html5QrcodeSupportedFormats.EAN_8, ZXing.BarcodeFormat.EAN_8],
      [Html5QrcodeSupportedFormats.PDF_417, ZXing.BarcodeFormat.PDF_417],
      [Html5QrcodeSupportedFormats.RSS_14, ZXing.BarcodeFormat.RSS_14],
      [
        Html5QrcodeSupportedFormats.RSS_EXPANDED,
        ZXing.BarcodeFormat.RSS_EXPANDED
      ],
      [Html5QrcodeSupportedFormats.UPC_A, ZXing.BarcodeFormat.UPC_A],
      [Html5QrcodeSupportedFormats.UPC_E, ZXing.BarcodeFormat.UPC_E],
      [
        Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,
        ZXing.BarcodeFormat.UPC_EAN_EXTENSION
      ]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!ZXing) {
      throw "Use html5qrcode.min.js without edit, ZXing not found.";
    }
    this.verbose = verbose;
    this.logger = logger;
    var formats = this.createZXingFormats(requestedFormats);
    var hints = /* @__PURE__ */ new Map();
    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, formats);
    hints.set(ZXing.DecodeHintType.TRY_HARDER, false);
    this.hints = hints;
  }
  ZXingHtml5QrcodeDecoder2.prototype.decodeAsync = function(canvas) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      try {
        resolve(_this.decode(canvas));
      } catch (error) {
        reject(error);
      }
    });
  };
  ZXingHtml5QrcodeDecoder2.prototype.decode = function(canvas) {
    var zxingDecoder = new ZXing.MultiFormatReader(this.verbose, this.hints);
    var luminanceSource = new ZXing.HTMLCanvasElementLuminanceSource(canvas);
    var binaryBitmap = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(luminanceSource));
    var result = zxingDecoder.decode(binaryBitmap);
    return {
      text: result.text,
      format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),
      debugData: this.createDebugData()
    };
  };
  ZXingHtml5QrcodeDecoder2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value2, key, _2) {
      result.set(value2, key);
    });
    return result;
  };
  ZXingHtml5QrcodeDecoder2.prototype.toHtml5QrcodeSupportedFormats = function(zxingFormat) {
    if (!this.reverseFormatMap.has(zxingFormat)) {
      throw "reverseFormatMap doesn't have ".concat(zxingFormat);
    }
    return this.reverseFormatMap.get(zxingFormat);
  };
  ZXingHtml5QrcodeDecoder2.prototype.createZXingFormats = function(requestedFormats) {
    var zxingFormats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        zxingFormats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.logError("".concat(requestedFormat, " is not supported by") + "ZXingHtml5QrcodeShim");
      }
    }
    return zxingFormats;
  };
  ZXingHtml5QrcodeDecoder2.prototype.createDebugData = function() {
    return { decoderName: "zxing-js" };
  };
  return ZXingHtml5QrcodeDecoder2;
}();

// node_modules/html5-qrcode/esm/native-bar-code-detector.js
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var BarcodeDetectorDelegate = function() {
  function BarcodeDetectorDelegate2(requestedFormats, verbose, logger) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, "qr_code"],
      [Html5QrcodeSupportedFormats.AZTEC, "aztec"],
      [Html5QrcodeSupportedFormats.CODABAR, "codabar"],
      [Html5QrcodeSupportedFormats.CODE_39, "code_39"],
      [Html5QrcodeSupportedFormats.CODE_93, "code_93"],
      [Html5QrcodeSupportedFormats.CODE_128, "code_128"],
      [Html5QrcodeSupportedFormats.DATA_MATRIX, "data_matrix"],
      [Html5QrcodeSupportedFormats.ITF, "itf"],
      [Html5QrcodeSupportedFormats.EAN_13, "ean_13"],
      [Html5QrcodeSupportedFormats.EAN_8, "ean_8"],
      [Html5QrcodeSupportedFormats.PDF_417, "pdf417"],
      [Html5QrcodeSupportedFormats.UPC_A, "upc_a"],
      [Html5QrcodeSupportedFormats.UPC_E, "upc_e"]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!BarcodeDetectorDelegate2.isSupported()) {
      throw "Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();";
    }
    this.verbose = verbose;
    this.logger = logger;
    var formats = this.createBarcodeDetectorFormats(requestedFormats);
    this.detector = new BarcodeDetector(formats);
    if (!this.detector) {
      throw "BarcodeDetector detector not supported";
    }
  }
  BarcodeDetectorDelegate2.isSupported = function() {
    if (!("BarcodeDetector" in window)) {
      return false;
    }
    var dummyDetector = new BarcodeDetector({ formats: ["qr_code"] });
    return typeof dummyDetector !== "undefined";
  };
  BarcodeDetectorDelegate2.prototype.decodeAsync = function(canvas) {
    return __awaiter(this, void 0, void 0, function() {
      var barcodes, largestBarcode;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.detector.detect(canvas)];
          case 1:
            barcodes = _a2.sent();
            if (!barcodes || barcodes.length === 0) {
              throw "No barcode or QR code detected.";
            }
            largestBarcode = this.selectLargestBarcode(barcodes);
            return [2, {
              text: largestBarcode.rawValue,
              format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),
              debugData: this.createDebugData()
            }];
        }
      });
    });
  };
  BarcodeDetectorDelegate2.prototype.selectLargestBarcode = function(barcodes) {
    var largestBarcode = null;
    var maxArea = 0;
    for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {
      var barcode = barcodes_1[_i];
      var area = barcode.boundingBox.width * barcode.boundingBox.height;
      if (area > maxArea) {
        maxArea = area;
        largestBarcode = barcode;
      }
    }
    if (!largestBarcode) {
      throw "No largest barcode found";
    }
    return largestBarcode;
  };
  BarcodeDetectorDelegate2.prototype.createBarcodeDetectorFormats = function(requestedFormats) {
    var formats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        formats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.warn("".concat(requestedFormat, " is not supported by") + "BarcodeDetectorDelegate");
      }
    }
    return { formats };
  };
  BarcodeDetectorDelegate2.prototype.toHtml5QrcodeSupportedFormats = function(barcodeDetectorFormat) {
    if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {
      throw "reverseFormatMap doesn't have ".concat(barcodeDetectorFormat);
    }
    return this.reverseFormatMap.get(barcodeDetectorFormat);
  };
  BarcodeDetectorDelegate2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value2, key, _2) {
      result.set(value2, key);
    });
    return result;
  };
  BarcodeDetectorDelegate2.prototype.createDebugData = function() {
    return { decoderName: "BarcodeDetector" };
  };
  return BarcodeDetectorDelegate2;
}();

// node_modules/html5-qrcode/esm/code-decoder.js
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Html5QrcodeShim = function() {
  function Html5QrcodeShim2(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger) {
    this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;
    this.executions = 0;
    this.executionResults = [];
    this.wasPrimaryDecoderUsedInLastDecode = false;
    this.verbose = verbose;
    if (useBarCodeDetectorIfSupported && BarcodeDetectorDelegate.isSupported()) {
      this.primaryDecoder = new BarcodeDetectorDelegate(requestedFormats, verbose, logger);
      this.secondaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
    } else {
      this.primaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
    }
  }
  Html5QrcodeShim2.prototype.decodeAsync = function(canvas) {
    return __awaiter2(this, void 0, void 0, function() {
      var startTime;
      return __generator2(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            startTime = performance.now();
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, , 3, 4]);
            return [4, this.getDecoder().decodeAsync(canvas)];
          case 2:
            return [2, _a2.sent()];
          case 3:
            this.possiblyLogPerformance(startTime);
            return [7];
          case 4:
            return [2];
        }
      });
    });
  };
  Html5QrcodeShim2.prototype.decodeRobustlyAsync = function(canvas) {
    return __awaiter2(this, void 0, void 0, function() {
      var startTime, error_1;
      return __generator2(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            startTime = performance.now();
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, 4, 5]);
            return [4, this.primaryDecoder.decodeAsync(canvas)];
          case 2:
            return [2, _a2.sent()];
          case 3:
            error_1 = _a2.sent();
            if (this.secondaryDecoder) {
              return [2, this.secondaryDecoder.decodeAsync(canvas)];
            }
            throw error_1;
          case 4:
            this.possiblyLogPerformance(startTime);
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Html5QrcodeShim2.prototype.getDecoder = function() {
    if (!this.secondaryDecoder) {
      return this.primaryDecoder;
    }
    if (this.wasPrimaryDecoderUsedInLastDecode === false) {
      this.wasPrimaryDecoderUsedInLastDecode = true;
      return this.primaryDecoder;
    }
    this.wasPrimaryDecoderUsedInLastDecode = false;
    return this.secondaryDecoder;
  };
  Html5QrcodeShim2.prototype.possiblyLogPerformance = function(startTime) {
    if (!this.verbose) {
      return;
    }
    var executionTime = performance.now() - startTime;
    this.executionResults.push(executionTime);
    this.executions++;
    this.possiblyFlushPerformanceReport();
  };
  Html5QrcodeShim2.prototype.possiblyFlushPerformanceReport = function() {
    if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {
      return;
    }
    var sum = 0;
    for (var _i = 0, _a2 = this.executionResults; _i < _a2.length; _i++) {
      var executionTime = _a2[_i];
      sum += executionTime;
    }
    var mean = sum / this.executionResults.length;
    console.log("".concat(mean, " ms for ").concat(this.executionResults.length, " last runs."));
    this.executions = 0;
    this.executionResults = [];
  };
  return Html5QrcodeShim2;
}();

// node_modules/html5-qrcode/esm/camera/core-impl.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var AbstractCameraCapability = function() {
  function AbstractCameraCapability2(name, track) {
    this.name = name;
    this.track = track;
  }
  AbstractCameraCapability2.prototype.isSupported = function() {
    if (!this.track.getCapabilities) {
      return false;
    }
    return this.name in this.track.getCapabilities();
  };
  AbstractCameraCapability2.prototype.apply = function(value2) {
    var constraint = {};
    constraint[this.name] = value2;
    var constraints = { advanced: [constraint] };
    return this.track.applyConstraints(constraints);
  };
  AbstractCameraCapability2.prototype.value = function() {
    var settings = this.track.getSettings();
    if (this.name in settings) {
      var settingValue = settings[this.name];
      return settingValue;
    }
    return null;
  };
  return AbstractCameraCapability2;
}();
var AbstractRangeCameraCapability = function(_super) {
  __extends(AbstractRangeCameraCapability2, _super);
  function AbstractRangeCameraCapability2(name, track) {
    return _super.call(this, name, track) || this;
  }
  AbstractRangeCameraCapability2.prototype.min = function() {
    return this.getCapabilities().min;
  };
  AbstractRangeCameraCapability2.prototype.max = function() {
    return this.getCapabilities().max;
  };
  AbstractRangeCameraCapability2.prototype.step = function() {
    return this.getCapabilities().step;
  };
  AbstractRangeCameraCapability2.prototype.apply = function(value2) {
    var constraint = {};
    constraint[this.name] = value2;
    var constraints = { advanced: [constraint] };
    return this.track.applyConstraints(constraints);
  };
  AbstractRangeCameraCapability2.prototype.getCapabilities = function() {
    this.failIfNotSupported();
    var capabilities = this.track.getCapabilities();
    var capability = capabilities[this.name];
    return {
      min: capability.min,
      max: capability.max,
      step: capability.step
    };
  };
  AbstractRangeCameraCapability2.prototype.failIfNotSupported = function() {
    if (!this.isSupported()) {
      throw new Error("".concat(this.name, " capability not supported"));
    }
  };
  return AbstractRangeCameraCapability2;
}(AbstractCameraCapability);
var ZoomFeatureImpl = function(_super) {
  __extends(ZoomFeatureImpl2, _super);
  function ZoomFeatureImpl2(track) {
    return _super.call(this, "zoom", track) || this;
  }
  return ZoomFeatureImpl2;
}(AbstractRangeCameraCapability);
var TorchFeatureImpl = function(_super) {
  __extends(TorchFeatureImpl2, _super);
  function TorchFeatureImpl2(track) {
    return _super.call(this, "torch", track) || this;
  }
  return TorchFeatureImpl2;
}(AbstractCameraCapability);
var CameraCapabilitiesImpl = function() {
  function CameraCapabilitiesImpl2(track) {
    this.track = track;
  }
  CameraCapabilitiesImpl2.prototype.zoomFeature = function() {
    return new ZoomFeatureImpl(this.track);
  };
  CameraCapabilitiesImpl2.prototype.torchFeature = function() {
    return new TorchFeatureImpl(this.track);
  };
  return CameraCapabilitiesImpl2;
}();
var RenderedCameraImpl = function() {
  function RenderedCameraImpl2(parentElement, mediaStream, callbacks) {
    this.isClosed = false;
    this.parentElement = parentElement;
    this.mediaStream = mediaStream;
    this.callbacks = callbacks;
    this.surface = this.createVideoElement(this.parentElement.clientWidth);
    parentElement.append(this.surface);
  }
  RenderedCameraImpl2.prototype.createVideoElement = function(width) {
    var videoElement = document.createElement("video");
    videoElement.style.width = "".concat(width, "px");
    videoElement.style.display = "block";
    videoElement.muted = true;
    videoElement.setAttribute("muted", "true");
    videoElement.playsInline = true;
    return videoElement;
  };
  RenderedCameraImpl2.prototype.setupSurface = function() {
    var _this = this;
    this.surface.onabort = function() {
      throw "RenderedCameraImpl video surface onabort() called";
    };
    this.surface.onerror = function() {
      throw "RenderedCameraImpl video surface onerror() called";
    };
    var onVideoStart = function() {
      var videoWidth = _this.surface.clientWidth;
      var videoHeight = _this.surface.clientHeight;
      _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);
      _this.surface.removeEventListener("playing", onVideoStart);
    };
    this.surface.addEventListener("playing", onVideoStart);
    this.surface.srcObject = this.mediaStream;
    this.surface.play();
  };
  RenderedCameraImpl2.create = function(parentElement, mediaStream, options, callbacks) {
    return __awaiter3(this, void 0, void 0, function() {
      var renderedCamera, aspectRatioConstraint;
      return __generator3(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            renderedCamera = new RenderedCameraImpl2(parentElement, mediaStream, callbacks);
            if (!options.aspectRatio)
              return [3, 2];
            aspectRatioConstraint = {
              aspectRatio: options.aspectRatio
            };
            return [4, renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            renderedCamera.setupSurface();
            return [2, renderedCamera];
        }
      });
    });
  };
  RenderedCameraImpl2.prototype.failIfClosed = function() {
    if (this.isClosed) {
      throw "The RenderedCamera has already been closed.";
    }
  };
  RenderedCameraImpl2.prototype.getFirstTrackOrFail = function() {
    this.failIfClosed();
    if (this.mediaStream.getVideoTracks().length === 0) {
      throw "No video tracks found";
    }
    return this.mediaStream.getVideoTracks()[0];
  };
  RenderedCameraImpl2.prototype.pause = function() {
    this.failIfClosed();
    this.surface.pause();
  };
  RenderedCameraImpl2.prototype.resume = function(onResumeCallback) {
    this.failIfClosed();
    var $this = this;
    var onVideoResume = function() {
      setTimeout(onResumeCallback, 200);
      $this.surface.removeEventListener("playing", onVideoResume);
    };
    this.surface.addEventListener("playing", onVideoResume);
    this.surface.play();
  };
  RenderedCameraImpl2.prototype.isPaused = function() {
    this.failIfClosed();
    return this.surface.paused;
  };
  RenderedCameraImpl2.prototype.getSurface = function() {
    this.failIfClosed();
    return this.surface;
  };
  RenderedCameraImpl2.prototype.getRunningTrackCapabilities = function() {
    return this.getFirstTrackOrFail().getCapabilities();
  };
  RenderedCameraImpl2.prototype.getRunningTrackSettings = function() {
    return this.getFirstTrackOrFail().getSettings();
  };
  RenderedCameraImpl2.prototype.applyVideoConstraints = function(constraints) {
    return __awaiter3(this, void 0, void 0, function() {
      return __generator3(this, function(_a2) {
        if ("aspectRatio" in constraints) {
          throw "Changing 'aspectRatio' in run-time is not yet supported.";
        }
        return [2, this.getFirstTrackOrFail().applyConstraints(constraints)];
      });
    });
  };
  RenderedCameraImpl2.prototype.close = function() {
    if (this.isClosed) {
      return Promise.resolve();
    }
    var $this = this;
    return new Promise(function(resolve, _2) {
      var tracks = $this.mediaStream.getVideoTracks();
      var tracksToClose = tracks.length;
      var tracksClosed = 0;
      $this.mediaStream.getVideoTracks().forEach(function(videoTrack) {
        $this.mediaStream.removeTrack(videoTrack);
        videoTrack.stop();
        ++tracksClosed;
        if (tracksClosed >= tracksToClose) {
          $this.isClosed = true;
          $this.parentElement.removeChild($this.surface);
          resolve();
        }
      });
    });
  };
  RenderedCameraImpl2.prototype.getCapabilities = function() {
    return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());
  };
  return RenderedCameraImpl2;
}();
var CameraImpl = function() {
  function CameraImpl2(mediaStream) {
    this.mediaStream = mediaStream;
  }
  CameraImpl2.prototype.render = function(parentElement, options, callbacks) {
    return __awaiter3(this, void 0, void 0, function() {
      return __generator3(this, function(_a2) {
        return [2, RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)];
      });
    });
  };
  CameraImpl2.create = function(videoConstraints) {
    return __awaiter3(this, void 0, void 0, function() {
      var constraints, mediaStream;
      return __generator3(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!navigator.mediaDevices) {
              throw "navigator.mediaDevices not supported";
            }
            constraints = {
              audio: false,
              video: videoConstraints
            };
            return [4, navigator.mediaDevices.getUserMedia(constraints)];
          case 1:
            mediaStream = _a2.sent();
            return [2, new CameraImpl2(mediaStream)];
        }
      });
    });
  };
  return CameraImpl2;
}();

// node_modules/html5-qrcode/esm/camera/factories.js
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraFactory = function() {
  function CameraFactory2() {
  }
  CameraFactory2.failIfNotSupported = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        if (!navigator.mediaDevices) {
          throw "navigator.mediaDevices not supported";
        }
        return [2, new CameraFactory2()];
      });
    });
  };
  CameraFactory2.prototype.create = function(videoConstraints) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, CameraImpl.create(videoConstraints)];
      });
    });
  };
  return CameraFactory2;
}();

// node_modules/html5-qrcode/esm/camera/retriever.js
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator5 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraRetriever = function() {
  function CameraRetriever2() {
  }
  CameraRetriever2.retrieve = function() {
    if (navigator.mediaDevices) {
      return CameraRetriever2.getCamerasFromMediaDevices();
    }
    var mst = MediaStreamTrack;
    if (MediaStreamTrack && mst.getSources) {
      return CameraRetriever2.getCamerasFromMediaStreamTrack();
    }
    return CameraRetriever2.rejectWithError();
  };
  CameraRetriever2.rejectWithError = function() {
    var errorMessage = Html5QrcodeStrings.unableToQuerySupportedDevices();
    if (!CameraRetriever2.isHttpsOrLocalhost()) {
      errorMessage = Html5QrcodeStrings.insecureContextCameraQueryError();
    }
    return Promise.reject(errorMessage);
  };
  CameraRetriever2.isHttpsOrLocalhost = function() {
    if (location.protocol === "https:") {
      return true;
    }
    var host = location.host.split(":")[0];
    return host === "127.0.0.1" || host === "localhost";
  };
  CameraRetriever2.getCamerasFromMediaDevices = function() {
    return __awaiter5(this, void 0, void 0, function() {
      var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;
      return __generator5(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            closeActiveStreams = function(stream) {
              var tracks = stream.getVideoTracks();
              for (var _i2 = 0, tracks_1 = tracks; _i2 < tracks_1.length; _i2++) {
                var track = tracks_1[_i2];
                track.enabled = false;
                track.stop();
                stream.removeTrack(track);
              }
            };
            return [4, navigator.mediaDevices.getUserMedia({ audio: false, video: true })];
          case 1:
            mediaStream = _a2.sent();
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 2:
            devices = _a2.sent();
            results = [];
            for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
              device = devices_1[_i];
              if (device.kind === "videoinput") {
                results.push({
                  id: device.deviceId,
                  label: device.label
                });
              }
            }
            closeActiveStreams(mediaStream);
            return [2, results];
        }
      });
    });
  };
  CameraRetriever2.getCamerasFromMediaStreamTrack = function() {
    return new Promise(function(resolve, _2) {
      var callback = function(sourceInfos) {
        var results = [];
        for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
          var sourceInfo = sourceInfos_1[_i];
          if (sourceInfo.kind === "video") {
            results.push({
              id: sourceInfo.id,
              label: sourceInfo.label
            });
          }
        }
        resolve(results);
      };
      var mst = MediaStreamTrack;
      mst.getSources(callback);
    });
  };
  return CameraRetriever2;
}();

// node_modules/html5-qrcode/esm/state-manager.js
var Html5QrcodeScannerState;
(function(Html5QrcodeScannerState2) {
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["UNKNOWN"] = 0] = "UNKNOWN";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["NOT_STARTED"] = 1] = "NOT_STARTED";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["SCANNING"] = 2] = "SCANNING";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["PAUSED"] = 3] = "PAUSED";
})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));
var StateManagerImpl = function() {
  function StateManagerImpl2() {
    this.state = Html5QrcodeScannerState.NOT_STARTED;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  }
  StateManagerImpl2.prototype.directTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.state = newState;
  };
  StateManagerImpl2.prototype.startTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.onGoingTransactionNewState = newState;
    return this;
  };
  StateManagerImpl2.prototype.execute = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot execute().";
    }
    var tempNewState = this.onGoingTransactionNewState;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
    this.directTransition(tempNewState);
  };
  StateManagerImpl2.prototype.cancel = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot cancel().";
    }
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  };
  StateManagerImpl2.prototype.getState = function() {
    return this.state;
  };
  StateManagerImpl2.prototype.failIfTransitionOngoing = function() {
    if (this.onGoingTransactionNewState !== Html5QrcodeScannerState.UNKNOWN) {
      throw "Cannot transition to a new state, already under transition";
    }
  };
  StateManagerImpl2.prototype.validateTransition = function(newState) {
    switch (this.state) {
      case Html5QrcodeScannerState.UNKNOWN:
        throw "Transition from unknown is not allowed";
      case Html5QrcodeScannerState.NOT_STARTED:
        this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);
        break;
      case Html5QrcodeScannerState.SCANNING:
        break;
      case Html5QrcodeScannerState.PAUSED:
        break;
    }
  };
  StateManagerImpl2.prototype.failIfNewStateIs = function(newState, disallowedStatesToTransition) {
    for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {
      var disallowedState = disallowedStatesToTransition_1[_i];
      if (newState === disallowedState) {
        throw "Cannot transition from ".concat(this.state, " to ").concat(newState);
      }
    }
  };
  return StateManagerImpl2;
}();
var StateManagerProxy = function() {
  function StateManagerProxy2(stateManager) {
    this.stateManager = stateManager;
  }
  StateManagerProxy2.prototype.startTransition = function(newState) {
    return this.stateManager.startTransition(newState);
  };
  StateManagerProxy2.prototype.directTransition = function(newState) {
    this.stateManager.directTransition(newState);
  };
  StateManagerProxy2.prototype.getState = function() {
    return this.stateManager.getState();
  };
  StateManagerProxy2.prototype.canScanFile = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isScanning = function() {
    return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isStrictlyScanning = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;
  };
  StateManagerProxy2.prototype.isPaused = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;
  };
  return StateManagerProxy2;
}();
var StateManagerFactory = function() {
  function StateManagerFactory2() {
  }
  StateManagerFactory2.create = function() {
    return new StateManagerProxy(new StateManagerImpl());
  };
  return StateManagerFactory2;
}();

// node_modules/html5-qrcode/esm/html5-qrcode.js
var __extends2 = /* @__PURE__ */ function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Constants = function(_super) {
  __extends2(Constants2, _super);
  function Constants2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Constants2.DEFAULT_WIDTH = 300;
  Constants2.DEFAULT_WIDTH_OFFSET = 2;
  Constants2.FILE_SCAN_MIN_HEIGHT = 300;
  Constants2.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;
  Constants2.MIN_QR_BOX_SIZE = 50;
  Constants2.SHADED_LEFT = 1;
  Constants2.SHADED_RIGHT = 2;
  Constants2.SHADED_TOP = 3;
  Constants2.SHADED_BOTTOM = 4;
  Constants2.SHADED_REGION_ELEMENT_ID = "qr-shaded-region";
  Constants2.VERBOSE = false;
  Constants2.BORDER_SHADER_DEFAULT_COLOR = "#ffffff";
  Constants2.BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)";
  return Constants2;
}(Html5QrcodeConstants);
var InternalHtml5QrcodeConfig = function() {
  function InternalHtml5QrcodeConfig2(config, logger) {
    this.logger = logger;
    this.fps = Constants.SCAN_DEFAULT_FPS;
    if (!config) {
      this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;
    } else {
      if (config.fps) {
        this.fps = config.fps;
      }
      this.disableFlip = config.disableFlip === true;
      this.qrbox = config.qrbox;
      this.aspectRatio = config.aspectRatio;
      this.videoConstraints = config.videoConstraints;
    }
  }
  InternalHtml5QrcodeConfig2.prototype.isMediaStreamConstraintsValid = function() {
    if (!this.videoConstraints) {
      this.logger.logError("Empty videoConstraints", true);
      return false;
    }
    return VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);
  };
  InternalHtml5QrcodeConfig2.prototype.isShadedBoxEnabled = function() {
    return !isNullOrUndefined(this.qrbox);
  };
  InternalHtml5QrcodeConfig2.create = function(config, logger) {
    return new InternalHtml5QrcodeConfig2(config, logger);
  };
  return InternalHtml5QrcodeConfig2;
}();
var Html5Qrcode = function() {
  function Html5Qrcode2(elementId, configOrVerbosityFlag) {
    this.element = null;
    this.canvasElement = null;
    this.scannerPausedUiElement = null;
    this.hasBorderShaders = null;
    this.borderShaders = null;
    this.qrMatch = null;
    this.renderedCamera = null;
    this.qrRegion = null;
    this.context = null;
    this.lastScanImageFile = null;
    this.isScanning = false;
    if (!document.getElementById(elementId)) {
      throw "HTML Element with id=".concat(elementId, " not found");
    }
    this.elementId = elementId;
    this.verbose = false;
    var experimentalFeatureConfig;
    var configObject;
    if (typeof configOrVerbosityFlag == "boolean") {
      this.verbose = configOrVerbosityFlag === true;
    } else if (configOrVerbosityFlag) {
      configObject = configOrVerbosityFlag;
      this.verbose = configObject.verbose === true;
      experimentalFeatureConfig = configObject.experimentalFeatures;
    }
    this.logger = new BaseLoggger(this.verbose);
    this.qrcode = new Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);
    this.foreverScanTimeout;
    this.shouldScan = true;
    this.stateManagerProxy = StateManagerFactory.create();
  }
  Html5Qrcode2.prototype.start = function(cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!cameraIdOrConfig) {
      throw "cameraIdOrConfig is required";
    }
    if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function") {
      throw "qrCodeSuccessCallback is required and should be a function.";
    }
    var qrCodeErrorCallbackInternal;
    if (qrCodeErrorCallback) {
      qrCodeErrorCallbackInternal = qrCodeErrorCallback;
    } else {
      qrCodeErrorCallbackInternal = this.verbose ? this.logger.log : function() {
      };
    }
    var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);
    this.clearElement();
    var videoConstraintsAvailableAndValid = false;
    if (internalConfig.videoConstraints) {
      if (!internalConfig.isMediaStreamConstraintsValid()) {
        this.logger.logError("'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'", true);
      } else {
        videoConstraintsAvailableAndValid = true;
      }
    }
    var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;
    var element = document.getElementById(this.elementId);
    var rootElementWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
    element.style.position = "relative";
    this.shouldScan = true;
    this.element = element;
    var $this = this;
    var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.SCANNING);
    return new Promise(function(resolve, reject) {
      var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);
      if (!videoConstraints) {
        toScanningStateChangeTransaction.cancel();
        reject("videoConstraints should be defined");
        return;
      }
      var cameraRenderingOptions = {};
      if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {
        cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;
      }
      var renderingCallbacks = {
        onRenderSurfaceReady: function(viewfinderWidth, viewfinderHeight) {
          $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);
          $this.isScanning = true;
          $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);
        }
      };
      CameraFactory.failIfNotSupported().then(function(factory) {
        factory.create(videoConstraints).then(function(camera) {
          return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks).then(function(renderedCamera) {
            $this.renderedCamera = renderedCamera;
            toScanningStateChangeTransaction.execute();
            resolve(null);
          }).catch(function(error) {
            toScanningStateChangeTransaction.cancel();
            reject(error);
          });
        }).catch(function(error) {
          toScanningStateChangeTransaction.cancel();
          reject(Html5QrcodeStrings.errorGettingUserMedia(error));
        });
      }).catch(function(_2) {
        toScanningStateChangeTransaction.cancel();
        reject(Html5QrcodeStrings.cameraStreamingNotSupported());
      });
    });
  };
  Html5Qrcode2.prototype.pause = function(shouldPauseVideo) {
    if (!this.stateManagerProxy.isStrictlyScanning()) {
      throw "Cannot pause, scanner is not scanning.";
    }
    this.stateManagerProxy.directTransition(Html5QrcodeScannerState.PAUSED);
    this.showPausedState();
    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
      shouldPauseVideo = false;
    }
    if (shouldPauseVideo && this.renderedCamera) {
      this.renderedCamera.pause();
    }
  };
  Html5Qrcode2.prototype.resume = function() {
    if (!this.stateManagerProxy.isPaused()) {
      throw "Cannot result, scanner is not paused.";
    }
    if (!this.renderedCamera) {
      throw "renderedCamera doesn't exist while trying resume()";
    }
    var $this = this;
    var transitionToScanning = function() {
      $this.stateManagerProxy.directTransition(Html5QrcodeScannerState.SCANNING);
      $this.hidePausedState();
    };
    if (!this.renderedCamera.isPaused()) {
      transitionToScanning();
      return;
    }
    this.renderedCamera.resume(function() {
      transitionToScanning();
    });
  };
  Html5Qrcode2.prototype.getState = function() {
    return this.stateManagerProxy.getState();
  };
  Html5Qrcode2.prototype.stop = function() {
    var _this = this;
    if (!this.stateManagerProxy.isScanning()) {
      throw "Cannot stop, scanner is not running or paused.";
    }
    var toStoppedStateTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.NOT_STARTED);
    this.shouldScan = false;
    if (this.foreverScanTimeout) {
      clearTimeout(this.foreverScanTimeout);
    }
    var removeQrRegion = function() {
      if (!_this.element) {
        return;
      }
      var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);
      if (childElement) {
        _this.element.removeChild(childElement);
      }
    };
    var $this = this;
    return this.renderedCamera.close().then(function() {
      $this.renderedCamera = null;
      if ($this.element) {
        $this.element.removeChild($this.canvasElement);
        $this.canvasElement = null;
      }
      removeQrRegion();
      if ($this.qrRegion) {
        $this.qrRegion = null;
      }
      if ($this.context) {
        $this.context = null;
      }
      toStoppedStateTransaction.execute();
      $this.hidePausedState();
      $this.isScanning = false;
      return Promise.resolve();
    });
  };
  Html5Qrcode2.prototype.scanFile = function(imageFile, showImage) {
    return this.scanFileV2(imageFile, showImage).then(function(html5qrcodeResult) {
      return html5qrcodeResult.decodedText;
    });
  };
  Html5Qrcode2.prototype.scanFileV2 = function(imageFile, showImage) {
    var _this = this;
    if (!imageFile || !(imageFile instanceof File)) {
      throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'.";
    }
    if (isNullOrUndefined(showImage)) {
      showImage = true;
    }
    if (!this.stateManagerProxy.canScanFile()) {
      throw "Cannot start file scan - ongoing camera scan";
    }
    return new Promise(function(resolve, reject) {
      _this.possiblyCloseLastScanImageFile();
      _this.clearElement();
      _this.lastScanImageFile = URL.createObjectURL(imageFile);
      var inputImage = new Image();
      inputImage.onload = function() {
        var imageWidth = inputImage.width;
        var imageHeight = inputImage.height;
        var element = document.getElementById(_this.elementId);
        var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
        var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);
        var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
        if (showImage) {
          var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, "qr-canvas-visible");
          visibleCanvas.style.display = "inline-block";
          element.appendChild(visibleCanvas);
          var context_1 = visibleCanvas.getContext("2d");
          if (!context_1) {
            throw "Unable to get 2d context from canvas";
          }
          context_1.canvas.width = containerWidth;
          context_1.canvas.height = containerHeight;
          context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);
        }
        var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;
        var hiddenImageWidth = Math.max(inputImage.width, config.width);
        var hiddenImageHeight = Math.max(inputImage.height, config.height);
        var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;
        var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;
        var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);
        element.appendChild(hiddenCanvas);
        var context = hiddenCanvas.getContext("2d");
        if (!context) {
          throw "Unable to get 2d context from canvas";
        }
        context.canvas.width = hiddenCanvasWidth;
        context.canvas.height = hiddenCanvasHeight;
        context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);
        try {
          _this.qrcode.decodeRobustlyAsync(hiddenCanvas).then(function(result) {
            resolve(Html5QrcodeResultFactory.createFromQrcodeResult(result));
          }).catch(reject);
        } catch (exception) {
          reject("QR code parse error, error = ".concat(exception));
        }
      };
      inputImage.onerror = reject;
      inputImage.onabort = reject;
      inputImage.onstalled = reject;
      inputImage.onsuspend = reject;
      inputImage.src = URL.createObjectURL(imageFile);
    });
  };
  Html5Qrcode2.prototype.clear = function() {
    this.clearElement();
  };
  Html5Qrcode2.getCameras = function() {
    return CameraRetriever.retrieve();
  };
  Html5Qrcode2.prototype.getRunningTrackCapabilities = function() {
    return this.getRenderedCameraOrFail().getRunningTrackCapabilities();
  };
  Html5Qrcode2.prototype.getRunningTrackSettings = function() {
    return this.getRenderedCameraOrFail().getRunningTrackSettings();
  };
  Html5Qrcode2.prototype.getRunningTrackCameraCapabilities = function() {
    return this.getRenderedCameraOrFail().getCapabilities();
  };
  Html5Qrcode2.prototype.applyVideoConstraints = function(videoConstaints) {
    if (!videoConstaints) {
      throw "videoConstaints is required argument.";
    } else if (!VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {
      throw "invalid videoConstaints passed, check logs for more details";
    }
    return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);
  };
  Html5Qrcode2.prototype.getRenderedCameraOrFail = function() {
    if (this.renderedCamera == null) {
      throw "Scanning is not in running state, call this API only when QR code scanning using camera is in running state.";
    }
    return this.renderedCamera;
  };
  Html5Qrcode2.prototype.getSupportedFormats = function(configOrVerbosityFlag) {
    var allFormats = [
      Html5QrcodeSupportedFormats.QR_CODE,
      Html5QrcodeSupportedFormats.AZTEC,
      Html5QrcodeSupportedFormats.CODABAR,
      Html5QrcodeSupportedFormats.CODE_39,
      Html5QrcodeSupportedFormats.CODE_93,
      Html5QrcodeSupportedFormats.CODE_128,
      Html5QrcodeSupportedFormats.DATA_MATRIX,
      Html5QrcodeSupportedFormats.MAXICODE,
      Html5QrcodeSupportedFormats.ITF,
      Html5QrcodeSupportedFormats.EAN_13,
      Html5QrcodeSupportedFormats.EAN_8,
      Html5QrcodeSupportedFormats.PDF_417,
      Html5QrcodeSupportedFormats.RSS_14,
      Html5QrcodeSupportedFormats.RSS_EXPANDED,
      Html5QrcodeSupportedFormats.UPC_A,
      Html5QrcodeSupportedFormats.UPC_E,
      Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION
    ];
    if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == "boolean") {
      return allFormats;
    }
    if (!configOrVerbosityFlag.formatsToSupport) {
      return allFormats;
    }
    if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {
      throw "configOrVerbosityFlag.formatsToSupport should be undefined or an array.";
    }
    if (configOrVerbosityFlag.formatsToSupport.length === 0) {
      throw "Atleast 1 formatsToSupport is needed.";
    }
    var supportedFormats = [];
    for (var _i = 0, _a2 = configOrVerbosityFlag.formatsToSupport; _i < _a2.length; _i++) {
      var format = _a2[_i];
      if (isValidHtml5QrcodeSupportedFormats(format)) {
        supportedFormats.push(format);
      } else {
        this.logger.warn("Invalid format: ".concat(format, " passed in config, ignoring."));
      }
    }
    if (supportedFormats.length === 0) {
      throw "None of formatsToSupport match supported values.";
    }
    return supportedFormats;
  };
  Html5Qrcode2.prototype.getUseBarCodeDetectorIfSupported = function(config) {
    if (isNullOrUndefined(config)) {
      return true;
    }
    if (!isNullOrUndefined(config.useBarCodeDetectorIfSupported)) {
      return config.useBarCodeDetectorIfSupported !== false;
    }
    if (isNullOrUndefined(config.experimentalFeatures)) {
      return true;
    }
    var experimentalFeatures = config.experimentalFeatures;
    if (isNullOrUndefined(experimentalFeatures.useBarCodeDetectorIfSupported)) {
      return true;
    }
    return experimentalFeatures.useBarCodeDetectorIfSupported !== false;
  };
  Html5Qrcode2.prototype.validateQrboxSize = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    var _this = this;
    var qrboxSize = internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    var validateMinSize = function(size) {
      if (size < Constants.MIN_QR_BOX_SIZE) {
        throw "minimum size of 'config.qrbox' dimension value is" + " ".concat(Constants.MIN_QR_BOX_SIZE, "px.");
      }
    };
    var correctWidthBasedOnRootElementSize = function(configWidth) {
      if (configWidth > viewfinderWidth) {
        _this.logger.warn("`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.");
        configWidth = viewfinderWidth;
      }
      return configWidth;
    };
    validateMinSize(qrDimensions.width);
    validateMinSize(qrDimensions.height);
    qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);
  };
  Html5Qrcode2.prototype.validateQrboxConfig = function(qrboxSize) {
    if (typeof qrboxSize === "number") {
      return;
    }
    if (typeof qrboxSize === "function") {
      return;
    }
    if (qrboxSize.width === void 0 || qrboxSize.height === void 0) {
      throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set.";
    }
  };
  Html5Qrcode2.prototype.toQrdimensions = function(viewfinderWidth, viewfinderHeight, qrboxSize) {
    if (typeof qrboxSize === "number") {
      return { width: qrboxSize, height: qrboxSize };
    } else if (typeof qrboxSize === "function") {
      try {
        return qrboxSize(viewfinderWidth, viewfinderHeight);
      } catch (error) {
        throw new Error("qrbox config was passed as a function but it failed with unknown error" + error);
      }
    }
    return qrboxSize;
  };
  Html5Qrcode2.prototype.setupUi = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    if (internalConfig.isShadedBoxEnabled()) {
      this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);
    }
    var qrboxSize = isNullOrUndefined(internalConfig.qrbox) ? { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    if (qrDimensions.height > viewfinderHeight) {
      this.logger.warn("[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored");
    }
    var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;
    var defaultQrRegion = {
      x: 0,
      y: 0,
      width: viewfinderWidth,
      height: viewfinderHeight
    };
    var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;
    var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);
    var contextAttributes = { willReadFrequently: true };
    var context = canvasElement.getContext("2d", contextAttributes);
    context.canvas.width = qrRegion.width;
    context.canvas.height = qrRegion.height;
    this.element.append(canvasElement);
    if (shouldShadingBeApplied) {
      this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);
    }
    this.createScannerPausedUiElement(this.element);
    this.qrRegion = qrRegion;
    this.context = context;
    this.canvasElement = canvasElement;
  };
  Html5Qrcode2.prototype.createScannerPausedUiElement = function(rootElement) {
    var scannerPausedUiElement = document.createElement("div");
    scannerPausedUiElement.innerText = Html5QrcodeStrings.scannerPaused();
    scannerPausedUiElement.style.display = "none";
    scannerPausedUiElement.style.position = "absolute";
    scannerPausedUiElement.style.top = "0px";
    scannerPausedUiElement.style.zIndex = "1";
    scannerPausedUiElement.style.background = "rgba(9, 9, 9, 0.46)";
    scannerPausedUiElement.style.color = "#FFECEC";
    scannerPausedUiElement.style.textAlign = "center";
    scannerPausedUiElement.style.width = "100%";
    rootElement.appendChild(scannerPausedUiElement);
    this.scannerPausedUiElement = scannerPausedUiElement;
  };
  Html5Qrcode2.prototype.scanContext = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (this.stateManagerProxy.isPaused()) {
      return Promise.resolve(false);
    }
    return this.qrcode.decodeAsync(this.canvasElement).then(function(result) {
      qrCodeSuccessCallback(result.text, Html5QrcodeResultFactory.createFromQrcodeResult(result));
      _this.possiblyUpdateShaders(true);
      return true;
    }).catch(function(error) {
      _this.possiblyUpdateShaders(false);
      var errorMessage = Html5QrcodeStrings.codeParseError(error);
      qrCodeErrorCallback(errorMessage, Html5QrcodeErrorFactory.createFrom(errorMessage));
      return false;
    });
  };
  Html5Qrcode2.prototype.foreverScan = function(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!this.shouldScan) {
      return;
    }
    if (!this.renderedCamera) {
      return;
    }
    var videoElement = this.renderedCamera.getSurface();
    var widthRatio = videoElement.videoWidth / videoElement.clientWidth;
    var heightRatio = videoElement.videoHeight / videoElement.clientHeight;
    if (!this.qrRegion) {
      throw "qrRegion undefined when localMediaStream is ready.";
    }
    var sWidthOffset = this.qrRegion.width * widthRatio;
    var sHeightOffset = this.qrRegion.height * heightRatio;
    var sxOffset = this.qrRegion.x * widthRatio;
    var syOffset = this.qrRegion.y * heightRatio;
    this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);
    var triggerNextScan = function() {
      _this.foreverScanTimeout = setTimeout(function() {
        _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);
      }, _this.getTimeoutFps(internalConfig.fps));
    };
    this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function(isSuccessfull) {
      if (!isSuccessfull && internalConfig.disableFlip !== true) {
        _this.context.translate(_this.context.canvas.width, 0);
        _this.context.scale(-1, 1);
        _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function() {
          triggerNextScan();
        });
      } else {
        triggerNextScan();
      }
    }).catch(function(error) {
      _this.logger.logError("Error happend while scanning context", error);
      triggerNextScan();
    });
  };
  Html5Qrcode2.prototype.createVideoConstraints = function(cameraIdOrConfig) {
    if (typeof cameraIdOrConfig == "string") {
      return { deviceId: { exact: cameraIdOrConfig } };
    } else if (typeof cameraIdOrConfig == "object") {
      var facingModeKey = "facingMode";
      var deviceIdKey = "deviceId";
      var allowedFacingModeValues_1 = { "user": true, "environment": true };
      var exactKey = "exact";
      var isValidFacingModeValue = function(value2) {
        if (value2 in allowedFacingModeValues_1) {
          return true;
        } else {
          throw "config has invalid 'facingMode' value = " + "'".concat(value2, "'");
        }
      };
      var keys = Object.keys(cameraIdOrConfig);
      if (keys.length !== 1) {
        throw "'cameraIdOrConfig' object should have exactly 1 key," + " if passed as an object, found ".concat(keys.length, " keys");
      }
      var key = Object.keys(cameraIdOrConfig)[0];
      if (key !== facingModeKey && key !== deviceIdKey) {
        throw "Only '".concat(facingModeKey, "' and '").concat(deviceIdKey, "' ") + " are supported for 'cameraIdOrConfig'";
      }
      if (key === facingModeKey) {
        var facingMode = cameraIdOrConfig.facingMode;
        if (typeof facingMode == "string") {
          if (isValidFacingModeValue(facingMode)) {
            return { facingMode };
          }
        } else if (typeof facingMode == "object") {
          if (exactKey in facingMode) {
            if (isValidFacingModeValue(facingMode["".concat(exactKey)])) {
              return {
                facingMode: {
                  exact: facingMode["".concat(exactKey)]
                }
              };
            }
          } else {
            throw "'facingMode' should be string or object with" + " ".concat(exactKey, " as key.");
          }
        } else {
          var type_1 = typeof facingMode;
          throw "Invalid type of 'facingMode' = ".concat(type_1);
        }
      } else {
        var deviceId = cameraIdOrConfig.deviceId;
        if (typeof deviceId == "string") {
          return { deviceId };
        } else if (typeof deviceId == "object") {
          if (exactKey in deviceId) {
            return {
              deviceId: { exact: deviceId["".concat(exactKey)] }
            };
          } else {
            throw "'deviceId' should be string or object with" + " ".concat(exactKey, " as key.");
          }
        } else {
          var type_2 = typeof deviceId;
          throw "Invalid type of 'deviceId' = ".concat(type_2);
        }
      }
    }
    var type = typeof cameraIdOrConfig;
    throw "Invalid type of 'cameraIdOrConfig' = ".concat(type);
  };
  Html5Qrcode2.prototype.computeCanvasDrawConfig = function(imageWidth, imageHeight, containerWidth, containerHeight) {
    if (imageWidth <= containerWidth && imageHeight <= containerHeight) {
      var xoffset = (containerWidth - imageWidth) / 2;
      var yoffset = (containerHeight - imageHeight) / 2;
      return {
        x: xoffset,
        y: yoffset,
        width: imageWidth,
        height: imageHeight
      };
    } else {
      var formerImageWidth = imageWidth;
      var formerImageHeight = imageHeight;
      if (imageWidth > containerWidth) {
        imageHeight = containerWidth / imageWidth * imageHeight;
        imageWidth = containerWidth;
      }
      if (imageHeight > containerHeight) {
        imageWidth = containerHeight / imageHeight * imageWidth;
        imageHeight = containerHeight;
      }
      this.logger.log("Image downsampled from " + "".concat(formerImageWidth, "X").concat(formerImageHeight) + " to ".concat(imageWidth, "X").concat(imageHeight, "."));
      return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
    }
  };
  Html5Qrcode2.prototype.clearElement = function() {
    if (this.stateManagerProxy.isScanning()) {
      throw "Cannot clear while scan is ongoing, close it first.";
    }
    var element = document.getElementById(this.elementId);
    if (element) {
      element.innerHTML = "";
    }
  };
  Html5Qrcode2.prototype.possiblyUpdateShaders = function(qrMatch) {
    if (this.qrMatch === qrMatch) {
      return;
    }
    if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {
      this.borderShaders.forEach(function(shader) {
        shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;
      });
    }
    this.qrMatch = qrMatch;
  };
  Html5Qrcode2.prototype.possiblyCloseLastScanImageFile = function() {
    if (this.lastScanImageFile) {
      URL.revokeObjectURL(this.lastScanImageFile);
      this.lastScanImageFile = null;
    }
  };
  Html5Qrcode2.prototype.createCanvasElement = function(width, height, customId) {
    var canvasWidth = width;
    var canvasHeight = height;
    var canvasElement = document.createElement("canvas");
    canvasElement.style.width = "".concat(canvasWidth, "px");
    canvasElement.style.height = "".concat(canvasHeight, "px");
    canvasElement.style.display = "none";
    canvasElement.id = isNullOrUndefined(customId) ? "qr-canvas" : customId;
    return canvasElement;
  };
  Html5Qrcode2.prototype.getShadedRegionBounds = function(width, height, qrboxSize) {
    if (qrboxSize.width > width || qrboxSize.height > height) {
      throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element.";
    }
    return {
      x: (width - qrboxSize.width) / 2,
      y: (height - qrboxSize.height) / 2,
      width: qrboxSize.width,
      height: qrboxSize.height
    };
  };
  Html5Qrcode2.prototype.possiblyInsertShadingElement = function(element, width, height, qrboxSize) {
    if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {
      return;
    }
    var shadingElement = document.createElement("div");
    shadingElement.style.position = "absolute";
    var rightLeftBorderSize = (width - qrboxSize.width) / 2;
    var topBottomBorderSize = (height - qrboxSize.height) / 2;
    shadingElement.style.borderLeft = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderRight = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderTop = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderBottom = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.boxSizing = "border-box";
    shadingElement.style.top = "0px";
    shadingElement.style.bottom = "0px";
    shadingElement.style.left = "0px";
    shadingElement.style.right = "0px";
    shadingElement.id = "".concat(Constants.SHADED_REGION_ELEMENT_ID);
    if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {
      this.hasBorderShaders = false;
    } else {
      var smallSize = 5;
      var largeSize = 40;
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);
      this.hasBorderShaders = true;
    }
    element.append(shadingElement);
  };
  Html5Qrcode2.prototype.insertShaderBorders = function(shaderElem, width, height, top, bottom, side, isLeft) {
    var elem = document.createElement("div");
    elem.style.position = "absolute";
    elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;
    elem.style.width = "".concat(width, "px");
    elem.style.height = "".concat(height, "px");
    if (top !== null) {
      elem.style.top = "".concat(top, "px");
    }
    if (bottom !== null) {
      elem.style.bottom = "".concat(bottom, "px");
    }
    if (isLeft) {
      elem.style.left = "".concat(side, "px");
    } else {
      elem.style.right = "".concat(side, "px");
    }
    if (!this.borderShaders) {
      this.borderShaders = [];
    }
    this.borderShaders.push(elem);
    shaderElem.appendChild(elem);
  };
  Html5Qrcode2.prototype.showPausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "block";
  };
  Html5Qrcode2.prototype.hidePausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "none";
  };
  Html5Qrcode2.prototype.getTimeoutFps = function(fps) {
    return 1e3 / fps;
  };
  return Html5Qrcode2;
}();

// node_modules/html5-qrcode/esm/image-assets.js
var SVG_XML_PREFIX = "data:image/svg+xml;base64,";
var ASSET_CAMERA_SCAN = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNzEuNjQzIDM3MS42NDMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM3MS42NDMgMzcxLjY0MyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBhdGggZD0iTTEwNS4wODQgMzguMjcxaDE2My43Njh2MjBIMTA1LjA4NHoiLz48cGF0aCBkPSJNMzExLjU5NiAxOTAuMTg5Yy03LjQ0MS05LjM0Ny0xOC40MDMtMTYuMjA2LTMyLjc0My0yMC41MjJWMzBjMC0xNi41NDItMTMuNDU4LTMwLTMwLTMwSDEyNS4wODRjLTE2LjU0MiAwLTMwIDEzLjQ1OC0zMCAzMHYxMjAuMTQzaC04LjI5NmMtMTYuNTQyIDAtMzAgMTMuNDU4LTMwIDMwdjEuMzMzYTI5LjgwNCAyOS44MDQgMCAwIDAgNC42MDMgMTUuOTM5Yy03LjM0IDUuNDc0LTEyLjEwMyAxNC4yMjEtMTIuMTAzIDI0LjA2MXYxLjMzM2MwIDkuODQgNC43NjMgMTguNTg3IDEyLjEwMyAyNC4wNjJhMjkuODEgMjkuODEgMCAwIDAtNC42MDMgMTUuOTM4djEuMzMzYzAgMTYuNTQyIDEzLjQ1OCAzMCAzMCAzMGg4LjMyNGMuNDI3IDExLjYzMSA3LjUwMyAyMS41ODcgMTcuNTM0IDI2LjE3Ny45MzEgMTAuNTAzIDQuMDg0IDMwLjE4NyAxNC43NjggNDUuNTM3YTkuOTg4IDkuOTg4IDAgMCAwIDguMjE2IDQuMjg4IDkuOTU4IDkuOTU4IDAgMCAwIDUuNzA0LTEuNzkzYzQuNTMzLTMuMTU1IDUuNjUtOS4zODggMi40OTUtMTMuOTIxLTYuNzk4LTkuNzY3LTkuNjAyLTIyLjYwOC0xMC43Ni0zMS40aDgyLjY4NWMuMjcyLjQxNC41NDUuODE4LjgxNSAxLjIxIDMuMTQyIDQuNTQxIDkuMzcyIDUuNjc5IDEzLjkxMyAyLjUzNCA0LjU0Mi0zLjE0MiA1LjY3Ny05LjM3MSAyLjUzNS0xMy45MTMtMTEuOTE5LTE3LjIyOS04Ljc4Ny0zNS44ODQgOS41ODEtNTcuMDEyIDMuMDY3LTIuNjUyIDEyLjMwNy0xMS43MzIgMTEuMjE3LTI0LjAzMy0uODI4LTkuMzQzLTcuMTA5LTE3LjE5NC0xOC42NjktMjMuMzM3YTkuODU3IDkuODU3IDAgMCAwLTEuMDYxLS40ODZjLS40NjYtLjE4Mi0xMS40MDMtNC41NzktOS43NDEtMTUuNzA2IDEuMDA3LTYuNzM3IDE0Ljc2OC04LjI3MyAyMy43NjYtNy42NjYgMjMuMTU2IDEuNTY5IDM5LjY5OCA3LjgwMyA0Ny44MzYgMTguMDI2IDUuNzUyIDcuMjI1IDcuNjA3IDE2LjYyMyA1LjY3MyAyOC43MzMtLjQxMyAyLjU4NS0uODI0IDUuMjQxLTEuMjQ1IDcuOTU5LTUuNzU2IDM3LjE5NC0xMi45MTkgODMuNDgzLTQ5Ljg3IDExNC42NjEtNC4yMjEgMy41NjEtNC43NTYgOS44Ny0xLjE5NCAxNC4wOTJhOS45OCA5Ljk4IDAgMCAwIDcuNjQ4IDMuNTUxIDkuOTU1IDkuOTU1IDAgMCAwIDYuNDQ0LTIuMzU4YzQyLjY3Mi0zNi4wMDUgNTAuODAyLTg4LjUzMyA1Ni43MzctMTI2Ljg4OC40MTUtMi42ODQuODIxLTUuMzA5IDEuMjI5LTcuODYzIDIuODM0LTE3LjcyMS0uNDU1LTMyLjY0MS05Ljc3Mi00NC4zNDV6bS0yMzIuMzA4IDQyLjYyYy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM2MwLTUuNTE0IDQuNDg2LTEwIDEwLTEwaDE1djIxLjMzM2gtMTV6bS0yLjUtNTIuNjY2YzAtNS41MTQgNC40ODYtMTAgMTAtMTBoNy41djIxLjMzM2gtNy41Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM3ptMTcuNSA5My45OTloLTcuNWMtNS41MTQgMC0xMC00LjQ4Ni0xMC0xMHYtMS4zMzNjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGg3LjV2MjEuMzMzem0zMC43OTYgMjguODg3Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi04LjI3MWg5MS40NTdjLS44NTEgNi42NjgtLjQzNyAxMi43ODcuNzMxIDE4LjI3MWgtODIuMTg4em03OS40ODItMTEzLjY5OGMtMy4xMjQgMjAuOTA2IDEyLjQyNyAzMy4xODQgMjEuNjI1IDM3LjA0IDUuNDQxIDIuOTY4IDcuNTUxIDUuNjQ3IDcuNzAxIDcuMTg4LjIxIDIuMTUtMi41NTMgNS42ODQtNC40NzcgNy4yNTEtLjQ4Mi4zNzgtLjkyOS44LTEuMzM1IDEuMjYxLTYuOTg3IDcuOTM2LTExLjk4MiAxNS41Mi0xNS40MzIgMjIuNjg4aC05Ny41NjRWMzBjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGgxMjMuNzY5YzUuNTE0IDAgMTAgNC40ODYgMTAgMTB2MTM1LjU3OWMtMy4wMzItLjM4MS02LjE1LS42OTQtOS4zODktLjkxNC0yNS4xNTktMS42OTQtNDIuMzcgNy43NDgtNDQuODk4IDI0LjY2NnoiLz48cGF0aCBkPSJNMTc5LjEyOSA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXpNMTcyLjYyOSAxNDIuODZoLTEyLjU2VjEzMC44YTUgNSAwIDEgMC0xMCAwdjE3LjA2MWE1IDUgMCAwIDAgNSA1aDE3LjU2YTUgNSAwIDEgMCAwLTEwLjAwMXpNMjE2LjU2OCA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXptLTUgMjQuMDYxaC0xNC4wNlY5My4xNjdoMTQuMDZ2MTQuMDYxek0yMTEuNjY5IDEyNS45MzZIMTk3LjQxYTUgNSAwIDAgMC01IDV2MTQuMjU3YTUgNSAwIDAgMCA1IDVoMTQuMjU5YTUgNSAwIDAgMCA1LTV2LTE0LjI1N2E1IDUgMCAwIDAtNS01eiIvPjwvc3ZnPg==";
var ASSET_FILE_SCAN = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OS4wMTggNTkuMDE4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1OS4wMTggNTkuMDE4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJtNTguNzQxIDU0LjgwOS01Ljk2OS02LjI0NGExMC43NCAxMC43NCAwIDAgMCAyLjgyLTcuMjVjMC01Ljk1My00Ljg0My0xMC43OTYtMTAuNzk2LTEwLjc5NlMzNCAzNS4zNjEgMzQgNDEuMzE0IDM4Ljg0MyA1Mi4xMSA0NC43OTYgNTIuMTFjMi40NDEgMCA0LjY4OC0uODI0IDYuNDk5LTIuMTk2bDYuMDAxIDYuMjc3YS45OTguOTk4IDAgMCAwIDEuNDE0LjAzMiAxIDEgMCAwIDAgLjAzMS0xLjQxNHpNMzYgNDEuMzE0YzAtNC44NSAzLjk0Ni04Ljc5NiA4Ljc5Ni04Ljc5NnM4Ljc5NiAzLjk0NiA4Ljc5NiA4Ljc5Ni0zLjk0NiA4Ljc5Ni04Ljc5NiA4Ljc5NlMzNiA0Ni4xNjQgMzYgNDEuMzE0ek0xMC40MzEgMTYuMDg4YzAgMy4wNyAyLjQ5OCA1LjU2OCA1LjU2OSA1LjU2OHM1LjU2OS0yLjQ5OCA1LjU2OS01LjU2OGMwLTMuMDcxLTIuNDk4LTUuNTY5LTUuNTY5LTUuNTY5cy01LjU2OSAyLjQ5OC01LjU2OSA1LjU2OXptOS4xMzggMGMwIDEuOTY4LTEuNjAyIDMuNTY4LTMuNTY5IDMuNTY4cy0zLjU2OS0xLjYwMS0zLjU2OS0zLjU2OCAxLjYwMi0zLjU2OSAzLjU2OS0zLjU2OSAzLjU2OSAxLjYwMSAzLjU2OSAzLjU2OXoiLz48cGF0aCBkPSJtMzAuODgyIDI4Ljk4NyA5LjE4LTEwLjA1NCAxMS4yNjIgMTAuMzIzYTEgMSAwIDAgMCAxLjM1MS0xLjQ3NWwtMTItMTFhMSAxIDAgMCAwLTEuNDE0LjA2M2wtOS43OTQgMTAuNzI3LTQuNzQzLTQuNzQzYTEuMDAzIDEuMDAzIDAgMCAwLTEuMzY4LS4wNDRMNi4zMzkgMzcuNzY4YTEgMSAwIDEgMCAxLjMyMiAxLjUwMWwxNi4zMTMtMTQuMzYyIDcuMzE5IDcuMzE4YS45OTkuOTk5IDAgMSAwIDEuNDE0LTEuNDE0bC0xLjgyNS0xLjgyNHoiLz48cGF0aCBkPSJNMzAgNDYuNTE4SDJ2LTQyaDU0djI4YTEgMSAwIDEgMCAyIDB2LTI5YTEgMSAwIDAgMC0xLTFIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoMjlhMSAxIDAgMSAwIDAtMnoiLz48L3N2Zz4=";
var ASSET_INFO_ICON_16PX = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NjAgNDYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NjAgNDYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNMjMwIDBDMTAyLjk3NSAwIDAgMTAyLjk3NSAwIDIzMHMxMDIuOTc1IDIzMCAyMzAgMjMwIDIzMC0xMDIuOTc0IDIzMC0yMzBTMzU3LjAyNSAwIDIzMCAwem0zOC4zMzMgMzc3LjM2YzAgOC42NzYtNy4wMzQgMTUuNzEtMTUuNzEgMTUuNzFoLTQzLjEwMWMtOC42NzYgMC0xNS43MS03LjAzNC0xNS43MS0xNS43MVYyMDIuNDc3YzAtOC42NzYgNy4wMzMtMTUuNzEgMTUuNzEtMTUuNzFoNDMuMTAxYzguNjc2IDAgMTUuNzEgNy4wMzMgMTUuNzEgMTUuNzFWMzc3LjM2ek0yMzAgMTU3Yy0yMS41MzkgMC0zOS0xNy40NjEtMzktMzlzMTcuNDYxLTM5IDM5LTM5IDM5IDE3LjQ2MSAzOSAzOS0xNy40NjEgMzktMzkgMzl6Ii8+PC9zdmc+";
var ASSET_CLOSE_ICON_16PX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAQgAAAEIBarqQRAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE1SURBVDiNfdI7S0NBEAXgLya1otFgpbYSbISAgpXYi6CmiH9KCAiChaVga6OiWPgfRDQ+0itaGVNosXtluWwcuMzePfM4M3sq8lbHBubwg1dc4m1E/J/N4ghDPOIsfk/4xiEao5KX0McFljN4C9d4QTPXuY99jP3DsIoDPGM6BY5i5yI5R7O4q+ImFkJY2DCh3cAH2klyB+9J1xUMMAG7eCh1a+Mr+k48b5diXrFVwwLuS+BJ9MfR7+G0FHOHhTHhnXNWS87VDF4pcnfQK4Ep7XScNLmPTZgURNKKYENYWDpzW1BhscS1WHS8CDgURFJQrWcoF3c13KKbgg1BYQfy8xZWEzTTw1QZbAoKu8FqJnktdu5hcVSHmchiILzzuaDQvjBzV2m8yohCE1jHfPx/xhU+y4G/D75ELlRJsSYAAAAASUVORK5CYII=";

// node_modules/html5-qrcode/esm/storage.js
var PersistedDataFactory = function() {
  function PersistedDataFactory2() {
  }
  PersistedDataFactory2.createDefault = function() {
    return {
      hasPermission: false,
      lastUsedCameraId: null
    };
  };
  return PersistedDataFactory2;
}();
var PersistedDataManager = function() {
  function PersistedDataManager2() {
    this.data = PersistedDataFactory.createDefault();
    var data = localStorage.getItem(PersistedDataManager2.LOCAL_STORAGE_KEY);
    if (!data) {
      this.reset();
    } else {
      this.data = JSON.parse(data);
    }
  }
  PersistedDataManager2.prototype.hasCameraPermissions = function() {
    return this.data.hasPermission;
  };
  PersistedDataManager2.prototype.getLastUsedCameraId = function() {
    return this.data.lastUsedCameraId;
  };
  PersistedDataManager2.prototype.setHasPermission = function(hasPermission) {
    this.data.hasPermission = hasPermission;
    this.flush();
  };
  PersistedDataManager2.prototype.setLastUsedCameraId = function(lastUsedCameraId) {
    this.data.lastUsedCameraId = lastUsedCameraId;
    this.flush();
  };
  PersistedDataManager2.prototype.resetLastUsedCameraId = function() {
    this.data.lastUsedCameraId = null;
    this.flush();
  };
  PersistedDataManager2.prototype.reset = function() {
    this.data = PersistedDataFactory.createDefault();
    this.flush();
  };
  PersistedDataManager2.prototype.flush = function() {
    localStorage.setItem(PersistedDataManager2.LOCAL_STORAGE_KEY, JSON.stringify(this.data));
  };
  PersistedDataManager2.LOCAL_STORAGE_KEY = "HTML5_QRCODE_DATA";
  return PersistedDataManager2;
}();

// node_modules/html5-qrcode/esm/ui.js
var LibraryInfoDiv = function() {
  function LibraryInfoDiv2() {
    this.infoDiv = document.createElement("div");
  }
  LibraryInfoDiv2.prototype.renderInto = function(parent) {
    this.infoDiv.style.position = "absolute";
    this.infoDiv.style.top = "10px";
    this.infoDiv.style.right = "10px";
    this.infoDiv.style.zIndex = "2";
    this.infoDiv.style.display = "none";
    this.infoDiv.style.padding = "5pt";
    this.infoDiv.style.border = "1px solid #171717";
    this.infoDiv.style.fontSize = "10pt";
    this.infoDiv.style.background = "rgb(0 0 0 / 69%)";
    this.infoDiv.style.borderRadius = "5px";
    this.infoDiv.style.textAlign = "center";
    this.infoDiv.style.fontWeight = "400";
    this.infoDiv.style.color = "white";
    this.infoDiv.innerText = LibraryInfoStrings.poweredBy();
    var projectLink = document.createElement("a");
    projectLink.innerText = "ScanApp";
    projectLink.href = "https://scanapp.org";
    projectLink.target = "new";
    projectLink.style.color = "white";
    this.infoDiv.appendChild(projectLink);
    var breakElemFirst = document.createElement("br");
    var breakElemSecond = document.createElement("br");
    this.infoDiv.appendChild(breakElemFirst);
    this.infoDiv.appendChild(breakElemSecond);
    var reportIssueLink = document.createElement("a");
    reportIssueLink.innerText = LibraryInfoStrings.reportIssues();
    reportIssueLink.href = "https://github.com/mebjas/html5-qrcode/issues";
    reportIssueLink.target = "new";
    reportIssueLink.style.color = "white";
    this.infoDiv.appendChild(reportIssueLink);
    parent.appendChild(this.infoDiv);
  };
  LibraryInfoDiv2.prototype.show = function() {
    this.infoDiv.style.display = "block";
  };
  LibraryInfoDiv2.prototype.hide = function() {
    this.infoDiv.style.display = "none";
  };
  return LibraryInfoDiv2;
}();
var LibraryInfoIcon = function() {
  function LibraryInfoIcon2(onTapIn, onTapOut) {
    this.isShowingInfoIcon = true;
    this.onTapIn = onTapIn;
    this.onTapOut = onTapOut;
    this.infoIcon = document.createElement("img");
  }
  LibraryInfoIcon2.prototype.renderInto = function(parent) {
    var _this = this;
    this.infoIcon.alt = "Info icon";
    this.infoIcon.src = ASSET_INFO_ICON_16PX;
    this.infoIcon.style.position = "absolute";
    this.infoIcon.style.top = "4px";
    this.infoIcon.style.right = "4px";
    this.infoIcon.style.opacity = "0.6";
    this.infoIcon.style.cursor = "pointer";
    this.infoIcon.style.zIndex = "2";
    this.infoIcon.style.width = "16px";
    this.infoIcon.style.height = "16px";
    this.infoIcon.onmouseover = function(_2) {
      return _this.onHoverIn();
    };
    this.infoIcon.onmouseout = function(_2) {
      return _this.onHoverOut();
    };
    this.infoIcon.onclick = function(_2) {
      return _this.onClick();
    };
    parent.appendChild(this.infoIcon);
  };
  LibraryInfoIcon2.prototype.onHoverIn = function() {
    if (this.isShowingInfoIcon) {
      this.infoIcon.style.opacity = "1";
    }
  };
  LibraryInfoIcon2.prototype.onHoverOut = function() {
    if (this.isShowingInfoIcon) {
      this.infoIcon.style.opacity = "0.6";
    }
  };
  LibraryInfoIcon2.prototype.onClick = function() {
    if (this.isShowingInfoIcon) {
      this.isShowingInfoIcon = false;
      this.onTapIn();
      this.infoIcon.src = ASSET_CLOSE_ICON_16PX;
      this.infoIcon.style.opacity = "1";
    } else {
      this.isShowingInfoIcon = true;
      this.onTapOut();
      this.infoIcon.src = ASSET_INFO_ICON_16PX;
      this.infoIcon.style.opacity = "0.6";
    }
  };
  return LibraryInfoIcon2;
}();
var LibraryInfoContainer = function() {
  function LibraryInfoContainer2() {
    var _this = this;
    this.infoDiv = new LibraryInfoDiv();
    this.infoIcon = new LibraryInfoIcon(function() {
      _this.infoDiv.show();
    }, function() {
      _this.infoDiv.hide();
    });
  }
  LibraryInfoContainer2.prototype.renderInto = function(parent) {
    this.infoDiv.renderInto(parent);
    this.infoIcon.renderInto(parent);
  };
  return LibraryInfoContainer2;
}();

// node_modules/html5-qrcode/esm/camera/permissions.js
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator6 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraPermissions = function() {
  function CameraPermissions2() {
  }
  CameraPermissions2.hasPermissions = function() {
    return __awaiter6(this, void 0, void 0, function() {
      var devices, _i, devices_1, device;
      return __generator6(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 1:
            devices = _a2.sent();
            for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
              device = devices_1[_i];
              if (device.kind === "videoinput" && device.label) {
                return [2, true];
              }
            }
            return [2, false];
        }
      });
    });
  };
  return CameraPermissions2;
}();

// node_modules/html5-qrcode/esm/ui/scanner/scan-type-selector.js
var ScanTypeSelector = function() {
  function ScanTypeSelector2(supportedScanTypes) {
    this.supportedScanTypes = this.validateAndReturnScanTypes(supportedScanTypes);
  }
  ScanTypeSelector2.prototype.getDefaultScanType = function() {
    return this.supportedScanTypes[0];
  };
  ScanTypeSelector2.prototype.hasMoreThanOneScanType = function() {
    return this.supportedScanTypes.length > 1;
  };
  ScanTypeSelector2.prototype.isCameraScanRequired = function() {
    for (var _i = 0, _a2 = this.supportedScanTypes; _i < _a2.length; _i++) {
      var scanType = _a2[_i];
      if (ScanTypeSelector2.isCameraScanType(scanType)) {
        return true;
      }
    }
    return false;
  };
  ScanTypeSelector2.isCameraScanType = function(scanType) {
    return scanType === Html5QrcodeScanType.SCAN_TYPE_CAMERA;
  };
  ScanTypeSelector2.isFileScanType = function(scanType) {
    return scanType === Html5QrcodeScanType.SCAN_TYPE_FILE;
  };
  ScanTypeSelector2.prototype.validateAndReturnScanTypes = function(supportedScanTypes) {
    if (!supportedScanTypes || supportedScanTypes.length === 0) {
      return Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;
    }
    var maxExpectedValues = Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.length;
    if (supportedScanTypes.length > maxExpectedValues) {
      throw "Max ".concat(maxExpectedValues, " values expected for ") + "supportedScanTypes";
    }
    for (var _i = 0, supportedScanTypes_1 = supportedScanTypes; _i < supportedScanTypes_1.length; _i++) {
      var scanType = supportedScanTypes_1[_i];
      if (!Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.includes(scanType)) {
        throw "Unsupported scan type ".concat(scanType);
      }
    }
    return supportedScanTypes;
  };
  return ScanTypeSelector2;
}();

// node_modules/html5-qrcode/esm/ui/scanner/base.js
var PublicUiElementIdAndClasses = function() {
  function PublicUiElementIdAndClasses2() {
  }
  PublicUiElementIdAndClasses2.ALL_ELEMENT_CLASS = "html5-qrcode-element";
  PublicUiElementIdAndClasses2.CAMERA_PERMISSION_BUTTON_ID = "html5-qrcode-button-camera-permission";
  PublicUiElementIdAndClasses2.CAMERA_START_BUTTON_ID = "html5-qrcode-button-camera-start";
  PublicUiElementIdAndClasses2.CAMERA_STOP_BUTTON_ID = "html5-qrcode-button-camera-stop";
  PublicUiElementIdAndClasses2.TORCH_BUTTON_ID = "html5-qrcode-button-torch";
  PublicUiElementIdAndClasses2.CAMERA_SELECTION_SELECT_ID = "html5-qrcode-select-camera";
  PublicUiElementIdAndClasses2.FILE_SELECTION_BUTTON_ID = "html5-qrcode-button-file-selection";
  PublicUiElementIdAndClasses2.ZOOM_SLIDER_ID = "html5-qrcode-input-range-zoom";
  PublicUiElementIdAndClasses2.SCAN_TYPE_CHANGE_ANCHOR_ID = "html5-qrcode-anchor-scan-type-change";
  PublicUiElementIdAndClasses2.TORCH_BUTTON_CLASS_TORCH_ON = "html5-qrcode-button-torch-on";
  PublicUiElementIdAndClasses2.TORCH_BUTTON_CLASS_TORCH_OFF = "html5-qrcode-button-torch-off";
  return PublicUiElementIdAndClasses2;
}();
var BaseUiElementFactory = function() {
  function BaseUiElementFactory2() {
  }
  BaseUiElementFactory2.createElement = function(elementType, elementId) {
    var element = document.createElement(elementType);
    element.id = elementId;
    element.classList.add(PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS);
    if (elementType === "button") {
      element.setAttribute("type", "button");
    }
    return element;
  };
  return BaseUiElementFactory2;
}();

// node_modules/html5-qrcode/esm/ui/scanner/torch-button.js
var __awaiter7 = function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator7 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var TorchController = function() {
  function TorchController2(torchCapability, buttonController, onTorchActionFailureCallback) {
    this.isTorchOn = false;
    this.torchCapability = torchCapability;
    this.buttonController = buttonController;
    this.onTorchActionFailureCallback = onTorchActionFailureCallback;
  }
  TorchController2.prototype.isTorchEnabled = function() {
    return this.isTorchOn;
  };
  TorchController2.prototype.flipState = function() {
    return __awaiter7(this, void 0, void 0, function() {
      var isTorchOnExpected, error_1;
      return __generator7(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            this.buttonController.disable();
            isTorchOnExpected = !this.isTorchOn;
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this.torchCapability.apply(isTorchOnExpected)];
          case 2:
            _a2.sent();
            this.updateUiBasedOnLatestSettings(this.torchCapability.value(), isTorchOnExpected);
            return [3, 4];
          case 3:
            error_1 = _a2.sent();
            this.propagateFailure(isTorchOnExpected, error_1);
            this.buttonController.enable();
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  TorchController2.prototype.updateUiBasedOnLatestSettings = function(isTorchOn, isTorchOnExpected) {
    if (isTorchOn === isTorchOnExpected) {
      this.buttonController.setText(isTorchOnExpected ? Html5QrcodeScannerStrings.torchOffButton() : Html5QrcodeScannerStrings.torchOnButton());
      this.isTorchOn = isTorchOnExpected;
    } else {
      this.propagateFailure(isTorchOnExpected);
    }
    this.buttonController.enable();
  };
  TorchController2.prototype.propagateFailure = function(isTorchOnExpected, error) {
    var errorMessage = isTorchOnExpected ? Html5QrcodeScannerStrings.torchOnFailedMessage() : Html5QrcodeScannerStrings.torchOffFailedMessage();
    if (error) {
      errorMessage += "; Error = " + error;
    }
    this.onTorchActionFailureCallback(errorMessage);
  };
  TorchController2.prototype.reset = function() {
    this.isTorchOn = false;
  };
  return TorchController2;
}();
var TorchButton = function() {
  function TorchButton2(torchCapability, onTorchActionFailureCallback) {
    this.onTorchActionFailureCallback = onTorchActionFailureCallback;
    this.torchButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.TORCH_BUTTON_ID);
    this.torchController = new TorchController(torchCapability, this, onTorchActionFailureCallback);
  }
  TorchButton2.prototype.render = function(parentElement, torchButtonOptions) {
    var _this = this;
    this.torchButton.innerText = Html5QrcodeScannerStrings.torchOnButton();
    this.torchButton.style.display = torchButtonOptions.display;
    this.torchButton.style.marginLeft = torchButtonOptions.marginLeft;
    var $this = this;
    this.torchButton.addEventListener("click", function(_2) {
      return __awaiter7(_this, void 0, void 0, function() {
        return __generator7(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, $this.torchController.flipState()];
            case 1:
              _a2.sent();
              if ($this.torchController.isTorchEnabled()) {
                $this.torchButton.classList.remove(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);
                $this.torchButton.classList.add(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);
              } else {
                $this.torchButton.classList.remove(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);
                $this.torchButton.classList.add(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);
              }
              return [2];
          }
        });
      });
    });
    parentElement.appendChild(this.torchButton);
  };
  TorchButton2.prototype.updateTorchCapability = function(torchCapability) {
    this.torchController = new TorchController(torchCapability, this, this.onTorchActionFailureCallback);
  };
  TorchButton2.prototype.getTorchButton = function() {
    return this.torchButton;
  };
  TorchButton2.prototype.hide = function() {
    this.torchButton.style.display = "none";
  };
  TorchButton2.prototype.show = function() {
    this.torchButton.style.display = "inline-block";
  };
  TorchButton2.prototype.disable = function() {
    this.torchButton.disabled = true;
  };
  TorchButton2.prototype.enable = function() {
    this.torchButton.disabled = false;
  };
  TorchButton2.prototype.setText = function(text) {
    this.torchButton.innerText = text;
  };
  TorchButton2.prototype.reset = function() {
    this.torchButton.innerText = Html5QrcodeScannerStrings.torchOnButton();
    this.torchController.reset();
  };
  TorchButton2.create = function(parentElement, torchCapability, torchButtonOptions, onTorchActionFailureCallback) {
    var button = new TorchButton2(torchCapability, onTorchActionFailureCallback);
    button.render(parentElement, torchButtonOptions);
    return button;
  };
  return TorchButton2;
}();

// node_modules/html5-qrcode/esm/ui/scanner/file-selection-ui.js
var FileSelectionUi = function() {
  function FileSelectionUi2(parentElement, showOnRender, onFileSelected) {
    this.fileBasedScanRegion = this.createFileBasedScanRegion();
    this.fileBasedScanRegion.style.display = showOnRender ? "block" : "none";
    parentElement.appendChild(this.fileBasedScanRegion);
    var fileScanLabel = document.createElement("label");
    fileScanLabel.setAttribute("for", this.getFileScanInputId());
    fileScanLabel.style.display = "inline-block";
    this.fileBasedScanRegion.appendChild(fileScanLabel);
    this.fileSelectionButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID);
    this.setInitialValueToButton();
    this.fileSelectionButton.addEventListener("click", function(_2) {
      fileScanLabel.click();
    });
    fileScanLabel.append(this.fileSelectionButton);
    this.fileScanInput = BaseUiElementFactory.createElement("input", this.getFileScanInputId());
    this.fileScanInput.type = "file";
    this.fileScanInput.accept = "image/*";
    this.fileScanInput.style.display = "none";
    fileScanLabel.appendChild(this.fileScanInput);
    var $this = this;
    this.fileScanInput.addEventListener("change", function(e) {
      if (e == null || e.target == null) {
        return;
      }
      var target = e.target;
      if (target.files && target.files.length === 0) {
        return;
      }
      var fileList = target.files;
      var file = fileList[0];
      var fileName = file.name;
      $this.setImageNameToButton(fileName);
      onFileSelected(file);
    });
    var dragAndDropMessage = this.createDragAndDropMessage();
    this.fileBasedScanRegion.appendChild(dragAndDropMessage);
    this.fileBasedScanRegion.addEventListener("dragenter", function(event) {
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();
      event.stopPropagation();
      event.preventDefault();
    });
    this.fileBasedScanRegion.addEventListener("dragleave", function(event) {
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();
      event.stopPropagation();
      event.preventDefault();
    });
    this.fileBasedScanRegion.addEventListener("dragover", function(event) {
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();
      event.stopPropagation();
      event.preventDefault();
    });
    this.fileBasedScanRegion.addEventListener("drop", function(event) {
      event.stopPropagation();
      event.preventDefault();
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();
      var dataTransfer = event.dataTransfer;
      if (dataTransfer) {
        var files = dataTransfer.files;
        if (!files || files.length === 0) {
          return;
        }
        var isAnyFileImage = false;
        for (var i3 = 0; i3 < files.length; ++i3) {
          var file = files.item(i3);
          if (!file) {
            continue;
          }
          var imageType = /image.*/;
          if (!file.type.match(imageType)) {
            continue;
          }
          isAnyFileImage = true;
          var fileName = file.name;
          $this.setImageNameToButton(fileName);
          onFileSelected(file);
          dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessage();
          break;
        }
        if (!isAnyFileImage) {
          dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages();
        }
      }
    });
  }
  FileSelectionUi2.prototype.hide = function() {
    this.fileBasedScanRegion.style.display = "none";
    this.fileScanInput.disabled = true;
  };
  FileSelectionUi2.prototype.show = function() {
    this.fileBasedScanRegion.style.display = "block";
    this.fileScanInput.disabled = false;
  };
  FileSelectionUi2.prototype.isShowing = function() {
    return this.fileBasedScanRegion.style.display === "block";
  };
  FileSelectionUi2.prototype.resetValue = function() {
    this.fileScanInput.value = "";
    this.setInitialValueToButton();
  };
  FileSelectionUi2.prototype.createFileBasedScanRegion = function() {
    var fileBasedScanRegion = document.createElement("div");
    fileBasedScanRegion.style.textAlign = "center";
    fileBasedScanRegion.style.margin = "auto";
    fileBasedScanRegion.style.width = "80%";
    fileBasedScanRegion.style.maxWidth = "600px";
    fileBasedScanRegion.style.border = this.fileBasedScanRegionDefaultBorder();
    fileBasedScanRegion.style.padding = "10px";
    fileBasedScanRegion.style.marginBottom = "10px";
    return fileBasedScanRegion;
  };
  FileSelectionUi2.prototype.fileBasedScanRegionDefaultBorder = function() {
    return "6px dashed #ebebeb";
  };
  FileSelectionUi2.prototype.fileBasedScanRegionActiveBorder = function() {
    return "6px dashed rgb(153 151 151)";
  };
  FileSelectionUi2.prototype.createDragAndDropMessage = function() {
    var dragAndDropMessage = document.createElement("div");
    dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessage();
    dragAndDropMessage.style.fontWeight = "400";
    return dragAndDropMessage;
  };
  FileSelectionUi2.prototype.setImageNameToButton = function(imageFileName) {
    var MAX_CHARS = 20;
    if (imageFileName.length > MAX_CHARS) {
      var start8Chars = imageFileName.substring(0, 8);
      var length_1 = imageFileName.length;
      var last8Chars = imageFileName.substring(length_1 - 8, length_1);
      imageFileName = "".concat(start8Chars, "....").concat(last8Chars);
    }
    var newText = Html5QrcodeScannerStrings.fileSelectionChooseAnother() + " - " + imageFileName;
    this.fileSelectionButton.innerText = newText;
  };
  FileSelectionUi2.prototype.setInitialValueToButton = function() {
    var initialText = Html5QrcodeScannerStrings.fileSelectionChooseImage() + " - " + Html5QrcodeScannerStrings.fileSelectionNoImageSelected();
    this.fileSelectionButton.innerText = initialText;
  };
  FileSelectionUi2.prototype.getFileScanInputId = function() {
    return "html5-qrcode-private-filescan-input";
  };
  FileSelectionUi2.create = function(parentElement, showOnRender, onFileSelected) {
    var button = new FileSelectionUi2(parentElement, showOnRender, onFileSelected);
    return button;
  };
  return FileSelectionUi2;
}();

// node_modules/html5-qrcode/esm/ui/scanner/camera-selection-ui.js
var CameraSelectionUi = function() {
  function CameraSelectionUi2(cameras) {
    this.selectElement = BaseUiElementFactory.createElement("select", PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID);
    this.cameras = cameras;
    this.options = [];
  }
  CameraSelectionUi2.prototype.render = function(parentElement) {
    var cameraSelectionContainer = document.createElement("span");
    cameraSelectionContainer.style.marginRight = "10px";
    var numCameras = this.cameras.length;
    if (numCameras === 0) {
      throw new Error("No cameras found");
    }
    if (numCameras === 1) {
      cameraSelectionContainer.style.display = "none";
    } else {
      var selectCameraString = Html5QrcodeScannerStrings.selectCamera();
      cameraSelectionContainer.innerText = "".concat(selectCameraString, " (").concat(this.cameras.length, ")  ");
    }
    var anonymousCameraId = 1;
    for (var _i = 0, _a2 = this.cameras; _i < _a2.length; _i++) {
      var camera = _a2[_i];
      var value2 = camera.id;
      var name_1 = camera.label == null ? value2 : camera.label;
      if (!name_1 || name_1 === "") {
        name_1 = [
          Html5QrcodeScannerStrings.anonymousCameraPrefix(),
          anonymousCameraId++
        ].join(" ");
      }
      var option = document.createElement("option");
      option.value = value2;
      option.innerText = name_1;
      this.options.push(option);
      this.selectElement.appendChild(option);
    }
    cameraSelectionContainer.appendChild(this.selectElement);
    parentElement.appendChild(cameraSelectionContainer);
  };
  CameraSelectionUi2.prototype.disable = function() {
    this.selectElement.disabled = true;
  };
  CameraSelectionUi2.prototype.isDisabled = function() {
    return this.selectElement.disabled === true;
  };
  CameraSelectionUi2.prototype.enable = function() {
    this.selectElement.disabled = false;
  };
  CameraSelectionUi2.prototype.getValue = function() {
    return this.selectElement.value;
  };
  CameraSelectionUi2.prototype.hasValue = function(value2) {
    for (var _i = 0, _a2 = this.options; _i < _a2.length; _i++) {
      var option = _a2[_i];
      if (option.value === value2) {
        return true;
      }
    }
    return false;
  };
  CameraSelectionUi2.prototype.setValue = function(value2) {
    if (!this.hasValue(value2)) {
      throw new Error("".concat(value2, " is not present in the camera list."));
    }
    this.selectElement.value = value2;
  };
  CameraSelectionUi2.prototype.hasSingleItem = function() {
    return this.cameras.length === 1;
  };
  CameraSelectionUi2.prototype.numCameras = function() {
    return this.cameras.length;
  };
  CameraSelectionUi2.create = function(parentElement, cameras) {
    var cameraSelectUi = new CameraSelectionUi2(cameras);
    cameraSelectUi.render(parentElement);
    return cameraSelectUi;
  };
  return CameraSelectionUi2;
}();

// node_modules/html5-qrcode/esm/ui/scanner/camera-zoom-ui.js
var CameraZoomUi = function() {
  function CameraZoomUi2() {
    this.onChangeCallback = null;
    this.zoomElementContainer = document.createElement("div");
    this.rangeInput = BaseUiElementFactory.createElement("input", PublicUiElementIdAndClasses.ZOOM_SLIDER_ID);
    this.rangeInput.type = "range";
    this.rangeText = document.createElement("span");
    this.rangeInput.min = "1";
    this.rangeInput.max = "5";
    this.rangeInput.value = "1";
    this.rangeInput.step = "0.1";
  }
  CameraZoomUi2.prototype.render = function(parentElement, renderOnCreate) {
    this.zoomElementContainer.style.display = renderOnCreate ? "block" : "none";
    this.zoomElementContainer.style.padding = "5px 10px";
    this.zoomElementContainer.style.textAlign = "center";
    parentElement.appendChild(this.zoomElementContainer);
    this.rangeInput.style.display = "inline-block";
    this.rangeInput.style.width = "50%";
    this.rangeInput.style.height = "5px";
    this.rangeInput.style.background = "#d3d3d3";
    this.rangeInput.style.outline = "none";
    this.rangeInput.style.opacity = "0.7";
    var zoomString = Html5QrcodeScannerStrings.zoom();
    this.rangeText.innerText = "".concat(this.rangeInput.value, "x ").concat(zoomString);
    this.rangeText.style.marginRight = "10px";
    var $this = this;
    this.rangeInput.addEventListener("input", function() {
      return $this.onValueChange();
    });
    this.rangeInput.addEventListener("change", function() {
      return $this.onValueChange();
    });
    this.zoomElementContainer.appendChild(this.rangeInput);
    this.zoomElementContainer.appendChild(this.rangeText);
  };
  CameraZoomUi2.prototype.onValueChange = function() {
    var zoomString = Html5QrcodeScannerStrings.zoom();
    this.rangeText.innerText = "".concat(this.rangeInput.value, "x ").concat(zoomString);
    if (this.onChangeCallback) {
      this.onChangeCallback(parseFloat(this.rangeInput.value));
    }
  };
  CameraZoomUi2.prototype.setValues = function(minValue, maxValue, defaultValue, step) {
    this.rangeInput.min = minValue.toString();
    this.rangeInput.max = maxValue.toString();
    this.rangeInput.step = step.toString();
    this.rangeInput.value = defaultValue.toString();
    this.onValueChange();
  };
  CameraZoomUi2.prototype.show = function() {
    this.zoomElementContainer.style.display = "block";
  };
  CameraZoomUi2.prototype.hide = function() {
    this.zoomElementContainer.style.display = "none";
  };
  CameraZoomUi2.prototype.setOnCameraZoomValueChangeCallback = function(onChangeCallback) {
    this.onChangeCallback = onChangeCallback;
  };
  CameraZoomUi2.prototype.removeOnCameraZoomValueChangeCallback = function() {
    this.onChangeCallback = null;
  };
  CameraZoomUi2.create = function(parentElement, renderOnCreate) {
    var cameraZoomUi = new CameraZoomUi2();
    cameraZoomUi.render(parentElement, renderOnCreate);
    return cameraZoomUi;
  };
  return CameraZoomUi2;
}();

// node_modules/html5-qrcode/esm/html5-qrcode-scanner.js
var Html5QrcodeScannerStatus;
(function(Html5QrcodeScannerStatus2) {
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_DEFAULT"] = 0] = "STATUS_DEFAULT";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_SUCCESS"] = 1] = "STATUS_SUCCESS";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_WARNING"] = 2] = "STATUS_WARNING";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_REQUESTING_PERMISSION"] = 3] = "STATUS_REQUESTING_PERMISSION";
})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));
function toHtml5QrcodeCameraScanConfig(config) {
  return {
    fps: config.fps,
    qrbox: config.qrbox,
    aspectRatio: config.aspectRatio,
    disableFlip: config.disableFlip,
    videoConstraints: config.videoConstraints
  };
}
function toHtml5QrcodeFullConfig(config, verbose) {
  return {
    formatsToSupport: config.formatsToSupport,
    useBarCodeDetectorIfSupported: config.useBarCodeDetectorIfSupported,
    experimentalFeatures: config.experimentalFeatures,
    verbose
  };
}
var Html5QrcodeScanner = function() {
  function Html5QrcodeScanner2(elementId, config, verbose) {
    this.lastMatchFound = null;
    this.cameraScanImage = null;
    this.fileScanImage = null;
    this.fileSelectionUi = null;
    this.elementId = elementId;
    this.config = this.createConfig(config);
    this.verbose = verbose === true;
    if (!document.getElementById(elementId)) {
      throw "HTML Element with id=".concat(elementId, " not found");
    }
    this.scanTypeSelector = new ScanTypeSelector(this.config.supportedScanTypes);
    this.currentScanType = this.scanTypeSelector.getDefaultScanType();
    this.sectionSwapAllowed = true;
    this.logger = new BaseLoggger(this.verbose);
    this.persistedDataManager = new PersistedDataManager();
    if (config.rememberLastUsedCamera !== true) {
      this.persistedDataManager.reset();
    }
  }
  Html5QrcodeScanner2.prototype.render = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    this.lastMatchFound = null;
    this.qrCodeSuccessCallback = function(decodedText, result) {
      if (qrCodeSuccessCallback) {
        qrCodeSuccessCallback(decodedText, result);
      } else {
        if (_this.lastMatchFound === decodedText) {
          return;
        }
        _this.lastMatchFound = decodedText;
        _this.setHeaderMessage(Html5QrcodeScannerStrings.lastMatch(decodedText), Html5QrcodeScannerStatus.STATUS_SUCCESS);
      }
    };
    this.qrCodeErrorCallback = function(errorMessage, error) {
      if (qrCodeErrorCallback) {
        qrCodeErrorCallback(errorMessage, error);
      }
    };
    var container = document.getElementById(this.elementId);
    if (!container) {
      throw "HTML Element with id=".concat(this.elementId, " not found");
    }
    container.innerHTML = "";
    this.createBasicLayout(container);
    this.html5Qrcode = new Html5Qrcode(this.getScanRegionId(), toHtml5QrcodeFullConfig(this.config, this.verbose));
  };
  Html5QrcodeScanner2.prototype.pause = function(shouldPauseVideo) {
    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
      shouldPauseVideo = false;
    }
    this.getHtml5QrcodeOrFail().pause(shouldPauseVideo);
  };
  Html5QrcodeScanner2.prototype.resume = function() {
    this.getHtml5QrcodeOrFail().resume();
  };
  Html5QrcodeScanner2.prototype.getState = function() {
    return this.getHtml5QrcodeOrFail().getState();
  };
  Html5QrcodeScanner2.prototype.clear = function() {
    var _this = this;
    var emptyHtmlContainer = function() {
      var mainContainer = document.getElementById(_this.elementId);
      if (mainContainer) {
        mainContainer.innerHTML = "";
        _this.resetBasicLayout(mainContainer);
      }
    };
    if (this.html5Qrcode) {
      return new Promise(function(resolve, reject) {
        if (!_this.html5Qrcode) {
          resolve();
          return;
        }
        if (_this.html5Qrcode.isScanning) {
          _this.html5Qrcode.stop().then(function(_2) {
            if (!_this.html5Qrcode) {
              resolve();
              return;
            }
            _this.html5Qrcode.clear();
            emptyHtmlContainer();
            resolve();
          }).catch(function(error) {
            if (_this.verbose) {
              _this.logger.logError("Unable to stop qrcode scanner", error);
            }
            reject(error);
          });
        } else {
          _this.html5Qrcode.clear();
          emptyHtmlContainer();
          resolve();
        }
      });
    }
    return Promise.resolve();
  };
  Html5QrcodeScanner2.prototype.getRunningTrackCapabilities = function() {
    return this.getHtml5QrcodeOrFail().getRunningTrackCapabilities();
  };
  Html5QrcodeScanner2.prototype.getRunningTrackSettings = function() {
    return this.getHtml5QrcodeOrFail().getRunningTrackSettings();
  };
  Html5QrcodeScanner2.prototype.applyVideoConstraints = function(videoConstaints) {
    return this.getHtml5QrcodeOrFail().applyVideoConstraints(videoConstaints);
  };
  Html5QrcodeScanner2.prototype.getHtml5QrcodeOrFail = function() {
    if (!this.html5Qrcode) {
      throw "Code scanner not initialized.";
    }
    return this.html5Qrcode;
  };
  Html5QrcodeScanner2.prototype.createConfig = function(config) {
    if (config) {
      if (!config.fps) {
        config.fps = Html5QrcodeConstants.SCAN_DEFAULT_FPS;
      }
      if (config.rememberLastUsedCamera !== !Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED) {
        config.rememberLastUsedCamera = Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED;
      }
      if (!config.supportedScanTypes) {
        config.supportedScanTypes = Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;
      }
      return config;
    }
    return {
      fps: Html5QrcodeConstants.SCAN_DEFAULT_FPS,
      rememberLastUsedCamera: Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED,
      supportedScanTypes: Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE
    };
  };
  Html5QrcodeScanner2.prototype.createBasicLayout = function(parent) {
    parent.style.position = "relative";
    parent.style.padding = "0px";
    parent.style.border = "1px solid silver";
    this.createHeader(parent);
    var qrCodeScanRegion = document.createElement("div");
    var scanRegionId = this.getScanRegionId();
    qrCodeScanRegion.id = scanRegionId;
    qrCodeScanRegion.style.width = "100%";
    qrCodeScanRegion.style.minHeight = "100px";
    qrCodeScanRegion.style.textAlign = "center";
    parent.appendChild(qrCodeScanRegion);
    if (ScanTypeSelector.isCameraScanType(this.currentScanType)) {
      this.insertCameraScanImageToScanRegion();
    } else {
      this.insertFileScanImageToScanRegion();
    }
    var qrCodeDashboard = document.createElement("div");
    var dashboardId = this.getDashboardId();
    qrCodeDashboard.id = dashboardId;
    qrCodeDashboard.style.width = "100%";
    parent.appendChild(qrCodeDashboard);
    this.setupInitialDashboard(qrCodeDashboard);
  };
  Html5QrcodeScanner2.prototype.resetBasicLayout = function(mainContainer) {
    mainContainer.style.border = "none";
  };
  Html5QrcodeScanner2.prototype.setupInitialDashboard = function(dashboard) {
    this.createSection(dashboard);
    this.createSectionControlPanel();
    if (this.scanTypeSelector.hasMoreThanOneScanType()) {
      this.createSectionSwap();
    }
  };
  Html5QrcodeScanner2.prototype.createHeader = function(dashboard) {
    var header = document.createElement("div");
    header.style.textAlign = "left";
    header.style.margin = "0px";
    dashboard.appendChild(header);
    var libraryInfo = new LibraryInfoContainer();
    libraryInfo.renderInto(header);
    var headerMessageContainer = document.createElement("div");
    headerMessageContainer.id = this.getHeaderMessageContainerId();
    headerMessageContainer.style.display = "none";
    headerMessageContainer.style.textAlign = "center";
    headerMessageContainer.style.fontSize = "14px";
    headerMessageContainer.style.padding = "2px 10px";
    headerMessageContainer.style.margin = "4px";
    headerMessageContainer.style.borderTop = "1px solid #f6f6f6";
    header.appendChild(headerMessageContainer);
  };
  Html5QrcodeScanner2.prototype.createSection = function(dashboard) {
    var section = document.createElement("div");
    section.id = this.getDashboardSectionId();
    section.style.width = "100%";
    section.style.padding = "10px 0px 10px 0px";
    section.style.textAlign = "left";
    dashboard.appendChild(section);
  };
  Html5QrcodeScanner2.prototype.createCameraListUi = function(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton) {
    var $this = this;
    $this.showHideScanTypeSwapLink(false);
    $this.setHeaderMessage(Html5QrcodeScannerStrings.cameraPermissionRequesting());
    var createPermissionButtonIfNotExists = function() {
      if (!requestPermissionButton) {
        $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
      }
    };
    Html5Qrcode.getCameras().then(function(cameras) {
      $this.persistedDataManager.setHasPermission(true);
      $this.showHideScanTypeSwapLink(true);
      $this.resetHeaderMessage();
      if (cameras && cameras.length > 0) {
        scpCameraScanRegion.removeChild(requestPermissionContainer);
        $this.renderCameraSelection(cameras);
      } else {
        $this.setHeaderMessage(Html5QrcodeScannerStrings.noCameraFound(), Html5QrcodeScannerStatus.STATUS_WARNING);
        createPermissionButtonIfNotExists();
      }
    }).catch(function(error) {
      $this.persistedDataManager.setHasPermission(false);
      if (requestPermissionButton) {
        requestPermissionButton.disabled = false;
      } else {
        createPermissionButtonIfNotExists();
      }
      $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
      $this.showHideScanTypeSwapLink(true);
    });
  };
  Html5QrcodeScanner2.prototype.createPermissionButton = function(scpCameraScanRegion, requestPermissionContainer) {
    var $this = this;
    var requestPermissionButton = BaseUiElementFactory.createElement("button", this.getCameraPermissionButtonId());
    requestPermissionButton.innerText = Html5QrcodeScannerStrings.cameraPermissionTitle();
    requestPermissionButton.addEventListener("click", function() {
      requestPermissionButton.disabled = true;
      $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton);
    });
    requestPermissionContainer.appendChild(requestPermissionButton);
  };
  Html5QrcodeScanner2.prototype.createPermissionsUi = function(scpCameraScanRegion, requestPermissionContainer) {
    var $this = this;
    if (ScanTypeSelector.isCameraScanType(this.currentScanType) && this.persistedDataManager.hasCameraPermissions()) {
      CameraPermissions.hasPermissions().then(function(hasPermissions) {
        if (hasPermissions) {
          $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer);
        } else {
          $this.persistedDataManager.setHasPermission(false);
          $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
        }
      }).catch(function(_2) {
        $this.persistedDataManager.setHasPermission(false);
        $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
      });
      return;
    }
    this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
  };
  Html5QrcodeScanner2.prototype.createSectionControlPanel = function() {
    var section = document.getElementById(this.getDashboardSectionId());
    var sectionControlPanel = document.createElement("div");
    section.appendChild(sectionControlPanel);
    var scpCameraScanRegion = document.createElement("div");
    scpCameraScanRegion.id = this.getDashboardSectionCameraScanRegionId();
    scpCameraScanRegion.style.display = ScanTypeSelector.isCameraScanType(this.currentScanType) ? "block" : "none";
    sectionControlPanel.appendChild(scpCameraScanRegion);
    var requestPermissionContainer = document.createElement("div");
    requestPermissionContainer.style.textAlign = "center";
    scpCameraScanRegion.appendChild(requestPermissionContainer);
    if (this.scanTypeSelector.isCameraScanRequired()) {
      this.createPermissionsUi(scpCameraScanRegion, requestPermissionContainer);
    }
    this.renderFileScanUi(sectionControlPanel);
  };
  Html5QrcodeScanner2.prototype.renderFileScanUi = function(parent) {
    var showOnRender = ScanTypeSelector.isFileScanType(this.currentScanType);
    var $this = this;
    var onFileSelected = function(file) {
      if (!$this.html5Qrcode) {
        throw "html5Qrcode not defined";
      }
      if (!ScanTypeSelector.isFileScanType($this.currentScanType)) {
        return;
      }
      $this.setHeaderMessage(Html5QrcodeScannerStrings.loadingImage());
      $this.html5Qrcode.scanFileV2(file, true).then(function(html5qrcodeResult) {
        $this.resetHeaderMessage();
        $this.qrCodeSuccessCallback(html5qrcodeResult.decodedText, html5qrcodeResult);
      }).catch(function(error) {
        $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
        $this.qrCodeErrorCallback(error, Html5QrcodeErrorFactory.createFrom(error));
      });
    };
    this.fileSelectionUi = FileSelectionUi.create(parent, showOnRender, onFileSelected);
  };
  Html5QrcodeScanner2.prototype.renderCameraSelection = function(cameras) {
    var _this = this;
    var $this = this;
    var scpCameraScanRegion = document.getElementById(this.getDashboardSectionCameraScanRegionId());
    scpCameraScanRegion.style.textAlign = "center";
    var cameraZoomUi = CameraZoomUi.create(scpCameraScanRegion, false);
    var renderCameraZoomUiIfSupported = function(cameraCapabilities) {
      var zoomCapability = cameraCapabilities.zoomFeature();
      if (!zoomCapability.isSupported()) {
        return;
      }
      cameraZoomUi.setOnCameraZoomValueChangeCallback(function(zoomValue) {
        zoomCapability.apply(zoomValue);
      });
      var defaultZoom = 1;
      if (_this.config.defaultZoomValueIfSupported) {
        defaultZoom = _this.config.defaultZoomValueIfSupported;
      }
      defaultZoom = clip(defaultZoom, zoomCapability.min(), zoomCapability.max());
      cameraZoomUi.setValues(zoomCapability.min(), zoomCapability.max(), defaultZoom, zoomCapability.step());
      cameraZoomUi.show();
    };
    var cameraSelectUi = CameraSelectionUi.create(scpCameraScanRegion, cameras);
    var cameraActionContainer = document.createElement("span");
    var cameraActionStartButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID);
    cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonStartScanningText();
    cameraActionContainer.appendChild(cameraActionStartButton);
    var cameraActionStopButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID);
    cameraActionStopButton.innerText = Html5QrcodeScannerStrings.scanButtonStopScanningText();
    cameraActionStopButton.style.display = "none";
    cameraActionStopButton.disabled = true;
    cameraActionContainer.appendChild(cameraActionStopButton);
    var torchButton;
    var createAndShowTorchButtonIfSupported = function(cameraCapabilities) {
      if (!cameraCapabilities.torchFeature().isSupported()) {
        if (torchButton) {
          torchButton.hide();
        }
        return;
      }
      if (!torchButton) {
        torchButton = TorchButton.create(cameraActionContainer, cameraCapabilities.torchFeature(), { display: "none", marginLeft: "5px" }, function(errorMessage) {
          $this.setHeaderMessage(errorMessage, Html5QrcodeScannerStatus.STATUS_WARNING);
        });
      } else {
        torchButton.updateTorchCapability(cameraCapabilities.torchFeature());
      }
      torchButton.show();
    };
    scpCameraScanRegion.appendChild(cameraActionContainer);
    var resetCameraActionStartButton = function(shouldShow) {
      if (!shouldShow) {
        cameraActionStartButton.style.display = "none";
      }
      cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonStartScanningText();
      cameraActionStartButton.style.opacity = "1";
      cameraActionStartButton.disabled = false;
      if (shouldShow) {
        cameraActionStartButton.style.display = "inline-block";
      }
    };
    cameraActionStartButton.addEventListener("click", function(_2) {
      cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonScanningStarting();
      cameraSelectUi.disable();
      cameraActionStartButton.disabled = true;
      cameraActionStartButton.style.opacity = "0.5";
      if (_this.scanTypeSelector.hasMoreThanOneScanType()) {
        $this.showHideScanTypeSwapLink(false);
      }
      $this.resetHeaderMessage();
      var cameraId2 = cameraSelectUi.getValue();
      $this.persistedDataManager.setLastUsedCameraId(cameraId2);
      $this.html5Qrcode.start(cameraId2, toHtml5QrcodeCameraScanConfig($this.config), $this.qrCodeSuccessCallback, $this.qrCodeErrorCallback).then(function(_3) {
        cameraActionStopButton.disabled = false;
        cameraActionStopButton.style.display = "inline-block";
        resetCameraActionStartButton(false);
        var cameraCapabilities = $this.html5Qrcode.getRunningTrackCameraCapabilities();
        if (_this.config.showTorchButtonIfSupported === true) {
          createAndShowTorchButtonIfSupported(cameraCapabilities);
        }
        if (_this.config.showZoomSliderIfSupported === true) {
          renderCameraZoomUiIfSupported(cameraCapabilities);
        }
      }).catch(function(error) {
        $this.showHideScanTypeSwapLink(true);
        cameraSelectUi.enable();
        resetCameraActionStartButton(true);
        $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
      });
    });
    if (cameraSelectUi.hasSingleItem()) {
      cameraActionStartButton.click();
    }
    cameraActionStopButton.addEventListener("click", function(_2) {
      if (!$this.html5Qrcode) {
        throw "html5Qrcode not defined";
      }
      cameraActionStopButton.disabled = true;
      $this.html5Qrcode.stop().then(function(_3) {
        if (_this.scanTypeSelector.hasMoreThanOneScanType()) {
          $this.showHideScanTypeSwapLink(true);
        }
        cameraSelectUi.enable();
        cameraActionStartButton.disabled = false;
        cameraActionStopButton.style.display = "none";
        cameraActionStartButton.style.display = "inline-block";
        if (torchButton) {
          torchButton.reset();
          torchButton.hide();
        }
        cameraZoomUi.removeOnCameraZoomValueChangeCallback();
        cameraZoomUi.hide();
        $this.insertCameraScanImageToScanRegion();
      }).catch(function(error) {
        cameraActionStopButton.disabled = false;
        $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
      });
    });
    if ($this.persistedDataManager.getLastUsedCameraId()) {
      var cameraId = $this.persistedDataManager.getLastUsedCameraId();
      if (cameraSelectUi.hasValue(cameraId)) {
        cameraSelectUi.setValue(cameraId);
        cameraActionStartButton.click();
      } else {
        $this.persistedDataManager.resetLastUsedCameraId();
      }
    }
  };
  Html5QrcodeScanner2.prototype.createSectionSwap = function() {
    var $this = this;
    var TEXT_IF_CAMERA_SCAN_SELECTED = Html5QrcodeScannerStrings.textIfCameraScanSelected();
    var TEXT_IF_FILE_SCAN_SELECTED = Html5QrcodeScannerStrings.textIfFileScanSelected();
    var section = document.getElementById(this.getDashboardSectionId());
    var switchContainer = document.createElement("div");
    switchContainer.style.textAlign = "center";
    var switchScanTypeLink = BaseUiElementFactory.createElement("span", this.getDashboardSectionSwapLinkId());
    switchScanTypeLink.style.textDecoration = "underline";
    switchScanTypeLink.style.cursor = "pointer";
    switchScanTypeLink.innerText = ScanTypeSelector.isCameraScanType(this.currentScanType) ? TEXT_IF_CAMERA_SCAN_SELECTED : TEXT_IF_FILE_SCAN_SELECTED;
    switchScanTypeLink.addEventListener("click", function() {
      if (!$this.sectionSwapAllowed) {
        if ($this.verbose) {
          $this.logger.logError("Section swap called when not allowed");
        }
        return;
      }
      $this.resetHeaderMessage();
      $this.fileSelectionUi.resetValue();
      $this.sectionSwapAllowed = false;
      if (ScanTypeSelector.isCameraScanType($this.currentScanType)) {
        $this.clearScanRegion();
        $this.getCameraScanRegion().style.display = "none";
        $this.fileSelectionUi.show();
        switchScanTypeLink.innerText = TEXT_IF_FILE_SCAN_SELECTED;
        $this.currentScanType = Html5QrcodeScanType.SCAN_TYPE_FILE;
        $this.insertFileScanImageToScanRegion();
      } else {
        $this.clearScanRegion();
        $this.getCameraScanRegion().style.display = "block";
        $this.fileSelectionUi.hide();
        switchScanTypeLink.innerText = TEXT_IF_CAMERA_SCAN_SELECTED;
        $this.currentScanType = Html5QrcodeScanType.SCAN_TYPE_CAMERA;
        $this.insertCameraScanImageToScanRegion();
        $this.startCameraScanIfPermissionExistsOnSwap();
      }
      $this.sectionSwapAllowed = true;
    });
    switchContainer.appendChild(switchScanTypeLink);
    section.appendChild(switchContainer);
  };
  Html5QrcodeScanner2.prototype.startCameraScanIfPermissionExistsOnSwap = function() {
    var _this = this;
    var $this = this;
    if (this.persistedDataManager.hasCameraPermissions()) {
      CameraPermissions.hasPermissions().then(function(hasPermissions) {
        if (hasPermissions) {
          var permissionButton = document.getElementById($this.getCameraPermissionButtonId());
          if (!permissionButton) {
            _this.logger.logError("Permission button not found, fail;");
            throw "Permission button not found";
          }
          permissionButton.click();
        } else {
          $this.persistedDataManager.setHasPermission(false);
        }
      }).catch(function(_2) {
        $this.persistedDataManager.setHasPermission(false);
      });
      return;
    }
  };
  Html5QrcodeScanner2.prototype.resetHeaderMessage = function() {
    var messageDiv = document.getElementById(this.getHeaderMessageContainerId());
    messageDiv.style.display = "none";
  };
  Html5QrcodeScanner2.prototype.setHeaderMessage = function(messageText, scannerStatus) {
    if (!scannerStatus) {
      scannerStatus = Html5QrcodeScannerStatus.STATUS_DEFAULT;
    }
    var messageDiv = this.getHeaderMessageDiv();
    messageDiv.innerText = messageText;
    messageDiv.style.display = "block";
    switch (scannerStatus) {
      case Html5QrcodeScannerStatus.STATUS_SUCCESS:
        messageDiv.style.background = "rgba(106, 175, 80, 0.26)";
        messageDiv.style.color = "#477735";
        break;
      case Html5QrcodeScannerStatus.STATUS_WARNING:
        messageDiv.style.background = "rgba(203, 36, 49, 0.14)";
        messageDiv.style.color = "#cb2431";
        break;
      case Html5QrcodeScannerStatus.STATUS_DEFAULT:
      default:
        messageDiv.style.background = "rgba(0, 0, 0, 0)";
        messageDiv.style.color = "rgb(17, 17, 17)";
        break;
    }
  };
  Html5QrcodeScanner2.prototype.showHideScanTypeSwapLink = function(shouldDisplay) {
    if (this.scanTypeSelector.hasMoreThanOneScanType()) {
      if (shouldDisplay !== true) {
        shouldDisplay = false;
      }
      this.sectionSwapAllowed = shouldDisplay;
      this.getDashboardSectionSwapLink().style.display = shouldDisplay ? "inline-block" : "none";
    }
  };
  Html5QrcodeScanner2.prototype.insertCameraScanImageToScanRegion = function() {
    var $this = this;
    var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
    if (this.cameraScanImage) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild(this.cameraScanImage);
      return;
    }
    this.cameraScanImage = new Image();
    this.cameraScanImage.onload = function(_2) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild($this.cameraScanImage);
    };
    this.cameraScanImage.width = 64;
    this.cameraScanImage.style.opacity = "0.8";
    this.cameraScanImage.src = ASSET_CAMERA_SCAN;
    this.cameraScanImage.alt = Html5QrcodeScannerStrings.cameraScanAltText();
  };
  Html5QrcodeScanner2.prototype.insertFileScanImageToScanRegion = function() {
    var $this = this;
    var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
    if (this.fileScanImage) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild(this.fileScanImage);
      return;
    }
    this.fileScanImage = new Image();
    this.fileScanImage.onload = function(_2) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild($this.fileScanImage);
    };
    this.fileScanImage.width = 64;
    this.fileScanImage.style.opacity = "0.8";
    this.fileScanImage.src = ASSET_FILE_SCAN;
    this.fileScanImage.alt = Html5QrcodeScannerStrings.fileScanAltText();
  };
  Html5QrcodeScanner2.prototype.clearScanRegion = function() {
    var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
    qrCodeScanRegion.innerHTML = "";
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionId = function() {
    return "".concat(this.elementId, "__dashboard_section");
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionCameraScanRegionId = function() {
    return "".concat(this.elementId, "__dashboard_section_csr");
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionSwapLinkId = function() {
    return PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID;
  };
  Html5QrcodeScanner2.prototype.getScanRegionId = function() {
    return "".concat(this.elementId, "__scan_region");
  };
  Html5QrcodeScanner2.prototype.getDashboardId = function() {
    return "".concat(this.elementId, "__dashboard");
  };
  Html5QrcodeScanner2.prototype.getHeaderMessageContainerId = function() {
    return "".concat(this.elementId, "__header_message");
  };
  Html5QrcodeScanner2.prototype.getCameraPermissionButtonId = function() {
    return PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID;
  };
  Html5QrcodeScanner2.prototype.getCameraScanRegion = function() {
    return document.getElementById(this.getDashboardSectionCameraScanRegionId());
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionSwapLink = function() {
    return document.getElementById(this.getDashboardSectionSwapLinkId());
  };
  Html5QrcodeScanner2.prototype.getHeaderMessageDiv = function() {
    return document.getElementById(this.getHeaderMessageContainerId());
  };
  return Html5QrcodeScanner2;
}();

// src/app/modules/dashboard/services/inventory-check/inventory-check.service.ts
var _InventoryCheckService = class _InventoryCheckService {
  constructor() {
    this.inventoriesCheck = [];
    this.inventoriesCheck$ = new Subject();
  }
  onListener() {
    return this.inventoriesCheck$.asObservable();
  }
  assign(item) {
    this.inventoriesCheck = item;
    this.inventoriesCheck$.next(this.inventoriesCheck.slice());
  }
  getAll() {
    return this.inventoriesCheck.slice();
  }
  getByInventoryId(id) {
    return this.inventoriesCheck.find((item) => item.Inventory.id === id);
  }
  getTableData() {
    return this.inventoriesCheck.map((item, i3) => ({
      no: i3 + 1,
      id: item.id,
      inventoryId: item.Inventory.id,
      track: item.Inventory.track,
      image: item.Inventory.image,
      code: item.Inventory.code,
      year: item.year + 543,
      category: item.Inventory.Category.name,
      status: item.Inventory.Status.name,
      fund: item.Inventory.Fund.name,
      location: item.Inventory.Location.name,
      description: item.Inventory.description
    })).slice();
  }
  create(item) {
    this.inventoriesCheck.push(item);
    this.inventoriesCheck$.next(this.inventoriesCheck.slice());
  }
  delete(id) {
    const index = this.inventoriesCheck.findIndex((item) => item.id === id);
    if (index !== -1) {
      this.inventoriesCheck.splice(index, 1);
      this.inventoriesCheck$.next(this.inventoriesCheck.slice());
    }
  }
};
_InventoryCheckService.\u0275fac = function InventoryCheckService_Factory(t2) {
  return new (t2 || _InventoryCheckService)();
};
_InventoryCheckService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _InventoryCheckService, factory: _InventoryCheckService.\u0275fac, providedIn: "root" });
var InventoryCheckService = _InventoryCheckService;

// src/app/modules/dashboard/services/inventory-check/inventory-check-api.service.ts
var _InventoryCheckApiService = class _InventoryCheckApiService {
  constructor(http, inventoryCheckService, inventoryService, socketInventoryService, logService, socketLogService) {
    this.http = http;
    this.inventoryCheckService = inventoryCheckService;
    this.inventoryService = inventoryService;
    this.socketInventoryService = socketInventoryService;
    this.logService = logService;
    this.socketLogService = socketLogService;
    this.apiUrl = environment.apiUrl + "inventory-check";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.inventoryCheckService.assign(res)));
  }
  getByYear(year) {
    return this.http.get(`${this.apiUrl}/year/${year}`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.inventoryCheckService.assign(res)));
  }
  getById(id) {
    return this.http.get(`${this.apiUrl}/id/${id}`);
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => {
      const inventoryCheck = this.inventoryCheckService.getByInventoryId(res.item.inventoryCheck.Inventory.id);
      if (!inventoryCheck)
        this.inventoryCheckService.create(res.item.inventoryCheck);
      this.inventoryService.update(payload.inventoryId, {
        Status: {
          id: payload.statusId,
          name: payload.statusName
        }
      });
      this.socketInventoryService.update(payload.inventoryId, {
        Status: {
          id: payload.statusId,
          name: payload.statusName
        }
      });
      if (!res.item.log)
        return;
      this.logService.create(res.item.log);
      this.socketLogService.create(res.item.log);
    }));
  }
  delete(id) {
    return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap((res) => this.inventoryCheckService.delete(id)));
  }
};
_InventoryCheckApiService.\u0275fac = function InventoryCheckApiService_Factory(t2) {
  return new (t2 || _InventoryCheckApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(InventoryCheckService), \u0275\u0275inject(InventoryService), \u0275\u0275inject(SocketInventoryService), \u0275\u0275inject(LogService), \u0275\u0275inject(SocketLogService));
};
_InventoryCheckApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _InventoryCheckApiService, factory: _InventoryCheckApiService.\u0275fac, providedIn: "root" });
var InventoryCheckApiService = _InventoryCheckApiService;

// src/app/modules/dashboard/constants/inventory.constant.ts
var INVENTORY = {
  validationField: {
    code: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C" },
    description: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C" },
    unit: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2B\u0E19\u0E48\u0E27\u0E22\u0E19\u0E31\u0E1A" },
    value: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E21\u0E39\u0E25\u0E04\u0E48\u0E32\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C" },
    receivedDate: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E44\u0E14\u0E49\u0E21\u0E32" },
    category: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17" },
    status: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30" },
    fund: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19" },
    location: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2B\u0E49\u0E2D\u0E07" },
    image: { mimeType: "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E44\u0E1F\u0E25\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07 \u0E01\u0E23\u0E38\u0E13\u0E32\u0E2D\u0E31\u0E1B\u0E42\u0E2B\u0E25\u0E14\u0E44\u0E1F\u0E25\u0E4C\u0E23\u0E39\u0E1B\u0E20\u0E32\u0E1E\u0E40\u0E17\u0E48\u0E32\u0E19\u0E31\u0E49\u0E19" }
  }
};

// src/app/modules/dashboard/pipes/disp-textarea.pipe.ts
var _DispTextareaPipe = class _DispTextareaPipe {
  transform(value2) {
    if (!value2)
      return "-";
    const lines = value2.split("\n");
    const content = lines.map((line) => `<p>${line}</p>`).join("");
    return content.replace(/['"]+/g, "");
  }
};
_DispTextareaPipe.\u0275fac = function DispTextareaPipe_Factory(t2) {
  return new (t2 || _DispTextareaPipe)();
};
_DispTextareaPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "dispTextarea", type: _DispTextareaPipe, pure: true });
var DispTextareaPipe = _DispTextareaPipe;

// src/app/modules/dashboard/components/scan/scan-edit/scan-edit.component.ts
function ScanEditComponent_For_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 20);
    \u0275\u0275listener("selectionChange", function ScanEditComponent_For_17_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSelectChip("status"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const status_r3 = ctx.$implicit;
    \u0275\u0275property("value", status_r3.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", status_r3.name, " ");
  }
}
function ScanEditComponent_Conditional_37_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 19);
  }
}
var _ScanEditComponent = class _ScanEditComponent {
  constructor() {
    this.formBuilder = inject(FormBuilder);
    this.statusService = inject(StatusService);
    this.inventoryCheckApiService = inject(InventoryCheckApiService);
    this.toastService = inject(ToastNotificationService);
    this.subscription = new Subscription();
    this.dialogRef = inject(MatDialogRef);
    this.inventory = inject(MAT_DIALOG_DATA);
    this.imageUrl = environment.imageUrl;
    this.statuses = this.statusService.getActiveDetails();
    this.validationField = INVENTORY.validationField;
    this.title = "\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.isLoading = false;
    this.form = this.initForm();
  }
  ngOnInit() {
    if (this.inventory)
      this.form.setValue({ status: this.inventory.Status.id });
    else {
      this.toastService.error("Error", "\u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
      this.dialogRef.close();
    }
    this.dialogRef.keydownEvents().subscribe((event) => event.key === "Escape" && this.dialogRef.close());
    this.subscription = this.statusService.onListener().subscribe(() => {
      this.statuses = this.statusService.getActiveDetails();
      this.status.setValue(null);
    });
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    const status = this.statuses.find((status2) => status2.id === this.status.value);
    const statusName = status ? status.name : "";
    const payload = {
      inventoryId: this.inventory.id,
      statusId: this.status.value,
      statusName
    };
    this.isLoading = true;
    this.inventoryCheckApiService.create(payload).pipe(finalize(() => this.isLoading = false)).subscribe((res) => {
      this.toastService.success("Success", res.message, 1500);
      this.dialogRef.close();
    });
  }
  onReset() {
    this.form.setValue({ status: this.inventory.Status.id });
  }
  onSelectChip(keyName) {
    this[keyName].markAsTouched();
  }
  get status() {
    return this.form.controls["status"];
  }
  initForm() {
    return this.formBuilder.group({
      status: this.formBuilder.control(null, [Validators.required])
    });
  }
};
_ScanEditComponent.\u0275fac = function ScanEditComponent_Factory(t2) {
  return new (t2 || _ScanEditComponent)();
};
_ScanEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ScanEditComponent, selectors: [["app-scan-edit"]], decls: 38, vars: 13, consts: [[1, "d-flex", "justify-between", "align-center"], ["mat-dialog-title", ""], ["mat-icon-button", "", "tabindex", "-1", 1, "btn-close", 3, "click"], [3, "ngSubmit", "formGroup"], [1, "form-container"], [1, "box"], [1, "blurred-img"], [1, "size", 3, "defaultImage", "lazyLoad"], [1, "d-flex", "flex-column"], ["formControlName", "status"], [3, "value"], [2, "color", "#f44336"], [3, "control", "errorMessage"], ["matListItemTitle", ""], ["matListItemLine", ""], [1, "view-textarea", 3, "innerHTML"], [2, "justify-content", "space-between"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], ["mode", "indeterminate"], [3, "selectionChange", "value"]], template: function ScanEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h2", 1);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 2);
    \u0275\u0275listener("click", function ScanEditComponent_Template_button_click_3_listener() {
      return ctx.dialogRef.close();
    });
    \u0275\u0275elementStart(4, "mat-icon");
    \u0275\u0275text(5, "close");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "form", 3);
    \u0275\u0275listener("ngSubmit", function ScanEditComponent_Template_form_ngSubmit_6_listener() {
      return ctx.onSubmit();
    });
    \u0275\u0275element(7, "mat-divider");
    \u0275\u0275elementStart(8, "mat-dialog-content", 4)(9, "div", 5)(10, "div", 6);
    \u0275\u0275element(11, "img", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "div", 8)(13, "mat-card-title");
    \u0275\u0275text(14, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "mat-chip-listbox", 9);
    \u0275\u0275repeaterCreate(16, ScanEditComponent_For_17_Template, 2, 2, "mat-chip-option", 10, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "mat-error", 11);
    \u0275\u0275element(19, "app-error-field", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "mat-list")(21, "mat-list-item")(22, "span", 13);
    \u0275\u0275text(23, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "span", 14);
    \u0275\u0275text(25);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "mat-list-item")(27, "span", 13);
    \u0275\u0275text(28, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(29, "div", 15);
    \u0275\u0275pipe(30, "dispTextarea");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(31, "mat-divider");
    \u0275\u0275elementStart(32, "mat-dialog-actions", 16)(33, "button", 17);
    \u0275\u0275text(34, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(35, "button", 18);
    \u0275\u0275listener("click", function ScanEditComponent_Template_button_click_35_listener() {
      return ctx.onReset();
    });
    \u0275\u0275text(36, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(37, ScanEditComponent_Conditional_37_Template, 1, 0, "mat-progress-bar", 19);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(5);
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx.imageUrl + ctx.inventory.image);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx.statuses);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx.status)("errorMessage", ctx.validationField.status);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx.inventory.code);
    \u0275\u0275advance(4);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind1(30, 11, ctx.inventory.description), \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(37, ctx.isLoading ? 37 : -1);
  }
}, dependencies: [\u0275NgNoValidate, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatList, MatListItem, MatDivider, MatListItemLine, MatListItemTitle, MatCardTitle, MatError, MatProgressBar, MatDialogTitle, MatDialogActions, MatDialogContent, MatChipListbox, MatChipOption, LazyLoadImageDirective, ErrorFieldComponent, DispTextareaPipe], styles: ["\n\nmat-list-item[_ngcontent-%COMP%] {\n  padding: 0;\n}\nimg[_ngcontent-%COMP%] {\n  width: 150px !important;\n  height: 150px !important;\n}\n.view-textarea[_ngcontent-%COMP%] {\n  margin-top: -12px;\n  color: rgba(0, 0, 0, 0.54);\n}\n.view-textarea[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin: 0 0 8px;\n}\n.dark-theme[_nghost-%COMP%]   .view-textarea[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .view-textarea[_ngcontent-%COMP%] {\n  color: rgba(255, 255, 255, 0.7);\n}\n/*# sourceMappingURL=scan-edit.component.css.map */"] });
var ScanEditComponent = _ScanEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ScanEditComponent, { className: "ScanEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\scan\\scan-edit\\scan-edit.component.ts", lineNumber: 18 });
})();

// src/app/modules/dashboard/services/search/search-api.service.ts
var _SearchApiService = class _SearchApiService {
  constructor(http) {
    this.http = http;
    this.apiUrl = environment.apiUrl + "inventory/search";
  }
  search(payload) {
    const params = new HttpParams().set("code", payload);
    return this.http.get(this.apiUrl, { params });
  }
};
_SearchApiService.\u0275fac = function SearchApiService_Factory(t2) {
  return new (t2 || _SearchApiService)(\u0275\u0275inject(HttpClient));
};
_SearchApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SearchApiService, factory: _SearchApiService.\u0275fac, providedIn: "root" });
var SearchApiService = _SearchApiService;

// src/app/modules/dashboard/services/search/search.service.ts
var _SearchService = class _SearchService {
  constructor(searchApiService) {
    this.searchApiService = searchApiService;
    this.cache = [];
    this.search$ = new BehaviorSubject("");
  }
  onListener() {
    return this.search$.asObservable().pipe(debounceTime(300), distinctUntilChanged(), switchMap((query) => this.onSearch(query)));
  }
  onSearch(query) {
    const items = this.cache.filter((item) => item.includes(query));
    if (items.length > 0)
      return of(items);
    return this.searchApiService.search(query).pipe(tap((res) => {
      const combine = /* @__PURE__ */ new Set([...this.cache, ...res]);
      this.cache = Array.from(combine).sort();
    }));
  }
  getCache() {
    return this.cache;
  }
  updateCache(query, update) {
    const index = this.cache.findIndex((item) => item === query);
    if (index !== -1)
      this.cache[index] = update;
  }
  clearCache() {
    this.cache = [];
  }
};
_SearchService.\u0275fac = function SearchService_Factory(t2) {
  return new (t2 || _SearchService)(\u0275\u0275inject(SearchApiService));
};
_SearchService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SearchService, factory: _SearchService.\u0275fac, providedIn: "root" });
var SearchService = _SearchService;

// src/app/modules/dashboard/components/scan/scan.component.ts
var _c02 = ["qrBox"];
var _c1 = (a0) => ({ blur: a0 });
function ScanComponent_For_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-option", 6);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const code_r2 = ctx.$implicit;
    \u0275\u0275property("value", code_r2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(code_r2);
  }
}
function ScanComponent_button_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 19);
    \u0275\u0275listener("click", function ScanComponent_button_23_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.search.setValue(""));
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "close");
    \u0275\u0275elementEnd()();
  }
}
function ScanComponent_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 18);
  }
}
var Tap;
(function(Tap4) {
  Tap4[Tap4["Camera"] = 0] = "Camera";
  Tap4[Tap4["Search"] = 1] = "Search";
})(Tap || (Tap = {}));
var ScanType;
(function(ScanType2) {
  ScanType2[ScanType2["QRcode"] = 0] = "QRcode";
  ScanType2[ScanType2["Barcode"] = 1] = "Barcode";
})(ScanType || (ScanType = {}));
var _ScanComponent = class _ScanComponent {
  constructor() {
    this.formBuilder = inject(FormBuilder);
    this.scanApiService = inject(ScanApiService);
    this.inventoryService = inject(InventoryService);
    this.toastService = inject(ToastNotificationService);
    this.searchService = inject(SearchService);
    this.dialog = inject(MatDialog);
    this.subscription = new Subscription();
    this.platform = inject(Platform);
    this.title = "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23 \u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.selectedTap = new FormControl(Tap.Search);
    this.form = this.initForm();
    this.isLoading = false;
    this.isScanning = false;
    this.isScanType = 0;
    this.scanSize = { width: 0, height: 0 };
    this.html5QrcodeScanner = null;
    this.cache = this.searchService.getCache();
  }
  ngOnInit() {
    this.initSubscriptions();
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onTapChange(indexTap) {
    if (indexTap !== Tap.Camera) {
      if (this.qrRender)
        this.qrRender.remove();
      if (this.html5QrcodeScanner)
        this.html5QrcodeScanner.clear();
      return;
    }
    defer(() => this.qrBox ? of(null) : interval(300).pipe(filter(() => !!this.qrBox), take(1))).subscribe(() => this.onStartCamera());
  }
  onSearchAutoComplete(query) {
    this.searchService.search$.next(query);
  }
  onSearchInventory() {
    if (!this.search.value)
      return;
    const code = this.search.value.replace(/^\s+|\s+$/gm, "");
    this.determineType(code);
  }
  onStartCamera() {
    this.isScanning = true;
    if (ScanType.Barcode === this.isScanType)
      this.scanSize = { width: 300, height: 100 };
    else
      this.scanSize = { width: 250, height: 250 };
    const id = "qrReader";
    this.qrRender = document.getElementById("div");
    if (!this.qrRender) {
      this.qrRender = document.createElement("div");
      this.qrRender.id = id;
      this.qrRender.className = "w-100";
      this.qrBox.nativeElement.appendChild(this.qrRender);
    }
    timer(500).pipe(finalize(() => timer(300).subscribe(() => this.isScanning = false))).subscribe(() => {
      this.html5QrcodeScanner = new Html5QrcodeScanner(id, { fps: 10, qrbox: this.scanSize }, false);
      this.html5QrcodeScanner.render((decodedText, decodedResult) => this.onScanSuccess(decodedText), (errorMessage, error) => null);
    });
  }
  onScanSuccess(data) {
    if (this.isScanning == true)
      return;
    this.isScanning = true;
    this.determineType(data);
  }
  determineType(data) {
    if (data.length === 7) {
      this.onGetInventory("track", data.toUpperCase());
      return;
    }
    this.onGetInventory("code", data);
  }
  onGetInventory(type, data) {
    let inventory;
    if (type === "code")
      inventory = this.inventoryService.getByCode(data);
    else
      inventory = this.inventoryService.getByTrack(data);
    if (inventory) {
      this.search.setValue("");
      this.dialogOpen(inventory);
      return;
    }
    this.isLoading = true;
    this.operation$ = type === "code" ? this.scanApiService.getByCode(data) : this.scanApiService.getByTrack(data);
    this.operation$.pipe(finalize(() => this.isLoading = false)).subscribe((res) => {
      if (res) {
        this.search.setValue("");
        this.dialogOpen(res);
        return;
      }
      timer(1500).subscribe(() => this.isScanning = false);
      this.toastService.warning("", `${data} \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C`);
    });
  }
  dialogOpen(inventory) {
    this.dialog.open(ScanEditComponent, {
      data: inventory,
      width: "500px"
    }).afterClosed().subscribe(() => timer(500).subscribe(() => this.isScanning = false));
  }
  get search() {
    return this.form.controls["search"];
  }
  initForm() {
    return this.formBuilder.group({
      search: [""]
    });
  }
  _filter(value2) {
    const filterValue = value2.toLowerCase();
    return this.cache.filter((option) => option.toLowerCase().includes(filterValue));
  }
  initSubscriptions() {
    defer(() => this.qrBox ? of(null) : interval(300).pipe(filter(() => !!this.qrBox), take(1))).subscribe(() => this.onStartCamera());
    this.subscription = this.searchService.onListener().subscribe((cache2) => this.cache = this.searchService.getCache());
    this.filteredOptions = merge(this.search.valueChanges, this.searchService.onListener().pipe(map(() => this.search.value))).pipe(startWith(""), map((value2) => this._filter(value2 || "")));
  }
};
_ScanComponent.\u0275fac = function ScanComponent_Factory(t2) {
  return new (t2 || _ScanComponent)();
};
_ScanComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ScanComponent, selectors: [["app-scan"]], viewQuery: function ScanComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c02, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.qrBox = _t2.first);
  }
}, decls: 33, vars: 14, consts: [["qrBox", ""], ["auto", "matAutocomplete"], [1, "mat-elevation-z8", "mb-20"], ["dynamicHeight", "", 3, "selectedIndexChange"], ["label", "\u0E01\u0E25\u0E49\u0E2D\u0E07"], [3, "ngModelChange", "change", "ngModel"], [3, "value"], [3, "ngClass"], ["label", "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C"], [3, "ngSubmit", "formGroup"], [1, "w-100"], ["type", "text", "matInput", "", 3, "input", "formControl", "matAutocomplete"], ["autoActiveFirstOption", ""], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click", 4, "ngIf"], ["type", "submit", "matSuffix", "", "mat-icon-button", ""], ["matSuffix", "", "fontIcon", "search"], [1, "justify-between"], ["type", "button", "mat-raised-button", "", "color", "primary", 3, "click", "disabled"], ["mode", "indeterminate"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click"]], template: function ScanComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 2)(1, "mat-tab-group", 3);
    \u0275\u0275listener("selectedIndexChange", function ScanComponent_Template_mat_tab_group_selectedIndexChange_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onTapChange($event));
    });
    \u0275\u0275elementStart(2, "mat-tab", 4)(3, "mat-card-content")(4, "mat-radio-group", 5);
    \u0275\u0275twoWayListener("ngModelChange", function ScanComponent_Template_mat_radio_group_ngModelChange_4_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.isScanType, $event) || (ctx.isScanType = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function ScanComponent_Template_mat_radio_group_change_4_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onStartCamera());
    });
    \u0275\u0275elementStart(5, "mat-radio-button", 6);
    \u0275\u0275text(6, "QR code");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "mat-radio-button", 6);
    \u0275\u0275text(8, "Barcode");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(9, "div", 7, 0);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "mat-tab", 8)(12, "mat-card-content")(13, "form", 9);
    \u0275\u0275listener("ngSubmit", function ScanComponent_Template_form_ngSubmit_13_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchInventory());
    });
    \u0275\u0275elementStart(14, "mat-form-field", 10)(15, "mat-label");
    \u0275\u0275text(16, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "input", 11);
    \u0275\u0275listener("input", function ScanComponent_Template_input_input_17_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchAutoComplete(ctx.search.value));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "mat-autocomplete", 12, 1);
    \u0275\u0275repeaterCreate(20, ScanComponent_For_21_Template, 2, 2, "mat-option", 6, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275pipe(22, "async");
    \u0275\u0275elementEnd();
    \u0275\u0275template(23, ScanComponent_button_23_Template, 3, 0, "button", 13);
    \u0275\u0275elementStart(24, "button", 14);
    \u0275\u0275element(25, "mat-icon", 15);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(26, "mat-card-actions", 16)(27, "button", 17);
    \u0275\u0275listener("click", function ScanComponent_Template_button_click_27_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchInventory());
    });
    \u0275\u0275elementStart(28, "mat-icon");
    \u0275\u0275text(29, "search");
    \u0275\u0275elementEnd();
    \u0275\u0275text(30, " \u0E04\u0E49\u0E19\u0E2B\u0E32 ");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(31, "mat-card-footer");
    \u0275\u0275template(32, ScanComponent_Conditional_32_Template, 1, 0, "mat-progress-bar", 18);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const auto_r5 = \u0275\u0275reference(19);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.isScanType);
    \u0275\u0275advance();
    \u0275\u0275property("value", 0);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", 1);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(12, _c1, ctx.isScanning));
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(4);
    \u0275\u0275property("formControl", ctx.search)("matAutocomplete", auto_r5);
    \u0275\u0275advance(3);
    \u0275\u0275repeater(\u0275\u0275pipeBind1(22, 10, ctx.filteredOptions));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.search.value);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(5);
    \u0275\u0275conditional(32, ctx.isLoading ? 32 : -1);
  }
}, dependencies: [NgClass, NgIf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormControlDirective, FormGroupDirective, MatButton, MatIconButton, MatIcon, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatInput, MatFormField, MatLabel, MatSuffix, MatProgressBar, MatRadioGroup, MatRadioButton, MatOption, MatTab, MatTabGroup, MatAutocomplete, MatAutocompleteTrigger, NgModel, AsyncPipe], styles: ['\n\nimg[_ngcontent-%COMP%] {\n  width: 100px;\n  height: 100px;\n}\n.dark-theme[_nghost-%COMP%]   .search-box[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .search-box[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n  color: #f54831;\n  background-color: #303030;\n}\n.dark-theme[_nghost-%COMP%]   .search-box[_ngcontent-%COMP%]   button[type=submit][_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .search-box[_ngcontent-%COMP%]   button[type=submit][_ngcontent-%COMP%] {\n  color: #fff;\n  background-color: #ff5722;\n}\n.mat-column-image[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  padding-block: 8px;\n}\n.mat-column-code[_ngcontent-%COMP%] {\n  flex: 0 0 140px;\n}\n.mat-column-description[_ngcontent-%COMP%] {\n  min-width: 200px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  min-width: 60px;\n}\n.search-box[_ngcontent-%COMP%] {\n  display: flex;\n  max-width: 850px;\n}\n.search-box[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n  padding: 12px 20px;\n  color: #ff9800;\n  background-color: #f1f4f7;\n  font-size: 1rem;\n  font-weight: 700;\n  outline: none;\n  border: none;\n  border-radius: 1.25rem 0 0 1.25rem;\n  box-sizing: border-box;\n}\n.search-box[_ngcontent-%COMP%]   button[type=submit][_ngcontent-%COMP%] {\n  flex-basis: 120px;\n  background-color: #ff9800;\n  font-size: 1rem;\n  outline: none;\n  border: none;\n  border-radius: 0 1.25rem 1.25rem 0;\n  box-sizing: border-box;\n  cursor: pointer;\n}\n.search-box[_ngcontent-%COMP%]   button[type=submit][_ngcontent-%COMP%]:disabled {\n  cursor: default;\n  opacity: 0.6;\n}\n.search-box[_ngcontent-%COMP%]   .search-input-box[_ngcontent-%COMP%] {\n  position: relative;\n  flex-grow: 1;\n}\n.search-box[_ngcontent-%COMP%]   .search-input-box[_ngcontent-%COMP%]   .close[_ngcontent-%COMP%] {\n  position: absolute;\n  top: -3px;\n  right: -5px;\n  color: #6c757d;\n}\n.stock-field[_ngcontent-%COMP%] {\n  margin-top: 20px;\n  width: 80px;\n}\n.btn-submit[_ngcontent-%COMP%] {\n  align-items: center;\n  appearance: none;\n  background-clip: padding-box;\n  background-color: initial;\n  background-image: none;\n  border-style: none;\n  box-sizing: border-box;\n  color: #fff;\n  cursor: pointer;\n  display: inline-block;\n  flex-direction: row;\n  flex-shrink: 0;\n  font-family: Eina01, sans-serif;\n  font-size: 16px;\n  font-weight: 800;\n  justify-content: center;\n  line-height: 24px;\n  margin: 0;\n  min-height: 64px;\n  outline: none;\n  overflow: visible;\n  padding: 19px 26px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  text-decoration: none;\n  text-transform: none;\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  vertical-align: middle;\n  width: auto;\n  word-break: keep-all;\n  z-index: 0;\n}\n@media (min-width: 768px) {\n  .button-77[_ngcontent-%COMP%] {\n    padding: 19px 32px;\n  }\n}\n.btn-submit[_ngcontent-%COMP%]:before, .btn-submit[_ngcontent-%COMP%]:after {\n  border-radius: 80px;\n}\n.btn-submit[_ngcontent-%COMP%]:before {\n  background-color: rgba(249, 58, 19, 0.32);\n  content: "";\n  display: block;\n  height: 100%;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 100%;\n  z-index: -2;\n}\n.btn-submit[_ngcontent-%COMP%]:after {\n  background-color: initial;\n  background-image:\n    linear-gradient(\n      92.83deg,\n      #ff7426 0,\n      #f93a13 100%);\n  bottom: 4px;\n  content: "";\n  display: block;\n  left: 4px;\n  overflow: hidden;\n  position: absolute;\n  right: 4px;\n  top: 4px;\n  transition: all 100ms ease-out;\n  z-index: -1;\n}\n.btn-submit[_ngcontent-%COMP%]:hover:not(:disabled):after {\n  bottom: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  transition-timing-function: ease-in;\n}\n.btn-submit[_ngcontent-%COMP%]:active:not(:disabled) {\n  color: #ccc;\n}\n.btn-submit[_ngcontent-%COMP%]:active:not(:disabled):after {\n  background-image:\n    linear-gradient(\n      0deg,\n      rgba(0, 0, 0, 0.2),\n      rgba(0, 0, 0, 0.2)),\n    linear-gradient(\n      92.83deg,\n      #ff7426 0,\n      #f93a13 100%);\n  bottom: 4px;\n  left: 4px;\n  right: 4px;\n  top: 4px;\n}\n.btn-submit[_ngcontent-%COMP%]:disabled {\n  cursor: default;\n  opacity: 0.24;\n}\n/*# sourceMappingURL=scan.component.css.map */'] });
var ScanComponent = _ScanComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ScanComponent, { className: "ScanComponent", filePath: "src\\app\\modules\\dashboard\\components\\scan\\scan.component.ts", lineNumber: 49 });
})();

// src/app/modules/dashboard/components/log/log.component.ts
var _LogComponent = class _LogComponent {
  onRouterActive() {
    window.scrollTo(0, 0);
  }
};
_LogComponent.\u0275fac = function LogComponent_Factory(t2) {
  return new (t2 || _LogComponent)();
};
_LogComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LogComponent, selectors: [["app-log"]], decls: 1, vars: 0, consts: [[3, "activate"]], template: function LogComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "router-outlet", 0);
    \u0275\u0275listener("activate", function LogComponent_Template_router_outlet_activate_0_listener() {
      return ctx.onRouterActive();
    });
    \u0275\u0275elementEnd();
  }
}, dependencies: [RouterOutlet] });
var LogComponent = _LogComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LogComponent, { className: "LogComponent", filePath: "src\\app\\modules\\dashboard\\components\\log\\log.component.ts", lineNumber: 8 });
})();

// src/app/modules/dashboard/services/user/user.service.ts
var _UserService = class _UserService {
  constructor() {
    this.users = [];
    this.users$ = new Subject();
  }
  onListener() {
    return this.users$.asObservable();
  }
  assign(items) {
    this.users = items;
    this.users$.next(this.users.slice());
  }
  getAll() {
    return this.users.slice();
  }
  getTableData() {
    return this.users.map((item, i3) => __spreadValues({ no: i3 + 1 }, item)).slice();
  }
  create(item) {
    this.users.push(item);
    this.users$.next(this.users.slice());
  }
  update(id, item) {
    const index = this.users.findIndex((item2) => item2.id === id);
    if (index !== -1) {
      this.users[index] = __spreadValues(__spreadValues({}, this.users[index]), item);
      this.users$.next(this.users.slice());
    }
  }
};
_UserService.\u0275fac = function UserService_Factory(t2) {
  return new (t2 || _UserService)();
};
_UserService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _UserService, factory: _UserService.\u0275fac, providedIn: "root" });
var UserService = _UserService;

// src/app/modules/dashboard/services/user/user-api.service.ts
var _UserApiService = class _UserApiService {
  constructor(http, userService) {
    this.http = http;
    this.userService = userService;
    this.apiUrl = environment.apiUrl + "user";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(tap((res) => this.userService.assign(res)));
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => this.userService.create(res.item)));
  }
  update(id, payload) {
    return this.http.patch(`${this.apiUrl}/${id}`, payload).pipe(tap((res) => this.userService.update(id, res.item)));
  }
};
_UserApiService.\u0275fac = function UserApiService_Factory(t2) {
  return new (t2 || _UserApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(UserService));
};
_UserApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _UserApiService, factory: _UserApiService.\u0275fac, providedIn: "root" });
var UserApiService = _UserApiService;

// src/app/modules/dashboard/constants/user.constant.ts
var USER = {
  patternPassword: "^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$ %^&*-]).{8,}$",
  validationField: {
    email: {
      required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 E-mail",
      email: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 E-mail \u0E43\u0E2B\u0E49\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07 (example@gmail.com)"
    },
    password: {
      required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19",
      pattern: "\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E15\u0E31\u0E27\u0E40\u0E25\u0E47\u0E01, \u0E15\u0E31\u0E27\u0E43\u0E2B\u0E0D\u0E48, \u0E15\u0E31\u0E27\u0E40\u0E25\u0E02, \u0E2D\u0E31\u0E01\u0E29\u0E23\u0E1E\u0E34\u0E40\u0E28\u0E29 \u0E41\u0E25\u0E30\u0E44\u0E21\u0E48\u0E15\u0E48\u0E33\u0E01\u0E27\u0E48\u0E32 8 \u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23"
    },
    confirmPassword: {
      required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E22\u0E37\u0E19\u0E22\u0E35\u0E19\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E43\u0E2B\u0E21\u0E48",
      match: "\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E19"
    },
    firstname: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E0A\u0E37\u0E48\u0E2D" },
    lastname: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E19\u0E32\u0E21\u0E2A\u0E01\u0E38\u0E25" },
    role: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E34\u0E17\u0E18\u0E34", oneOf: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E40\u0E25\u0E37\u0E2D\u0E01 user \u0E2B\u0E23\u0E37\u0E2D admin" },
    active: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19" }
  }
};

// src/app/modules/dashboard/components/user/user-edit/user-edit.component.ts
var _c03 = ["formDirec"];
var _c12 = ["emailInput"];
function UserEditComponent_Conditional_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-form-field")(1, "mat-label");
    \u0275\u0275text(2, "Password");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "input", 21);
    \u0275\u0275elementStart(4, "mat-icon", 22);
    \u0275\u0275listener("click", function UserEditComponent_Conditional_18_Template_mat_icon_click_4_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.hidePassword = !ctx_r2.hidePassword);
    });
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "mat-error");
    \u0275\u0275element(7, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "mat-form-field")(9, "mat-label");
    \u0275\u0275text(10, "Confirm Password");
    \u0275\u0275elementEnd();
    \u0275\u0275element(11, "input", 23);
    \u0275\u0275elementStart(12, "mat-icon", 22);
    \u0275\u0275listener("click", function UserEditComponent_Conditional_18_Template_mat_icon_click_12_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.hideConfirmPassword = !ctx_r2.hideConfirmPassword);
    });
    \u0275\u0275text(13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "mat-error");
    \u0275\u0275element(15, "app-error-field", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("type", ctx_r2.hidePassword ? "password" : "text");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.hidePassword ? "visibility_off" : "visibility");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r2.password)("errorMessage", ctx_r2.validationField.password);
    \u0275\u0275advance(4);
    \u0275\u0275property("type", ctx_r2.hideConfirmPassword ? "password" : "text");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.hideConfirmPassword ? "visibility_off" : "visibility");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r2.confirmPassword)("errorMessage", ctx_r2.validationField.confirmPassword);
  }
}
function UserEditComponent_mat_option_36_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-option", 24);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const role_r4 = ctx.$implicit;
    \u0275\u0275property("value", role_r4);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(role_r4);
  }
}
function UserEditComponent_Conditional_53_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 20);
  }
}
var _UserEditComponent = class _UserEditComponent {
  constructor() {
    this.formBuilder = inject(FormBuilder);
    this.dialogRef = inject(MatDialogRef);
    this.data = inject(MAT_DIALOG_DATA);
    this.userApiService = inject(UserApiService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.validationField = USER.validationField;
    this.patternPassword = USER.patternPassword;
    this.roleOptions = ["user", "admin"];
    this.title = "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19";
    this.isEdit = false;
    this.isLoading = false;
    this.hidePassword = true;
    this.hideConfirmPassword = true;
    this.form = this.initForm();
  }
  ngOnInit() {
    if (this.data) {
      this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E1C\u0E39\u0E49\u0E43\u0E02\u0E49\u0E07\u0E32\u0E19";
      this.isEdit = true;
      this.password.disable();
      this.confirmPassword.disable();
      this.form.clearValidators();
      this.form.patchValue(this.data);
    }
    this.dialogRef.keydownEvents().subscribe((event) => event.key === "Escape" && this.onCloseDialog());
    this.dialogRef.backdropClick().subscribe(() => this.onCloseDialog());
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    if (JSON.stringify(this.data) === JSON.stringify(this.form.value))
      return;
    const _a2 = __spreadValues({}, this.form.getRawValue()), { id } = _a2, payload = __objRest(_a2, ["id"]);
    this.isLoading = true;
    this.operation$ = this.isEdit ? this.userApiService.update(id, payload) : this.userApiService.create(payload);
    this.operation$.pipe(catchError((error) => {
      if (error.status === 0)
        this.dialogRef.close();
      return throwError(() => error);
    }), finalize(() => this.isLoading = false)).subscribe((res) => {
      if (this.isEdit)
        this.dialogRef.close();
      else
        this.onReset();
      this.toastService.success("Success", res.message);
    });
  }
  onReset() {
    if (this.isEdit)
      this.form.patchValue(this.data);
    else
      this.formDirec.resetForm();
    this.emailInput.nativeElement.focus();
  }
  newDialogBackdropHandler() {
    const isChange = this.email.value !== "" || this.password.value !== "" || this.confirmPassword.value !== "" || this.firstname.value !== "" || this.lastname.value !== "" || this.role.value !== "user" || this.remark.value !== "";
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  editDialogBackdropHandler() {
    const isChange = this.email.value !== this.data.email || this.firstname.value !== this.data.firstname || this.lastname.value !== this.data.lastname || this.role.value !== this.data.role || this.active.value !== this.data.active || this.remark.value !== this.data.remark;
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  confirmDialogBackdropHandler() {
    const confirmation = confirm("\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01\u0E01\u0E32\u0E23\u0E41\u0E01\u0E49\u0E44\u0E02\u0E41\u0E25\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E1F\u0E2D\u0E23\u0E4C\u0E21\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48?");
    if (confirmation)
      this.dialogRef.close();
  }
  onCloseDialog() {
    if (this.isEdit)
      this.editDialogBackdropHandler();
    else
      this.newDialogBackdropHandler();
  }
  get email() {
    return this.form.controls["email"];
  }
  get password() {
    return this.form.controls["password"];
  }
  get confirmPassword() {
    return this.form.controls["confirmPassword"];
  }
  get firstname() {
    return this.form.controls["firstname"];
  }
  get lastname() {
    return this.form.controls["lastname"];
  }
  get role() {
    return this.form.controls["role"];
  }
  get active() {
    return this.form.controls["active"];
  }
  get remark() {
    return this.form.controls["remark"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      id: [null],
      email: ["", [Validators.required, Validators.email]],
      password: [
        "",
        [Validators.required, Validators.pattern(this.patternPassword)]
      ],
      confirmPassword: [""],
      firstname: ["", [Validators.required]],
      lastname: ["", [Validators.required]],
      role: [
        "user",
        [Validators.required, this.validationService.oneOf(this.roleOptions)]
      ],
      active: [true, [Validators.required]],
      remark: [""]
    }, {
      validators: this.validationService.comparePassword.bind(this, [
        "password",
        "confirmPassword"
      ])
    });
  }
};
_UserEditComponent.\u0275fac = function UserEditComponent_Factory(t2) {
  return new (t2 || _UserEditComponent)();
};
_UserEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _UserEditComponent, selectors: [["app-user-edit"]], viewQuery: function UserEditComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c03, 5);
    \u0275\u0275viewQuery(_c12, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.formDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.emailInput = _t2.first);
  }
}, decls: 54, vars: 13, consts: [["formDirec", "ngForm"], ["emailInput", ""], [1, "d-flex", "justify-between", "align-center"], ["mat-dialog-title", ""], ["mat-icon-button", "", "tabindex", "-1", 1, "btn-close", 3, "click"], [3, "ngSubmit", "formGroup"], [1, "form-container"], [1, "box"], ["type", "email", "matInput", "", "formControlName", "email"], [3, "control", "errorMessage"], [1, "row"], ["type", "text", "matInput", "", "formControlName", "firstname"], ["type", "text", "matInput", "", "formControlName", "lastname"], ["formControlName", "role"], [3, "value", 4, "ngFor", "ngForOf"], ["type", "text", "matInput", "", "formControlName", "remark"], [1, "d-flex", "gap-10"], ["formControlName", "active"], ["type", "submit", "mat-raised-button", "", "color", "primary"], ["type", "button", "mat-button", "", "color", "warn", 3, "click"], ["mode", "indeterminate"], ["matInput", "", "formControlName", "password", "autocomplete", "off", 3, "type"], ["matSuffix", "", 3, "click"], ["matInput", "", "formControlName", "confirmPassword", "autocomplete", "off", 3, "type"], [3, "value"]], template: function UserEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "h2", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 4);
    \u0275\u0275listener("click", function UserEditComponent_Template_button_click_3_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseDialog());
    });
    \u0275\u0275elementStart(4, "mat-icon");
    \u0275\u0275text(5, "close");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "form", 5, 0);
    \u0275\u0275listener("ngSubmit", function UserEditComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSubmit());
    });
    \u0275\u0275element(8, "mat-divider");
    \u0275\u0275elementStart(9, "mat-dialog-content", 6)(10, "div", 7)(11, "mat-form-field")(12, "mat-label");
    \u0275\u0275text(13, "E-mail");
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "input", 8, 1);
    \u0275\u0275elementStart(16, "mat-error");
    \u0275\u0275element(17, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(18, UserEditComponent_Conditional_18_Template, 16, 8);
    \u0275\u0275elementStart(19, "div", 10)(20, "mat-form-field")(21, "mat-label");
    \u0275\u0275text(22, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(23, "input", 11);
    \u0275\u0275elementStart(24, "mat-error");
    \u0275\u0275element(25, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "mat-form-field")(27, "mat-label");
    \u0275\u0275text(28, "\u0E19\u0E32\u0E21\u0E2A\u0E01\u0E38\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275element(29, "input", 12);
    \u0275\u0275elementStart(30, "mat-error");
    \u0275\u0275element(31, "app-error-field", 9);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(32, "mat-form-field")(33, "mat-label");
    \u0275\u0275text(34, "\u0E2A\u0E34\u0E17\u0E18\u0E34");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(35, "mat-select", 13);
    \u0275\u0275template(36, UserEditComponent_mat_option_36_Template, 2, 2, "mat-option", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(37, "mat-error");
    \u0275\u0275element(38, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(39, "mat-form-field")(40, "mat-label");
    \u0275\u0275text(41, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(42, "input", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(43, "div", 16);
    \u0275\u0275element(44, "mat-slide-toggle", 17);
    \u0275\u0275elementStart(45, "span");
    \u0275\u0275text(46, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275element(47, "mat-divider");
    \u0275\u0275elementStart(48, "mat-dialog-actions")(49, "button", 18);
    \u0275\u0275text(50, "\u0E15\u0E01\u0E25\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(51, "button", 19);
    \u0275\u0275listener("click", function UserEditComponent_Template_button_click_51_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onReset());
    });
    \u0275\u0275text(52, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(53, UserEditComponent_Conditional_53_Template, 1, 0, "mat-progress-bar", 20);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(11);
    \u0275\u0275property("control", ctx.email)("errorMessage", ctx.validationField.email);
    \u0275\u0275advance();
    \u0275\u0275conditional(18, !ctx.isEdit ? 18 : -1);
    \u0275\u0275advance(7);
    \u0275\u0275property("control", ctx.firstname)("errorMessage", ctx.validationField.firstname);
    \u0275\u0275advance(6);
    \u0275\u0275property("control", ctx.lastname)("errorMessage", ctx.validationField.lastname);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", ctx.roleOptions);
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx.role)("errorMessage", ctx.validationField.role);
    \u0275\u0275advance(15);
    \u0275\u0275conditional(53, ctx.isLoading ? 53 : -1);
  }
}, dependencies: [NgForOf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatDivider, MatInput, MatFormField, MatLabel, MatError, MatSuffix, MatProgressBar, MatSlideToggle, MatDialogTitle, MatDialogActions, MatDialogContent, MatSelect, MatOption, ErrorFieldComponent] });
var UserEditComponent = _UserEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(UserEditComponent, { className: "UserEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\user\\user-edit\\user-edit.component.ts", lineNumber: 29 });
})();

// src/app/modules/dashboard/components/user/user.component.ts
var UserComponent_Defer_5_DepsFn = () => [MatIconButton, MatIcon, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader];
var _c04 = () => [10, 25, 50, 100];
function UserComponent_Defer_3_mat_header_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 20);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r3.no, " ");
  }
}
function UserComponent_Defer_3_mat_header_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 20);
    \u0275\u0275text(1, "E-mail");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r4.email, " ");
  }
}
function UserComponent_Defer_3_mat_header_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 20);
    \u0275\u0275text(1, "\u0E0A\u0E37\u0E48\u0E2D - \u0E2A\u0E01\u0E38\u0E25");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r5.firstname + " " + element_r5.lastname, " ");
  }
}
function UserComponent_Defer_3_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 20);
    \u0275\u0275text(1, "\u0E2A\u0E34\u0E17\u0E18\u0E34");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r6.role, " ");
  }
}
function UserComponent_Defer_3_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 20);
    \u0275\u0275text(1, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E02\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_24_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 21);
    \u0275\u0275text(1, "toggle_on");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_24_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 22);
    \u0275\u0275text(1, "toggle_off");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275template(1, UserComponent_Defer_3_mat_cell_24_Conditional_1_Template, 2, 0, "mat-icon", 21)(2, UserComponent_Defer_3_mat_cell_24_Conditional_2_Template, 2, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r7 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(1, element_r7.active ? 1 : 2);
  }
}
function UserComponent_Defer_3_mat_header_cell_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 20);
    \u0275\u0275text(1, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
  }
}
function UserComponent_Defer_3_mat_cell_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r8 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r8.remark, " ");
  }
}
function UserComponent_Defer_3_mat_header_cell_29_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function UserComponent_Defer_3_mat_cell_30_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 24);
    \u0275\u0275listener("click", function UserComponent_Defer_3_mat_cell_30_Conditional_1_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r9);
      const element_r10 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onUpdate(element_r10));
    });
    \u0275\u0275elementStart(1, "mat-icon", 25);
    \u0275\u0275text(2, "edit");
    \u0275\u0275elementEnd()();
  }
}
function UserComponent_Defer_3_mat_cell_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275template(1, UserComponent_Defer_3_mat_cell_30_Conditional_1_Template, 3, 0, "button", 23);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r10 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275conditional(1, element_r10.id !== ctx_r1.profileId ? 1 : -1);
  }
}
function UserComponent_Defer_3_mat_header_row_31_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function UserComponent_Defer_3_mat_row_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function UserComponent_Defer_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 2)(1, "mat-card-header", 3)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "mat-form-field", 4)(6, "mat-label");
    \u0275\u0275text(7, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 5);
    \u0275\u0275listener("keyup", function UserComponent_Defer_3_Template_input_keyup_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.applyFilter($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "mat-table", 6);
    \u0275\u0275elementContainerStart(10, 7);
    \u0275\u0275template(11, UserComponent_Defer_3_mat_header_cell_11_Template, 2, 0, "mat-header-cell", 8)(12, UserComponent_Defer_3_mat_cell_12_Template, 2, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(13, 10);
    \u0275\u0275template(14, UserComponent_Defer_3_mat_header_cell_14_Template, 2, 0, "mat-header-cell", 8)(15, UserComponent_Defer_3_mat_cell_15_Template, 2, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(16, 11);
    \u0275\u0275template(17, UserComponent_Defer_3_mat_header_cell_17_Template, 2, 0, "mat-header-cell", 8)(18, UserComponent_Defer_3_mat_cell_18_Template, 2, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(19, 12);
    \u0275\u0275template(20, UserComponent_Defer_3_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 8)(21, UserComponent_Defer_3_mat_cell_21_Template, 2, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 13);
    \u0275\u0275template(23, UserComponent_Defer_3_mat_header_cell_23_Template, 2, 0, "mat-header-cell", 8)(24, UserComponent_Defer_3_mat_cell_24_Template, 3, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(25, 14);
    \u0275\u0275template(26, UserComponent_Defer_3_mat_header_cell_26_Template, 2, 0, "mat-header-cell", 8)(27, UserComponent_Defer_3_mat_cell_27_Template, 2, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(28, 15);
    \u0275\u0275template(29, UserComponent_Defer_3_mat_header_cell_29_Template, 1, 0, "mat-header-cell", 16)(30, UserComponent_Defer_3_mat_cell_30_Template, 2, 1, "mat-cell", 9);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(31, UserComponent_Defer_3_mat_header_row_31_Template, 1, 0, "mat-header-row", 17)(32, UserComponent_Defer_3_mat_row_32_Template, 1, 0, "mat-row", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275element(33, "mat-paginator", 19);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance(6);
    \u0275\u0275property("dataSource", ctx_r1.dataSource);
    \u0275\u0275advance(22);
    \u0275\u0275property("matHeaderRowDef", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(5, _c04));
  }
}
function UserComponent_DeferPlaceholder_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 26);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _UserComponent = class _UserComponent {
  constructor() {
    this.subscription = new Subscription();
    this.profileService = inject(ProfileService);
    this.userService = inject(UserService);
    this.userApiService = inject(UserApiService);
    this.validationService = inject(ValidationService);
    this.dialog = inject(MatDialog);
    this.title = "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E1A\u0E31\u0E0D\u0E0A\u0E35\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19";
    this.profileId = this.profileService.get().id;
    this.displayedColumns = [
      "no",
      "email",
      "name",
      "role",
      "active",
      "remark",
      "action"
    ];
    this.dataSource = new MatTableDataSource([]);
    this.isFirstLoading = false;
  }
  ngOnInit() {
    this.initDataSource();
    this.subscription = this.userService.onListener().subscribe(() => this.dataSource.data = this.userService.getTableData());
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onCreate() {
    this.dialog.open(UserEditComponent, {
      width: "500px",
      disableClose: true
    });
  }
  onUpdate(item) {
    this.dialog.open(UserEditComponent, {
      data: item,
      width: "500px",
      disableClose: true
    });
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  initDataSource() {
    this.dataSource.data = this.userService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data))
      this.userApiService.getAll().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
    });
  }
};
_UserComponent.\u0275fac = function UserComponent_Factory(t2) {
  return new (t2 || _UserComponent)();
};
_UserComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _UserComponent, selectors: [["app-user"]], viewQuery: function UserComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
  }
}, decls: 7, vars: 1, consts: [[300], ["mat-fab", "", "color", "primary", 1, "mb-20", 3, "click"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "w-100"], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "email"], ["matColumnDef", "name"], ["matColumnDef", "role"], ["matColumnDef", "active"], ["matColumnDef", "remark"], ["matColumnDef", "action"], [4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], ["mat-sort-header", ""], [1, "toggle-on"], [1, "toggle-off"], ["mat-icon-button", ""], ["mat-icon-button", "", 3, "click"], ["color", "accent"], [3, "form"]], template: function UserComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 1);
    \u0275\u0275listener("click", function UserComponent_Template_button_click_0_listener() {
      return ctx.onCreate();
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(3, UserComponent_Defer_3_Template, 34, 6)(4, UserComponent_DeferPlaceholder_4_Template, 1, 1);
    \u0275\u0275defer(5, 3, UserComponent_Defer_5_DepsFn, null, 4, null, null, 0, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(5);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
  }
}, dependencies: [MatFabButton, MatIcon, LoadingDataComponent], styles: ["\n\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-email[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.mat-column-name[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.mat-column-role[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-active[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  flex: 0 0 100px;\n}\n.mat-column-remark[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n/*# sourceMappingURL=user.component.css.map */"] });
var UserComponent = _UserComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(UserComponent, { className: "UserComponent", filePath: "src\\app\\modules\\dashboard\\components\\user\\user.component.ts", lineNumber: 27 });
})();

// src/app/modules/dashboard/services/category/category-api.service.ts
var _CategoryApiService = class _CategoryApiService {
  constructor(http, categoryService, socketCategoryService) {
    this.http = http;
    this.categoryService = categoryService;
    this.socketCategoryService = socketCategoryService;
    this.apiUrl = environment.apiUrl + "category";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(tap((res) => this.categoryService.assign(res)));
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => {
      this.categoryService.create(res.item);
      this.socketCategoryService.create(res.item);
    }));
  }
  update(id, payload) {
    return this.http.put(`${this.apiUrl}/${id}`, payload).pipe(tap((res) => {
      this.categoryService.update(id, res.item);
      this.socketCategoryService.update(id, res.item);
    }));
  }
  delete(id) {
    return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap((res) => {
      this.categoryService.delete(id);
      this.socketCategoryService.delete(id);
    }));
  }
};
_CategoryApiService.\u0275fac = function CategoryApiService_Factory(t2) {
  return new (t2 || _CategoryApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(CategoryService), \u0275\u0275inject(SocketCategoryService));
};
_CategoryApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _CategoryApiService, factory: _CategoryApiService.\u0275fac, providedIn: "root" });
var CategoryApiService = _CategoryApiService;

// src/app/modules/dashboard/constants/category.constant.ts
var CATEGORY = {
  validationField: {
    name: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17" },
    active: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19" }
  }
};

// src/app/modules/dashboard/components/category/category-edit/category-edit.component.ts
var _c05 = ["formDirec"];
var _c13 = ["nameInput"];
function CategoryEditComponent_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 15);
  }
}
var _CategoryEditComponent = class _CategoryEditComponent {
  constructor() {
    this.data = inject(MAT_DIALOG_DATA);
    this.formBuilder = inject(FormBuilder);
    this.dialogRef = inject(MatDialogRef);
    this.categoryApiService = inject(CategoryApiService);
    this.toastService = inject(ToastNotificationService);
    this.validationField = CATEGORY.validationField;
    this.title = "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17";
    this.isEdit = false;
    this.isLoading = false;
    this.form = this.initForm();
  }
  ngOnInit() {
    if (this.data) {
      this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17";
      this.isEdit = true;
      this.form.patchValue(this.data);
    }
    this.dialogRef.keydownEvents().subscribe((event) => event.key === "Escape" && this.onCloseDialog());
    this.dialogRef.backdropClick().subscribe(() => this.onCloseDialog());
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    if (JSON.stringify(this.data) === JSON.stringify(this.form.value))
      return;
    const _a2 = __spreadValues({}, this.form.getRawValue()), { id } = _a2, payload = __objRest(_a2, ["id"]);
    this.isLoading = true;
    this.operation$ = this.isEdit ? this.categoryApiService.update(id, payload) : this.categoryApiService.create(payload);
    this.operation$.pipe(catchError((error) => {
      if (error.status === 0)
        this.dialogRef.close();
      return throwError(() => error);
    }), finalize(() => this.isLoading = false)).subscribe((res) => {
      if (this.isEdit)
        this.dialogRef.close();
      else
        this.onReset();
      this.toastService.success("Success", res.message);
    });
  }
  onReset() {
    if (this.isEdit)
      this.form.patchValue(this.data);
    else
      this.formDirec.resetForm();
    this.nameInput.nativeElement.focus();
  }
  newDialogBackdropHandler() {
    const isChange = this.name.value !== "" || this.remark.value !== "";
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  editDialogBackdropHandler() {
    const isChange = this.name.value !== this.data.name || this.active.value !== this.data.active || this.remark.value !== this.data.remark;
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  confirmDialogBackdropHandler() {
    const confirmation = confirm("\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01\u0E01\u0E32\u0E23\u0E41\u0E01\u0E49\u0E44\u0E02\u0E41\u0E25\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E1F\u0E2D\u0E23\u0E4C\u0E21\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48?");
    if (confirmation)
      this.dialogRef.close();
  }
  onCloseDialog() {
    if (this.isEdit)
      this.editDialogBackdropHandler();
    else
      this.newDialogBackdropHandler();
  }
  get name() {
    return this.form.controls["name"];
  }
  get active() {
    return this.form.controls["active"];
  }
  get remark() {
    return this.form.controls["remark"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      id: [null],
      name: ["", [Validators.required]],
      active: [true, [Validators.required]],
      remark: [""]
    });
  }
};
_CategoryEditComponent.\u0275fac = function CategoryEditComponent_Factory(t2) {
  return new (t2 || _CategoryEditComponent)();
};
_CategoryEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CategoryEditComponent, selectors: [["app-category-edit"]], viewQuery: function CategoryEditComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c05, 5);
    \u0275\u0275viewQuery(_c13, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.formDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.nameInput = _t2.first);
  }
}, decls: 33, vars: 7, consts: [["formDirec", "ngForm"], ["nameInput", ""], [1, "d-flex", "justify-between", "align-center"], ["mat-dialog-title", ""], ["mat-icon-button", "", "tabindex", "-1", 1, "btn-close", 3, "click"], [3, "ngSubmit", "formGroup"], [1, "form-container"], [1, "box"], ["type", "text", "matInput", "", "formControlName", "name"], [3, "control", "errorMessage"], ["type", "text", "matInput", "", "formControlName", "remark"], [1, "d-flex", "gap-10"], ["formControlName", "active"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], ["mode", "indeterminate"]], template: function CategoryEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "h2", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 4);
    \u0275\u0275listener("click", function CategoryEditComponent_Template_button_click_3_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseDialog());
    });
    \u0275\u0275elementStart(4, "mat-icon");
    \u0275\u0275text(5, "close");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "form", 5, 0);
    \u0275\u0275listener("ngSubmit", function CategoryEditComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSubmit());
    });
    \u0275\u0275element(8, "mat-divider");
    \u0275\u0275elementStart(9, "mat-dialog-content", 6)(10, "div", 7)(11, "mat-form-field")(12, "mat-label");
    \u0275\u0275text(13, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "input", 8, 1);
    \u0275\u0275elementStart(16, "mat-error");
    \u0275\u0275element(17, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "mat-form-field")(19, "mat-label");
    \u0275\u0275text(20, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(21, "input", 10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 11);
    \u0275\u0275element(23, "mat-slide-toggle", 12);
    \u0275\u0275elementStart(24, "span");
    \u0275\u0275text(25, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(26, "mat-divider");
    \u0275\u0275elementStart(27, "mat-dialog-actions")(28, "button", 13);
    \u0275\u0275text(29, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "button", 14);
    \u0275\u0275listener("click", function CategoryEditComponent_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onReset());
    });
    \u0275\u0275text(31, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(32, CategoryEditComponent_Conditional_32_Template, 1, 0, "mat-progress-bar", 15);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(11);
    \u0275\u0275property("control", ctx.name)("errorMessage", ctx.validationField.name);
    \u0275\u0275advance(11);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(32, ctx.isLoading ? 32 : -1);
  }
}, dependencies: [\u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatDivider, MatInput, MatFormField, MatLabel, MatError, MatProgressBar, MatSlideToggle, MatDialogTitle, MatDialogActions, MatDialogContent, ErrorFieldComponent] });
var CategoryEditComponent = _CategoryEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CategoryEditComponent, { className: "CategoryEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\category\\category-edit\\category-edit.component.ts", lineNumber: 27 });
})();

// src/app/modules/dashboard/components/category/category.component.ts
var CategoryComponent_Defer_5_DepsFn = () => [MatIconButton, MatIcon, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader];
var _c06 = () => [10, 25, 50, 100];
function CategoryComponent_Defer_3_mat_header_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function CategoryComponent_Defer_3_mat_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r3.no, " ");
  }
}
function CategoryComponent_Defer_3_mat_header_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
  }
}
function CategoryComponent_Defer_3_mat_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r4.name, " ");
  }
}
function CategoryComponent_Defer_3_mat_header_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd();
  }
}
function CategoryComponent_Defer_3_mat_cell_18_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 20);
    \u0275\u0275text(1, "toggle_on");
    \u0275\u0275elementEnd();
  }
}
function CategoryComponent_Defer_3_mat_cell_18_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 21);
    \u0275\u0275text(1, "toggle_off");
    \u0275\u0275elementEnd();
  }
}
function CategoryComponent_Defer_3_mat_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275template(1, CategoryComponent_Defer_3_mat_cell_18_Conditional_1_Template, 2, 0, "mat-icon", 20)(2, CategoryComponent_Defer_3_mat_cell_18_Conditional_2_Template, 2, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(1, element_r5.active ? 1 : 2);
  }
}
function CategoryComponent_Defer_3_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
  }
}
function CategoryComponent_Defer_3_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r6.remark, " ");
  }
}
function CategoryComponent_Defer_3_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function CategoryComponent_Defer_3_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell")(1, "button", 22);
    \u0275\u0275listener("click", function CategoryComponent_Defer_3_mat_cell_24_Template_button_click_1_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onUpdate(element_r8));
    });
    \u0275\u0275elementStart(2, "mat-icon", 23);
    \u0275\u0275text(3, "edit");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "button", 24);
    \u0275\u0275listener("click", function CategoryComponent_Defer_3_mat_cell_24_Template_button_click_4_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onConfirm(element_r8.id, element_r8.name));
    });
    \u0275\u0275elementStart(5, "mat-icon");
    \u0275\u0275text(6, "delete");
    \u0275\u0275elementEnd()()();
  }
}
function CategoryComponent_Defer_3_mat_header_row_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function CategoryComponent_Defer_3_mat_row_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function CategoryComponent_Defer_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 3)(1, "mat-card-header", 4)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "mat-form-field", 5)(6, "mat-label");
    \u0275\u0275text(7, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 6);
    \u0275\u0275listener("keyup", function CategoryComponent_Defer_3_Template_input_keyup_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.applyFilter($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "mat-table", 7);
    \u0275\u0275elementContainerStart(10, 8);
    \u0275\u0275template(11, CategoryComponent_Defer_3_mat_header_cell_11_Template, 2, 0, "mat-header-cell", 9)(12, CategoryComponent_Defer_3_mat_cell_12_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(13, 11);
    \u0275\u0275template(14, CategoryComponent_Defer_3_mat_header_cell_14_Template, 2, 0, "mat-header-cell", 9)(15, CategoryComponent_Defer_3_mat_cell_15_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(16, 12);
    \u0275\u0275template(17, CategoryComponent_Defer_3_mat_header_cell_17_Template, 2, 0, "mat-header-cell", 9)(18, CategoryComponent_Defer_3_mat_cell_18_Template, 3, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(19, 13);
    \u0275\u0275template(20, CategoryComponent_Defer_3_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 9)(21, CategoryComponent_Defer_3_mat_cell_21_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 14);
    \u0275\u0275template(23, CategoryComponent_Defer_3_mat_header_cell_23_Template, 1, 0, "mat-header-cell", 15)(24, CategoryComponent_Defer_3_mat_cell_24_Template, 7, 0, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(25, CategoryComponent_Defer_3_mat_header_row_25_Template, 1, 0, "mat-header-row", 16)(26, CategoryComponent_Defer_3_mat_row_26_Template, 1, 0, "mat-row", 17);
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "mat-paginator", 18);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance(6);
    \u0275\u0275property("dataSource", ctx_r1.dataSource);
    \u0275\u0275advance(16);
    \u0275\u0275property("matHeaderRowDef", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(5, _c06));
  }
}
function CategoryComponent_DeferPlaceholder_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 25);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _CategoryComponent = class _CategoryComponent {
  constructor() {
    this.subscription = new Subscription();
    this.categoryService = inject(CategoryService);
    this.categoryApiService = inject(CategoryApiService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.dialog = inject(MatDialog);
    this.title = "\u0E23\u0E32\u0E22\u0E0A\u0E37\u0E48\u0E2D\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17";
    this.displayedColumns = ["no", "name", "active", "remark", "action"];
    this.dataSource = new MatTableDataSource([]);
    this.isFirstLoading = false;
  }
  ngOnInit() {
    this.initDataSource();
    this.subscription = this.categoryService.onListener().subscribe(() => this.dataSource.data = this.categoryService.getTableData());
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onCreate() {
    this.dialog.open(CategoryEditComponent, {
      width: "500px",
      disableClose: true
    });
  }
  onUpdate(item) {
    this.dialog.open(CategoryEditComponent, {
      data: item,
      width: "500px",
      disableClose: true
    });
  }
  onConfirm(id, title) {
    this.id = id;
    this.sweetAlertTitle = `\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E1A ${title}?`;
    this.sweetAlert.alert(this.sweetAlertTitle);
  }
  onDelete(confirm2) {
    if (!confirm2)
      return;
    this.categoryApiService.delete(this.id).subscribe((res) => this.toastService.info("Info", res.message));
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  initDataSource() {
    this.dataSource.data = this.categoryService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data))
      this.categoryApiService.getAll().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
    });
  }
};
_CategoryComponent.\u0275fac = function CategoryComponent_Factory(t2) {
  return new (t2 || _CategoryComponent)();
};
_CategoryComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CategoryComponent, selectors: [["app-category"]], viewQuery: function CategoryComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(SweetAlertComponent, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sweetAlert = _t2.first);
  }
}, decls: 8, vars: 2, consts: [[300], ["mat-fab", "", "color", "primary", 1, "mb-20", 3, "click"], [3, "confirm", "icon"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "w-100"], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "name"], ["matColumnDef", "active"], ["matColumnDef", "remark"], ["matColumnDef", "action"], [4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], ["mat-sort-header", ""], [1, "toggle-on"], [1, "toggle-off"], ["mat-icon-button", "", 3, "click"], ["color", "accent"], ["mat-icon-button", "", "color", "warn", 3, "click"], [3, "form"]], template: function CategoryComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 1);
    \u0275\u0275listener("click", function CategoryComponent_Template_button_click_0_listener() {
      return ctx.onCreate();
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(3, CategoryComponent_Defer_3_Template, 28, 6)(4, CategoryComponent_DeferPlaceholder_4_Template, 1, 1);
    \u0275\u0275defer(5, 3, CategoryComponent_Defer_5_DepsFn, null, 4, null, null, 0, \u0275\u0275deferEnableTimerScheduling);
    \u0275\u0275elementStart(7, "app-sweet-alert", 2);
    \u0275\u0275listener("confirm", function CategoryComponent_Template_app_sweet_alert_confirm_7_listener($event) {
      return ctx.onDelete($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(5);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", "error");
  }
}, dependencies: [MatFabButton, MatIcon, LoadingDataComponent, SweetAlertComponent], styles: ["\n\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-name[_ngcontent-%COMP%] {\n  min-width: 120px;\n}\n.mat-column-active[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-remark[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  justify-content: center;\n}\n/*# sourceMappingURL=table-styles.css.map */"] });
var CategoryComponent = _CategoryComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CategoryComponent, { className: "CategoryComponent", filePath: "src\\app\\modules\\dashboard\\components\\category\\category.component.ts", lineNumber: 31 });
})();

// src/app/modules/dashboard/constants/profile.constant.ts
var PROFILE = {
  validationField: {
    email: {
      required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 E-mail",
      email: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 E-mail \u0E43\u0E2B\u0E49\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07 (example@gmail.com)"
    },
    firstname: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E0A\u0E37\u0E48\u0E2D" },
    lastname: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E19\u0E32\u0E21\u0E2A\u0E01\u0E38\u0E25" },
    role: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E34\u0E17\u0E18\u0E34", oneOf: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E40\u0E25\u0E37\u0E2D\u0E01 user \u0E2B\u0E23\u0E37\u0E2D admin" }
  }
};

// src/app/modules/dashboard/components/profile/profile.component.ts
var ProfileComponent_Defer_2_DepsFn = () => [\u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatError, MatProgressBar, ErrorFieldComponent];
function ProfileComponent_Defer_0_Conditional_41_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 14);
  }
}
function ProfileComponent_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card")(1, "mat-card-header", 1)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 2);
    \u0275\u0275listener("click", function ProfileComponent_Defer_0_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onReset());
    });
    \u0275\u0275text(5, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "form", 3);
    \u0275\u0275listener("ngSubmit", function ProfileComponent_Defer_0_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275elementStart(7, "mat-card-content", 4)(8, "mat-form-field")(9, "mat-label");
    \u0275\u0275text(10, "E-mail");
    \u0275\u0275elementEnd();
    \u0275\u0275element(11, "input", 5);
    \u0275\u0275elementStart(12, "mat-error");
    \u0275\u0275element(13, "app-error-field", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 7)(15, "mat-form-field")(16, "mat-label");
    \u0275\u0275text(17, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(18, "input", 8);
    \u0275\u0275elementStart(19, "mat-error");
    \u0275\u0275element(20, "app-error-field", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(21, "mat-form-field")(22, "mat-label");
    \u0275\u0275text(23, "\u0E19\u0E32\u0E21\u0E2A\u0E01\u0E38\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275element(24, "input", 9);
    \u0275\u0275elementStart(25, "mat-error");
    \u0275\u0275element(26, "app-error-field", 6);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(27, "mat-form-field")(28, "mat-label");
    \u0275\u0275text(29, "\u0E2A\u0E34\u0E17\u0E18\u0E34");
    \u0275\u0275elementEnd();
    \u0275\u0275element(30, "input", 10);
    \u0275\u0275elementStart(31, "mat-error");
    \u0275\u0275element(32, "app-error-field", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(33, "mat-form-field")(34, "mat-label");
    \u0275\u0275text(35, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(36, "input", 11);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(37, "mat-card-actions", 12)(38, "button", 13);
    \u0275\u0275text(39, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(40, "mat-card-footer");
    \u0275\u0275template(41, ProfileComponent_Defer_0_Conditional_41_Template, 1, 0, "mat-progress-bar", 14);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.form);
    \u0275\u0275advance(7);
    \u0275\u0275property("control", ctx_r1.email)("errorMessage", ctx_r1.validationField.email);
    \u0275\u0275advance(7);
    \u0275\u0275property("control", ctx_r1.firstname)("errorMessage", ctx_r1.validationField.firstname);
    \u0275\u0275advance(6);
    \u0275\u0275property("control", ctx_r1.lastname)("errorMessage", ctx_r1.validationField.lastname);
    \u0275\u0275advance(6);
    \u0275\u0275property("control", ctx_r1.role)("errorMessage", ctx_r1.validationField.role);
    \u0275\u0275advance(6);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(41, ctx_r1.isLoading ? 41 : -1);
  }
}
function ProfileComponent_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 15);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _ProfileComponent = class _ProfileComponent {
  constructor() {
    this.subscription = new Subscription();
    this.profileService = inject(ProfileService);
    this.ProfileApiService = inject(ProfileApiService);
    this.formBuilder = inject(FormBuilder);
    this.validationField = PROFILE.validationField;
    this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E42\u0E1B\u0E23\u0E44\u0E1F\u0E25\u0E4C";
    this.isLoading = false;
    this.form = this.initForm();
  }
  ngOnInit() {
    this.subscription = this.profileService.onListener().subscribe((profile) => {
      this.profile = profile;
      this.form.patchValue(this.profile);
    });
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    const payload = __spreadValues({}, this.form.value);
    this.isLoading = true;
    this.ProfileApiService.update(payload).pipe(finalize(() => this.isLoading = false)).subscribe();
  }
  onReset() {
    this.form.patchValue(this.profile);
  }
  get email() {
    return this.form.controls["email"];
  }
  get firstname() {
    return this.form.controls["firstname"];
  }
  get lastname() {
    return this.form.controls["lastname"];
  }
  get role() {
    return this.form.controls["role"];
  }
  get remark() {
    return this.form.controls["remark"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      email: ["", [Validators.required, Validators.email]],
      firstname: ["", [Validators.required]],
      lastname: ["", [Validators.required]],
      role: [{ value: "", disabled: true }, [Validators.required]],
      remark: [""]
    });
  }
};
_ProfileComponent.\u0275fac = function ProfileComponent_Factory(t2) {
  return new (t2 || _ProfileComponent)();
};
_ProfileComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProfileComponent, selectors: [["app-profile"]], decls: 4, vars: 1, consts: [[500], [1, "justify-between"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], [1, "form-container", 3, "ngSubmit", "formGroup"], [1, "box"], ["type", "email", "matInput", "", "formControlName", "email"], [3, "control", "errorMessage"], [1, "row"], ["type", "text", "matInput", "", "formControlName", "firstname"], ["type", "text", "matInput", "", "formControlName", "lastname"], ["type", "text", "matInput", "", "formControlName", "role"], ["type", "text", "matInput", "", "formControlName", "remark"], [1, "gap-10"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["mode", "indeterminate"], [3, "form"]], template: function ProfileComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ProfileComponent_Defer_0_Template, 42, 13)(1, ProfileComponent_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, ProfileComponent_Defer_2_DepsFn, null, 1, null, null, 0, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275deferWhen(ctx.profile);
  }
}, dependencies: [LoadingDataComponent] });
var ProfileComponent = _ProfileComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProfileComponent, { className: "ProfileComponent", filePath: "src\\app\\modules\\dashboard\\components\\profile\\profile.component.ts", lineNumber: 14 });
})();

// src/app/modules/dashboard/constants/password.constant.ts
var PASSWORD = {
  patternPassword: /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$ %^&*-]).{8,}$/,
  validationField: {
    oldPassword: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E40\u0E01\u0E48\u0E32" },
    newPassword: {
      required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E43\u0E2B\u0E21\u0E48",
      pattern: "\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35\u0E15\u0E31\u0E27\u0E40\u0E25\u0E47\u0E01, \u0E15\u0E31\u0E27\u0E43\u0E2B\u0E0D\u0E48, \u0E15\u0E31\u0E27\u0E40\u0E25\u0E02, \u0E2D\u0E31\u0E01\u0E29\u0E23\u0E1E\u0E34\u0E40\u0E28\u0E29 \u0E41\u0E25\u0E30\u0E44\u0E21\u0E48\u0E15\u0E48\u0E33\u0E01\u0E27\u0E48\u0E32 8 \u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23"
    },
    confirmPassword: {
      required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E43\u0E2B\u0E21\u0E48",
      match: "\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E19"
    }
  }
};

// src/app/modules/dashboard/components/password/password.component.ts
var _c07 = ["formDirec"];
var PasswordComponent_Defer_2_DepsFn = () => [RouterLink, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatAnchor, MatButton, MatIcon, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatError, MatSuffix, MatProgressBar, ErrorFieldComponent];
function PasswordComponent_Defer_0_Conditional_39_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 13);
  }
}
function PasswordComponent_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card")(1, "mat-card-header", 2)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 3);
    \u0275\u0275listener("click", function PasswordComponent_Defer_0_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onReset());
    });
    \u0275\u0275text(5, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "form", 4, 0);
    \u0275\u0275listener("ngSubmit", function PasswordComponent_Defer_0_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275elementStart(8, "mat-card-content", 5)(9, "mat-form-field")(10, "mat-label");
    \u0275\u0275text(11, "\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E40\u0E01\u0E48\u0E32");
    \u0275\u0275elementEnd();
    \u0275\u0275element(12, "input", 6);
    \u0275\u0275elementStart(13, "mat-icon", 7);
    \u0275\u0275listener("click", function PasswordComponent_Defer_0_Template_mat_icon_click_13_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideOldPassword = !ctx_r1.hideOldPassword);
    });
    \u0275\u0275text(14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "mat-error");
    \u0275\u0275element(16, "app-error-field", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "mat-form-field")(18, "mat-label");
    \u0275\u0275text(19, "\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E43\u0E2B\u0E21\u0E48");
    \u0275\u0275elementEnd();
    \u0275\u0275element(20, "input", 9);
    \u0275\u0275elementStart(21, "mat-icon", 7);
    \u0275\u0275listener("click", function PasswordComponent_Defer_0_Template_mat_icon_click_21_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideNewPassword = !ctx_r1.hideNewPassword);
    });
    \u0275\u0275text(22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "mat-error");
    \u0275\u0275element(24, "app-error-field", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(25, "mat-form-field")(26, "mat-label");
    \u0275\u0275text(27, "\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19\u0E43\u0E2B\u0E21\u0E48");
    \u0275\u0275elementEnd();
    \u0275\u0275element(28, "input", 10);
    \u0275\u0275elementStart(29, "mat-icon", 7);
    \u0275\u0275listener("click", function PasswordComponent_Defer_0_Template_mat_icon_click_29_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideConfirmPassword = !ctx_r1.hideConfirmPassword);
    });
    \u0275\u0275text(30);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "mat-error");
    \u0275\u0275element(32, "app-error-field", 8);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(33, "mat-card-actions", 2)(34, "button", 11);
    \u0275\u0275text(35, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "a", 12);
    \u0275\u0275text(37, "\u0E25\u0E37\u0E21\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19 ?");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "mat-card-footer");
    \u0275\u0275template(39, PasswordComponent_Defer_0_Conditional_39_Template, 1, 0, "mat-progress-bar", 13);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.form);
    \u0275\u0275advance(6);
    \u0275\u0275property("type", ctx_r1.hideOldPassword ? "password" : "text");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.hideOldPassword ? "visibility_off" : "visibility");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.oldPassword)("errorMessage", ctx_r1.validationField.oldPassword);
    \u0275\u0275advance(4);
    \u0275\u0275property("type", ctx_r1.hideNewPassword ? "password" : "text");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.hideNewPassword ? "visibility_off" : "visibility");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.newPassword)("errorMessage", ctx_r1.validationField.newPassword);
    \u0275\u0275advance(4);
    \u0275\u0275property("type", ctx_r1.hideConfirmPassword ? "password" : "text");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.hideConfirmPassword ? "visibility_off" : "visibility");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.confirmPassword)("errorMessage", ctx_r1.validationField.confirmPassword);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(5);
    \u0275\u0275conditional(39, ctx_r1.isLoading ? 39 : -1);
  }
}
function PasswordComponent_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 14);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _PasswordComponent = class _PasswordComponent {
  constructor() {
    this.profileService = inject(ProfileService);
    this.profileApiService = inject(ProfileApiService);
    this.formBuilder = inject(FormBuilder);
    this.validationService = inject(ValidationService);
    this.patternPassword = PASSWORD.patternPassword;
    this.validationField = PASSWORD.validationField;
    this.title = "\u0E40\u0E1B\u0E25\u0E35\u0E48\u0E22\u0E19\u0E23\u0E2B\u0E31\u0E2A\u0E1C\u0E48\u0E32\u0E19";
    this.isLoading = false;
    this.hideOldPassword = true;
    this.hideNewPassword = true;
    this.hideConfirmPassword = true;
    this.form = this.initForm();
  }
  ngOnInit() {
    this.profile = this.profileService.get();
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    this.isLoading = true;
    const payload = this.form.getRawValue();
    this.profileApiService.changePassword(payload).pipe(finalize(() => this.isLoading = false)).subscribe();
  }
  onReset() {
    this.formDirec.resetForm();
  }
  get oldPassword() {
    return this.form.controls["oldPassword"];
  }
  get newPassword() {
    return this.form.controls["newPassword"];
  }
  get confirmPassword() {
    return this.form.controls["confirmPassword"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      oldPassword: ["", [Validators.required]],
      newPassword: [
        "",
        [Validators.required, Validators.pattern(this.patternPassword)]
      ],
      confirmPassword: [""]
    }, {
      validators: this.validationService.comparePassword.bind(this, [
        "newPassword",
        "confirmPassword"
      ])
    });
  }
};
_PasswordComponent.\u0275fac = function PasswordComponent_Factory(t2) {
  return new (t2 || _PasswordComponent)();
};
_PasswordComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PasswordComponent, selectors: [["app-password"]], viewQuery: function PasswordComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c07, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.formDirec = _t2.first);
  }
}, decls: 4, vars: 1, consts: [["formDirec", "ngForm"], [500], [1, "justify-between"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], [1, "form-container", 3, "ngSubmit", "formGroup"], [1, "box"], ["matInput", "", "formControlName", "oldPassword", "autocomplete", "off", 3, "type"], ["matSuffix", "", 3, "click"], [3, "control", "errorMessage"], ["matInput", "", "formControlName", "newPassword", "autocomplete", "off", 3, "type"], ["matInput", "", "formControlName", "confirmPassword", "autocomplete", "off", 3, "type"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["mat-button", "", "routerLink", "/login/forgot-password"], ["mode", "indeterminate"], [3, "form"]], template: function PasswordComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PasswordComponent_Defer_0_Template, 40, 17)(1, PasswordComponent_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, PasswordComponent_Defer_2_DepsFn, null, 1, null, null, 1, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275deferWhen(ctx.profile);
  }
}, dependencies: [LoadingDataComponent] });
var PasswordComponent = _PasswordComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PasswordComponent, { className: "PasswordComponent", filePath: "src\\app\\modules\\dashboard\\components\\password\\password.component.ts", lineNumber: 20 });
})();

// src/app/modules/dashboard/services/status/status-api.service.ts
var _StatusApiService = class _StatusApiService {
  constructor(http, statusService, socketStatusService) {
    this.http = http;
    this.statusService = statusService;
    this.socketStatusService = socketStatusService;
    this.apiUrl = environment.apiUrl + "status";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(tap((res) => this.statusService.assign(res)));
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => {
      this.statusService.create(res.item);
      this.socketStatusService.create(res.item);
    }));
  }
  update(id, payload) {
    return this.http.put(`${this.apiUrl}/${id}`, payload).pipe(tap((res) => {
      this.statusService.update(id, res.item);
      this.socketStatusService.update(id, res.item);
    }));
  }
  delete(id) {
    return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap((res) => {
      this.statusService.delete(id);
      this.socketStatusService.delete(id);
    }));
  }
};
_StatusApiService.\u0275fac = function StatusApiService_Factory(t2) {
  return new (t2 || _StatusApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(StatusService), \u0275\u0275inject(SocketStatusService));
};
_StatusApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _StatusApiService, factory: _StatusApiService.\u0275fac, providedIn: "root" });
var StatusApiService = _StatusApiService;

// src/app/modules/dashboard/services/fund/fund-api.service.ts
var _FundApiService = class _FundApiService {
  constructor(http, fundService, socketFundService) {
    this.http = http;
    this.fundService = fundService;
    this.socketFundService = socketFundService;
    this.apiUrl = environment.apiUrl + "fund";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(tap((res) => this.fundService.assign(res)));
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => {
      this.fundService.create(res.item);
      this.socketFundService.create(res.item);
    }));
  }
  update(id, payload) {
    return this.http.put(`${this.apiUrl}/${id}`, payload).pipe(tap((res) => {
      this.fundService.update(id, res.item);
      this.socketFundService.update(id, res.item);
    }));
  }
  delete(id) {
    return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap((res) => {
      this.fundService.delete(id);
      this.socketFundService.delete(id);
    }));
  }
};
_FundApiService.\u0275fac = function FundApiService_Factory(t2) {
  return new (t2 || _FundApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(FundService), \u0275\u0275inject(SocketFundService));
};
_FundApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FundApiService, factory: _FundApiService.\u0275fac, providedIn: "root" });
var FundApiService = _FundApiService;

// src/app/modules/dashboard/services/location/location-api.service.ts
var _LocationApiService = class _LocationApiService {
  constructor(http, locationService, socketLocationService) {
    this.http = http;
    this.locationService = locationService;
    this.socketLocationService = socketLocationService;
    this.apiUrl = environment.apiUrl + "location";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(tap((res) => this.locationService.assign(res)));
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => {
      this.locationService.create(res.item);
      this.socketLocationService.create(res.item);
    }));
  }
  update(id, payload) {
    return this.http.put(`${this.apiUrl}/${id}`, payload).pipe(tap((res) => {
      this.locationService.update(id, res.item);
      this.socketLocationService.update(id, res.item);
    }));
  }
  delete(id) {
    return this.http.delete(`${this.apiUrl}/${id}`).pipe(tap((res) => {
      this.locationService.delete(id);
      this.socketLocationService.delete(id);
    }));
  }
};
_LocationApiService.\u0275fac = function LocationApiService_Factory(t2) {
  return new (t2 || _LocationApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(LocationService), \u0275\u0275inject(SocketLocationService));
};
_LocationApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LocationApiService, factory: _LocationApiService.\u0275fac, providedIn: "root" });
var LocationApiService = _LocationApiService;

// src/app/modules/dashboard/dashboard.resolver.ts
var dashboardResolver = (route, state) => {
  const profileService = inject(ProfileService);
  const userService = inject(UserService);
  const userApiService = inject(UserApiService);
  const categoryService = inject(CategoryService);
  const categoryApiService = inject(CategoryApiService);
  const statusService = inject(StatusService);
  const statusApiService = inject(StatusApiService);
  const fundService = inject(FundService);
  const fundApiService = inject(FundApiService);
  const locationService = inject(LocationService);
  const locationApiService = inject(LocationApiService);
  const validationService = inject(ValidationService);
  const loadingScreenService = inject(LoadingScreenService);
  const isAdmin = profileService.isAdmin();
  const users = validationService.isEmpty(userService.getAll());
  const categories = validationService.isEmpty(categoryService.getAll());
  const statuses = validationService.isEmpty(statusService.getAll());
  const funds = validationService.isEmpty(fundService.getAll());
  const locations = validationService.isEmpty(locationService.getAll());
  const operations$ = [];
  if (isAdmin && users)
    operations$.push(userApiService.getAll());
  if (categories)
    operations$.push(categoryApiService.getAll());
  if (statuses)
    operations$.push(statusApiService.getAll());
  if (funds)
    operations$.push(fundApiService.getAll());
  if (locations)
    operations$.push(locationApiService.getAll());
  if (!validationService.isEmpty(operations$)) {
    loadingScreenService.setIsLoading(true);
    return forkJoin(operations$).pipe(tap(() => loadingScreenService.setIsLoading(false)), map(() => true));
  }
  return true;
};

// src/app/modules/dashboard/components/print/print.component.ts
var _PrintComponent = class _PrintComponent {
};
_PrintComponent.\u0275fac = function PrintComponent_Factory(t2) {
  return new (t2 || _PrintComponent)();
};
_PrintComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PrintComponent, selectors: [["app-print"]], decls: 1, vars: 0, template: function PrintComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "router-outlet");
  }
}, dependencies: [RouterOutlet] });
var PrintComponent = _PrintComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PrintComponent, { className: "PrintComponent", filePath: "src\\app\\modules\\dashboard\\components\\print\\print.component.ts", lineNumber: 8 });
})();

// src/app/modules/dashboard/pipes/cut-detail.pipe.ts
var _CutDetailPipe = class _CutDetailPipe {
  transform(value2) {
    const maxLength = 50;
    if (value2.length < maxLength)
      return value2;
    const shortened = value2.slice(0, maxLength);
    const lastSpaceIndex = shortened.lastIndexOf(" ");
    return shortened.slice(0, lastSpaceIndex) + " ...";
  }
};
_CutDetailPipe.\u0275fac = function CutDetailPipe_Factory(t2) {
  return new (t2 || _CutDetailPipe)();
};
_CutDetailPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "cutDetail", type: _CutDetailPipe, pure: true });
var CutDetailPipe = _CutDetailPipe;

// src/app/modules/dashboard/components/print/print-list/print-list.component.ts
var _c08 = (a0) => ["./process", a0];
var _c14 = () => ["/inventory"];
var _c2 = () => ({ isPrint: true });
var _c3 = () => [10, 25, 50, 100];
var _c4 = (a0) => ["../inventory/view", a0];
function PrintListComponent_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 23);
    \u0275\u0275text(1, "\u0E23\u0E39\u0E1B");
    \u0275\u0275elementEnd();
  }
}
function PrintListComponent_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell", 24)(1, "a", 25);
    \u0275\u0275element(2, "img", 26);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const element_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(3, _c4, element_r1.id));
    \u0275\u0275advance();
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx_r1.imageUrl + element_r1.image);
  }
}
function PrintListComponent_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 23);
    \u0275\u0275text(1, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function PrintListComponent_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r3.code, " ");
  }
}
function PrintListComponent_mat_header_cell_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 23);
    \u0275\u0275text(1, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function PrintListComponent_mat_cell_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cutDetail");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, element_r4.description), " ");
  }
}
function PrintListComponent_mat_header_cell_29_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 23);
    \u0275\u0275text(1, "\u0E08\u0E33\u0E19\u0E27\u0E19\u0E1E\u0E34\u0E21\u0E1E\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function PrintListComponent_mat_cell_30_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell", 27)(1, "div", 28)(2, "button", 29);
    \u0275\u0275listener("click", function PrintListComponent_mat_cell_30_Template_button_click_2_listener() {
      const element_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.incrementPrintCount(element_r6.id));
    });
    \u0275\u0275elementStart(3, "mat-icon", 30);
    \u0275\u0275text(4, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "mat-form-field", 31)(6, "input", 32);
    \u0275\u0275listener("blur", function PrintListComponent_mat_cell_30_Template_input_blur_6_listener($event) {
      const element_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBlurPrintCount($event, element_r6.id));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "button", 29);
    \u0275\u0275listener("click", function PrintListComponent_mat_cell_30_Template_button_click_7_listener() {
      const element_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.decrementPrintCount(element_r6.id));
    });
    \u0275\u0275elementStart(8, "mat-icon", 30);
    \u0275\u0275text(9, "remove");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const element_r6 = ctx.$implicit;
    \u0275\u0275advance(6);
    \u0275\u0275property("value", element_r6.printCount);
  }
}
function PrintListComponent_mat_header_cell_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function PrintListComponent_mat_cell_33_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell", 27)(1, "button", 29);
    \u0275\u0275listener("click", function PrintListComponent_mat_cell_33_Template_button_click_1_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeleteInventory(element_r8.id));
    });
    \u0275\u0275elementStart(2, "mat-icon", 33);
    \u0275\u0275text(3, "close");
    \u0275\u0275elementEnd()()();
  }
}
function PrintListComponent_mat_header_row_34_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function PrintListComponent_mat_row_35_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
var _PrintListComponent = class _PrintListComponent {
  constructor() {
    this.subscription = new Subscription();
    this.printService = inject(PrintService);
    this.title = "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23 \u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.imageUrl = environment.imageUrl;
    this.isLoading = false;
    this.print = "1";
    this.displayedColumns = [
      "image",
      "code",
      "description",
      "printCount",
      "action"
    ];
    this.dataSource = new MatTableDataSource([]);
  }
  ngOnInit() {
    this.dataSource.data = this.printService.getAll();
    this.subscription = this.printService.onListener().subscribe((inventories) => this.dataSource.data = inventories);
  }
  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onReset() {
    this.printService.reset();
  }
  onBlurPrintCount(event, id) {
    const inventory = this.printService.getById(id);
    if (!inventory)
      return;
    const el = event.target;
    el.value = el.value.replace(/[^0-9]/g, "");
    if (+el.value <= 0)
      el.value = "1";
    if (+el.value >= 100)
      el.value = "100";
    this.printService.updateCount(id, +el.value);
  }
  incrementPrintCount(id) {
    this.printService.incrementCount(id);
  }
  decrementPrintCount(id) {
    this.printService.decrementCount(id);
  }
  onDeleteInventory(id) {
    this.printService.delete(id);
  }
};
_PrintListComponent.\u0275fac = function PrintListComponent_Factory(t2) {
  return new (t2 || _PrintListComponent)();
};
_PrintListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PrintListComponent, selectors: [["app-print-list"]], viewQuery: function PrintListComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
  }
}, decls: 37, vars: 15, consts: [[1, "d-flex", "justify-between", "gap-10", "mb-20"], [1, "d-flex", "gap-10"], [3, "ngModelChange", "ngModel"], ["value", "1", "checked", ""], ["value", "2"], ["mat-raised-button", "", "color", "primary", 3, "routerLink"], ["mat-raised-button", "", "color", "accent", 3, "routerLink", "queryParams"], [1, "mb-16", "d-flex", "justify-between", "align-center"], ["type", "button", "mat-button", "", "color", "warn", 3, "click"], ["matSort", "", 3, "dataSource"], ["matColumnDef", "image"], ["mat-sort-header", "", 4, "matHeaderCellDef"], ["style", "padding-block: 8px", 4, "matCellDef"], ["matColumnDef", "code"], [4, "matCellDef"], ["matColumnDef", "description"], ["matColumnDef", "printCount"], ["class", "p-0", 4, "matCellDef"], ["matColumnDef", "action"], [4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSize", "pageSizeOptions"], ["mat-sort-header", ""], [2, "padding-block", "8px"], ["tabindex", "-1", 1, "blurred-img", 3, "routerLink"], [3, "defaultImage", "lazyLoad"], [1, "p-0"], [1, "d-flex", "align-center"], ["mat-icon-button", "", "tabindex", "-1", 3, "click"], ["color", "accent"], [1, "printCount-field"], ["type", "number", "matInput", "", 3, "blur", "value"], ["color", "warn"]], template: function PrintListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "mat-radio-group", 2);
    \u0275\u0275twoWayListener("ngModelChange", function PrintListComponent_Template_mat_radio_group_ngModelChange_2_listener($event) {
      \u0275\u0275twoWayBindingSet(ctx.print, $event) || (ctx.print = $event);
      return $event;
    });
    \u0275\u0275elementStart(3, "mat-radio-button", 3);
    \u0275\u0275text(4, "\u0E04\u0E34\u0E27\u0E2D\u0E32\u0E23\u0E4C\u0E42\u0E04\u0E49\u0E14");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "mat-radio-button", 4);
    \u0275\u0275text(6, "\u0E1A\u0E32\u0E23\u0E4C\u0E42\u0E04\u0E49\u0E14");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "a", 5);
    \u0275\u0275text(8, " \u0E1E\u0E34\u0E21\u0E1E\u0E4C ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "a", 6);
    \u0275\u0275text(10, "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "mat-card")(12, "mat-card-header", 7)(13, "mat-card-title");
    \u0275\u0275text(14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "button", 8);
    \u0275\u0275listener("click", function PrintListComponent_Template_button_click_15_listener() {
      return ctx.onReset();
    });
    \u0275\u0275text(16, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "mat-card-content")(18, "mat-table", 9);
    \u0275\u0275elementContainerStart(19, 10);
    \u0275\u0275template(20, PrintListComponent_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 11)(21, PrintListComponent_mat_cell_21_Template, 3, 5, "mat-cell", 12);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 13);
    \u0275\u0275template(23, PrintListComponent_mat_header_cell_23_Template, 2, 0, "mat-header-cell", 11)(24, PrintListComponent_mat_cell_24_Template, 2, 1, "mat-cell", 14);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(25, 15);
    \u0275\u0275template(26, PrintListComponent_mat_header_cell_26_Template, 2, 0, "mat-header-cell", 11)(27, PrintListComponent_mat_cell_27_Template, 3, 3, "mat-cell", 14);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(28, 16);
    \u0275\u0275template(29, PrintListComponent_mat_header_cell_29_Template, 2, 0, "mat-header-cell", 11)(30, PrintListComponent_mat_cell_30_Template, 10, 1, "mat-cell", 17);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(31, 18);
    \u0275\u0275template(32, PrintListComponent_mat_header_cell_32_Template, 1, 0, "mat-header-cell", 19)(33, PrintListComponent_mat_cell_33_Template, 4, 0, "mat-cell", 17);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(34, PrintListComponent_mat_header_row_34_Template, 1, 0, "mat-header-row", 20)(35, PrintListComponent_mat_row_35_Template, 1, 0, "mat-row", 21);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(36, "mat-paginator", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275twoWayProperty("ngModel", ctx.print);
    \u0275\u0275advance(5);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(10, _c08, ctx.print));
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(12, _c14))("queryParams", \u0275\u0275pureFunction0(13, _c2));
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("dataSource", ctx.dataSource);
    \u0275\u0275advance(16);
    \u0275\u0275property("matHeaderRowDef", ctx.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("pageSize", 50)("pageSizeOptions", \u0275\u0275pureFunction0(14, _c3));
  }
}, dependencies: [RouterLink, NgControlStatus, MatAnchor, MatButton, MatIconButton, MatIcon, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatRadioGroup, MatRadioButton, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader, LazyLoadImageDirective, NgModel, CutDetailPipe], styles: ["\n\nimg[_ngcontent-%COMP%] {\n  width: 100px;\n  height: 100px;\n}\n.printCount-field[_ngcontent-%COMP%] {\n  margin-top: 20px;\n  width: 80px;\n}\n.mat-column-image[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-code[_ngcontent-%COMP%] {\n  flex: 0 0 140px;\n}\n.mat-column-description[_ngcontent-%COMP%] {\n  min-width: 200px;\n}\n.mat-column-printCount[_ngcontent-%COMP%] {\n  min-width: 200px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  min-width: 60px;\n}\n/*# sourceMappingURL=print-list.component.css.map */"] });
var PrintListComponent = _PrintListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PrintListComponent, { className: "PrintListComponent", filePath: "src\\app\\modules\\dashboard\\components\\print\\print-list\\print-list.component.ts", lineNumber: 22 });
})();

// src/app/modules/dashboard/services/log/log-api.service.ts
var _LogApiService = class _LogApiService {
  constructor(http, logService) {
    this.http = http;
    this.logService = logService;
    this.apiUrl = environment.apiUrl + "log";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.logService.assign(res)));
  }
  getInit() {
    return this.http.get(`${this.apiUrl}/init`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.logService.assign(res)));
  }
  getByDate(startDate, endDate) {
    return this.http.get(`${this.apiUrl}/date/${startDate}/${endDate}`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.logService.assign(res)));
  }
  getByTrack(track) {
    return this.http.get(`${this.apiUrl}/track/${track}`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.logService.assign(res)));
  }
  getByCode(code) {
    return this.http.get(`${this.apiUrl}/code/${code}`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.logService.assign(res)));
  }
  getById(id) {
    return this.http.get(`${this.apiUrl}/${id}`);
  }
};
_LogApiService.\u0275fac = function LogApiService_Factory(t2) {
  return new (t2 || _LogApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(LogService));
};
_LogApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LogApiService, factory: _LogApiService.\u0275fac, providedIn: "root" });
var LogApiService = _LogApiService;

// src/app/modules/dashboard/components/log/log-list/log-list.component.ts
var _c09 = ["filterInput"];
var LogListComponent_Defer_41_DepsFn = () => [RouterLink, NgClass, \u0275NgNoValidate, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader, MatSelect, MatSelectTrigger, MatOption, LazyLoadImageDirective, LoadingDataComponent, DatePipe, CutDetailPipe];
var _c15 = () => [10, 25, 50, 100];
var _c22 = (a0) => ["./view", a0];
var _c32 = (a0, a1) => ({ newParcel: a0, editParcel: a1 });
function LogListComponent_For_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-option", 17);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const code_r3 = ctx.$implicit;
    \u0275\u0275property("value", code_r3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(code_r3);
  }
}
function LogListComponent_button_27_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 25);
    \u0275\u0275listener("click", function LogListComponent_button_27_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.search.setValue(""));
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "close");
    \u0275\u0275elementEnd()();
  }
}
function LogListComponent_Conditional_38_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 24);
  }
}
function LogListComponent_Defer_39_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 31);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r4.category.value == null ? null : ctx_r4.category.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function LogListComponent_Defer_39_For_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 37);
    \u0275\u0275listener("click", function LogListComponent_Defer_39_For_16_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r8 = ctx.$implicit;
    \u0275\u0275property("value", category_r8);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(category_r8);
  }
}
function LogListComponent_Defer_39_Conditional_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 31);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r4.status.value == null ? null : ctx_r4.status.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function LogListComponent_Defer_39_For_25_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 37);
    \u0275\u0275listener("click", function LogListComponent_Defer_39_For_25_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const status_r10 = ctx.$implicit;
    \u0275\u0275property("value", status_r10);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(status_r10);
  }
}
function LogListComponent_Defer_39_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 31);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r4.inventory.value == null ? null : ctx_r4.inventory.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function LogListComponent_Defer_39_For_34_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 37);
    \u0275\u0275listener("click", function LogListComponent_Defer_39_For_34_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const inventory_r12 = ctx.$implicit;
    \u0275\u0275property("value", inventory_r12);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(inventory_r12);
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r13 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r13.no, " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E23\u0E39\u0E1B");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell")(1, "a", 51);
    \u0275\u0275element(2, "img", 52);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const element_r14 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(3, _c22, element_r14.id));
    \u0275\u0275advance();
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx_r4.imageUrl + element_r14.image);
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r15 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r15.code, " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r16 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r16.categoryName, " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r17 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r17.statusName, " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cutDetail");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r18 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, element_r18.description), " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_21_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " \u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_21_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, " \u0E41\u0E01\u0E49\u0E44\u0E02\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell")(1, "span", 53);
    \u0275\u0275template(2, LogListComponent_Defer_39_Conditional_40_mat_cell_21_Conditional_2_Template, 1, 0)(3, LogListComponent_Defer_39_Conditional_40_mat_cell_21_Conditional_3_Template, 1, 0);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const element_r19 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(2, _c32, element_r19.isCreated, !element_r19.isCreated));
    \u0275\u0275advance();
    \u0275\u0275conditional(2, element_r19.isCreated ? 2 : 3);
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 50);
    \u0275\u0275text(1, "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E2A\u0E23\u0E49\u0E32\u0E07 Log");
    \u0275\u0275elementEnd();
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "date");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r20 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(2, 1, element_r20.createdAt, "medium"), " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_div_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r21 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r21.track, " ");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_header_row_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function LogListComponent_Defer_39_Conditional_40_mat_row_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function LogListComponent_Defer_39_Conditional_40_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-table", 35);
    \u0275\u0275elementContainerStart(1, 38);
    \u0275\u0275template(2, LogListComponent_Defer_39_Conditional_40_mat_header_cell_2_Template, 2, 0, "mat-header-cell", 39)(3, LogListComponent_Defer_39_Conditional_40_mat_cell_3_Template, 2, 1, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(4, 41);
    \u0275\u0275template(5, LogListComponent_Defer_39_Conditional_40_mat_header_cell_5_Template, 2, 0, "mat-header-cell", 39)(6, LogListComponent_Defer_39_Conditional_40_mat_cell_6_Template, 3, 5, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(7, 42);
    \u0275\u0275template(8, LogListComponent_Defer_39_Conditional_40_mat_header_cell_8_Template, 2, 0, "mat-header-cell", 39)(9, LogListComponent_Defer_39_Conditional_40_mat_cell_9_Template, 2, 1, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(10, 43);
    \u0275\u0275template(11, LogListComponent_Defer_39_Conditional_40_mat_header_cell_11_Template, 2, 0, "mat-header-cell", 39)(12, LogListComponent_Defer_39_Conditional_40_mat_cell_12_Template, 2, 1, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(13, 44);
    \u0275\u0275template(14, LogListComponent_Defer_39_Conditional_40_mat_header_cell_14_Template, 2, 0, "mat-header-cell", 39)(15, LogListComponent_Defer_39_Conditional_40_mat_cell_15_Template, 2, 1, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(16, 45);
    \u0275\u0275template(17, LogListComponent_Defer_39_Conditional_40_mat_header_cell_17_Template, 2, 0, "mat-header-cell", 39)(18, LogListComponent_Defer_39_Conditional_40_mat_cell_18_Template, 3, 3, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(19, 46);
    \u0275\u0275template(20, LogListComponent_Defer_39_Conditional_40_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 39)(21, LogListComponent_Defer_39_Conditional_40_mat_cell_21_Template, 4, 5, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 47);
    \u0275\u0275template(23, LogListComponent_Defer_39_Conditional_40_mat_header_cell_23_Template, 2, 0, "mat-header-cell", 39)(24, LogListComponent_Defer_39_Conditional_40_mat_cell_24_Template, 3, 4, "mat-cell", 40);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(25, LogListComponent_Defer_39_Conditional_40_div_25_Template, 2, 1, "div", 40)(26, LogListComponent_Defer_39_Conditional_40_mat_header_row_26_Template, 1, 0, "mat-header-row", 48)(27, LogListComponent_Defer_39_Conditional_40_mat_row_27_Template, 1, 0, "mat-row", 49);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275property("dataSource", ctx_r4.dataSource);
    \u0275\u0275advance(26);
    \u0275\u0275property("matHeaderRowDef", ctx_r4.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r4.displayedColumns);
  }
}
function LogListComponent_Defer_39_Conditional_41_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 54);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "list");
  }
}
function LogListComponent_Defer_39_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 26)(1, "mat-card-header", 27)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 28);
    \u0275\u0275listener("click", function LogListComponent_Defer_39_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.onResetFilter());
    });
    \u0275\u0275text(5, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "mat-card-content")(7, "form", 29)(8, "mat-form-field")(9, "mat-label");
    \u0275\u0275text(10, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "mat-select", 30)(12, "mat-select-trigger");
    \u0275\u0275text(13);
    \u0275\u0275template(14, LogListComponent_Defer_39_Conditional_14_Template, 2, 1, "span", 31);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(15, LogListComponent_Defer_39_For_16_Template, 2, 2, "mat-option", 17, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "mat-form-field")(18, "mat-label");
    \u0275\u0275text(19, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "mat-select", 32)(21, "mat-select-trigger");
    \u0275\u0275text(22);
    \u0275\u0275template(23, LogListComponent_Defer_39_Conditional_23_Template, 2, 1, "span", 31);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(24, LogListComponent_Defer_39_For_25_Template, 2, 2, "mat-option", 17, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "mat-form-field")(27, "mat-label");
    \u0275\u0275text(28, "\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(29, "mat-select", 33)(30, "mat-select-trigger");
    \u0275\u0275text(31);
    \u0275\u0275template(32, LogListComponent_Defer_39_Conditional_32_Template, 2, 1, "span", 31);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(33, LogListComponent_Defer_39_For_34_Template, 2, 2, "mat-option", 17, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(35, "mat-form-field")(36, "mat-label");
    \u0275\u0275text(37, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(38, "input", 34, 2);
    \u0275\u0275listener("keyup", function LogListComponent_Defer_39_Template_input_keyup_38_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.applyFilter($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(40, LogListComponent_Defer_39_Conditional_40_Template, 28, 3, "mat-table", 35)(41, LogListComponent_Defer_39_Conditional_41_Template, 1, 1);
    \u0275\u0275element(42, "mat-paginator", 36);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r4.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx_r4.form);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", (ctx_r4.category.value == null ? null : ctx_r4.category.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(14, ((ctx_r4.category.value == null ? null : ctx_r4.category.value.length) || 0) > 1 ? 14 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.filterLog.categories);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1(" ", (ctx_r4.status.value == null ? null : ctx_r4.status.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(23, ((ctx_r4.status.value == null ? null : ctx_r4.status.value.length) || 0) > 1 ? 23 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.filterLog.statuses);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1(" ", (ctx_r4.inventory.value == null ? null : ctx_r4.inventory.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(32, ((ctx_r4.inventory.value == null ? null : ctx_r4.inventory.value.length) || 0) > 1 ? 32 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.filterLog.inventories);
    \u0275\u0275advance(7);
    \u0275\u0275conditional(40, !ctx_r4.isLoading ? 40 : 41);
    \u0275\u0275advance(2);
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(10, _c15));
  }
}
function LogListComponent_DeferPlaceholder_40_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 54);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "list");
  }
}
var Tap2;
(function(Tap4) {
  Tap4[Tap4["Date"] = 0] = "Date";
  Tap4[Tap4["Code"] = 1] = "Code";
})(Tap2 || (Tap2 = {}));
var _LogListComponent = class _LogListComponent {
  constructor() {
    this.subscription = new Subscription();
    this.formBuilder = inject(FormBuilder);
    this.categoryService = inject(CategoryService);
    this.statusService = inject(StatusService);
    this.logService = inject(LogService);
    this.logApiService = inject(LogApiService);
    this.validationService = inject(ValidationService);
    this.searchService = inject(SearchService);
    this.datePipe = inject(DatePipe);
    this.imageUrl = environment.imageUrl;
    this.title = "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23 \u0E1B\u0E23\u0E30\u0E27\u0E49\u0E15\u0E34\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.filterLog = {
      inventories: ["\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C", "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C"],
      categories: this.categoryService.getActiveNames(),
      statuses: this.statusService.getActiveNames()
    };
    this.form = this.initForm();
    this.isLoading = false;
    this.selectedTap = new FormControl(Tap2.Date);
    this.startDate = new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
    this.endDate = /* @__PURE__ */ new Date();
    this.dateRange = this.formBuilder.group({
      start: [this.startDate, [Validators.required]],
      end: [this.endDate, [Validators.required]]
    });
    this.displayedColumns = [
      "no",
      "image",
      "code",
      "category",
      "status",
      "isCreated",
      "description",
      "createdAt"
    ];
    this.dataSource = new MatTableDataSource([]);
    this.isFirstLoading = false;
    this.isSort = false;
    this.search = new FormControl();
    this.cache = this.searchService.getCache();
  }
  ngOnInit() {
    this.initDataSource();
    this.initSubscriptions();
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSearchAutoComplete(query) {
    this.searchService.search$.next(query);
  }
  onSearch() {
    if (this.selectedTap.value === Tap2.Date) {
      if (this.dateRange.invalid)
        return;
      const startDate = this.datePipe.transform(this.dateRange.controls["start"].value, "yyyy-MM-dd");
      const endDate = this.datePipe.transform(this.dateRange.controls["end"].value, "yyyy-MM-dd");
      this.operation$ = this.logApiService.getByDate(startDate, endDate);
    } else if (this.selectedTap.value === Tap2.Code) {
      if (!this.search)
        return;
      const code = this.search.value.replace(/^\s+|\s+$/gm, "");
      if (!code)
        return;
      this.operation$ = this.logApiService.getByCode(code);
    }
    this.isLoading = true;
    this.isSort = false;
    this.operation$.pipe(tap(() => this.onFilter()), finalize(() => this.isLoading = false)).subscribe();
  }
  onSearchAll() {
    this.isLoading = true;
    this.isSort = false;
    this.logApiService.getAll().pipe(tap(() => this.setFilter()), finalize(() => this.isLoading = false)).subscribe();
  }
  setFilter() {
    this.form.setValue({
      inventory: [],
      category: [],
      status: []
    });
  }
  onFilter() {
    const logs = this.logService.getAll();
    const filters = {
      categoryName: this.category.value,
      statusName: this.status.value
    };
    const logFilter = Object.keys(filters).reduce((result, keyName) => result.filter((log) => {
      if (filters[keyName].length === 0)
        return result;
      return filters[keyName].includes(log[keyName]);
    }), logs);
    if (this.validationService.isEmpty(this.inventory.value)) {
      this.dataSource.data = logFilter.map((log, i3) => __spreadProps(__spreadValues({}, log), {
        no: i3 + 1
      }));
      return;
    }
    const newParcel = this.inventory.value.includes("\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    const editParcel = this.inventory.value.includes("\u0E41\u0E01\u0E49\u0E44\u0E02\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    this.dataSource.data = logFilter.filter((log) => log.isCreated && newParcel || !log.isCreated && editParcel).map((log, i3) => __spreadProps(__spreadValues({}, log), { no: i3 + 1 }));
  }
  onResetFilter() {
    this.filterInput.nativeElement.value = "";
    this.dataSource.filter = "";
    this.setFilter();
    this.onFilter();
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  get inventory() {
    return this.form.controls["inventory"];
  }
  get category() {
    return this.form.controls["category"];
  }
  get status() {
    return this.form.controls["status"];
  }
  initForm() {
    return this.formBuilder.group({
      inventory: this.formBuilder.control([]),
      category: this.formBuilder.control([]),
      status: this.formBuilder.control([])
    });
  }
  initDataSource() {
    this.dataSource.data = this.logService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data)) {
      this.logApiService.getInit().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
      return;
    }
    this.initPaginatorAndSort();
  }
  initPaginatorAndSort() {
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
      if (!this.isSort) {
        this.dataSource.sort.sort({
          id: "createdAt",
          start: "desc",
          disableClear: true
        });
        this.isSort = true;
      }
    });
  }
  initSubscriptions() {
    this.subscription.add(this.logService.onListener().subscribe(() => {
      this.dataSource.data = this.logService.getTableData();
      this.initPaginatorAndSort();
    }));
    this.subscription.add(this.searchService.onListener().subscribe((cache2) => this.cache = this.searchService.getCache()));
    this.filteredOptions = merge(this.search.valueChanges, this.searchService.onListener().pipe(map(() => this.search.value))).pipe(startWith(""), map((value2) => this._filter(value2 || "")));
  }
  _filter(value2) {
    const filterValue = value2.toLowerCase();
    return this.cache.filter((option) => option.toLowerCase().includes(filterValue));
  }
};
_LogListComponent.\u0275fac = function LogListComponent_Factory(t2) {
  return new (t2 || _LogListComponent)();
};
_LogListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LogListComponent, selectors: [["app-log-list"]], viewQuery: function LogListComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(_c09, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.filterInput = _t2.first);
  }
}, decls: 43, vars: 13, consts: [["picker", ""], ["auto", "matAutocomplete"], ["filterInput", ""], [300], [1, "mb-20", "mat-elevation-z8"], ["mat-stretch-tabs", "false", 3, "selectedIndexChange", "selectedIndex"], ["label", "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48"], [1, "w-100"], [3, "rangePicker", "formGroup"], ["matStartDate", "", "formControlName", "start", "readonly", "", 3, "click"], ["matEndDate", "", "formControlName", "end", "readonly", "", 3, "click"], ["align", "end"], ["matIconSuffix", "", 3, "for"], ["label", "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C"], [3, "ngSubmit"], ["type", "text", "matInput", "", 3, "input", "formControl", "matAutocomplete"], ["autoActiveFirstOption", ""], [3, "value"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click", 4, "ngIf"], ["type", "submit", "matSuffix", "", "mat-icon-button", ""], ["matSuffix", "", "fontIcon", "search"], [1, "justify-between"], ["type", "button", "mat-raised-button", "", "color", "primary", 3, "click", "disabled"], ["type", "button", "mat-raised-button", "", "color", "accent", 3, "click", "disabled"], ["mode", "indeterminate"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click"], [1, "mat-elevation-z8"], [1, "mb-16", "d-flex", "justify-between", "align-center"], ["type", "button", "mat-button", "", "color", "warn", 3, "click"], [1, "filter-box", 3, "formGroup"], ["formControlName", "category", "multiple", ""], [1, "additional-selection"], ["formControlName", "status", "multiple", ""], ["formControlName", "inventory", "multiple", ""], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], [3, "click", "value"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "image"], ["matColumnDef", "code"], ["matColumnDef", "category"], ["matColumnDef", "status"], ["matColumnDef", "description"], ["matColumnDef", "isCreated"], ["matColumnDef", "createdAt"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["mat-sort-header", ""], [1, "blurred-img", 3, "routerLink"], [3, "defaultImage", "lazyLoad"], [1, "detail-log", 3, "ngClass"], [3, "form"]], template: function LogListComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 4)(1, "mat-tab-group", 5);
    \u0275\u0275listener("selectedIndexChange", function LogListComponent_Template_mat_tab_group_selectedIndexChange_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectedTap.setValue($event));
    });
    \u0275\u0275elementStart(2, "mat-tab", 6)(3, "mat-card-content")(4, "mat-form-field", 7)(5, "mat-label");
    \u0275\u0275text(6, "\u0E08\u0E32\u0E01 - \u0E16\u0E36\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "mat-date-range-input", 8)(8, "input", 9);
    \u0275\u0275listener("click", function LogListComponent_Template_input_click_8_listener() {
      \u0275\u0275restoreView(_r1);
      const picker_r2 = \u0275\u0275reference(14);
      return \u0275\u0275resetView(picker_r2.open());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "input", 10);
    \u0275\u0275listener("click", function LogListComponent_Template_input_click_9_listener() {
      \u0275\u0275restoreView(_r1);
      const picker_r2 = \u0275\u0275reference(14);
      return \u0275\u0275resetView(picker_r2.open());
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "mat-hint", 11);
    \u0275\u0275text(11, "\u0E27\u0E31\u0E19/\u0E40\u0E14\u0E37\u0E2D\u0E19/\u0E1E.\u0E28.");
    \u0275\u0275elementEnd();
    \u0275\u0275element(12, "mat-datepicker-toggle", 12)(13, "mat-date-range-picker", null, 0);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(15, "mat-tab", 13)(16, "mat-card-content")(17, "form", 14);
    \u0275\u0275listener("ngSubmit", function LogListComponent_Template_form_ngSubmit_17_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearch());
    });
    \u0275\u0275elementStart(18, "mat-form-field", 7)(19, "mat-label");
    \u0275\u0275text(20, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "input", 15);
    \u0275\u0275listener("input", function LogListComponent_Template_input_input_21_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchAutoComplete(ctx.search.value));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "mat-autocomplete", 16, 1);
    \u0275\u0275repeaterCreate(24, LogListComponent_For_25_Template, 2, 2, "mat-option", 17, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275pipe(26, "async");
    \u0275\u0275elementEnd();
    \u0275\u0275template(27, LogListComponent_button_27_Template, 3, 0, "button", 18);
    \u0275\u0275elementStart(28, "button", 19);
    \u0275\u0275element(29, "mat-icon", 20);
    \u0275\u0275elementEnd()()()()()();
    \u0275\u0275elementStart(30, "mat-card-actions", 21)(31, "button", 22);
    \u0275\u0275listener("click", function LogListComponent_Template_button_click_31_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearch());
    });
    \u0275\u0275elementStart(32, "mat-icon");
    \u0275\u0275text(33, "search");
    \u0275\u0275elementEnd();
    \u0275\u0275text(34, " \u0E04\u0E49\u0E19\u0E2B\u0E32 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(35, "button", 23);
    \u0275\u0275listener("click", function LogListComponent_Template_button_click_35_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchAll());
    });
    \u0275\u0275text(36, " \u0E04\u0E49\u0E19\u0E2B\u0E32\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(37, "mat-card-footer");
    \u0275\u0275template(38, LogListComponent_Conditional_38_Template, 1, 0, "mat-progress-bar", 24);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(39, LogListComponent_Defer_39_Template, 43, 11)(40, LogListComponent_DeferPlaceholder_40_Template, 1, 1);
    \u0275\u0275defer(41, 39, LogListComponent_Defer_41_DepsFn, null, 40, null, null, 3, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    const picker_r2 = \u0275\u0275reference(14);
    const auto_r22 = \u0275\u0275reference(23);
    \u0275\u0275advance();
    \u0275\u0275property("selectedIndex", ctx.selectedTap.value);
    \u0275\u0275advance(6);
    \u0275\u0275property("rangePicker", picker_r2)("formGroup", ctx.dateRange);
    \u0275\u0275advance(5);
    \u0275\u0275property("for", picker_r2);
    \u0275\u0275advance(9);
    \u0275\u0275property("formControl", ctx.search)("matAutocomplete", auto_r22);
    \u0275\u0275advance(3);
    \u0275\u0275repeater(\u0275\u0275pipeBind1(26, 11, ctx.filteredOptions));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.search.value);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(38, ctx.isLoading ? 38 : -1);
    \u0275\u0275advance(3);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
  }
}, dependencies: [NgIf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormControlDirective, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatInput, MatFormField, MatLabel, MatHint, MatSuffix, MatProgressBar, MatOption, MatDatepickerToggle, MatDateRangeInput, MatStartDate, MatEndDate, MatDateRangePicker, MatTab, MatTabGroup, MatAutocomplete, MatAutocompleteTrigger, LoadingDataComponent, NgForm, AsyncPipe], styles: ["\n\nimg[_ngcontent-%COMP%] {\n  width: 100%;\n  height: 100%;\n}\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-image[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  padding-block: 8px;\n}\n.mat-column-code[_ngcontent-%COMP%] {\n  flex: 0 0 140px;\n}\n.mat-column-category[_ngcontent-%COMP%] {\n  flex: 0 0 150px;\n}\n.mat-column-status[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-isCreated[_ngcontent-%COMP%] {\n  flex: 0 0 150px;\n}\n.mat-column-description[_ngcontent-%COMP%] {\n  min-width: 200px;\n}\n.mat-column-createdAt[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.filter-box[_ngcontent-%COMP%] {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-between;\n  gap: 10px;\n}\n.filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n  flex: 1 1 calc(25% - 10px);\n  min-width: 150px;\n}\n.filter-box[_ngcontent-%COMP%]   .additional-selection[_ngcontent-%COMP%] {\n  opacity: 0.75;\n  font-size: 0.75em;\n}\n@media (max-width: 968px) {\n  .filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n    flex: 1 1 calc(50% - 10px);\n  }\n}\n@media (min-width: 599px) {\n  .filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n    flex: 1 1 calc(25% - 10px);\n  }\n}\n.detail-log[_ngcontent-%COMP%] {\n  font-weight: 600;\n  padding: 6px 10px;\n  border-radius: 6px;\n}\n.newParcel[_ngcontent-%COMP%] {\n  background-color: #ff9800;\n  color: #000;\n}\n.editParcel[_ngcontent-%COMP%] {\n  background-color: #ffeb3b;\n  color: #000;\n}\n.dark-theme[_nghost-%COMP%]   .newParcel[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .newParcel[_ngcontent-%COMP%] {\n  background-color: #ff5722;\n  color: #fff;\n}\n.dark-theme[_nghost-%COMP%]   .editParcel[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .editParcel[_ngcontent-%COMP%] {\n  background-color: #d6a505;\n  color: #fff;\n}\n/*# sourceMappingURL=log-list.component.css.map */"] });
var LogListComponent = _LogListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LogListComponent, { className: "LogListComponent", filePath: "src\\app\\modules\\dashboard\\components\\log\\log-list\\log-list.component.ts", lineNumber: 46 });
})();

// src/app/modules/dashboard/components/log/log-view/log-view.component.ts
var LogViewComponent_Defer_2_DepsFn = () => [NgIf, MatButton, MatList, MatListItem, MatListSubheaderCssMatStyler, MatDivider, MatListItemLine, MatListItemTitle, MatCard, MatCardContent, MatCardHeader, MatCardTitle, LazyLoadImageDirective, DecimalPipe, DatePipe, ThaiYearPipe, DispTextareaPipe];
function LogViewComponent_Defer_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 3);
    \u0275\u0275text(2, " \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E1B\u0E23\u0E30\u0E27\u0E31\u0E15\u0E34\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function LogViewComponent_Defer_0_ng_template_1_Conditional_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
  }
}
function LogViewComponent_Defer_0_ng_template_1_Conditional_28_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0, "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
  }
}
function LogViewComponent_Defer_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-card", 4)(1, "mat-card-header", 5)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "div", 6);
    \u0275\u0275element(6, "img", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "mat-list")(8, "div", 8);
    \u0275\u0275text(9, "\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14\u0E1B\u0E23\u0E30\u0E27\u0E31\u0E15\u0E34");
    \u0275\u0275elementEnd();
    \u0275\u0275element(10, "mat-divider");
    \u0275\u0275elementStart(11, "mat-list-item")(12, "span", 9);
    \u0275\u0275text(13, "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1B\u0E23\u0E30\u0E27\u0E31\u0E15\u0E34");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "span", 10);
    \u0275\u0275text(15);
    \u0275\u0275pipe(16, "date");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 11)(18, "mat-list-item")(19, "span", 9);
    \u0275\u0275text(20, "\u0E0A\u0E37\u0E48\u0E2D - \u0E2A\u0E01\u0E38\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "span", 10);
    \u0275\u0275text(22);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(23, "mat-list-item")(24, "span", 9);
    \u0275\u0275text(25, "\u0E40\u0E1E\u0E34\u0E48\u0E21 / \u0E41\u0E01\u0E49\u0E44\u0E02");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "span", 10);
    \u0275\u0275template(27, LogViewComponent_Defer_0_ng_template_1_Conditional_27_Template, 1, 0)(28, LogViewComponent_Defer_0_ng_template_1_Conditional_28_Template, 1, 0);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(29, "mat-list")(30, "div", 12);
    \u0275\u0275text(31, "\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(32, "mat-divider");
    \u0275\u0275elementStart(33, "mat-list-item")(34, "span", 9);
    \u0275\u0275text(35, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "span", 10);
    \u0275\u0275text(37);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "mat-list-item")(39, "span", 9);
    \u0275\u0275text(40, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(41, "div", 13);
    \u0275\u0275pipe(42, "dispTextarea");
    \u0275\u0275elementStart(43, "div", 11)(44, "mat-list-item")(45, "span", 9);
    \u0275\u0275text(46, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(47, "span", 10);
    \u0275\u0275text(48);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(49, "mat-list-item")(50, "span", 9);
    \u0275\u0275text(51, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(52, "span", 10);
    \u0275\u0275text(53);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(54, "div", 11)(55, "mat-list-item")(56, "span", 9);
    \u0275\u0275text(57, "\u0E2B\u0E19\u0E48\u0E27\u0E22\u0E19\u0E31\u0E1A");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(58, "span", 10);
    \u0275\u0275text(59);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(60, "mat-list-item")(61, "span", 9);
    \u0275\u0275text(62, "\u0E21\u0E39\u0E25\u0E04\u0E48\u0E32\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(63, "span", 10);
    \u0275\u0275text(64);
    \u0275\u0275pipe(65, "number");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(66, "div", 11)(67, "mat-list-item")(68, "span", 9);
    \u0275\u0275text(69, "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E44\u0E14\u0E49\u0E21\u0E32");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(70, "span", 10);
    \u0275\u0275text(71);
    \u0275\u0275pipe(72, "thaiYear");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(73, "mat-list-item")(74, "span", 9);
    \u0275\u0275text(75, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\u0E40\u0E14\u0E34\u0E21");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(76, "span", 10);
    \u0275\u0275text(77);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(78, "div", 11)(79, "mat-list-item")(80, "span", 9);
    \u0275\u0275text(81, "\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(82, "span", 10);
    \u0275\u0275text(83);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(84, "mat-list-item")(85, "span", 9);
    \u0275\u0275text(86, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(87, "span", 10);
    \u0275\u0275text(88);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(89, "mat-list-item")(90, "span", 9);
    \u0275\u0275text(91, "\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19\u0E21\u0E32\u0E41\u0E25\u0E49\u0E27");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(92, "span", 10);
    \u0275\u0275text(93);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(94, "mat-list-item")(95, "span", 9);
    \u0275\u0275text(96, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(97, "div", 13);
    \u0275\u0275pipe(98, "dispTextarea");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r0.title);
    \u0275\u0275advance(3);
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx_r0.imageUrl + ctx_r0.log.image);
    \u0275\u0275advance(9);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(16, 19, ctx_r0.log.createdAt, "medium"));
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate2("", ctx_r0.log.firstname, " ", ctx_r0.log.lastname, "");
    \u0275\u0275advance(5);
    \u0275\u0275conditional(27, ctx_r0.log.isCreated ? 27 : 28);
    \u0275\u0275advance(10);
    \u0275\u0275textInterpolate(ctx_r0.log.code);
    \u0275\u0275advance(4);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind1(42, 22, ctx_r0.log.description), \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(ctx_r0.log.categoryName);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r0.log.statusName);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r0.log.unit);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(65, 24, ctx_r0.log.value, "1.2-2"));
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(72, 27, ctx_r0.log.receivedDate));
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r0.isEmpty(ctx_r0.log.oldCode));
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r0.log.fundName);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r0.log.locationName);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r0.getUseDate(ctx_r0.log.receivedDate));
    \u0275\u0275advance(4);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind1(98, 29, ctx_r0.log.remark), \u0275\u0275sanitizeHtml);
  }
}
function LogViewComponent_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LogViewComponent_Defer_0_ng_container_0_Template, 3, 0, "ng-container", 2)(1, LogViewComponent_Defer_0_ng_template_1_Template, 99, 31, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const content_r2 = \u0275\u0275reference(2);
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", !ctx_r0.log)("ngIfElse", content_r2);
  }
}
function LogViewComponent_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 14);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _LogViewComponent = class _LogViewComponent {
  constructor() {
    this.route = inject(ActivatedRoute);
    this.logService = inject(LogService);
    this.logApiService = inject(LogApiService);
    this.inventoryService = inject(InventoryService);
    this.imageUrl = environment.imageUrl;
    this.title = "\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14\u0E1B\u0E23\u0E30\u0E27\u0E49\u0E15\u0E34\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.isLoading = false;
    this.id = +this.route.snapshot.params["id"];
    this.log = this.logService.getById(this.id);
  }
  ngOnInit() {
    if (!this.log) {
      this.isLoading = true;
      this.logApiService.getById(this.id).pipe(finalize(() => this.isLoading = false)).subscribe((res) => res && (this.log = res));
    }
  }
  isEmpty(value2) {
    if (!value2)
      return "-";
    return value2;
  }
  getUseDate(receivedDate) {
    const date = new Date(receivedDate);
    return this.inventoryService.getUseDate(date);
  }
};
_LogViewComponent.\u0275fac = function LogViewComponent_Factory(t2) {
  return new (t2 || _LogViewComponent)();
};
_LogViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LogViewComponent, selectors: [["app-log-view"]], decls: 4, vars: 1, consts: [["content", ""], [300], [4, "ngIf", "ngIfElse"], ["mat-flat-button", "", "color", "warn", 1, "w-100"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "blurred-img"], [1, "size", 3, "defaultImage", "lazyLoad"], ["mat-subheader", "", 1, "m-left-0"], ["matListItemTitle", ""], ["matListItemLine", ""], [1, "d-flex", "flex-row"], ["mat-subheader", "", 2, "margin-left", "0"], [1, "view-textarea", 3, "innerHTML"], [3, "form"]], template: function LogViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, LogViewComponent_Defer_0_Template, 3, 2)(1, LogViewComponent_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, LogViewComponent_Defer_2_DepsFn, null, 1, null, null, 1, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275deferWhen(!ctx.isLoading);
  }
}, dependencies: [LoadingDataComponent], styles: ["\n\nmat-list-item[_ngcontent-%COMP%] {\n  padding: 0;\n}\n.m-left-0[_ngcontent-%COMP%] {\n  margin-left: 0;\n}\n.newParcel[_ngcontent-%COMP%] {\n  color: rgb(164, 56, 182);\n}\n.editParcel[_ngcontent-%COMP%] {\n  color: rgb(208, 225, 253);\n}\n.increaseQuantity[_ngcontent-%COMP%] {\n  color: rgb(70, 161, 74);\n}\n.decreaseQuantity[_ngcontent-%COMP%] {\n  color: rgb(245, 82, 70);\n}\n.print[_ngcontent-%COMP%] {\n  color: rgb(245, 185, 7);\n}\n.shadow-newParcel[_ngcontent-%COMP%] {\n  box-shadow: rgba(164, 56, 182, 0.2) 0px 7px 29px 0px;\n}\n.shadow-editParcel[_ngcontent-%COMP%] {\n  box-shadow: rgba(208, 225, 253, 0.2) 0px 7px 29px 0px;\n}\n.shadow-increaseQuantity[_ngcontent-%COMP%] {\n  box-shadow: rgba(70, 161, 74, 0.2) 0px 7px 29px 0px;\n}\n.shadow-decreaseQuantity[_ngcontent-%COMP%] {\n  box-shadow: rgba(245, 82, 70, 0.2) 0px 7px 29px 0px;\n}\n.shadow-print[_ngcontent-%COMP%] {\n  box-shadow: rgba(245, 185, 7, 0.2) 0px 7px 29px 0px;\n}\n.view-textarea[_ngcontent-%COMP%] {\n  margin-top: -12px;\n  color: rgba(0, 0, 0, 0.54);\n}\n.view-textarea[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin: 0 0 8px;\n}\n.dark-theme[_nghost-%COMP%]   .view-textarea[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .view-textarea[_ngcontent-%COMP%] {\n  color: rgba(255, 255, 255, 0.7);\n}\n/*# sourceMappingURL=log-view.component.css.map */"] });
var LogViewComponent = _LogViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LogViewComponent, { className: "LogViewComponent", filePath: "src\\app\\modules\\dashboard\\components\\log\\log-view\\log-view.component.ts", lineNumber: 15 });
})();

// src/app/modules/dashboard/constants/status.constant.ts
var STATUS = {
  validationField: {
    name: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30" },
    active: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19" }
  }
};

// src/app/modules/dashboard/components/status/status-edit/status-edit.component.ts
var _c010 = ["formDirec"];
var _c16 = ["nameInput"];
function StatusEditComponent_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 15);
  }
}
var _StatusEditComponent = class _StatusEditComponent {
  constructor() {
    this.data = inject(MAT_DIALOG_DATA);
    this.formBuilder = inject(FormBuilder);
    this.dialogRef = inject(MatDialogRef);
    this.statusApiService = inject(StatusApiService);
    this.toastService = inject(ToastNotificationService);
    this.validationField = STATUS.validationField;
    this.title = "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E2A\u0E16\u0E32\u0E19\u0E30";
    this.isEdit = false;
    this.isLoading = false;
    this.form = this.initForm();
  }
  ngOnInit() {
    if (this.data) {
      this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E2A\u0E16\u0E32\u0E19\u0E30";
      this.isEdit = true;
      this.form.patchValue(this.data);
    }
    this.dialogRef.keydownEvents().subscribe((event) => event.key === "Escape" && this.onCloseDialog());
    this.dialogRef.backdropClick().subscribe(() => this.onCloseDialog());
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    if (JSON.stringify(this.data) === JSON.stringify(this.form.value))
      return;
    const _a2 = __spreadValues({}, this.form.getRawValue()), { id } = _a2, payload = __objRest(_a2, ["id"]);
    this.isLoading = true;
    this.operation$ = this.isEdit ? this.statusApiService.update(id, payload) : this.statusApiService.create(payload);
    this.operation$.pipe(catchError((error) => {
      if (error.status === 0)
        this.dialogRef.close();
      return throwError(() => error);
    }), finalize(() => this.isLoading = false)).subscribe((res) => {
      if (this.isEdit)
        this.dialogRef.close();
      else
        this.onReset();
      this.toastService.success("Success", res.message);
    });
  }
  onReset() {
    if (this.isEdit)
      this.form.patchValue(this.data);
    else
      this.formDirec.resetForm();
    this.nameInput.nativeElement.focus();
  }
  newDialogBackdropHandler() {
    const isChange = this.name.value !== "" || this.remark.value !== "";
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  editDialogBackdropHandler() {
    const isChange = this.name.value !== this.data.name || this.active.value !== this.data.active || this.remark.value !== this.data.remark;
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  confirmDialogBackdropHandler() {
    const confirmation = confirm("\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01\u0E01\u0E32\u0E23\u0E41\u0E01\u0E49\u0E44\u0E02\u0E41\u0E25\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E1F\u0E2D\u0E23\u0E4C\u0E21\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48?");
    if (confirmation)
      this.dialogRef.close();
  }
  onCloseDialog() {
    if (this.isEdit)
      this.editDialogBackdropHandler();
    else
      this.newDialogBackdropHandler();
  }
  get name() {
    return this.form.controls["name"];
  }
  get active() {
    return this.form.controls["active"];
  }
  get remark() {
    return this.form.controls["remark"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      id: [null],
      name: ["", [Validators.required]],
      active: [true, [Validators.required]],
      remark: [""]
    });
  }
};
_StatusEditComponent.\u0275fac = function StatusEditComponent_Factory(t2) {
  return new (t2 || _StatusEditComponent)();
};
_StatusEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _StatusEditComponent, selectors: [["app-status-edit"]], viewQuery: function StatusEditComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c010, 5);
    \u0275\u0275viewQuery(_c16, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.formDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.nameInput = _t2.first);
  }
}, decls: 33, vars: 7, consts: [["formDirec", "ngForm"], ["nameInput", ""], [1, "d-flex", "justify-between", "align-center"], ["mat-dialog-title", ""], ["mat-icon-button", "", "tabindex", "-1", 1, "btn-close", 3, "click"], [3, "ngSubmit", "formGroup"], [1, "form-container"], [1, "box"], ["type", "text", "matInput", "", "formControlName", "name"], [3, "control", "errorMessage"], ["type", "text", "matInput", "", "formControlName", "remark"], [1, "d-flex", "gap-10"], ["formControlName", "active"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], ["mode", "indeterminate"]], template: function StatusEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "h2", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 4);
    \u0275\u0275listener("click", function StatusEditComponent_Template_button_click_3_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseDialog());
    });
    \u0275\u0275elementStart(4, "mat-icon");
    \u0275\u0275text(5, "close");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "form", 5, 0);
    \u0275\u0275listener("ngSubmit", function StatusEditComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSubmit());
    });
    \u0275\u0275element(8, "mat-divider");
    \u0275\u0275elementStart(9, "mat-dialog-content", 6)(10, "div", 7)(11, "mat-form-field")(12, "mat-label");
    \u0275\u0275text(13, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "input", 8, 1);
    \u0275\u0275elementStart(16, "mat-error");
    \u0275\u0275element(17, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "mat-form-field")(19, "mat-label");
    \u0275\u0275text(20, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(21, "input", 10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 11);
    \u0275\u0275element(23, "mat-slide-toggle", 12);
    \u0275\u0275elementStart(24, "span");
    \u0275\u0275text(25, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(26, "mat-divider");
    \u0275\u0275elementStart(27, "mat-dialog-actions")(28, "button", 13);
    \u0275\u0275text(29, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "button", 14);
    \u0275\u0275listener("click", function StatusEditComponent_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onReset());
    });
    \u0275\u0275text(31, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(32, StatusEditComponent_Conditional_32_Template, 1, 0, "mat-progress-bar", 15);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(11);
    \u0275\u0275property("control", ctx.name)("errorMessage", ctx.validationField.name);
    \u0275\u0275advance(11);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(32, ctx.isLoading ? 32 : -1);
  }
}, dependencies: [\u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatDivider, MatInput, MatFormField, MatLabel, MatError, MatProgressBar, MatSlideToggle, MatDialogTitle, MatDialogActions, MatDialogContent, ErrorFieldComponent] });
var StatusEditComponent = _StatusEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(StatusEditComponent, { className: "StatusEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\status\\status-edit\\status-edit.component.ts", lineNumber: 27 });
})();

// src/app/modules/dashboard/components/status/status.component.ts
var StatusComponent_Defer_5_DepsFn = () => [MatIconButton, MatIcon, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader];
var _c011 = () => [10, 25, 50, 100];
function StatusComponent_Defer_3_mat_header_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function StatusComponent_Defer_3_mat_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r3.no, " ");
  }
}
function StatusComponent_Defer_3_mat_header_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
  }
}
function StatusComponent_Defer_3_mat_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r4.name, " ");
  }
}
function StatusComponent_Defer_3_mat_header_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd();
  }
}
function StatusComponent_Defer_3_mat_cell_18_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 20);
    \u0275\u0275text(1, "toggle_on");
    \u0275\u0275elementEnd();
  }
}
function StatusComponent_Defer_3_mat_cell_18_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 21);
    \u0275\u0275text(1, "toggle_off");
    \u0275\u0275elementEnd();
  }
}
function StatusComponent_Defer_3_mat_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275template(1, StatusComponent_Defer_3_mat_cell_18_Conditional_1_Template, 2, 0, "mat-icon", 20)(2, StatusComponent_Defer_3_mat_cell_18_Conditional_2_Template, 2, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(1, element_r5.active ? 1 : 2);
  }
}
function StatusComponent_Defer_3_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
  }
}
function StatusComponent_Defer_3_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r6.remark, " ");
  }
}
function StatusComponent_Defer_3_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function StatusComponent_Defer_3_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell")(1, "button", 22);
    \u0275\u0275listener("click", function StatusComponent_Defer_3_mat_cell_24_Template_button_click_1_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onUpdate(element_r8));
    });
    \u0275\u0275elementStart(2, "mat-icon", 23);
    \u0275\u0275text(3, "edit");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "button", 24);
    \u0275\u0275listener("click", function StatusComponent_Defer_3_mat_cell_24_Template_button_click_4_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onConfirm(element_r8.id, element_r8.name));
    });
    \u0275\u0275elementStart(5, "mat-icon");
    \u0275\u0275text(6, "delete");
    \u0275\u0275elementEnd()()();
  }
}
function StatusComponent_Defer_3_mat_header_row_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function StatusComponent_Defer_3_mat_row_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function StatusComponent_Defer_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 3)(1, "mat-card-header", 4)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "mat-form-field", 5)(6, "mat-label");
    \u0275\u0275text(7, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 6);
    \u0275\u0275listener("keyup", function StatusComponent_Defer_3_Template_input_keyup_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.applyFilter($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "mat-table", 7);
    \u0275\u0275elementContainerStart(10, 8);
    \u0275\u0275template(11, StatusComponent_Defer_3_mat_header_cell_11_Template, 2, 0, "mat-header-cell", 9)(12, StatusComponent_Defer_3_mat_cell_12_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(13, 11);
    \u0275\u0275template(14, StatusComponent_Defer_3_mat_header_cell_14_Template, 2, 0, "mat-header-cell", 9)(15, StatusComponent_Defer_3_mat_cell_15_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(16, 12);
    \u0275\u0275template(17, StatusComponent_Defer_3_mat_header_cell_17_Template, 2, 0, "mat-header-cell", 9)(18, StatusComponent_Defer_3_mat_cell_18_Template, 3, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(19, 13);
    \u0275\u0275template(20, StatusComponent_Defer_3_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 9)(21, StatusComponent_Defer_3_mat_cell_21_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 14);
    \u0275\u0275template(23, StatusComponent_Defer_3_mat_header_cell_23_Template, 1, 0, "mat-header-cell", 15)(24, StatusComponent_Defer_3_mat_cell_24_Template, 7, 0, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(25, StatusComponent_Defer_3_mat_header_row_25_Template, 1, 0, "mat-header-row", 16)(26, StatusComponent_Defer_3_mat_row_26_Template, 1, 0, "mat-row", 17);
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "mat-paginator", 18);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance(6);
    \u0275\u0275property("dataSource", ctx_r1.dataSource);
    \u0275\u0275advance(16);
    \u0275\u0275property("matHeaderRowDef", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(5, _c011));
  }
}
function StatusComponent_DeferPlaceholder_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 25);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _StatusComponent = class _StatusComponent {
  constructor() {
    this.subscription = new Subscription();
    this.statusService = inject(StatusService);
    this.statusApiService = inject(StatusApiService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.dialog = inject(MatDialog);
    this.title = "\u0E23\u0E32\u0E22\u0E0A\u0E37\u0E48\u0E2D\u0E2A\u0E16\u0E32\u0E19\u0E30";
    this.displayedColumns = ["no", "name", "active", "remark", "action"];
    this.dataSource = new MatTableDataSource([]);
    this.isFirstLoading = false;
  }
  ngOnInit() {
    this.initDataSource();
    this.subscription = this.statusService.onListener().subscribe(() => this.dataSource.data = this.statusService.getTableData());
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onCreate() {
    this.dialog.open(StatusEditComponent, {
      width: "500px",
      disableClose: true
    });
  }
  onUpdate(item) {
    this.dialog.open(StatusEditComponent, {
      data: item,
      width: "500px",
      disableClose: true
    });
  }
  onConfirm(id, title) {
    this.id = id;
    this.sweetAlertTitle = `\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E1A ${title}?`;
    this.sweetAlert.alert(this.sweetAlertTitle);
  }
  onDelete(confirm2) {
    if (!confirm2)
      return;
    this.statusApiService.delete(this.id).subscribe((res) => this.toastService.info("Info", res.message));
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  initDataSource() {
    this.dataSource.data = this.statusService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data))
      this.statusApiService.getAll().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
    });
  }
};
_StatusComponent.\u0275fac = function StatusComponent_Factory(t2) {
  return new (t2 || _StatusComponent)();
};
_StatusComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _StatusComponent, selectors: [["app-status"]], viewQuery: function StatusComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(SweetAlertComponent, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sweetAlert = _t2.first);
  }
}, decls: 8, vars: 2, consts: [[300], ["mat-fab", "", "color", "primary", 1, "mb-20", 3, "click"], [3, "confirm", "icon"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "w-100"], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "name"], ["matColumnDef", "active"], ["matColumnDef", "remark"], ["matColumnDef", "action"], [4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], ["mat-sort-header", ""], [1, "toggle-on"], [1, "toggle-off"], ["mat-icon-button", "", 3, "click"], ["color", "accent"], ["mat-icon-button", "", "color", "warn", 3, "click"], [3, "form"]], template: function StatusComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 1);
    \u0275\u0275listener("click", function StatusComponent_Template_button_click_0_listener() {
      return ctx.onCreate();
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(3, StatusComponent_Defer_3_Template, 28, 6)(4, StatusComponent_DeferPlaceholder_4_Template, 1, 1);
    \u0275\u0275defer(5, 3, StatusComponent_Defer_5_DepsFn, null, 4, null, null, 0, \u0275\u0275deferEnableTimerScheduling);
    \u0275\u0275elementStart(7, "app-sweet-alert", 2);
    \u0275\u0275listener("confirm", function StatusComponent_Template_app_sweet_alert_confirm_7_listener($event) {
      return ctx.onDelete($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(5);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", "error");
  }
}, dependencies: [MatFabButton, MatIcon, LoadingDataComponent, SweetAlertComponent], styles: ["\n\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-name[_ngcontent-%COMP%] {\n  min-width: 120px;\n}\n.mat-column-active[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-remark[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  justify-content: center;\n}\n/*# sourceMappingURL=table-styles.css.map */"] });
var StatusComponent = _StatusComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(StatusComponent, { className: "StatusComponent", filePath: "src\\app\\modules\\dashboard\\components\\status\\status.component.ts", lineNumber: 31 });
})();

// src/app/modules/dashboard/constants/fund.constant.ts
var FUND = {
  validationField: {
    name: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19" },
    active: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19" }
  }
};

// src/app/modules/dashboard/components/fund/fund-edit/fund-edit.component.ts
var _c012 = ["formDirec"];
var _c17 = ["nameInput"];
function FundEditComponent_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 15);
  }
}
var _FundEditComponent = class _FundEditComponent {
  constructor() {
    this.data = inject(MAT_DIALOG_DATA);
    this.formBuilder = inject(FormBuilder);
    this.dialogRef = inject(MatDialogRef);
    this.fundApiService = inject(FundApiService);
    this.toastService = inject(ToastNotificationService);
    this.title = "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19";
    this.isEdit = false;
    this.isLoading = false;
    this.validationField = FUND.validationField;
    this.form = this.initForm();
  }
  ngOnInit() {
    if (this.data) {
      this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19";
      this.isEdit = true;
      this.form.patchValue(this.data);
    }
    this.dialogRef.keydownEvents().subscribe((event) => event.key === "Escape" && this.onCloseDialog());
    this.dialogRef.backdropClick().subscribe(() => this.onCloseDialog());
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    if (JSON.stringify(this.data) === JSON.stringify(this.form.value))
      return;
    const _a2 = __spreadValues({}, this.form.getRawValue()), { id } = _a2, payload = __objRest(_a2, ["id"]);
    this.isLoading = true;
    this.operation$ = this.isEdit ? this.fundApiService.update(id, payload) : this.fundApiService.create(payload);
    this.operation$.pipe(catchError((error) => {
      if (error.status === 0)
        this.dialogRef.close();
      return throwError(() => error);
    }), finalize(() => this.isLoading = false)).subscribe((res) => {
      if (this.isEdit)
        this.dialogRef.close();
      else
        this.onReset();
      this.toastService.success("Success", res.message);
    });
  }
  onReset() {
    if (this.isEdit)
      this.form.patchValue(this.data);
    else
      this.formDirec.resetForm();
    this.nameInput.nativeElement.focus();
  }
  newDialogBackdropHandler() {
    const isChange = this.name.value !== "" || this.remark.value !== "";
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  editDialogBackdropHandler() {
    const isChange = this.name.value !== this.data.name || this.active.value !== this.data.active || this.remark.value !== this.data.remark;
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  confirmDialogBackdropHandler() {
    const confirmation = confirm("\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01\u0E01\u0E32\u0E23\u0E41\u0E01\u0E49\u0E44\u0E02\u0E41\u0E25\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E1F\u0E2D\u0E23\u0E4C\u0E21\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48?");
    if (confirmation)
      this.dialogRef.close();
  }
  onCloseDialog() {
    if (this.isEdit)
      this.editDialogBackdropHandler();
    else
      this.newDialogBackdropHandler();
  }
  get name() {
    return this.form.controls["name"];
  }
  get active() {
    return this.form.controls["active"];
  }
  get remark() {
    return this.form.controls["remark"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      id: [null],
      name: ["", [Validators.required]],
      active: [true, [Validators.required]],
      remark: [""]
    });
  }
};
_FundEditComponent.\u0275fac = function FundEditComponent_Factory(t2) {
  return new (t2 || _FundEditComponent)();
};
_FundEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _FundEditComponent, selectors: [["app-fund-edit"]], viewQuery: function FundEditComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c012, 5);
    \u0275\u0275viewQuery(_c17, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.formDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.nameInput = _t2.first);
  }
}, decls: 33, vars: 7, consts: [["formDirec", "ngForm"], ["nameInput", ""], [1, "d-flex", "justify-between", "align-center"], ["mat-dialog-title", ""], ["mat-icon-button", "", "tabindex", "-1", 1, "btn-close", 3, "click"], [3, "ngSubmit", "formGroup"], [1, "form-container"], [1, "box"], ["type", "text", "matInput", "", "formControlName", "name"], [3, "control", "errorMessage"], ["type", "text", "matInput", "", "formControlName", "remark"], [1, "d-flex", "gap-10"], ["formControlName", "active"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], ["mode", "indeterminate"]], template: function FundEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "h2", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 4);
    \u0275\u0275listener("click", function FundEditComponent_Template_button_click_3_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseDialog());
    });
    \u0275\u0275elementStart(4, "mat-icon");
    \u0275\u0275text(5, "close");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "form", 5, 0);
    \u0275\u0275listener("ngSubmit", function FundEditComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSubmit());
    });
    \u0275\u0275element(8, "mat-divider");
    \u0275\u0275elementStart(9, "mat-dialog-content", 6)(10, "div", 7)(11, "mat-form-field")(12, "mat-label");
    \u0275\u0275text(13, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "input", 8, 1);
    \u0275\u0275elementStart(16, "mat-error");
    \u0275\u0275element(17, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "mat-form-field")(19, "mat-label");
    \u0275\u0275text(20, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(21, "input", 10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 11);
    \u0275\u0275element(23, "mat-slide-toggle", 12);
    \u0275\u0275elementStart(24, "span");
    \u0275\u0275text(25, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(26, "mat-divider");
    \u0275\u0275elementStart(27, "mat-dialog-actions")(28, "button", 13);
    \u0275\u0275text(29, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "button", 14);
    \u0275\u0275listener("click", function FundEditComponent_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onReset());
    });
    \u0275\u0275text(31, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(32, FundEditComponent_Conditional_32_Template, 1, 0, "mat-progress-bar", 15);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(11);
    \u0275\u0275property("control", ctx.name)("errorMessage", ctx.validationField.name);
    \u0275\u0275advance(11);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(32, ctx.isLoading ? 32 : -1);
  }
}, dependencies: [\u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatDivider, MatInput, MatFormField, MatLabel, MatError, MatProgressBar, MatSlideToggle, MatDialogTitle, MatDialogActions, MatDialogContent, ErrorFieldComponent] });
var FundEditComponent = _FundEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(FundEditComponent, { className: "FundEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\fund\\fund-edit\\fund-edit.component.ts", lineNumber: 27 });
})();

// src/app/modules/dashboard/components/fund/fund.component.ts
var FundComponent_Defer_5_DepsFn = () => [MatIconButton, MatIcon, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader];
var _c013 = () => [10, 25, 50, 100];
function FundComponent_Defer_3_mat_header_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function FundComponent_Defer_3_mat_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r3.no, " ");
  }
}
function FundComponent_Defer_3_mat_header_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
  }
}
function FundComponent_Defer_3_mat_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r4.name, " ");
  }
}
function FundComponent_Defer_3_mat_header_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd();
  }
}
function FundComponent_Defer_3_mat_cell_18_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 20);
    \u0275\u0275text(1, "toggle_on");
    \u0275\u0275elementEnd();
  }
}
function FundComponent_Defer_3_mat_cell_18_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 21);
    \u0275\u0275text(1, "toggle_off");
    \u0275\u0275elementEnd();
  }
}
function FundComponent_Defer_3_mat_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275template(1, FundComponent_Defer_3_mat_cell_18_Conditional_1_Template, 2, 0, "mat-icon", 20)(2, FundComponent_Defer_3_mat_cell_18_Conditional_2_Template, 2, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(1, element_r5.active ? 1 : 2);
  }
}
function FundComponent_Defer_3_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
  }
}
function FundComponent_Defer_3_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r6.remark, " ");
  }
}
function FundComponent_Defer_3_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function FundComponent_Defer_3_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell")(1, "button", 22);
    \u0275\u0275listener("click", function FundComponent_Defer_3_mat_cell_24_Template_button_click_1_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onUpdate(element_r8));
    });
    \u0275\u0275elementStart(2, "mat-icon", 23);
    \u0275\u0275text(3, "edit");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "button", 24);
    \u0275\u0275listener("click", function FundComponent_Defer_3_mat_cell_24_Template_button_click_4_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onConfirm(element_r8.id, element_r8.name));
    });
    \u0275\u0275elementStart(5, "mat-icon");
    \u0275\u0275text(6, "delete");
    \u0275\u0275elementEnd()()();
  }
}
function FundComponent_Defer_3_mat_header_row_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function FundComponent_Defer_3_mat_row_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function FundComponent_Defer_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 3)(1, "mat-card-header", 4)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "mat-form-field", 5)(6, "mat-label");
    \u0275\u0275text(7, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 6);
    \u0275\u0275listener("keyup", function FundComponent_Defer_3_Template_input_keyup_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.applyFilter($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "mat-table", 7);
    \u0275\u0275elementContainerStart(10, 8);
    \u0275\u0275template(11, FundComponent_Defer_3_mat_header_cell_11_Template, 2, 0, "mat-header-cell", 9)(12, FundComponent_Defer_3_mat_cell_12_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(13, 11);
    \u0275\u0275template(14, FundComponent_Defer_3_mat_header_cell_14_Template, 2, 0, "mat-header-cell", 9)(15, FundComponent_Defer_3_mat_cell_15_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(16, 12);
    \u0275\u0275template(17, FundComponent_Defer_3_mat_header_cell_17_Template, 2, 0, "mat-header-cell", 9)(18, FundComponent_Defer_3_mat_cell_18_Template, 3, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(19, 13);
    \u0275\u0275template(20, FundComponent_Defer_3_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 9)(21, FundComponent_Defer_3_mat_cell_21_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 14);
    \u0275\u0275template(23, FundComponent_Defer_3_mat_header_cell_23_Template, 1, 0, "mat-header-cell", 15)(24, FundComponent_Defer_3_mat_cell_24_Template, 7, 0, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(25, FundComponent_Defer_3_mat_header_row_25_Template, 1, 0, "mat-header-row", 16)(26, FundComponent_Defer_3_mat_row_26_Template, 1, 0, "mat-row", 17);
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "mat-paginator", 18);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance(6);
    \u0275\u0275property("dataSource", ctx_r1.dataSource);
    \u0275\u0275advance(16);
    \u0275\u0275property("matHeaderRowDef", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(5, _c013));
  }
}
function FundComponent_DeferPlaceholder_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 25);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _FundComponent = class _FundComponent {
  constructor() {
    this.subscription = new Subscription();
    this.fundService = inject(FundService);
    this.fundApiService = inject(FundApiService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.dialog = inject(MatDialog);
    this.title = "\u0E23\u0E32\u0E22\u0E0A\u0E37\u0E48\u0E2D\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19";
    this.displayedColumns = ["no", "name", "active", "remark", "action"];
    this.dataSource = new MatTableDataSource([]);
    this.isFirstLoading = false;
  }
  ngOnInit() {
    this.initDataSource();
    this.subscription = this.fundService.onListener().subscribe(() => this.dataSource.data = this.fundService.getTableData());
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onCreate() {
    this.dialog.open(FundEditComponent, {
      width: "500px",
      disableClose: true
    });
  }
  onUpdate(item) {
    this.dialog.open(FundEditComponent, {
      data: item,
      width: "500px",
      disableClose: true
    });
  }
  onConfirm(id, title) {
    this.id = id;
    this.sweetAlertTitle = `\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E1A ${title}?`;
    this.sweetAlert.alert(this.sweetAlertTitle);
  }
  onDelete(confirm2) {
    if (!confirm2)
      return;
    this.fundApiService.delete(this.id).subscribe((res) => this.toastService.info("Info", res.message));
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  initDataSource() {
    this.dataSource.data = this.fundService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data))
      this.fundApiService.getAll().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
    });
  }
};
_FundComponent.\u0275fac = function FundComponent_Factory(t2) {
  return new (t2 || _FundComponent)();
};
_FundComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _FundComponent, selectors: [["app-fund"]], viewQuery: function FundComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(SweetAlertComponent, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sweetAlert = _t2.first);
  }
}, decls: 8, vars: 2, consts: [[300], ["mat-fab", "", "color", "primary", 1, "mb-20", 3, "click"], [3, "confirm", "icon"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "w-100"], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "name"], ["matColumnDef", "active"], ["matColumnDef", "remark"], ["matColumnDef", "action"], [4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], ["mat-sort-header", ""], [1, "toggle-on"], [1, "toggle-off"], ["mat-icon-button", "", 3, "click"], ["color", "accent"], ["mat-icon-button", "", "color", "warn", 3, "click"], [3, "form"]], template: function FundComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 1);
    \u0275\u0275listener("click", function FundComponent_Template_button_click_0_listener() {
      return ctx.onCreate();
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(3, FundComponent_Defer_3_Template, 28, 6)(4, FundComponent_DeferPlaceholder_4_Template, 1, 1);
    \u0275\u0275defer(5, 3, FundComponent_Defer_5_DepsFn, null, 4, null, null, 0, \u0275\u0275deferEnableTimerScheduling);
    \u0275\u0275elementStart(7, "app-sweet-alert", 2);
    \u0275\u0275listener("confirm", function FundComponent_Template_app_sweet_alert_confirm_7_listener($event) {
      return ctx.onDelete($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(5);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", "error");
  }
}, dependencies: [MatFabButton, MatIcon, LoadingDataComponent, SweetAlertComponent], styles: ["\n\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-name[_ngcontent-%COMP%] {\n  min-width: 120px;\n}\n.mat-column-active[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-remark[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  justify-content: center;\n}\n/*# sourceMappingURL=table-styles.css.map */"] });
var FundComponent = _FundComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(FundComponent, { className: "FundComponent", filePath: "src\\app\\modules\\dashboard\\components\\fund\\fund.component.ts", lineNumber: 31 });
})();

// src/app/modules/dashboard/components/inventory/inventory.component.ts
var _InventoryComponent = class _InventoryComponent {
  constructor() {
    this.validationService = inject(ValidationService);
    this.inventoryService = inject(InventoryService);
    this.categoryService = inject(CategoryService);
    this.categoryApiService = inject(CategoryApiService);
    this.statusService = inject(StatusService);
    this.statusApiService = inject(StatusApiService);
    this.fundService = inject(FundService);
    this.fundApiService = inject(FundApiService);
    this.locationService = inject(LocationService);
    this.locationApiService = inject(LocationApiService);
  }
  ngOnInit() {
    this.inventoryService.setIsLoading(true);
    const categories = this.validationService.isEmpty(this.categoryService.getAll());
    const statuses = this.validationService.isEmpty(this.statusService.getAll());
    const funds = this.validationService.isEmpty(this.fundService.getAll());
    const locations = this.validationService.isEmpty(this.locationService.getAll());
    const operations$ = [];
    if (categories)
      operations$.push(this.categoryApiService.getAll());
    if (statuses)
      operations$.push(this.statusApiService.getAll());
    if (funds)
      operations$.push(this.fundApiService.getAll());
    if (locations)
      operations$.push(this.locationApiService.getAll());
    if (!this.validationService.isEmpty(operations$))
      forkJoin(operations$).subscribe(() => this.inventoryService.setIsLoading(false));
    else
      this.inventoryService.setIsLoading(false);
  }
  onRouterActive() {
    window.scrollTo(0, 0);
  }
};
_InventoryComponent.\u0275fac = function InventoryComponent_Factory(t2) {
  return new (t2 || _InventoryComponent)();
};
_InventoryComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryComponent, selectors: [["app-inventory"]], decls: 1, vars: 0, consts: [[3, "activate"]], template: function InventoryComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "router-outlet", 0);
    \u0275\u0275listener("activate", function InventoryComponent_Template_router_outlet_activate_0_listener() {
      return ctx.onRouterActive();
    });
    \u0275\u0275elementEnd();
  }
}, dependencies: [RouterOutlet] });
var InventoryComponent = _InventoryComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryComponent, { className: "InventoryComponent", filePath: "src\\app\\modules\\dashboard\\components\\inventory\\inventory.component.ts", lineNumber: 23 });
})();

// src/app/modules/dashboard/services/inventory/inventory-api.service.ts
var _InventoryApiService = class _InventoryApiService {
  constructor(http, inventoryService, socketInventoryService, logService, socketLogService) {
    this.http = http;
    this.inventoryService = inventoryService;
    this.socketInventoryService = socketInventoryService;
    this.logService = logService;
    this.socketLogService = socketLogService;
    this.apiUrl = environment.apiUrl + "inventory";
  }
  getAll() {
    return this.http.get(this.apiUrl).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.inventoryService.assign(res)));
  }
  getInit() {
    return this.http.get(`${this.apiUrl}/init`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.inventoryService.assign(res)));
  }
  getByDate(startDate, endDate) {
    return this.http.get(`${this.apiUrl}/date/${startDate}/${endDate}`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => this.inventoryService.assign(res)));
  }
  getById(id) {
    return this.http.get(`${this.apiUrl}/id/${id}`);
  }
  getByCode(code) {
    return this.http.get(`${this.apiUrl}/code/${code}`).pipe(switchMap((res) => timer(200).pipe(map(() => res))), tap((res) => {
      if (res)
        this.inventoryService.assign([res]);
      else
        this.inventoryService.assign([]);
    }));
  }
  create(payload) {
    return this.http.post(this.apiUrl, payload).pipe(tap((res) => {
      this.inventoryService.create(res.item.inventory);
      this.socketInventoryService.create(res.item.inventory);
      this.logService.create(res.item.log);
      this.socketLogService.create(res.item.log);
    }));
  }
  update(id, payload) {
    return this.http.put(`${this.apiUrl}/${id}`, payload).pipe(tap((res) => {
      this.inventoryService.update(id, res.item.inventory);
      this.socketInventoryService.update(id, res.item.inventory);
      this.logService.create(res.item.log);
      this.socketLogService.create(res.item.log);
    }));
  }
  downloadImage(url2) {
    return this.http.get(url2, { responseType: "blob" });
  }
};
_InventoryApiService.\u0275fac = function InventoryApiService_Factory(t2) {
  return new (t2 || _InventoryApiService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(InventoryService), \u0275\u0275inject(SocketInventoryService), \u0275\u0275inject(LogService), \u0275\u0275inject(SocketLogService));
};
_InventoryApiService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _InventoryApiService, factory: _InventoryApiService.\u0275fac, providedIn: "root" });
var InventoryApiService = _InventoryApiService;

// src/app/modules/dashboard/components/inventory/inventory-list/inventory-list.component.ts
var _c014 = ["filterInput"];
var InventoryListComponent_Defer_45_DepsFn = () => [RouterLink, \u0275NgNoValidate, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatSlideToggle, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader, MatSelect, MatSelectTrigger, MatOption, MatCheckbox, LazyLoadImageDirective, LoadingDataComponent, NgModel, CutDetailPipe];
var _c18 = () => [10, 25, 50, 100];
var _c23 = (a0) => ["./view", a0];
function InventoryListComponent_For_28_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-option", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const code_r3 = ctx.$implicit;
    \u0275\u0275property("value", code_r3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(code_r3);
  }
}
function InventoryListComponent_button_30_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 26);
    \u0275\u0275listener("click", function InventoryListComponent_button_30_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.search.setValue(""));
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "close");
    \u0275\u0275elementEnd()();
  }
}
function InventoryListComponent_Conditional_42_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 25);
  }
}
function InventoryListComponent_Defer_43_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 32);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r4.category.value == null ? null : ctx_r4.category.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function InventoryListComponent_Defer_43_For_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 40);
    \u0275\u0275listener("click", function InventoryListComponent_Defer_43_For_16_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r8 = ctx.$implicit;
    \u0275\u0275property("value", category_r8);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(category_r8);
  }
}
function InventoryListComponent_Defer_43_Conditional_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 32);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r4.status.value == null ? null : ctx_r4.status.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function InventoryListComponent_Defer_43_For_25_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 40);
    \u0275\u0275listener("click", function InventoryListComponent_Defer_43_For_25_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const status_r10 = ctx.$implicit;
    \u0275\u0275property("value", status_r10);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(status_r10);
  }
}
function InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_header_cell_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-header-cell", 55)(1, "mat-checkbox", 56);
    \u0275\u0275listener("change", function InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_header_cell_1_Template_mat_checkbox_change_1_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r4 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView($event ? ctx_r4.toggleAllRows() : null);
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("checked", ctx_r4.selection.hasValue() && ctx_r4.isAllSelected())("indeterminate", ctx_r4.selection.hasValue() && !ctx_r4.isAllSelected());
  }
}
function InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_cell_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell", 55)(1, "mat-checkbox", 57);
    \u0275\u0275listener("click", function InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_cell_2_Template_mat_checkbox_click_1_listener($event) {
      \u0275\u0275restoreView(_r12);
      return \u0275\u0275resetView($event.stopPropagation());
    })("change", function InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_cell_2_Template_mat_checkbox_change_1_listener($event) {
      const row_r13 = \u0275\u0275restoreView(_r12).$implicit;
      const ctx_r4 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView($event ? ctx_r4.selection.toggle(row_r13) : null);
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const row_r13 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("checked", ctx_r4.selection.isSelected(row_r13));
  }
}
function InventoryListComponent_Defer_43_Conditional_35_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 41);
    \u0275\u0275template(1, InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_header_cell_1_Template, 2, 2, "mat-header-cell", 53)(2, InventoryListComponent_Defer_43_Conditional_35_Conditional_1_mat_cell_2_Template, 2, 1, "mat-cell", 54);
    \u0275\u0275elementContainerEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r14 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r14.no, " ");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "\u0E23\u0E39\u0E1B");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell")(1, "a", 59);
    \u0275\u0275element(2, "img", 60);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const element_r15 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(3, _c23, element_r15.id));
    \u0275\u0275advance();
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx_r4.imageUrl + element_r15.image);
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r16 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r16.code, " ");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r17 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r17.category, " ");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r18 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r18.status, " ");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r19 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r19.location, " ");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 58);
    \u0275\u0275text(1, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cutDetail");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r20 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, element_r20.description), " ");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_header_row_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_mat_row_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function InventoryListComponent_Defer_43_Conditional_35_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-table", 38);
    \u0275\u0275template(1, InventoryListComponent_Defer_43_Conditional_35_Conditional_1_Template, 3, 0, "ng-container", 41);
    \u0275\u0275elementContainerStart(2, 42);
    \u0275\u0275template(3, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_3_Template, 2, 0, "mat-header-cell", 43)(4, InventoryListComponent_Defer_43_Conditional_35_mat_cell_4_Template, 2, 1, "mat-cell", 44);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(5, 45);
    \u0275\u0275template(6, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_6_Template, 2, 0, "mat-header-cell", 43)(7, InventoryListComponent_Defer_43_Conditional_35_mat_cell_7_Template, 3, 5, "mat-cell", 44);
    \u0275\u0275text(8, " \u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(9, 46);
    \u0275\u0275template(10, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_10_Template, 2, 0, "mat-header-cell", 43)(11, InventoryListComponent_Defer_43_Conditional_35_mat_cell_11_Template, 2, 1, "mat-cell", 44);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(12, 47);
    \u0275\u0275template(13, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_13_Template, 2, 0, "mat-header-cell", 43)(14, InventoryListComponent_Defer_43_Conditional_35_mat_cell_14_Template, 2, 1, "mat-cell", 44);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(15, 48);
    \u0275\u0275template(16, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_16_Template, 2, 0, "mat-header-cell", 43)(17, InventoryListComponent_Defer_43_Conditional_35_mat_cell_17_Template, 2, 1, "mat-cell", 44);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(18, 49);
    \u0275\u0275template(19, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_19_Template, 2, 0, "mat-header-cell", 43)(20, InventoryListComponent_Defer_43_Conditional_35_mat_cell_20_Template, 2, 1, "mat-cell", 44);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(21, 50);
    \u0275\u0275template(22, InventoryListComponent_Defer_43_Conditional_35_mat_header_cell_22_Template, 2, 0, "mat-header-cell", 43)(23, InventoryListComponent_Defer_43_Conditional_35_mat_cell_23_Template, 3, 3, "mat-cell", 44);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(24, InventoryListComponent_Defer_43_Conditional_35_mat_header_row_24_Template, 1, 0, "mat-header-row", 51)(25, InventoryListComponent_Defer_43_Conditional_35_mat_row_25_Template, 1, 0, "mat-row", 52);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275property("dataSource", ctx_r4.dataSource);
    \u0275\u0275advance();
    \u0275\u0275conditional(1, ctx_r4.isSelected ? 1 : -1);
    \u0275\u0275advance(23);
    \u0275\u0275property("matHeaderRowDef", ctx_r4.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r4.displayedColumns);
  }
}
function InventoryListComponent_Defer_43_Conditional_36_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 61);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "list");
  }
}
function InventoryListComponent_Defer_43_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 27)(1, "mat-card-header", 28)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 29);
    \u0275\u0275listener("click", function InventoryListComponent_Defer_43_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.onResetFilter());
    });
    \u0275\u0275text(5, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "mat-card-content")(7, "form", 30)(8, "mat-form-field")(9, "mat-label");
    \u0275\u0275text(10, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "mat-select", 31)(12, "mat-select-trigger");
    \u0275\u0275text(13);
    \u0275\u0275template(14, InventoryListComponent_Defer_43_Conditional_14_Template, 2, 1, "span", 32);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(15, InventoryListComponent_Defer_43_For_16_Template, 2, 2, "mat-option", 18, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "mat-form-field")(18, "mat-label");
    \u0275\u0275text(19, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "mat-select", 33)(21, "mat-select-trigger");
    \u0275\u0275text(22);
    \u0275\u0275template(23, InventoryListComponent_Defer_43_Conditional_23_Template, 2, 1, "span", 32);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(24, InventoryListComponent_Defer_43_For_25_Template, 2, 2, "mat-option", 18, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "mat-form-field")(27, "mat-label");
    \u0275\u0275text(28, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(29, "input", 34, 2);
    \u0275\u0275listener("keyup", function InventoryListComponent_Defer_43_Template_input_keyup_29_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.applyFilter($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(31, "div", 35)(32, "mat-slide-toggle", 36);
    \u0275\u0275twoWayListener("ngModelChange", function InventoryListComponent_Defer_43_Template_mat_slide_toggle_ngModelChange_32_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r4.isSelected, $event) || (ctx_r4.isSelected = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("click", function InventoryListComponent_Defer_43_Template_mat_slide_toggle_click_32_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.isSelectPrint());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "button", 37);
    \u0275\u0275listener("click", function InventoryListComponent_Defer_43_Template_button_click_33_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.addToPrint());
    });
    \u0275\u0275text(34, " \u0E40\u0E1E\u0E34\u0E48\u0E21\u0E44\u0E1B\u0E22\u0E31\u0E07\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E1E\u0E34\u0E21\u0E1E\u0E4C ");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(35, InventoryListComponent_Defer_43_Conditional_35_Template, 26, 4, "mat-table", 38)(36, InventoryListComponent_Defer_43_Conditional_36_Template, 1, 1);
    \u0275\u0275element(37, "mat-paginator", 39);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r4.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx_r4.form);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", (ctx_r4.category.value == null ? null : ctx_r4.category.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(14, ((ctx_r4.category.value == null ? null : ctx_r4.category.value.length) || 0) > 1 ? 14 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.filter.categories);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1(" ", (ctx_r4.status.value == null ? null : ctx_r4.status.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(23, ((ctx_r4.status.value == null ? null : ctx_r4.status.value.length) || 0) > 1 ? 23 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.filter.statuses);
    \u0275\u0275advance(8);
    \u0275\u0275twoWayProperty("ngModel", ctx_r4.isSelected);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", !ctx_r4.isSelected);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(35, !ctx_r4.isLoading ? 35 : 36);
    \u0275\u0275advance(2);
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(10, _c18));
  }
}
function InventoryListComponent_DeferPlaceholder_44_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 61);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "list");
  }
}
var Tap3;
(function(Tap4) {
  Tap4[Tap4["Date"] = 0] = "Date";
  Tap4[Tap4["Code"] = 1] = "Code";
})(Tap3 || (Tap3 = {}));
var _InventoryListComponent = class _InventoryListComponent {
  constructor() {
    this.activatedRoute = inject(ActivatedRoute);
    this.formBuilder = inject(FormBuilder);
    this.inventoryService = inject(InventoryService);
    this.inventoryApiService = inject(InventoryApiService);
    this.categoryService = inject(CategoryService);
    this.statusService = inject(StatusService);
    this.validationService = inject(ValidationService);
    this.printService = inject(PrintService);
    this.searchService = inject(SearchService);
    this.snackBar = inject(MatSnackBar);
    this.platfrom = inject(Platform);
    this.subscription = new Subscription();
    this.datePipe = inject(DatePipe);
    this.imageUrl = environment.imageUrl;
    this.filter = {
      categories: this.categoryService.getActiveNames(),
      statuses: this.statusService.getActiveNames()
    };
    this.form = this.initForm();
    this.title = "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23 \u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.isLoading = false;
    this.isSort = false;
    this.isSelected = false;
    this.isPrint = false;
    this.selectedTap = new FormControl(Tap3.Date);
    this.startDate = new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
    this.endDate = /* @__PURE__ */ new Date();
    this.dateRange = this.formBuilder.group({
      start: [this.startDate, [Validators.required]],
      end: [this.endDate, [Validators.required]]
    });
    this.displayedColumns = [
      "no",
      "image",
      "code",
      "category",
      "status",
      "location",
      "description"
    ];
    this.dataSource = new MatTableDataSource([]);
    this.selection = new SelectionModel(true, []);
    this.isFirstLoading = false;
    this.search = new FormControl();
    this.cache = [];
  }
  ngOnInit() {
    this.initDataSource();
    this.initSubscriptions();
    if (this.activatedRoute.snapshot.queryParams["isPrint"] === "true")
      this.isPrint = true;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSearchAutoComplete(query) {
    this.searchService.search$.next(query);
  }
  onSearch() {
    if (this.selectedTap.value === Tap3.Date) {
      if (this.dateRange.invalid)
        return;
      const startDate = this.datePipe.transform(this.dateRange.controls["start"].value, "yyyy-MM-dd");
      const endDate = this.datePipe.transform(this.dateRange.controls["end"].value, "yyyy-MM-dd");
      this.operation$ = this.inventoryApiService.getByDate(startDate, endDate);
    } else if (this.selectedTap.value === Tap3.Code) {
      if (!this.search.value)
        return;
      const code = this.search.value.replace(/^\s+|\s+$/gm, "");
      if (!code)
        return;
      const inventory = this.inventoryService.getTableDataWithCode(code);
      if (!this.validationService.isEmpty(inventory)) {
        this.dataSource.data = inventory;
        return;
      }
      this.operation$ = this.inventoryApiService.getByCode(code);
    }
    this.isLoading = true;
    this.isSort = false;
    this.operation$.pipe(tap(() => this.onFilter()), finalize(() => this.isLoading = false)).subscribe();
  }
  onSearchAll() {
    this.isLoading = true;
    this.isSort = false;
    this.inventoryApiService.getAll().pipe(tap(() => this.setFilter()), finalize(() => this.isLoading = false)).subscribe();
  }
  setFilter() {
    this.form.setValue({ category: [], status: [] });
  }
  onFilter() {
    const inventories = this.inventoryService.getTableData();
    const filters = this.form.value;
    this.dataSource.data = Object.keys(filters).reduce((result, keyName) => result.filter((item) => {
      if (filters[keyName].length === 0)
        return result;
      return filters[keyName].includes(item[keyName]);
    }), inventories).map((inventory, i3) => __spreadProps(__spreadValues({}, inventory), { no: i3 + 1 }));
  }
  onResetFilter() {
    this.filterInput.nativeElement.value = "";
    this.dataSource.filter = "";
    this.setFilter();
    this.onFilter();
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }
  toggleAllRows() {
    if (this.isAllSelected()) {
      this.selection.clear();
      return;
    }
    this.selection.select(...this.dataSource.data);
  }
  isSelectPrint() {
    if (this.isSelected)
      this.displayedColumns.unshift("select");
    else
      this.displayedColumns.shift();
  }
  addToPrint() {
    let horizontalPosition = "center";
    let verticalPosition = "bottom";
    if (this.platfrom.ANDROID || this.platfrom.IOS) {
      horizontalPosition = "center";
      verticalPosition = "top";
    }
    this.snackBar.open("\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\u0E44\u0E1B\u0E22\u0E31\u0E07\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E1E\u0E34\u0E21\u0E1E\u0E4C", "\u0E1B\u0E34\u0E14", {
      duration: 2500,
      horizontalPosition,
      verticalPosition
    });
    const inventories = this.selection.selected.filter((inventory) => !this.printService.getById(inventory.id)).map((inventory) => ({
      id: inventory.id,
      track: inventory.track,
      image: inventory.image,
      code: inventory.code,
      description: inventory.description,
      printCount: 1
    }));
    for (const inventory of inventories) {
      this.printService.create(inventory);
    }
  }
  get category() {
    return this.form.controls["category"];
  }
  get status() {
    return this.form.controls["status"];
  }
  initForm() {
    return this.formBuilder.group({
      category: this.formBuilder.control([]),
      status: this.formBuilder.control([])
    });
  }
  initDataSource() {
    this.dataSource.data = this.inventoryService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data)) {
      this.inventoryApiService.getInit().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
      return;
    }
    this.initPaginatorAndSort();
  }
  initPaginatorAndSort() {
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
      if (!this.isSort) {
        this.dataSource.sort.sort({
          id: "no",
          start: "desc",
          disableClear: true
        });
        this.isSort = true;
      }
      if (this.isPrint) {
        this.isSelected = this.isPrint;
        this.isSelectPrint();
      }
    });
  }
  initSubscriptions() {
    this.subscription.add(this.inventoryService.onListener().subscribe(() => {
      this.dataSource.data = this.inventoryService.getTableData();
      this.initPaginatorAndSort();
    }));
    this.subscription.add(this.categoryService.onListener().subscribe(() => {
      this.filter.categories = this.categoryService.getActiveNames();
    }));
    this.subscription.add(this.statusService.onListener().subscribe(() => {
      this.filter.statuses = this.statusService.getActiveNames();
    }));
    this.subscription.add(this.searchService.onListener().subscribe((cache2) => this.cache = this.searchService.getCache()));
    this.filteredOptions = merge(this.search.valueChanges, this.searchService.onListener().pipe(map(() => this.search.value))).pipe(startWith(""), map((value2) => this._filter(value2 || "")));
  }
  _filter(value2) {
    const filterValue = value2.toLowerCase();
    return this.cache.filter((option) => option.toLowerCase().includes(filterValue));
  }
};
_InventoryListComponent.\u0275fac = function InventoryListComponent_Factory(t2) {
  return new (t2 || _InventoryListComponent)();
};
_InventoryListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryListComponent, selectors: [["app-inventory-list"]], viewQuery: function InventoryListComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(_c014, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.filterInput = _t2.first);
  }
}, decls: 47, vars: 13, consts: [["picker", ""], ["auto", "matAutocomplete"], ["filterInput", ""], [300], ["routerLink", "new", "mat-fab", "", "color", "primary", 1, "mb-20"], [1, "mb-20", "mat-elevation-z8"], ["mat-stretch-tabs", "false", 3, "selectedIndexChange", "selectedIndex"], ["label", "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48"], [1, "w-100"], [3, "rangePicker", "formGroup"], ["matStartDate", "", "formControlName", "start", "readonly", "", 3, "click"], ["matEndDate", "", "formControlName", "end", "readonly", "", 3, "click"], ["align", "end"], ["matIconSuffix", "", 3, "for"], ["label", "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C"], [3, "ngSubmit"], ["type", "text", "matInput", "", 3, "input", "formControl", "matAutocomplete"], ["autoActiveFirstOption", ""], [3, "value"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click", 4, "ngIf"], ["type", "submit", "matSuffix", "", "mat-icon-button", ""], ["matSuffix", "", "fontIcon", "search"], [1, "justify-between"], ["type", "button", "mat-raised-button", "", "color", "primary", 3, "click", "disabled"], ["type", "button", "mat-raised-button", "", "color", "accent", 3, "click", "disabled"], ["mode", "indeterminate"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click"], [1, "mat-elevation-z8"], [1, "mb-16", "d-flex", "justify-between", "align-center"], ["type", "button", "mat-button", "", "color", "warn", 3, "click"], [1, "filter-box", 3, "formGroup"], ["formControlName", "category", "multiple", ""], [1, "additional-selection"], ["formControlName", "status", "multiple", ""], ["matInput", "", 3, "keyup"], [1, "d-flex", "align-center", "gap-10"], [3, "ngModelChange", "click", "ngModel"], ["type", "button", "mat-button", "", "color", "accent", 3, "click", "disabled"], ["matSort", "", 3, "dataSource"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], [3, "click", "value"], ["matColumnDef", "select"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "image"], ["matColumnDef", "code"], ["matColumnDef", "category"], ["matColumnDef", "status"], ["matColumnDef", "location"], ["matColumnDef", "description"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["class", "p-0", 4, "matHeaderCellDef"], ["class", "p-0", 4, "matCellDef"], [1, "p-0"], [3, "change", "checked", "indeterminate"], [3, "click", "change", "checked"], ["mat-sort-header", ""], [1, "blurred-img", 3, "routerLink"], [3, "defaultImage", "lazyLoad"], [3, "form"]], template: function InventoryListComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 4)(1, "mat-icon");
    \u0275\u0275text(2, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(3, "mat-card", 5)(4, "mat-tab-group", 6);
    \u0275\u0275listener("selectedIndexChange", function InventoryListComponent_Template_mat_tab_group_selectedIndexChange_4_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectedTap.setValue($event));
    });
    \u0275\u0275elementStart(5, "mat-tab", 7)(6, "mat-card-content")(7, "mat-form-field", 8)(8, "mat-label");
    \u0275\u0275text(9, "\u0E08\u0E32\u0E01 - \u0E16\u0E36\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "mat-date-range-input", 9)(11, "input", 10);
    \u0275\u0275listener("click", function InventoryListComponent_Template_input_click_11_listener() {
      \u0275\u0275restoreView(_r1);
      const picker_r2 = \u0275\u0275reference(17);
      return \u0275\u0275resetView(picker_r2.open());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "input", 11);
    \u0275\u0275listener("click", function InventoryListComponent_Template_input_click_12_listener() {
      \u0275\u0275restoreView(_r1);
      const picker_r2 = \u0275\u0275reference(17);
      return \u0275\u0275resetView(picker_r2.open());
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "mat-hint", 12);
    \u0275\u0275text(14, "\u0E27\u0E31\u0E19/\u0E40\u0E14\u0E37\u0E2D\u0E19/\u0E1E.\u0E28.");
    \u0275\u0275elementEnd();
    \u0275\u0275element(15, "mat-datepicker-toggle", 13)(16, "mat-date-range-picker", null, 0);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(18, "mat-tab", 14)(19, "mat-card-content")(20, "form", 15);
    \u0275\u0275listener("ngSubmit", function InventoryListComponent_Template_form_ngSubmit_20_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearch());
    });
    \u0275\u0275elementStart(21, "mat-form-field", 8)(22, "mat-label");
    \u0275\u0275text(23, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "input", 16);
    \u0275\u0275listener("input", function InventoryListComponent_Template_input_input_24_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchAutoComplete(ctx.search.value));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(25, "mat-autocomplete", 17, 1);
    \u0275\u0275repeaterCreate(27, InventoryListComponent_For_28_Template, 2, 2, "mat-option", 18, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275pipe(29, "async");
    \u0275\u0275elementEnd();
    \u0275\u0275template(30, InventoryListComponent_button_30_Template, 3, 0, "button", 19);
    \u0275\u0275elementStart(31, "button", 20);
    \u0275\u0275element(32, "mat-icon", 21);
    \u0275\u0275elementEnd()()()()();
    \u0275\u0275text(33, "> ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(34, "mat-card-actions", 22)(35, "button", 23);
    \u0275\u0275listener("click", function InventoryListComponent_Template_button_click_35_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearch());
    });
    \u0275\u0275elementStart(36, "mat-icon");
    \u0275\u0275text(37, "search");
    \u0275\u0275elementEnd();
    \u0275\u0275text(38, " \u0E04\u0E49\u0E19\u0E2B\u0E32 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(39, "button", 24);
    \u0275\u0275listener("click", function InventoryListComponent_Template_button_click_39_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearchAll());
    });
    \u0275\u0275text(40, " \u0E04\u0E49\u0E19\u0E2B\u0E32\u0E17\u0E31\u0E49\u0E07\u0E2B\u0E21\u0E14 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(41, "mat-card-footer");
    \u0275\u0275template(42, InventoryListComponent_Conditional_42_Template, 1, 0, "mat-progress-bar", 25);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(43, InventoryListComponent_Defer_43_Template, 38, 11)(44, InventoryListComponent_DeferPlaceholder_44_Template, 1, 1);
    \u0275\u0275defer(45, 43, InventoryListComponent_Defer_45_DepsFn, null, 44, null, null, 3, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    const picker_r2 = \u0275\u0275reference(17);
    const auto_r21 = \u0275\u0275reference(26);
    \u0275\u0275advance(4);
    \u0275\u0275property("selectedIndex", ctx.selectedTap.value);
    \u0275\u0275advance(6);
    \u0275\u0275property("rangePicker", picker_r2)("formGroup", ctx.dateRange);
    \u0275\u0275advance(5);
    \u0275\u0275property("for", picker_r2);
    \u0275\u0275advance(9);
    \u0275\u0275property("formControl", ctx.search)("matAutocomplete", auto_r21);
    \u0275\u0275advance(3);
    \u0275\u0275repeater(\u0275\u0275pipeBind1(29, 11, ctx.filteredOptions));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.search.value);
    \u0275\u0275advance(5);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(42, ctx.isLoading ? 42 : -1);
    \u0275\u0275advance(3);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
  }
}, dependencies: [RouterLink, NgIf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormControlDirective, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatFabAnchor, MatIcon, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatInput, MatFormField, MatLabel, MatHint, MatSuffix, MatProgressBar, MatOption, MatDatepickerToggle, MatDateRangeInput, MatStartDate, MatEndDate, MatDateRangePicker, MatTab, MatTabGroup, MatAutocomplete, MatAutocompleteTrigger, LoadingDataComponent, NgForm, AsyncPipe], styles: ["\n\n.mat-column-select[_ngcontent-%COMP%] {\n  flex: 0 0 60px;\n}\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-image[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  padding-block: 8px;\n}\n.mat-column-code[_ngcontent-%COMP%] {\n  flex: 0 0 140px;\n}\n.mat-column-category[_ngcontent-%COMP%] {\n  flex: 0 0 150px;\n}\n.mat-column-status[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-location[_ngcontent-%COMP%] {\n  flex: 0 0 100px;\n}\n.mat-column-description[_ngcontent-%COMP%] {\n  min-width: 200px;\n}\nimg[_ngcontent-%COMP%] {\n  width: 100%;\n  height: 100%;\n}\nmat-row[_ngcontent-%COMP%]:hover {\n  background-color: #f5f5f5;\n  transition: 0.2s;\n}\n.dark-theme[_nghost-%COMP%]   mat-row[_ngcontent-%COMP%]:hover, .dark-theme   [_nghost-%COMP%]   mat-row[_ngcontent-%COMP%]:hover {\n  background-color: #343434;\n}\n.filter-box[_ngcontent-%COMP%] {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-between;\n  gap: 10px;\n}\n.filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n  flex: 1 1 calc(25% - 10px);\n  min-width: 150px;\n}\n.filter-box[_ngcontent-%COMP%]   .additional-selection[_ngcontent-%COMP%] {\n  opacity: 0.75;\n  font-size: 0.75em;\n}\n@media (max-width: 968px) {\n  .filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n    flex: 1 1 calc(50% - 10px);\n  }\n}\n/*# sourceMappingURL=inventory-list.component.css.map */"] });
var InventoryListComponent = _InventoryListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryListComponent, { className: "InventoryListComponent", filePath: "src\\app\\modules\\dashboard\\components\\inventory\\inventory-list\\inventory-list.component.ts", lineNumber: 60 });
})();

// src/app/modules/dashboard/components/inventory/inventory-new/inventory-new.component.ts
var _c015 = ["formDirec"];
var _c19 = ["codeEl"];
var _c24 = ["dateEl"];
var _c33 = ["picker"];
var InventoryNewComponent_Defer_2_DepsFn = () => [NgForOf, NgIf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatHint, MatError, MatSuffix, MatProgressBar, MatDatepicker, MatDatepickerInput, MatDatepickerToggle, MatChipListbox, MatChipOption, MatCheckbox, NgxDropzoneComponent, NgxDropzoneLabelDirective, NgxDropzoneImagePreviewComponent, NgxMaskDirective, ErrorFieldComponent];
function InventoryNewComponent_Defer_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 7);
    \u0275\u0275text(2, " \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17, \u0E2A\u0E16\u0E32\u0E19\u0E30, \u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19, \u0E2B\u0E23\u0E37\u0E2D\u0E2B\u0E49\u0E2D\u0E07\u0E02\u0E2D\u0E07\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C \u0E01\u0E23\u0E38\u0E13\u0E32\u0E15\u0E34\u0E14\u0E15\u0E48\u0E2D Admin ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_ngx_dropzone_image_preview_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ngx-dropzone-image-preview", 36);
    \u0275\u0275listener("removed", function InventoryNewComponent_Defer_0_ng_template_1_ngx_dropzone_image_preview_12_Template_ngx_dropzone_image_preview_removed_0_listener() {
      const f_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onRemoveImage(f_r4));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const f_r4 = ctx.$implicit;
    \u0275\u0275property("file", f_r4)("removable", true);
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_For_35_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 37);
    \u0275\u0275listener("selectionChange", function InventoryNewComponent_Defer_0_ng_template_1_For_35_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("category"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r6 = ctx.$implicit;
    \u0275\u0275property("value", category_r6.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(category_r6.name);
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_For_43_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 37);
    \u0275\u0275listener("selectionChange", function InventoryNewComponent_Defer_0_ng_template_1_For_43_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("status"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const status_r8 = ctx.$implicit;
    \u0275\u0275property("value", status_r8.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", status_r8.name, " ");
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_For_80_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 37);
    \u0275\u0275listener("selectionChange", function InventoryNewComponent_Defer_0_ng_template_1_For_80_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("fund"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const fund_r10 = ctx.$implicit;
    \u0275\u0275property("value", fund_r10.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", fund_r10.name, " ");
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_For_88_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 37);
    \u0275\u0275listener("selectionChange", function InventoryNewComponent_Defer_0_ng_template_1_For_88_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("location"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const location_r12 = ctx.$implicit;
    \u0275\u0275property("value", location_r12.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", location_r12.name, " ");
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_Conditional_101_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 35);
  }
}
function InventoryNewComponent_Defer_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card")(1, "mat-card-header", 8)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 9);
    \u0275\u0275listener("click", function InventoryNewComponent_Defer_0_ng_template_1_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onReset());
    });
    \u0275\u0275text(5, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "form", 10, 1);
    \u0275\u0275listener("ngSubmit", function InventoryNewComponent_Defer_0_ng_template_1_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275elementStart(8, "mat-card-content", 11)(9, "ngx-dropzone", 12);
    \u0275\u0275listener("change", function InventoryNewComponent_Defer_0_ng_template_1_Template_ngx_dropzone_change_9_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onSelectImage($event));
    });
    \u0275\u0275elementStart(10, "ngx-dropzone-label");
    \u0275\u0275text(11, "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E23\u0E39\u0E1B (jpg, jpeg, png)");
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, InventoryNewComponent_Defer_0_ng_template_1_ngx_dropzone_image_preview_12_Template, 1, 2, "ngx-dropzone-image-preview", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "mat-error");
    \u0275\u0275element(14, "app-error-field", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "mat-form-field")(16, "mat-label");
    \u0275\u0275text(17, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(18, "input", 15, 2);
    \u0275\u0275elementStart(20, "mat-hint", 16);
    \u0275\u0275text(21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "mat-error");
    \u0275\u0275element(23, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(24, "mat-form-field")(25, "mat-label");
    \u0275\u0275text(26, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "textarea", 17);
    \u0275\u0275elementStart(28, "mat-error");
    \u0275\u0275element(29, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(30, "div", 18)(31, "mat-card-title");
    \u0275\u0275text(32, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "mat-chip-listbox", 19);
    \u0275\u0275repeaterCreate(34, InventoryNewComponent_Defer_0_ng_template_1_For_35_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "mat-error");
    \u0275\u0275element(37, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "div", 18)(39, "mat-card-title");
    \u0275\u0275text(40, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(41, "mat-chip-listbox", 21);
    \u0275\u0275repeaterCreate(42, InventoryNewComponent_Defer_0_ng_template_1_For_43_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(44, "mat-error");
    \u0275\u0275element(45, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(46, "div", 22)(47, "mat-form-field")(48, "mat-label");
    \u0275\u0275text(49, "\u0E2B\u0E19\u0E48\u0E27\u0E22\u0E19\u0E31\u0E1A");
    \u0275\u0275elementEnd();
    \u0275\u0275element(50, "input", 23);
    \u0275\u0275elementStart(51, "mat-error");
    \u0275\u0275element(52, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(53, "mat-form-field")(54, "mat-label");
    \u0275\u0275text(55, "\u0E21\u0E39\u0E25\u0E04\u0E48\u0E32\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(56, "input", 24);
    \u0275\u0275elementStart(57, "mat-error");
    \u0275\u0275element(58, "app-error-field", 14);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(59, "div", 22)(60, "mat-form-field")(61, "mat-label");
    \u0275\u0275text(62, "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E44\u0E14\u0E49\u0E21\u0E32");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(63, "input", 25, 3);
    \u0275\u0275listener("focusout", function InventoryNewComponent_Defer_0_ng_template_1_Template_input_focusout_63_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDateInput());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(65, "input", 26);
    \u0275\u0275listener("dateInput", function InventoryNewComponent_Defer_0_ng_template_1_Template_input_dateInput_65_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDatePicker($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(66, "mat-hint", 16);
    \u0275\u0275text(67, "\u0E27\u0E31\u0E19/\u0E40\u0E14\u0E37\u0E2D\u0E19/\u0E1E.\u0E28. (5/9/2560)");
    \u0275\u0275elementEnd();
    \u0275\u0275element(68, "mat-datepicker-toggle", 27)(69, "mat-datepicker", null, 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(71, "mat-form-field")(72, "mat-label");
    \u0275\u0275text(73, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\u0E40\u0E14\u0E34\u0E21");
    \u0275\u0275elementEnd();
    \u0275\u0275element(74, "input", 28);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(75, "div", 18)(76, "mat-card-title");
    \u0275\u0275text(77, "\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(78, "mat-chip-listbox", 29);
    \u0275\u0275repeaterCreate(79, InventoryNewComponent_Defer_0_ng_template_1_For_80_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(81, "mat-error");
    \u0275\u0275element(82, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(83, "div", 18)(84, "mat-card-title");
    \u0275\u0275text(85, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(86, "mat-chip-listbox", 30);
    \u0275\u0275repeaterCreate(87, InventoryNewComponent_Defer_0_ng_template_1_For_88_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(89, "mat-error");
    \u0275\u0275element(90, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(91, "mat-form-field")(92, "mat-label");
    \u0275\u0275text(93, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(94, "textarea", 31);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(95, "mat-card-actions", 32)(96, "button", 33);
    \u0275\u0275text(97, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(98, "mat-checkbox", 34);
    \u0275\u0275listener("change", function InventoryNewComponent_Defer_0_ng_template_1_Template_mat_checkbox_change_98_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.remember = $event.checked);
    });
    \u0275\u0275text(99, "\u0E08\u0E33\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E25\u0E48\u0E32\u0E2A\u0E38\u0E14");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(100, "mat-card-footer");
    \u0275\u0275template(101, InventoryNewComponent_Defer_0_ng_template_1_Conditional_101_Template, 1, 0, "mat-progress-bar", 35);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const picker_r13 = \u0275\u0275reference(70);
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.formInventory);
    \u0275\u0275advance(3);
    \u0275\u0275property("accept", "image/jpeg,image/jpg,image/png")("multiple", false);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.files);
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.image)("errorMessage", ctx_r1.validationField.image);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1("", ctx_r1.code.value.length, "/27");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.code)("errorMessage", ctx_r1.validationField.code);
    \u0275\u0275advance(6);
    \u0275\u0275property("control", ctx_r1.description)("errorMessage", ctx_r1.validationField.description);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx_r1.categories);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.category)("errorMessage", ctx_r1.validationField.category);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx_r1.statuses);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.status)("errorMessage", ctx_r1.validationField.status);
    \u0275\u0275advance(7);
    \u0275\u0275property("control", ctx_r1.unit)("errorMessage", ctx_r1.validationField.unit);
    \u0275\u0275advance(6);
    \u0275\u0275property("control", ctx_r1.value)("errorMessage", ctx_r1.validationField.value);
    \u0275\u0275advance(7);
    \u0275\u0275property("matDatepicker", picker_r13);
    \u0275\u0275advance(3);
    \u0275\u0275property("for", picker_r13)("disabled", ctx_r1.formInventory.disabled);
    \u0275\u0275advance(11);
    \u0275\u0275repeater(ctx_r1.funds);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.fund)("errorMessage", ctx_r1.validationField.fund);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx_r1.locations);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.location)("errorMessage", ctx_r1.validationField.location);
    \u0275\u0275advance(6);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("checked", ctx_r1.remember);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(101, ctx_r1.isLoading ? 101 : -1);
  }
}
function InventoryNewComponent_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryNewComponent_Defer_0_ng_container_0_Template, 3, 0, "ng-container", 6)(1, InventoryNewComponent_Defer_0_ng_template_1_Template, 102, 31, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const content_r14 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.categories.length <= 0 || ctx_r1.statuses.length <= 0 || ctx_r1.locations.length <= 0)("ngIfElse", content_r14);
  }
}
function InventoryNewComponent_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 38);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _InventoryNewComponent = class _InventoryNewComponent {
  constructor() {
    this.formBuilder = inject(FormBuilder);
    this.inventoryService = inject(InventoryService);
    this.inventoryApiService = inject(InventoryApiService);
    this.categoryService = inject(CategoryService);
    this.statusService = inject(StatusService);
    this.fundService = inject(FundService);
    this.locationService = inject(LocationService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.datePipe = inject(DatePipe);
    this.subscription = new Subscription();
    this.validationField = INVENTORY.validationField;
    this.files = [];
    this.title = "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.isLoading = this.inventoryService.getIsLoading();
    this.remember = false;
    this.categories = this.categoryService.getActiveDetails();
    this.statuses = this.statusService.getActiveDetails();
    this.funds = this.fundService.getActiveDetails();
    this.locations = this.locationService.getActiveDetails();
    this.formInventory = this.initFormInventory();
    this.formImage = this.initFormImage();
  }
  ngOnInit() {
    this.initSubscription();
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSubmit() {
    if (this.formInventory.invalid || this.image.hasError("mimeType"))
      return;
    const receivedDate = this.datePipe.transform(this.receivedDate.value, "yyyy-MM-dd");
    const category = this.categories.find((category2) => category2.id === this.category.value);
    const categoryName = category ? category.name : "";
    const status = this.statuses.find((status2) => status2.id === this.status.value);
    const statusName = status ? status.name : "";
    const fund = this.funds.find((fund2) => fund2.id === this.fund.value);
    const fundName = fund ? fund.name : "";
    const location2 = this.locations.find((location3) => location3.id === this.location.value);
    const locationName = location2 ? location2.name : "";
    const payload = new FormData();
    payload.append("code", this.code.value);
    payload.append("oldCode", this.oldCode.value);
    payload.append("description", this.description.value);
    payload.append("unit", this.unit.value);
    payload.append("value", this.value.value);
    payload.append("receivedDate", receivedDate);
    payload.append("remark", this.remark.value);
    payload.append("image", this.image.value);
    payload.append("categoryId", this.category.value.toString());
    payload.append("categoryName", categoryName);
    payload.append("statusId", this.status.value.toString());
    payload.append("statusName", statusName);
    payload.append("fundId", this.fund.value.toString());
    payload.append("fundName", fundName);
    payload.append("locationId", this.location.value.toString());
    payload.append("locationName", locationName);
    this.isLoading = true;
    this.inventoryApiService.create(payload).pipe(finalize(() => this.isLoading = false)).subscribe((res) => {
      this.toastService.success("Success", res.message);
      this.code.setValue(this.setCode(this.code.value));
      if (!this.remember)
        this.onReset();
    });
  }
  onReset() {
    this.files.length = 0;
    this.codeEl.nativeElement.focus();
    this.formImage.reset();
    this.fromDirec.resetForm();
    this.category.markAsUntouched();
    this.status.markAsUntouched();
    this.fund.markAsUntouched();
    this.location.markAsUntouched();
  }
  onSelectImage(event) {
    this.files.length = 0;
    this.files.push(...event.addedFiles);
    this.image.setValue(this.files[0]);
    this.image.markAsTouched();
  }
  onRemoveImage(file) {
    this.files.splice(this.files.indexOf(file), 1);
    this.image.patchValue(null);
  }
  onDateInput() {
    const [d2, m2, y2] = this.dateEl.nativeElement.value.split("/");
    const date = new Date(+y2 - 543, +m2 - 1, +d2);
    this.receivedDate.setValue(date);
    if (this.receivedDate.errors)
      this.dateInput.setErrors(this.receivedDate.errors);
    if (!this.receivedDate.errors) {
      this.dateInput.setErrors(null);
      this.convertCEtoBE(date);
    }
  }
  onDatePicker(matDate) {
    const [d2, m2, y2] = this.datePipe.transform(matDate.value, "d/M/yyyy").split("/");
    const date = `${d2}/${m2}/${+y2 + 543}`;
    this.dateInput.setValue(date);
  }
  convertCEtoBE(date) {
    const [d2, m2, y2] = this.datePipe.transform(date, "d/M/yyyy").split("/");
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const yearBE = +y2 + 543;
    const dateCE = new Date(yearBE, +m2 - 1, +d2);
    if (yearBE <= currentYear) {
      const [d3, m3, y3] = this.datePipe.transform(dateCE, "d/M/yyyy").split("/");
      const date2 = `${d3}/${m3}/${+y3 + 543}`;
      this.receivedDate.setValue(dateCE);
      this.dateInput.setValue(date2);
    }
  }
  onSelectChip(keyName) {
    this[keyName].markAsTouched();
  }
  get code() {
    return this.formInventory.controls["code"];
  }
  get oldCode() {
    return this.formInventory.controls["oldCode"];
  }
  get dateInput() {
    return this.formInventory.controls["dateInput"];
  }
  get description() {
    return this.formInventory.controls["description"];
  }
  get unit() {
    return this.formInventory.controls["unit"];
  }
  get value() {
    return this.formInventory.controls["value"];
  }
  get receivedDate() {
    return this.formInventory.controls["receivedDate"];
  }
  get remark() {
    return this.formInventory.controls["remark"];
  }
  get category() {
    return this.formInventory.controls["category"];
  }
  get status() {
    return this.formInventory.controls["status"];
  }
  get fund() {
    return this.formInventory.controls["fund"];
  }
  get location() {
    return this.formInventory.controls["location"];
  }
  get image() {
    return this.formImage;
  }
  initFormInventory() {
    return this.formBuilder.nonNullable.group({
      code: ["", [Validators.required]],
      oldCode: [""],
      dateInput: ["", [Validators.required]],
      description: ["", [Validators.required]],
      unit: ["", [Validators.required]],
      value: ["", [Validators.required]],
      receivedDate: this.formBuilder.control(null, [
        Validators.required,
        this.validationService.isDate()
      ]),
      remark: [""],
      category: this.formBuilder.control(null, [Validators.required]),
      status: this.formBuilder.control(null, [Validators.required]),
      fund: this.formBuilder.control(null, [Validators.required]),
      location: this.formBuilder.control(null, [Validators.required]),
      image: [""]
    });
  }
  initFormImage() {
    return this.formBuilder.control(null, {
      validators: [Validators.required],
      asyncValidators: [this.validationService.mimeType()]
    });
  }
  initSubscription() {
    this.subscription.add(this.categoryService.onListener().subscribe(() => {
      this.categories = this.categoryService.getActiveDetails();
      this.category.setValue(null);
    }));
    this.subscription.add(this.statusService.onListener().subscribe(() => {
      this.statuses = this.statusService.getActiveDetails();
      this.status.setValue(null);
    }));
    this.subscription.add(this.fundService.onListener().subscribe(() => {
      this.funds = this.fundService.getActiveDetails();
      this.fund.setValue(null);
    }));
    this.subscription.add(this.locationService.onListener().subscribe(() => {
      this.locations = this.locationService.getActiveDetails();
      this.location.setValue(null);
    }));
    this.subscription.add(this.inventoryService.onIsLoadingListener().subscribe((isLoading) => this.isLoading = isLoading));
  }
  setCode(code) {
    let parts2 = code.split("-");
    let lastPart = parts2[parts2.length - 1];
    let incrementedLastPart = (parseInt(lastPart) + 1).toString().padStart(4, "0");
    parts2[parts2.length - 1] = incrementedLastPart;
    return parts2.join("-");
  }
};
_InventoryNewComponent.\u0275fac = function InventoryNewComponent_Factory(t2) {
  return new (t2 || _InventoryNewComponent)();
};
_InventoryNewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryNewComponent, selectors: [["app-inventory-new"]], viewQuery: function InventoryNewComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c015, 5);
    \u0275\u0275viewQuery(_c19, 5);
    \u0275\u0275viewQuery(_c24, 5);
    \u0275\u0275viewQuery(_c33, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.fromDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.codeEl = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.dateEl = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.picker = _t2.first);
  }
}, decls: 4, vars: 1, consts: [["content", ""], ["formDirec", "ngForm"], ["codeEl", ""], ["dateEl", ""], ["picker", ""], [300], [4, "ngIf", "ngIfElse"], ["mat-flat-button", "", "color", "warn", 1, "w-100"], [1, "justify-between"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], [1, "form-container", 3, "ngSubmit", "formGroup"], [1, "box"], [1, "dropzone", 3, "change", "accept", "multiple"], ["ngProjectAs", "ngx-dropzone-preview", 5, ["ngx-dropzone-preview"], 3, "file", "removable", "removed", 4, "ngFor", "ngForOf"], [3, "control", "errorMessage"], ["type", "text", "matInput", "", "formControlName", "code"], ["align", "end"], ["matInput", "", "formControlName", "description", "rows", "3"], [1, "d-flex", "flex-column"], ["formControlName", "category"], [3, "value"], ["formControlName", "status"], [1, "row"], ["type", "text", "matInput", "", "formControlName", "unit"], ["matInput", "", "type", "text", "mask", "separator.2", "thousandSeparator", ",", "decimalMarker", ".", "formControlName", "value"], ["matInput", "", "mask", "d0/M0/0000", "formControlName", "dateInput", 3, "focusout"], ["matInput", "", "formControlName", "receivedDate", 1, "hidden-input", 3, "dateInput", "matDatepicker"], ["matIconSuffix", "", "tabindex", "-1", 3, "for", "disabled"], ["type", "text", "matInput", "", "formControlName", "oldCode"], ["formControlName", "fund"], ["formControlName", "location"], ["matInput", "", "formControlName", "remark"], [1, "gap-20"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], [3, "change", "checked"], ["mode", "indeterminate"], ["ngProjectAs", "ngx-dropzone-preview", 5, ["ngx-dropzone-preview"], 3, "removed", "file", "removable"], [3, "selectionChange", "value"], [3, "form"]], template: function InventoryNewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryNewComponent_Defer_0_Template, 3, 2)(1, InventoryNewComponent_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, InventoryNewComponent_Defer_2_DepsFn, null, 1, null, null, 5, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275deferWhen(!ctx.isLoading);
  }
}, dependencies: [LoadingDataComponent] });
var InventoryNewComponent = _InventoryNewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryNewComponent, { className: "InventoryNewComponent", filePath: "src\\app\\modules\\dashboard\\components\\inventory\\inventory-new\\inventory-new.component.ts", lineNumber: 38 });
})();

// src/app/modules/dashboard/components/inventory/inventory-view/inventory-view.component.ts
var InventoryViewComponent_Defer_2_DepsFn = () => [NgIf, MatButton, MatList, MatListItem, MatListItemLine, MatListItemTitle, MatCard, MatCardActions, MatCardContent, MatCardHeader, MatCardTitle, LazyLoadImageDirective, DecimalPipe, ThaiYearPipe, DispTextareaPipe];
function InventoryViewComponent_Defer_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 3);
    \u0275\u0275text(2, " \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function InventoryViewComponent_Defer_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 4)(1, "mat-card-header", 5)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "div", 6);
    \u0275\u0275element(6, "img", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "mat-list")(8, "mat-list-item")(9, "span", 8);
    \u0275\u0275text(10, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "span", 9);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "mat-list-item")(14, "span", 8);
    \u0275\u0275text(15, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(16, "div", 10);
    \u0275\u0275pipe(17, "dispTextarea");
    \u0275\u0275elementStart(18, "div", 11)(19, "mat-list-item")(20, "span", 8);
    \u0275\u0275text(21, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "span", 9);
    \u0275\u0275text(23);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(24, "mat-list-item")(25, "span", 8);
    \u0275\u0275text(26, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(27, "span", 9);
    \u0275\u0275text(28);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(29, "div", 11)(30, "mat-list-item")(31, "span", 8);
    \u0275\u0275text(32, "\u0E2B\u0E19\u0E48\u0E27\u0E22\u0E19\u0E31\u0E1A");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "span", 9);
    \u0275\u0275text(34);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(35, "mat-list-item")(36, "span", 8);
    \u0275\u0275text(37, "\u0E21\u0E39\u0E25\u0E04\u0E48\u0E32\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(38, "span", 9);
    \u0275\u0275text(39);
    \u0275\u0275pipe(40, "number");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(41, "div", 11)(42, "mat-list-item")(43, "span", 8);
    \u0275\u0275text(44, "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E44\u0E14\u0E49\u0E21\u0E32");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(45, "span", 9);
    \u0275\u0275text(46);
    \u0275\u0275pipe(47, "thaiYear");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(48, "mat-list-item")(49, "span", 8);
    \u0275\u0275text(50, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\u0E40\u0E14\u0E34\u0E21");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(51, "span", 9);
    \u0275\u0275text(52);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(53, "div", 11)(54, "mat-list-item")(55, "span", 8);
    \u0275\u0275text(56, "\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(57, "span", 9);
    \u0275\u0275text(58);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(59, "mat-list-item")(60, "span", 8);
    \u0275\u0275text(61, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(62, "span", 9);
    \u0275\u0275text(63);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(64, "mat-list-item")(65, "span", 8);
    \u0275\u0275text(66, "\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19\u0E21\u0E32\u0E41\u0E25\u0E49\u0E27");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(67, "span", 9);
    \u0275\u0275text(68);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(69, "mat-list-item")(70, "span", 8);
    \u0275\u0275text(71, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(72, "div", 10);
    \u0275\u0275pipe(73, "dispTextarea");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(74, "mat-card-actions", 12)(75, "button", 13);
    \u0275\u0275listener("click", function InventoryViewComponent_Defer_0_ng_template_1_Template_button_click_75_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onEdit());
    });
    \u0275\u0275text(76, " \u0E41\u0E01\u0E49\u0E44\u0E02 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(77, "button", 14);
    \u0275\u0275listener("click", function InventoryViewComponent_Defer_0_ng_template_1_Template_button_click_77_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onPrint());
    });
    \u0275\u0275text(78, " \u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1E\u0E31\u0E2A\u0E14\u0E38\u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E1B\u0E23\u0E34\u0E49\u0E19 ");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance(3);
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx_r1.imageUrl + ctx_r1.inventory.image);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r1.inventory.code);
    \u0275\u0275advance(4);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind1(17, 15, ctx_r1.inventory.description), \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(ctx_r1.inventory.Category.name);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r1.inventory.Status.name);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r1.inventory.unit);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(40, 17, ctx_r1.inventory.value, "1.2-2"));
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(47, 20, ctx_r1.inventory.receivedDate));
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r1.isEmpty(ctx_r1.inventory.oldCode));
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx_r1.inventory.Fund.name);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r1.inventory.Location.name);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx_r1.getUseDate(ctx_r1.inventory.receivedDate));
    \u0275\u0275advance(4);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind1(73, 22, ctx_r1.inventory.remark), \u0275\u0275sanitizeHtml);
  }
}
function InventoryViewComponent_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryViewComponent_Defer_0_ng_container_0_Template, 3, 0, "ng-container", 2)(1, InventoryViewComponent_Defer_0_ng_template_1_Template, 79, 24, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const content_r3 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", !ctx_r1.inventory)("ngIfElse", content_r3);
  }
}
function InventoryViewComponent_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 15);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _InventoryViewComponent = class _InventoryViewComponent {
  constructor() {
    this.subscription = new Subscription();
    this.router = inject(Router);
    this.route = inject(ActivatedRoute);
    this.inventoryService = inject(InventoryService);
    this.inventoryApiService = inject(InventoryApiService);
    this.printService = inject(PrintService);
    this.snackBar = inject(MatSnackBar);
    this.platfrom = inject(Platform);
    this.imageUrl = environment.imageUrl;
    this.title = "\u0E23\u0E32\u0E22\u0E25\u0E30\u0E40\u0E2D\u0E35\u0E22\u0E14\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.isEdit = false;
    this.isLoading = false;
    this.id = +this.route.snapshot.params["id"];
    this.inventory = this.inventoryService.getById(this.id);
    if (!this.inventory) {
      const navigation = this.router.getCurrentNavigation();
      this.inventory = navigation?.extras?.state["inventory"];
    }
  }
  ngOnInit() {
    if (!this.inventory) {
      this.isLoading = true;
      this.inventoryApiService.getById(this.id).pipe(finalize(() => this.isLoading = false)).subscribe((res) => res && (this.inventory = res));
    }
    this.subscription = this.inventoryService.onListener().subscribe(() => this.inventory = this.inventoryService.getById(this.id));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onEdit() {
    this.router.navigate(["/inventory/edit", this.inventory.id], {
      state: { inventory: this.inventory }
    });
  }
  getUseDate(receivedDate) {
    const date = new Date(receivedDate);
    return this.inventoryService.getUseDate(date);
  }
  isEmpty(value2) {
    if (!value2)
      return "-";
    return value2;
  }
  onPrint() {
    let horizontalPosition = "center";
    let verticalPosition = "bottom";
    if (this.platfrom.ANDROID || this.platfrom.IOS) {
      horizontalPosition = "center";
      verticalPosition = "top";
    }
    this.snackBar.open("\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\u0E44\u0E1B\u0E22\u0E31\u0E07\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E1E\u0E34\u0E21\u0E1E\u0E4C", "\u0E1B\u0E34\u0E14", {
      duration: 2500,
      horizontalPosition,
      verticalPosition
    });
    const inventory = {
      id: this.inventory.id,
      track: this.inventory.track,
      image: this.inventory.image,
      code: this.inventory.code,
      description: this.inventory.description,
      printCount: 1
    };
    this.printService.create(inventory);
  }
};
_InventoryViewComponent.\u0275fac = function InventoryViewComponent_Factory(t2) {
  return new (t2 || _InventoryViewComponent)();
};
_InventoryViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryViewComponent, selectors: [["app-inventory-view"]], decls: 4, vars: 1, consts: [["content", ""], [300], [4, "ngIf", "ngIfElse"], ["mat-flat-button", "", "color", "warn", 1, "w-100"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "blurred-img"], [1, "size", 3, "defaultImage", "lazyLoad"], ["matListItemTitle", ""], ["matListItemLine", ""], [1, "view-textarea", 3, "innerHTML"], [1, "d-flex", "flex-row"], [1, "gap-10"], ["type", "button", "mat-raised-button", "", "color", "primary", 3, "click"], ["type", "button", "mat-raised-button", "", "color", "accent", 3, "click"], [3, "form"]], template: function InventoryViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryViewComponent_Defer_0_Template, 3, 2)(1, InventoryViewComponent_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, InventoryViewComponent_Defer_2_DepsFn, null, 1, null, null, 1, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275deferWhen(!ctx.isLoading);
  }
}, dependencies: [LoadingDataComponent], styles: ["\n\nmat-list-item[_ngcontent-%COMP%] {\n  padding: 0;\n}\nmat-subheader[_ngcontent-%COMP%] {\n  margin-left: 0;\n}\n.view-textarea[_ngcontent-%COMP%] {\n  margin-top: -12px;\n  color: rgba(0, 0, 0, 0.54);\n}\n.view-textarea[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin: 0 0 8px;\n}\n.dark-theme[_nghost-%COMP%]   .view-textarea[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .view-textarea[_ngcontent-%COMP%] {\n  color: rgba(255, 255, 255, 0.7);\n}\n/*# sourceMappingURL=inventory-view.component.css.map */"] });
var InventoryViewComponent = _InventoryViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryViewComponent, { className: "InventoryViewComponent", filePath: "src\\app\\modules\\dashboard\\components\\inventory\\inventory-view\\inventory-view.component.ts", lineNumber: 21 });
})();

// src/app/modules/dashboard/components/inventory/inventory-edit/inventory-edit.component.ts
var _c016 = ["formDirec"];
var _c110 = ["codeEl"];
var _c25 = ["dateEl"];
var _c34 = ["picker"];
var InventoryEditComponent_Defer_2_DepsFn = () => [NgForOf, NgIf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatCard, MatCardActions, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatHint, MatError, MatSuffix, MatDatepicker, MatDatepickerInput, MatDatepickerToggle, MatChipListbox, MatChipOption, NgxDropzoneComponent, NgxDropzoneLabelDirective, NgxDropzoneImagePreviewComponent, NgxMaskDirective, ErrorFieldComponent];
function InventoryEditComponent_Defer_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 7);
    \u0275\u0275text(2, " \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17, \u0E2A\u0E16\u0E32\u0E19\u0E30, \u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19, \u0E2B\u0E23\u0E37\u0E2D\u0E2B\u0E49\u0E2D\u0E07\u0E02\u0E2D\u0E07\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C \u0E01\u0E23\u0E38\u0E13\u0E32\u0E15\u0E34\u0E14\u0E15\u0E48\u0E2D Admin ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 7);
    \u0275\u0275text(1, " \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
    \u0275\u0275elementEnd();
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_ngx_dropzone_image_preview_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ngx-dropzone-image-preview", 34);
    \u0275\u0275listener("removed", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_ngx_dropzone_image_preview_12_Template_ngx_dropzone_image_preview_removed_0_listener() {
      const f_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onRemoveImage(f_r4));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const f_r4 = ctx.$implicit;
    \u0275\u0275property("file", f_r4)("removable", true);
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_35_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 35);
    \u0275\u0275listener("selectionChange", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_35_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("category"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r6 = ctx.$implicit;
    \u0275\u0275property("value", category_r6.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(category_r6.name);
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_43_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 35);
    \u0275\u0275listener("selectionChange", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_43_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("status"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const status_r8 = ctx.$implicit;
    \u0275\u0275property("value", status_r8.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", status_r8.name, " ");
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_80_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 35);
    \u0275\u0275listener("selectionChange", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_80_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("fund"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const fund_r10 = ctx.$implicit;
    \u0275\u0275property("value", fund_r10.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", fund_r10.name, " ");
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_88_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-chip-option", 35);
    \u0275\u0275listener("selectionChange", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_88_Template_mat_chip_option_selectionChange_0_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onSelectChip("location"));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const location_r12 = ctx.$implicit;
    \u0275\u0275property("value", location_r12.id);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", location_r12.name, " ");
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card")(1, "mat-card-header", 8)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 9);
    \u0275\u0275listener("click", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onReset());
    });
    \u0275\u0275text(5, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "form", 10, 1);
    \u0275\u0275listener("ngSubmit", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275elementStart(8, "mat-card-content", 11)(9, "ngx-dropzone", 12);
    \u0275\u0275listener("change", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template_ngx_dropzone_change_9_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onSelectImage($event));
    });
    \u0275\u0275elementStart(10, "ngx-dropzone-label");
    \u0275\u0275text(11, "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E23\u0E39\u0E1B (jpg, jpeg, png)");
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_ngx_dropzone_image_preview_12_Template, 1, 2, "ngx-dropzone-image-preview", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "mat-error");
    \u0275\u0275element(14, "app-error-field", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "mat-form-field")(16, "mat-label");
    \u0275\u0275text(17, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(18, "input", 15, 2);
    \u0275\u0275elementStart(20, "mat-hint", 16);
    \u0275\u0275text(21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "mat-error");
    \u0275\u0275element(23, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(24, "mat-form-field")(25, "mat-label");
    \u0275\u0275text(26, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "textarea", 17);
    \u0275\u0275elementStart(28, "mat-error");
    \u0275\u0275element(29, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(30, "div", 18)(31, "mat-card-title");
    \u0275\u0275text(32, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "mat-chip-listbox", 19);
    \u0275\u0275repeaterCreate(34, InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_35_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "mat-error");
    \u0275\u0275element(37, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "div", 18)(39, "mat-card-title");
    \u0275\u0275text(40, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(41, "mat-chip-listbox", 21);
    \u0275\u0275repeaterCreate(42, InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_43_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(44, "mat-error");
    \u0275\u0275element(45, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(46, "div", 22)(47, "mat-form-field")(48, "mat-label");
    \u0275\u0275text(49, "\u0E2B\u0E19\u0E48\u0E27\u0E22\u0E19\u0E31\u0E1A");
    \u0275\u0275elementEnd();
    \u0275\u0275element(50, "input", 23);
    \u0275\u0275elementStart(51, "mat-error");
    \u0275\u0275element(52, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(53, "mat-form-field")(54, "mat-label");
    \u0275\u0275text(55, "\u0E21\u0E39\u0E25\u0E04\u0E48\u0E32\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
    \u0275\u0275element(56, "input", 24);
    \u0275\u0275elementStart(57, "mat-error");
    \u0275\u0275element(58, "app-error-field", 14);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(59, "div", 22)(60, "mat-form-field")(61, "mat-label");
    \u0275\u0275text(62, "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E44\u0E14\u0E49\u0E21\u0E32");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(63, "input", 25, 3);
    \u0275\u0275listener("focusout", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template_input_focusout_63_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onDateInput());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(65, "input", 26);
    \u0275\u0275listener("dateInput", function InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template_input_dateInput_65_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onDatePicker($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(66, "mat-hint", 16);
    \u0275\u0275text(67, "\u0E27\u0E31\u0E19/\u0E40\u0E14\u0E37\u0E2D\u0E19/\u0E1E.\u0E28. (5/9/2560)");
    \u0275\u0275elementEnd();
    \u0275\u0275element(68, "mat-datepicker-toggle", 27)(69, "mat-datepicker", null, 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(71, "mat-form-field")(72, "mat-label");
    \u0275\u0275text(73, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\u0E40\u0E14\u0E34\u0E21");
    \u0275\u0275elementEnd();
    \u0275\u0275element(74, "input", 28);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(75, "div", 18)(76, "mat-card-title");
    \u0275\u0275text(77, "\u0E41\u0E2B\u0E25\u0E48\u0E07\u0E40\u0E07\u0E34\u0E19");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(78, "mat-chip-listbox", 29);
    \u0275\u0275repeaterCreate(79, InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_80_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(81, "mat-error");
    \u0275\u0275element(82, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(83, "div", 18)(84, "mat-card-title");
    \u0275\u0275text(85, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(86, "mat-chip-listbox", 30);
    \u0275\u0275repeaterCreate(87, InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_For_88_Template, 2, 2, "mat-chip-option", 20, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(89, "mat-error");
    \u0275\u0275element(90, "app-error-field", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(91, "mat-form-field")(92, "mat-label");
    \u0275\u0275text(93, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(94, "textarea", 31);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(95, "mat-card-actions", 32)(96, "button", 33);
    \u0275\u0275text(97, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const picker_r13 = \u0275\u0275reference(70);
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("formGroup", ctx_r1.formInventory);
    \u0275\u0275advance(3);
    \u0275\u0275property("accept", "image/jpeg,image/jpg,image/png")("multiple", false);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.files);
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.image)("errorMessage", ctx_r1.validationField.image);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1("", ctx_r1.code.value.length, "/27");
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.code)("errorMessage", ctx_r1.validationField.code);
    \u0275\u0275advance(4);
    \u0275\u0275property("rows", ctx_r1.lines(ctx_r1.description.value));
    \u0275\u0275advance(2);
    \u0275\u0275property("control", ctx_r1.description)("errorMessage", ctx_r1.validationField.description);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx_r1.categories);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.category)("errorMessage", ctx_r1.validationField.category);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx_r1.statuses);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.status)("errorMessage", ctx_r1.validationField.status);
    \u0275\u0275advance(7);
    \u0275\u0275property("control", ctx_r1.unit)("errorMessage", ctx_r1.validationField.unit);
    \u0275\u0275advance(6);
    \u0275\u0275property("control", ctx_r1.value)("errorMessage", ctx_r1.validationField.value);
    \u0275\u0275advance(7);
    \u0275\u0275property("matDatepicker", picker_r13);
    \u0275\u0275advance(3);
    \u0275\u0275property("for", picker_r13)("disabled", ctx_r1.formInventory.disabled);
    \u0275\u0275advance(11);
    \u0275\u0275repeater(ctx_r1.funds);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.fund)("errorMessage", ctx_r1.validationField.fund);
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx_r1.locations);
    \u0275\u0275advance(3);
    \u0275\u0275property("control", ctx_r1.location)("errorMessage", ctx_r1.validationField.location);
    \u0275\u0275advance(6);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
  }
}
function InventoryEditComponent_Defer_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryEditComponent_Defer_0_ng_template_1_Conditional_0_Template, 2, 0, "button", 7)(1, InventoryEditComponent_Defer_0_ng_template_1_Conditional_1_Template, 98, 30);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(0, !ctx_r1.inventory ? 0 : 1);
  }
}
function InventoryEditComponent_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryEditComponent_Defer_0_ng_container_0_Template, 3, 0, "ng-container", 6)(1, InventoryEditComponent_Defer_0_ng_template_1_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const content_r14 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.categories.length <= 0 || ctx_r1.statuses.length <= 0 || ctx_r1.funds.length <= 0)("ngIfElse", content_r14);
  }
}
function InventoryEditComponent_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 36);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _InventoryEditComponent = class _InventoryEditComponent {
  constructor() {
    this.route = inject(ActivatedRoute);
    this.router = inject(Router);
    this.formBuilder = inject(FormBuilder);
    this.inventoryService = inject(InventoryService);
    this.inventoryApiService = inject(InventoryApiService);
    this.categoryService = inject(CategoryService);
    this.statusService = inject(StatusService);
    this.fundService = inject(FundService);
    this.locationService = inject(LocationService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.searchService = inject(SearchService);
    this.datePipe = inject(DatePipe);
    this.subscription = new Subscription();
    this.validationField = INVENTORY.validationField;
    this.imageUrl = environment.imageUrl;
    this.files = [];
    this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.isImageEdit = false;
    this.isLoading = this.inventoryService.getIsLoading();
    this.categories = this.categoryService.getActiveDetails();
    this.statuses = this.statusService.getActiveDetails();
    this.funds = this.fundService.getActiveDetails();
    this.locations = this.locationService.getActiveDetails();
    this.id = +this.route.snapshot.params["id"];
    this.inventory = this.inventoryService.getById(this.id);
    this.isInventory = false;
    this.formInventory = this.initFormInventory();
    this.formImage = this.initFormImage();
    if (!this.inventory) {
      const navigation = this.router.getCurrentNavigation();
      this.inventory = navigation?.extras?.state["inventory"];
    }
  }
  ngOnInit() {
    this.initSubscription();
    if (this.inventory) {
      this.assignInventory(this.inventory);
      return;
    }
    this.isInventory = true;
    this.inventoryApiService.getById(this.id).pipe(finalize(() => this.isInventory = false)).subscribe((res) => {
      this.inventory = res;
      this.assignInventory(this.inventory);
    });
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSubmit() {
    if (this.formInventory.invalid || this.image.hasError("mimeType"))
      return;
    this.onDateInput();
    const receivedDate = this.datePipe.transform(this.receivedDate.value, "yyyy-MM-dd");
    const category = this.categories.find((category2) => category2.id === this.category.value);
    const categoryName = category ? category.name : "";
    const status = this.statuses.find((status2) => status2.id === this.status.value);
    const statusName = status ? status.name : "";
    const fund = this.funds.find((fund2) => fund2.id === this.fund.value);
    const fundName = fund ? fund.name : "";
    const location2 = this.locations.find((location3) => location3.id === this.location.value);
    const locationName = location2 ? location2.name : "";
    const payload = new FormData();
    payload.append("code", this.code.value);
    payload.append("oldCode", this.oldCode.value);
    payload.append("description", this.description.value);
    payload.append("unit", this.unit.value);
    payload.append("value", this.value.value);
    payload.append("receivedDate", receivedDate);
    payload.append("remark", this.remark.value);
    payload.append("image", this.image.value);
    payload.append("imageEdit", this.isImageEdit.toString());
    payload.append("categoryId", this.category.value.toString());
    payload.append("categoryName", categoryName);
    payload.append("statusId", this.status.value.toString());
    payload.append("statusName", statusName);
    payload.append("fundId", this.fund.value.toString());
    payload.append("fundName", fundName);
    payload.append("locationId", this.location.value.toString());
    payload.append("locationName", locationName);
    this.isLoading = true;
    this.inventoryApiService.update(this.id, payload).pipe(finalize(() => this.isLoading = false)).subscribe((res) => {
      if (this.inventory.code !== res.item.inventory.code)
        this.searchService.updateCache(this.inventory.code, res.item.inventory.code);
      this.toastService.success("Success", res.message);
      this.router.navigate(["/inventory/view", this.id], {
        state: { inventory: res.item.inventory }
      });
    });
  }
  onReset() {
    this.files.length = 0;
    this.isImageEdit = false;
    this.codeEl.nativeElement.focus();
    this.formImage.reset();
    this.assignInventory(this.inventory);
  }
  onSelectImage(event) {
    this.files.length = 0;
    this.files.push(...event.addedFiles);
    this.image.setValue(this.files[0]);
    this.image.markAsTouched();
    this.isImageEdit = true;
  }
  onRemoveImage(file) {
    this.files.splice(this.files.indexOf(file), 1);
    this.image.patchValue(null);
    this.isImageEdit = true;
  }
  onDateInput() {
    const [d2, m2, y2] = this.dateEl.nativeElement.value.split("/");
    const date = new Date(+y2 - 543, +m2 - 1, +d2);
    this.receivedDate.setValue(date);
    if (this.receivedDate.errors)
      this.dateInput.setErrors(this.receivedDate.errors);
    if (!this.receivedDate.errors) {
      this.dateInput.setErrors(null);
      this.convertCEtoBE(date);
    }
  }
  onDatePicker(matDate) {
    const [d2, m2, y2] = this.datePipe.transform(matDate.value, "d/M/yyyy").split("/");
    const date = `${d2}/${m2}/${+y2 + 543}`;
    this.dateInput.setValue(date);
  }
  convertCEtoBE(date) {
    const [d2, m2, y2] = this.datePipe.transform(date, "d/M/yyyy").split("/");
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const yearBE = +y2 + 543;
    const dateCE = new Date(yearBE, +m2 - 1, +d2);
    if (yearBE <= currentYear) {
      const [d3, m3, y3] = this.datePipe.transform(dateCE, "d/M/yyyy").split("/");
      const date2 = `${d3}/${m3}/${+y3 + 543}`;
      this.receivedDate.setValue(dateCE);
      this.dateInput.setValue(date2);
    }
  }
  onSelectChip(keyName) {
    this[keyName].markAsTouched();
  }
  lines(value2) {
    const lines = value2.split("\n");
    return lines.length + 1;
  }
  get code() {
    return this.formInventory.controls["code"];
  }
  get oldCode() {
    return this.formInventory.controls["oldCode"];
  }
  get dateInput() {
    return this.formInventory.controls["dateInput"];
  }
  get description() {
    return this.formInventory.controls["description"];
  }
  get unit() {
    return this.formInventory.controls["unit"];
  }
  get value() {
    return this.formInventory.controls["value"];
  }
  get receivedDate() {
    return this.formInventory.controls["receivedDate"];
  }
  get remark() {
    return this.formInventory.controls["remark"];
  }
  get category() {
    return this.formInventory.controls["category"];
  }
  get status() {
    return this.formInventory.controls["status"];
  }
  get fund() {
    return this.formInventory.controls["fund"];
  }
  get location() {
    return this.formInventory.controls["location"];
  }
  get image() {
    return this.formImage;
  }
  assignInventory(inventory) {
    if (!inventory)
      return;
    if (inventory.image) {
      const downloadImageUrl = this.imageUrl + inventory.image;
      this.inventoryApiService.downloadImage(downloadImageUrl).subscribe((blob) => {
        const file = new File([blob], inventory.image, { type: blob.type });
        this.files.push(file);
      });
    }
    defer(() => this.dateEl ? of(null) : interval(100).pipe(filter(() => !!this.dateEl), take(1))).subscribe(() => {
      const receivedDate = new Date(inventory.receivedDate);
      this.formInventory.patchValue({
        code: inventory.code,
        oldCode: inventory.oldCode,
        description: inventory.description,
        unit: inventory.unit,
        value: inventory.value.toString(),
        receivedDate,
        remark: inventory.remark,
        category: inventory.Category.id,
        status: inventory.Status.id,
        fund: inventory.Fund.id,
        location: inventory.Location.id,
        image: inventory.image
      });
      const receivedDateInput = receivedDate.setFullYear(receivedDate.getFullYear() + 543);
      const datePipe = this.datePipe.transform(receivedDateInput, "d/M/yyyy");
      this.dateInput.setValue(datePipe);
    });
  }
  initFormInventory() {
    return this.formBuilder.nonNullable.group({
      code: ["", [Validators.required]],
      oldCode: [""],
      dateInput: ["", [Validators.required]],
      description: ["", [Validators.required]],
      unit: ["", [Validators.required]],
      value: ["", [Validators.required]],
      receivedDate: this.formBuilder.control(null, [
        Validators.required,
        this.validationService.isDate()
      ]),
      remark: [""],
      category: this.formBuilder.control(null, [Validators.required]),
      status: this.formBuilder.control(null, [Validators.required]),
      fund: this.formBuilder.control(null, [Validators.required]),
      location: this.formBuilder.control(null, [Validators.required]),
      image: [""]
    });
  }
  initFormImage() {
    return this.formBuilder.control(null, {
      validators: [Validators.required],
      asyncValidators: [this.validationService.mimeType()]
    });
  }
  initSubscription() {
    this.subscription.add(this.categoryService.onListener().subscribe(() => {
      this.categories = this.categoryService.getActiveDetails();
      this.category.setValue(null);
    }));
    this.subscription.add(this.statusService.onListener().subscribe(() => {
      this.statuses = this.statusService.getActiveDetails();
      this.status.setValue(null);
    }));
    this.subscription.add(this.fundService.onListener().subscribe(() => {
      this.funds = this.fundService.getActiveDetails();
      this.fund.setValue(null);
    }));
    this.subscription.add(this.locationService.onListener().subscribe(() => {
      this.locations = this.locationService.getActiveDetails();
      this.location.setValue(null);
    }));
    this.subscription.add(this.inventoryService.onIsLoadingListener().subscribe((isLoading) => this.isLoading = isLoading));
  }
};
_InventoryEditComponent.\u0275fac = function InventoryEditComponent_Factory(t2) {
  return new (t2 || _InventoryEditComponent)();
};
_InventoryEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryEditComponent, selectors: [["app-inventory-edit"]], viewQuery: function InventoryEditComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c016, 5);
    \u0275\u0275viewQuery(_c110, 5);
    \u0275\u0275viewQuery(_c25, 5);
    \u0275\u0275viewQuery(_c34, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.fromDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.codeEl = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.dateEl = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.picker = _t2.first);
  }
}, decls: 4, vars: 1, consts: [["content", ""], ["formDirec", "ngForm"], ["codeEl", ""], ["dateEl", ""], ["picker", ""], [300], [4, "ngIf", "ngIfElse"], ["mat-flat-button", "", "color", "warn", 1, "w-100"], [1, "justify-between"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], [1, "form-container", 3, "ngSubmit", "formGroup"], [1, "box"], [1, "dropzone", 3, "change", "accept", "multiple"], ["ngProjectAs", "ngx-dropzone-preview", 5, ["ngx-dropzone-preview"], 3, "file", "removable", "removed", 4, "ngFor", "ngForOf"], [3, "control", "errorMessage"], ["type", "text", "matInput", "", "formControlName", "code"], ["align", "end"], ["matInput", "", "formControlName", "description", 3, "rows"], [1, "d-flex", "flex-column"], ["formControlName", "category"], [3, "value"], ["formControlName", "status"], [1, "row"], ["type", "text", "matInput", "", "formControlName", "unit"], ["matInput", "", "type", "text", "mask", "separator.2", "thousandSeparator", ",", "decimalMarker", ".", "formControlName", "value"], ["matInput", "", "mask", "d0/M0/0000", "formControlName", "dateInput", 3, "focusout"], ["matInput", "", "formControlName", "receivedDate", 1, "hidden-input", 3, "dateInput", "matDatepicker"], ["matIconSuffix", "", 3, "for", "disabled"], ["type", "text", "matInput", "", "formControlName", "oldCode"], ["formControlName", "fund"], ["formControlName", "location"], ["matInput", "", "formControlName", "remark"], [1, "gap-20"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["ngProjectAs", "ngx-dropzone-preview", 5, ["ngx-dropzone-preview"], 3, "removed", "file", "removable"], [3, "selectionChange", "value"], [3, "form"]], template: function InventoryEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InventoryEditComponent_Defer_0_Template, 3, 2)(1, InventoryEditComponent_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, InventoryEditComponent_Defer_2_DepsFn, null, 1, null, null, 5, \u0275\u0275deferEnableTimerScheduling);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275deferWhen(!ctx.isLoading && !ctx.isInventory);
  }
}, dependencies: [LoadingDataComponent] });
var InventoryEditComponent = _InventoryEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryEditComponent, { className: "InventoryEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\inventory\\inventory-edit\\inventory-edit.component.ts", lineNumber: 49 });
})();

// node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b2[i3] = start += 1 << eb[i3 - 1];
  }
  var r = new u32(b2[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j2 = b2[i3]; j2 < b2[i3 + 1]; ++j2) {
      r[j2] = j2 - b2[i3] << 5 | i3;
    }
  }
  return [b2, r];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var revfd = _b[1];
var rev = new u16(32768);
for (i3 = 0; i3 < 32768; ++i3) {
  x2 = (i3 & 43690) >>> 1 | (i3 & 21845) << 1;
  x2 = (x2 & 52428) >>> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >>> 4 | (x2 & 3855) << 4;
  rev[i3] = ((x2 & 65280) >>> 8 | (x2 & 255) << 8) >>> 1;
}
var x2;
var i3;
var hMap = function(cd, mb, r) {
  var s2 = cd.length;
  var i3 = 0;
  var l2 = new u16(mb);
  for (; i3 < s2; ++i3)
    ++l2[cd[i3] - 1];
  var le2 = new u16(mb);
  for (i3 = 0; i3 < mb; ++i3) {
    le2[i3] = le2[i3 - 1] + l2[i3 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v2 = le2[cd[i3] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i3 = 0; i3 < s2; ++i3)
      co[i3] = rev[le2[cd[i3] - 1]++] >>> 15 - cd[i3];
  }
  return co;
};
var flt = new u8(288);
for (i3 = 0; i3 < 144; ++i3)
  flt[i3] = 8;
var i3;
for (i3 = 144; i3 < 256; ++i3)
  flt[i3] = 9;
var i3;
for (i3 = 256; i3 < 280; ++i3)
  flt[i3] = 7;
var i3;
for (i3 = 280; i3 < 288; ++i3)
  flt[i3] = 8;
var i3;
var fdt = new u8(32);
for (i3 = 0; i3 < 32; ++i3)
  fdt[i3] = 5;
var i3;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a2) {
  var m2 = a2[0];
  for (var i3 = 1; i3 < a2.length; ++i3) {
    if (a2[i3] > m2)
      m2 = a2[i3];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8) >>> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >>> (p2 & 7);
};
var shft = function(p2) {
  return (p2 / 8 >> 0) + (p2 & 7 && 1);
};
var slc = function(v2, s2, e) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e == null || e > v2.length)
    e = v2.length;
  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e - s2);
  n2.set(v2.subarray(s2, e));
  return n2;
};
var inflt = function(dat, buf, st2) {
  var sl = dat.length;
  var noBuf = !buf || st2;
  var noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st2.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t2), bt2);
        st2.b = bt2 += l2, st2.p = pos = t2 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s2 = r >>> 4;
          if (s2 < 16) {
            ldt[i3++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i3 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i3++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max(lt2);
        dbt = max(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >>> 4;
      pos += c2 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c2)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b2 = fleb[i3];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i3];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >>> 4;
        if (!d2)
          throw "invalid distance";
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt2 + 131072);
        var end = bt2 + add;
        for (; bt2 < end; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end;
      }
    }
    st2.l = lm, st2.p = pos, st2.b = bt2;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var wbits = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
};
var wbits16 = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
  d2[o2 + 2] |= v2 >>> 16;
};
var hTree = function(d2, mb) {
  var t2 = [];
  for (var i3 = 0; i3 < d2.length; ++i3) {
    if (d2[i3])
      t2.push({ s: i3, f: d2[i3] });
  }
  var s2 = t2.length;
  var t22 = t2.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v2 = new u8(t2[0].s + 1);
    v2[t2[0].s] = 1;
    return [v2, 1];
  }
  t2.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t2.push({ s: -1, f: 25001 });
  var l2 = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
  t2[0] = { s: -1, f: l2.f + r.f, l: l2, r };
  while (i1 != s2 - 1) {
    l2 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
    r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
    t2[i1++] = { s: -1, f: l2.f + r.f, l: l2, r };
  }
  var maxSym = t22[0].s;
  for (var i3 = 1; i3 < s2; ++i3) {
    if (t22[i3].s > maxSym)
      maxSym = t22[i3].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t2[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i3 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i3 < s2; ++i3) {
      var i2_1 = t22[i3].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i3].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i3;
    }
    for (; i3 >= 0 && dt2; --i3) {
      var i2_3 = t22[i3].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i3 = 1; i3 <= s2; ++i3) {
    if (c2[i3] == cln && i3 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i3];
    }
  }
  return [cl.subarray(0, cli), s2];
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i3 = 0; i3 < cl.length; ++i3)
    l2 += cf[i3] * cl[i3];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >>> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i3 = 0; i3 < s2; ++i3)
    out[o2 + i3 + 4] = dat[i3];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i3 = 0; i3 < lclt.length; ++i3)
    lcfreq[lclt[i3] & 31]++;
  for (var i3 = 0; i3 < lcdt.length; ++i3)
    lcfreq[lcdt[i3] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i3 = 0; i3 < nlcc; ++i3)
      wbits(out, p2 + 3 * i3, lct[clim[i3]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i3 = 0; i3 < clct.length; ++i3) {
        var len = clct[i3] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i3] >>> 5 & 127), p2 += clct[i3] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i3 = 0; i3 < li; ++i3) {
    if (syms[i3] > 255) {
      var len = syms[i3] >>> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, syms[i3] >>> 23 & 31), p2 += fleb[len];
      var dst = syms[i3] & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, syms[i3] >>> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[syms[i3]]), p2 += ll[syms[i3]];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, lst) {
  var s2 = dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i3 = 0; i3 <= s2; i3 += 65535) {
      var e = i3 + 65535;
      if (e < s2) {
        pos = wfblk(w2, pos, dat.subarray(i3, e));
      } else {
        w2[i3] = lst;
        pos = wfblk(w2, pos, dat.subarray(i3, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n2 = opt >>> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev2 = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i4) {
      return (dat[i4] ^ dat[i4 + 1] << bs1_1 ^ dat[i4 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i3 = 0, li = 0, wi = 0, bs = 0;
    for (; i3 < s2; ++i3) {
      var hv = hsh(i3);
      var imod = i3 & 32767;
      var pimod = head[hv];
      prev2[imod] = pimod;
      head[hv] = imod;
      if (wi <= i3) {
        var rem = s2 - i3;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i3 - bs, pos);
          li = lc_1 = eb = 0, bs = i3;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i3 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i3);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i3 + l2] == dat[i3 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i3 + nl] == dat[i3 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i3 - dif + j2 + 32768 & 32767;
                  var pti = prev2[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev2[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i3 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i3];
          ++lf[dat[i3]];
        }
      }
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i3 - bs, pos);
    if (!lst)
      pos = wfblk(w2, pos, et);
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length;
      for (var i3 = 0; i3 != l2; ) {
        var e = Math.min(i3 + 5552, l2);
        for (; i3 < e; ++i3)
          n2 += d2[i3], m2 += n2;
        n2 %= 65521, m2 %= 65521;
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      return (a2 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a2 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d2) {
  if ((d2[0] & 15) != 8 || d2[0] >>> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    throw "invalid zlib data";
  if (d2[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var a2 = adler();
  a2.p(data);
  var d2 = dopt(data, opts, 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}

// node_modules/jspdf/dist/jspdf.es.min.js
var n = /* @__PURE__ */ function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i2() {
  n.console && "function" == typeof n.console.log && n.console.log.apply(n.console, arguments);
}
var a = { log: i2, warn: function(t2) {
  n.console && ("function" == typeof n.console.warn ? n.console.warn.apply(n.console, arguments) : i2.call(null, arguments));
}, error: function(t2) {
  n.console && ("function" == typeof n.console.error ? n.console.error.apply(n.console, arguments) : i2(t2));
} };
function o(t2, e, r) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t2), n2.responseType = "blob", n2.onload = function() {
    l(n2.response, e, r);
  }, n2.onerror = function() {
    a.error("could not download file");
  }, n2.send();
}
function s(t2) {
  var e = new XMLHttpRequest();
  e.open("HEAD", t2, false);
  try {
    e.send();
  } catch (t3) {
  }
  return e.status >= 200 && e.status <= 299;
}
function c(t2) {
  try {
    t2.dispatchEvent(new MouseEvent("click"));
  } catch (r) {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e);
  }
}
var u;
var h;
var l = n.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== n ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t2, e, r) {
  var i3 = n.URL || n.webkitURL, a2 = document.createElement("a");
  e = e || t2.name || "download", a2.download = e, a2.rel = "noopener", "string" == typeof t2 ? (a2.href = t2, a2.origin !== location.origin ? s(a2.href) ? o(t2, e, r) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = i3.createObjectURL(t2), setTimeout(function() {
    i3.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e, r, n2) {
  if (r = r || e.name || "download", "string" == typeof e)
    if (s(e))
      o(e, r, n2);
    else {
      var i3 = document.createElement("a");
      i3.href = e, i3.target = "_blank", setTimeout(function() {
        c(i3);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e2, r2) {
      return void 0 === r2 ? r2 = { autoBom: false } : "object" !== _typeof(r2) && (a.warn("Deprecated: Expected third argument to be a object"), r2 = { autoBom: !r2 }), r2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e2.type) ? new Blob([String.fromCharCode(65279), e2], { type: e2.type }) : e2;
    }(e, n2), r);
} : function(e, r, i3, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e)
    return o(e, r, i3);
  var s2 = "application/octet-stream" === e.type, c2 = /constructor/i.test(n.HTMLElement) || n.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
    var h2 = new FileReader();
    h2.onloadend = function() {
      var t2 = h2.result;
      t2 = u2 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t2 : location = t2, a2 = null;
    }, h2.readAsDataURL(e);
  } else {
    var l2 = n.URL || n.webkitURL, f2 = l2.createObjectURL(e);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
function f(t2) {
  var e;
  t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6));
  t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
  for (var r = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
    return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
  } }], n2 = 0; n2 < r.length; n2++) {
    var i3 = r[n2].re, a2 = r[n2].process, o2 = i3.exec(t2);
    o2 && (e = a2(o2), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t3 = this.r.toString(16), e2 = this.g.toString(16), r2 = this.b.toString(16);
    return 1 == t3.length && (t3 = "0" + t3), 1 == e2.length && (e2 = "0" + e2), 1 == r2.length && (r2 = "0" + r2), "#" + t3 + e2 + r2;
  };
}
function d(t2, e) {
  var r = t2[0], n2 = t2[1], i3 = t2[2], a2 = t2[3];
  r = g(r, n2, i3, a2, e[0], 7, -680876936), a2 = g(a2, r, n2, i3, e[1], 12, -389564586), i3 = g(i3, a2, r, n2, e[2], 17, 606105819), n2 = g(n2, i3, a2, r, e[3], 22, -1044525330), r = g(r, n2, i3, a2, e[4], 7, -176418897), a2 = g(a2, r, n2, i3, e[5], 12, 1200080426), i3 = g(i3, a2, r, n2, e[6], 17, -1473231341), n2 = g(n2, i3, a2, r, e[7], 22, -45705983), r = g(r, n2, i3, a2, e[8], 7, 1770035416), a2 = g(a2, r, n2, i3, e[9], 12, -1958414417), i3 = g(i3, a2, r, n2, e[10], 17, -42063), n2 = g(n2, i3, a2, r, e[11], 22, -1990404162), r = g(r, n2, i3, a2, e[12], 7, 1804603682), a2 = g(a2, r, n2, i3, e[13], 12, -40341101), i3 = g(i3, a2, r, n2, e[14], 17, -1502002290), r = m(r, n2 = g(n2, i3, a2, r, e[15], 22, 1236535329), i3, a2, e[1], 5, -165796510), a2 = m(a2, r, n2, i3, e[6], 9, -1069501632), i3 = m(i3, a2, r, n2, e[11], 14, 643717713), n2 = m(n2, i3, a2, r, e[0], 20, -373897302), r = m(r, n2, i3, a2, e[5], 5, -701558691), a2 = m(a2, r, n2, i3, e[10], 9, 38016083), i3 = m(i3, a2, r, n2, e[15], 14, -660478335), n2 = m(n2, i3, a2, r, e[4], 20, -405537848), r = m(r, n2, i3, a2, e[9], 5, 568446438), a2 = m(a2, r, n2, i3, e[14], 9, -1019803690), i3 = m(i3, a2, r, n2, e[3], 14, -187363961), n2 = m(n2, i3, a2, r, e[8], 20, 1163531501), r = m(r, n2, i3, a2, e[13], 5, -1444681467), a2 = m(a2, r, n2, i3, e[2], 9, -51403784), i3 = m(i3, a2, r, n2, e[7], 14, 1735328473), r = v(r, n2 = m(n2, i3, a2, r, e[12], 20, -1926607734), i3, a2, e[5], 4, -378558), a2 = v(a2, r, n2, i3, e[8], 11, -2022574463), i3 = v(i3, a2, r, n2, e[11], 16, 1839030562), n2 = v(n2, i3, a2, r, e[14], 23, -35309556), r = v(r, n2, i3, a2, e[1], 4, -1530992060), a2 = v(a2, r, n2, i3, e[4], 11, 1272893353), i3 = v(i3, a2, r, n2, e[7], 16, -155497632), n2 = v(n2, i3, a2, r, e[10], 23, -1094730640), r = v(r, n2, i3, a2, e[13], 4, 681279174), a2 = v(a2, r, n2, i3, e[0], 11, -358537222), i3 = v(i3, a2, r, n2, e[3], 16, -722521979), n2 = v(n2, i3, a2, r, e[6], 23, 76029189), r = v(r, n2, i3, a2, e[9], 4, -640364487), a2 = v(a2, r, n2, i3, e[12], 11, -421815835), i3 = v(i3, a2, r, n2, e[15], 16, 530742520), r = b(r, n2 = v(n2, i3, a2, r, e[2], 23, -995338651), i3, a2, e[0], 6, -198630844), a2 = b(a2, r, n2, i3, e[7], 10, 1126891415), i3 = b(i3, a2, r, n2, e[14], 15, -1416354905), n2 = b(n2, i3, a2, r, e[5], 21, -57434055), r = b(r, n2, i3, a2, e[12], 6, 1700485571), a2 = b(a2, r, n2, i3, e[3], 10, -1894986606), i3 = b(i3, a2, r, n2, e[10], 15, -1051523), n2 = b(n2, i3, a2, r, e[1], 21, -2054922799), r = b(r, n2, i3, a2, e[8], 6, 1873313359), a2 = b(a2, r, n2, i3, e[15], 10, -30611744), i3 = b(i3, a2, r, n2, e[6], 15, -1560198380), n2 = b(n2, i3, a2, r, e[13], 21, 1309151649), r = b(r, n2, i3, a2, e[4], 6, -145523070), a2 = b(a2, r, n2, i3, e[11], 10, -1120210379), i3 = b(i3, a2, r, n2, e[2], 15, 718787259), n2 = b(n2, i3, a2, r, e[9], 21, -343485551), t2[0] = _(r, t2[0]), t2[1] = _(n2, t2[1]), t2[2] = _(i3, t2[2]), t2[3] = _(a2, t2[3]);
}
function p(t2, e, r, n2, i3, a2) {
  return e = _(_(e, t2), _(n2, a2)), _(e << i3 | e >>> 32 - i3, r);
}
function g(t2, e, r, n2, i3, a2, o2) {
  return p(e & r | ~e & n2, t2, e, i3, a2, o2);
}
function m(t2, e, r, n2, i3, a2, o2) {
  return p(e & n2 | r & ~n2, t2, e, i3, a2, o2);
}
function v(t2, e, r, n2, i3, a2, o2) {
  return p(e ^ r ^ n2, t2, e, i3, a2, o2);
}
function b(t2, e, r, n2, i3, a2, o2) {
  return p(r ^ (e | ~n2), t2, e, i3, a2, o2);
}
function y(t2) {
  var e, r = t2.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= t2.length; e += 64)
    d(n2, w(t2.substring(e - 64, e)));
  t2 = t2.substring(e - 64);
  var i3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < t2.length; e++)
    i3[e >> 2] |= t2.charCodeAt(e) << (e % 4 << 3);
  if (i3[e >> 2] |= 128 << (e % 4 << 3), e > 55)
    for (d(n2, i3), e = 0; e < 16; e++)
      i3[e] = 0;
  return i3[14] = 8 * r, d(n2, i3), n2;
}
function w(t2) {
  var e, r = [];
  for (e = 0; e < 64; e += 4)
    r[e >> 2] = t2.charCodeAt(e) + (t2.charCodeAt(e + 1) << 8) + (t2.charCodeAt(e + 2) << 16) + (t2.charCodeAt(e + 3) << 24);
  return r;
}
u = n.atob.bind(n), h = n.btoa.bind(n);
var N = "0123456789abcdef".split("");
function L(t2) {
  for (var e = "", r = 0; r < 4; r++)
    e += N[t2 >> 8 * r + 4 & 15] + N[t2 >> 8 * r & 15];
  return e;
}
function A(t2) {
  return String.fromCharCode((255 & t2) >> 0, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
}
function x(t2) {
  return y(t2).map(A).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t2) {
  for (var e = 0; e < t2.length; e++)
    t2[e] = L(t2[e]);
  return t2.join("");
}(y("hello"));
function _(t2, e) {
  if (S) {
    var r = (65535 & t2) + (65535 & e);
    return (t2 >> 16) + (e >> 16) + (r >> 16) << 16 | 65535 & r;
  }
  return t2 + e & 4294967295;
}
function P(t2, e) {
  var r, n2, i3, a2;
  if (t2 !== r) {
    for (var o2 = (i3 = t2, a2 = 1 + (256 / t2.length >> 0), new Array(a2 + 1).join(i3)), s2 = [], c2 = 0; c2 < 256; c2++)
      s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h2 = s2[c2];
      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
    }
    r = t2, n2 = s2;
  } else
    s2 = n2;
  var l2 = e.length, f2 = 0, d2 = 0, p2 = "";
  for (c2 = 0; c2 < l2; c2++)
    d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e.charCodeAt(c2) ^ o2);
  return p2;
}
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t2, e, r, n2) {
  this.v = 1, this.r = 2;
  var i3 = 192;
  t2.forEach(function(t3) {
    if (void 0 !== k.perm)
      throw new Error("Invalid permission: " + t3);
    i3 += k[t3];
  }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var a2 = (e + this.padding).substr(0, 32), o2 = (r + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i3)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t2) {
  if (/[^\u0000-\u00ff]/.test(t2))
    throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
  for (var e = "", r = t2.length, n2 = 0; n2 < r; n2++) {
    var i3 = t2.charCodeAt(n2);
    if (i3 < 33 || 35 === i3 || 37 === i3 || 40 === i3 || 41 === i3 || 47 === i3 || 60 === i3 || 62 === i3 || 91 === i3 || 93 === i3 || 123 === i3 || 125 === i3 || i3 > 126)
      e += "#" + ("0" + i3.toString(16)).slice(-2);
    else
      e += t2[n2];
  }
  return e;
}
function C(e) {
  if ("object" !== _typeof(e))
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r = {};
  this.subscribe = function(t2, e2, n2) {
    if (n2 = n2 || false, "string" != typeof t2 || "function" != typeof e2 || "boolean" != typeof n2)
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r.hasOwnProperty(t2) || (r[t2] = {});
    var i3 = Math.random().toString(35);
    return r[t2][i3] = [e2, !!n2], i3;
  }, this.unsubscribe = function(t2) {
    for (var e2 in r)
      if (r[e2][t2])
        return delete r[e2][t2], 0 === Object.keys(r[e2]).length && delete r[e2], true;
    return false;
  }, this.publish = function(t2) {
    if (r.hasOwnProperty(t2)) {
      var i3 = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r[t2]) {
        var c2 = r[t2][s2];
        try {
          c2[0].apply(e, i3);
        } catch (t3) {
          n.console && a.error("jsPDF PubSub Error", t3.message, t3);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r;
  };
}
function j(t2) {
  if (!(this instanceof j))
    return new j(t2);
  var e = "opacity,stroke-opacity".split(",");
  for (var r in t2)
    t2.hasOwnProperty(r) && e.indexOf(r) >= 0 && (this[r] = t2[r]);
  this.id = "", this.objectNumber = -1;
}
function O(t2, e) {
  this.gState = t2, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function B(t2, e, r, n2, i3) {
  if (!(this instanceof B))
    return new B(t2, e, r, n2, i3);
  this.type = "axial" === t2 ? 2 : 3, this.coords = e, this.colors = r, O.call(this, n2, i3);
}
function M(t2, e, r, n2, i3) {
  if (!(this instanceof M))
    return new M(t2, e, r, n2, i3);
  this.boundingBox = t2, this.xStep = e, this.yStep = r, this.stream = "", this.cloneIndex = 0, O.call(this, n2, i3);
}
function E(e) {
  var r, i3 = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
  "object" === _typeof(e = e || {}) && (i3 = e.orientation, o2 = e.unit || o2, s2 = e.format || s2, c2 = e.compress || e.compressPdf || c2, null !== (m2 = e.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = "number" == typeof e.userUnit ? Math.abs(e.userUnit) : 1, void 0 !== e.precision && (r = e.precision), void 0 !== e.floatPrecision && (p2 = e.floatPrecision), g2 = e.defaultPathOperation || "S"), u2 = e.filters || (true === c2 ? ["FlateEncode"] : u2), o2 = o2 || "mm", i3 = ("" + (i3 || "P")).toLowerCase();
  var v2 = e.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t2) {
    w2 = t2;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t2) {
    return L2[t2];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t2, e2) {
    if ("bold" == t2 && "normal" == e2 || "bold" == t2 && 400 == e2 || "normal" == t2 && "italic" == e2 || "bold" == t2 && "italic" == e2)
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e2 && (t2 = 400 == e2 || "normal" === e2 ? "italic" === t2 ? "italic" : "normal" : 700 != e2 && "bold" !== e2 || "normal" !== t2 ? (700 == e2 ? "bold" : e2) + "" + t2 : "bold"), t2;
  };
  y2.advancedAPI = function(t2) {
    var e2 = S2 === x2.COMPAT;
    return e2 && _2.call(this), "function" != typeof t2 || (t2(this), e2 && P2.call(this)), this;
  }, y2.compatAPI = function(t2) {
    var e2 = S2 === x2.ADVANCED;
    return e2 && P2.call(this), "function" != typeof t2 || (t2(this), e2 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = function(t2) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t2, e2) {
    var n2 = r || e2;
    if (isNaN(t2) || isNaN(n2))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t2.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, p2);
  } : "smart" === p2 ? function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, t2 > -1 && t2 < 1 ? 16 : 5);
  } : function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t2, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t2, 2);
  }, T2 = y2.__private__.f3 = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t2, 3);
  }, U2 = y2.scale = y2.__private__.scale = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t2 * _t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, z2 = function(t2) {
    return S2 === x2.COMPAT ? Rr() - t2 : S2 === x2.ADVANCED ? t2 : void 0;
  }, H2 = function(t2) {
    return U2(z2(t2));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t2) {
    "number" == typeof parseInt(t2, 10) && (r = parseInt(t2, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t2) {
    return V2 = void 0 !== t2 && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m2 && (Ye = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t2) {
    return Y2(t2), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t2) {
    var e2 = t2.getTimezoneOffset(), r2 = e2 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e2 / 60)), i4 = Math.abs(e2 % 60), a2 = [r2, Q2(n2), "'", Q2(i4), "'"].join("");
    return ["D:", t2.getFullYear(), Q2(t2.getMonth() + 1), Q2(t2.getDate()), Q2(t2.getHours()), Q2(t2.getMinutes()), Q2(t2.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t2) {
    var e2 = parseInt(t2.substr(2, 4), 10), r2 = parseInt(t2.substr(6, 2), 10) - 1, n2 = parseInt(t2.substr(8, 2), 10), i4 = parseInt(t2.substr(10, 2), 10), a2 = parseInt(t2.substr(12, 2), 10), o3 = parseInt(t2.substr(14, 2), 10);
    return new Date(e2, r2, n2, i4, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t2) {
    var e2;
    if (void 0 === t2 && (t2 = /* @__PURE__ */ new Date()), t2 instanceof Date)
      e2 = J2(t2);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e2 = t2;
    }
    return W2 = e2;
  }, Z2 = y2.__private__.getCreationDate = function(t2) {
    var e2 = W2;
    return "jsDate" === t2 && (e2 = X2(W2)), e2;
  };
  y2.setCreationDate = function(t2) {
    return K2(t2), this;
  }, y2.getCreationDate = function(t2) {
    return Z2(t2);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t2) {
    return ("0" + parseInt(t2)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t2) {
    return ("00" + (t2 = t2.toString())).substr(t2.length);
  }, et3 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et3 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y2.__private__.setCustomOutputDestination = function(t2) {
    st2 = true, ct2 = t2;
  };
  var ht2 = function(t2) {
    st2 || (ct2 = t2);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t2) {
    return t2 = t2.toString(), it2 += t2.length + 1, ct2.push(t2), ct2;
  }, ft2 = y2.__private__.write = function(t2) {
    return lt2(1 === arguments.length ? t2.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t2) {
    for (var e2 = t2.length, r2 = new ArrayBuffer(e2), n2 = new Uint8Array(r2); e2--; )
      n2[e2] = t2.charCodeAt(e2);
    return r2;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t2) {
    return gt2 = S2 === x2.ADVANCED ? t2 / _t2 : t2, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t2) {
    return bt2 = t2, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t2) {
    var e2 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2))
      mt2 = t2;
    else if (isNaN(t2)) {
      if (-1 === e2.indexOf(t2))
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
      mt2 = t2;
    } else
      mt2 = parseInt(t2, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t2) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2))
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
    yt2 = t2;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t2) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2))
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
    Nt2 = t2;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t2, e2, r2) {
    return wt2(t2), At2(e2), Lt2(r2), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t2) {
    if (-1 === Object.keys(xt2).indexOf(t2))
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t2];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t2) {
    for (var e2 in xt2)
      xt2.hasOwnProperty(e2) && t2[e2] && (xt2[e2] = t2[e2]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t2, e2) {
    if (-1 === Object.keys(xt2).indexOf(t2))
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t2] = e2;
  };
  var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), Ut2 = e.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t2(e2, r2, n2, i4, a2, o3) {
    if (!(this instanceof t2))
      return new t2(e2, r2, n2, i4, a2, o3);
    isNaN(e2) && (e2 = 1), isNaN(r2) && (r2 = 0), isNaN(n2) && (n2 = 0), isNaN(i4) && (i4 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e2, r2, n2, i4, a2, o3];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t2) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t2);
  }, Vt2.prototype.multiply = function(t2) {
    var e2 = t2.sx * this.sx + t2.shy * this.shx, r2 = t2.sx * this.shy + t2.shy * this.sy, n2 = t2.shx * this.sx + t2.sy * this.shx, i4 = t2.shx * this.shy + t2.sy * this.sy, a2 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o3 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
    return new Vt2(e2, r2, n2, i4, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t2 = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i4 = this.tx, a2 = this.ty, o3 = Math.sqrt(t2 * t2 + e2 * e2), s3 = (t2 /= o3) * r2 + (e2 /= o3) * n2;
    r2 -= t2 * s3, n2 -= e2 * s3;
    var c3 = Math.sqrt(r2 * r2 + n2 * n2);
    return s3 /= c3, t2 * (n2 /= c3) < e2 * (r2 /= c3) && (t2 = -t2, e2 = -e2, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i4, a2), rotate: new Vt2(t2, e2, -e2, t2, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t2) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t2 = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i4 = this.tx, a2 = this.ty, o3 = 1 / (t2 * n2 - e2 * r2), s3 = n2 * o3, c3 = -e2 * o3, u3 = -r2 * o3, h2 = t2 * o3;
    return new Vt2(s3, c3, u3, h2, -s3 * i4 - u3 * a2, -c3 * i4 - h2 * a2);
  }, Vt2.prototype.applyToPoint = function(t2) {
    var e2 = t2.x * this.sx + t2.y * this.shx + this.tx, r2 = t2.x * this.shy + t2.y * this.sy + this.ty;
    return new Cr(e2, r2);
  }, Vt2.prototype.applyToRectangle = function(t2) {
    var e2 = this.applyToPoint(t2), r2 = this.applyToPoint(new Cr(t2.x + t2.w, t2.y + t2.h));
    return new jr(e2.x, e2.y, r2.x - e2.x, r2.y - e2.y);
  }, Vt2.prototype.clone = function() {
    var t2 = this.sx, e2 = this.shy, r2 = this.shx, n2 = this.sy, i4 = this.tx, a2 = this.ty;
    return new Vt2(t2, e2, r2, n2, i4, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t2, e2) {
    return e2.multiply(t2);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = function(t2, e2) {
    if (!Bt2[t2]) {
      var r2 = (e2 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e2.id = r2, Bt2[t2] = r2, Ot2[r2] = e2, Tt2.publish("addPattern", e2);
    }
  };
  y2.ShadingPattern = B, y2.TilingPattern = M, y2.addShadingPattern = function(t2, e2) {
    return q2("addShadingPattern()"), Jt2(t2, e2), this;
  }, y2.beginTilingPattern = function(t2) {
    q2("beginTilingPattern()"), Br(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
  }, y2.endTilingPattern = function(t2, e2) {
    q2("endTilingPattern()"), e2.stream = ot2[$2].join("\n"), Jt2(t2, e2), Tt2.publish("endTilingPattern", e2), Wt2.pop().restore();
  };
  var Xt2 = y2.__private__.newObject = function() {
    var t2 = Kt2();
    return Zt2(t2, true), t2;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et3++, rt2[et3] = function() {
      return it2;
    }, et3;
  }, Zt2 = function(t2, e2) {
    return e2 = "boolean" == typeof e2 && e2, rt2[t2] = it2, e2 && lt2(t2 + " 0 obj"), t2;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t2 = { objId: Kt2(), content: "" };
    return at2.push(t2), t2;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t2) {
    var e2 = t2.split(" ");
    if (2 !== e2.length || "g" !== e2[1] && "G" !== e2[1]) {
      if (5 === e2.length && ("k" === e2[4] || "K" === e2[4])) {
        e2 = [(1 - e2[0]) * (1 - e2[3]), (1 - e2[1]) * (1 - e2[3]), (1 - e2[2]) * (1 - e2[3]), "r"];
      }
    } else {
      var r2 = parseFloat(e2[0]);
      e2 = [r2, r2, r2, "r"];
    }
    for (var n2 = "#", i4 = 0; i4 < 3; i4++)
      n2 += ("0" + Math.floor(255 * parseFloat(e2[i4])).toString(16)).slice(-2);
    return n2;
  }, re3 = y2.__private__.encodeColorString = function(e2) {
    var r2;
    "string" == typeof e2 && (e2 = { ch1: e2 });
    var n2 = e2.ch1, i4 = e2.ch2, a2 = e2.ch3, o3 = e2.ch4, s3 = "draw" === e2.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n2 && "#" !== n2.charAt(0)) {
      var c3 = new f(n2);
      if (c3.ok)
        n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2))
        throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n2 && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), "string" == typeof n2 && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i4 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (void 0 === i4 || void 0 === o3 && n2 === i4 && i4 === a2)
      if ("string" == typeof n2)
        r2 = n2 + " " + s3[0];
      else
        switch (e2.precision) {
          case 2:
            r2 = R2(n2 / 255) + " " + s3[0];
            break;
          case 3:
          default:
            r2 = T2(n2 / 255) + " " + s3[0];
        }
    else if (void 0 === o3 || "object" === _typeof(o3)) {
      if (o3 && !isNaN(o3.a) && 0 === o3.a)
        return r2 = ["1.", "1.", "1.", s3[1]].join(" ");
      if ("string" == typeof n2)
        r2 = [n2, i4, a2, s3[1]].join(" ");
      else
        switch (e2.precision) {
          case 2:
            r2 = [R2(n2 / 255), R2(i4 / 255), R2(a2 / 255), s3[1]].join(" ");
            break;
          default:
          case 3:
            r2 = [T2(n2 / 255), T2(i4 / 255), T2(a2 / 255), s3[1]].join(" ");
        }
    } else if ("string" == typeof n2)
      r2 = [n2, i4, a2, o3, s3[2]].join(" ");
    else
      switch (e2.precision) {
        case 2:
          r2 = [R2(n2), R2(i4), R2(a2), R2(o3), s3[2]].join(" ");
          break;
        case 3:
        default:
          r2 = [T2(n2), T2(i4), T2(a2), T2(o3), s3[2]].join(" ");
      }
    return r2;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t2) {
    var e2 = (t2 = t2 || {}).data || "", r2 = t2.filters || ne2(), n2 = t2.alreadyAppliedFilters || [], i4 = t2.addLength1 || false, a2 = e2.length, o3 = t2.objectId, s3 = function(t3) {
      return t3;
    };
    if (null !== m2 && void 0 === o3)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m2 && (s3 = Ye.encryptor(o3, 0));
    var c3 = {};
    true === r2 && (r2 = ["FlateEncode"]);
    var u3 = t2.additionalKeyValues || [], h2 = (c3 = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e2, r2) : { data: e2, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (0 !== c3.data.length && (u3.push({ key: "Length", value: c3.data.length }), true === i4 && u3.push({ key: "Length1", value: a2 })), 0 != h2.length)
      if (h2.split("/").length - 1 == 1)
        u3.push({ key: "Filter", value: h2 });
      else {
        u3.push({ key: "Filter", value: "[" + h2 + "]" });
        for (var l2 = 0; l2 < u3.length; l2 += 1)
          if ("DecodeParms" === u3[l2].key) {
            for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1)
              f2.push("null");
            f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p3 = 0; p3 < u3.length; p3++)
      lt2("/" + u3[p3].key + " " + u3[p3].value);
    lt2(">>"), 0 !== c3.data.length && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t2) {
    var e2 = t2.number, r2 = t2.data, n2 = t2.objId, i4 = t2.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t2.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t2.mediaBox.bottomLeftY)) + " " + O2(t2.mediaBox.topRightX) + " " + O2(t2.mediaBox.topRightY) + "]"), null !== t2.cropBox && lt2("/CropBox [" + O2(t2.cropBox.bottomLeftX) + " " + O2(t2.cropBox.bottomLeftY) + " " + O2(t2.cropBox.topRightX) + " " + O2(t2.cropBox.topRightY) + "]"), null !== t2.bleedBox && lt2("/BleedBox [" + O2(t2.bleedBox.bottomLeftX) + " " + O2(t2.bleedBox.bottomLeftY) + " " + O2(t2.bleedBox.topRightX) + " " + O2(t2.bleedBox.topRightY) + "]"), null !== t2.trimBox && lt2("/TrimBox [" + O2(t2.trimBox.bottomLeftX) + " " + O2(t2.trimBox.bottomLeftY) + " " + O2(t2.trimBox.topRightX) + " " + O2(t2.trimBox.topRightY) + "]"), null !== t2.artBox && lt2("/ArtBox [" + O2(t2.artBox.bottomLeftX) + " " + O2(t2.artBox.bottomLeftY) + " " + O2(t2.artBox.topRightX) + " " + O2(t2.artBox.topRightY) + "]"), "number" == typeof t2.userUnit && 1 !== t2.userUnit && lt2("/UserUnit " + t2.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e2], pageNumber: e2, page: r2 }), lt2("/Contents " + i4 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r2.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i4, true), ie2({ data: a2, filters: ne2(), objectId: i4 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t2, e2, r2 = [];
    for (t2 = 1; t2 <= Dt2; t2++)
      Rt2[t2].objId = Kt2(), Rt2[t2].contentsObjId = Kt2();
    for (t2 = 1; t2 <= Dt2; t2++)
      r2.push(ae2({ number: t2, data: ot2[t2], objId: Rt2[t2].objId, contentsObjId: Rt2[t2].contentsObjId, mediaBox: Rt2[t2].mediaBox, cropBox: Rt2[t2].cropBox, bleedBox: Rt2[t2].bleedBox, trimBox: Rt2[t2].trimBox, artBox: Rt2[t2].artBox, userUnit: Rt2[t2].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e2 = 0; e2 < Dt2; e2++)
      n2 += r2[e2] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t2) {
    Tt2.publish("putFont", { font: t2, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t2.isAlreadyPutted && (t2.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t2.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t2.encoding && lt2("/Encoding /" + t2.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t2 in Ft2)
      Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && se2(Ft2[t2]);
  }, ue2 = function(t2) {
    t2.objectNumber = Xt2();
    var e2 = [];
    e2.push({ key: "Type", value: "/XObject" }), e2.push({ key: "Subtype", value: "/Form" }), e2.push({ key: "BBox", value: "[" + [O2(t2.x), O2(t2.y), O2(t2.x + t2.width), O2(t2.y + t2.height)].join(" ") + "]" }), e2.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
    var r2 = t2.pages[1].join("\n");
    ie2({ data: r2, additionalKeyValues: e2, objectId: t2.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t2 in zt2)
      zt2.hasOwnProperty(t2) && ue2(zt2[t2]);
  }, le2 = function(t2, e2) {
    var r2, n2 = [], i4 = 1 / (e2 - 1);
    for (r2 = 0; r2 < 1; r2 += i4)
      n2.push(r2);
    if (n2.push(1), 0 != t2[0].offset) {
      var a2 = { offset: 0, color: t2[0].color };
      t2.unshift(a2);
    }
    if (1 != t2[t2.length - 1].offset) {
      var o3 = { offset: 1, color: t2[t2.length - 1].color };
      t2.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r2 = n2[u3]; r2 > t2[c3 + 1].offset; )
        c3++;
      var h2 = t2[c3].offset, l2 = (r2 - h2) / (t2[c3 + 1].offset - h2), f2 = t2[c3].color, d3 = t2[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
    }
    return s3.trim();
  }, fe2 = function(t2, e2) {
    e2 || (e2 = 21);
    var r2 = Xt2(), n2 = le2(t2.colors, e2), i4 = [];
    i4.push({ key: "FunctionType", value: "0" }), i4.push({ key: "Domain", value: "[0.0 1.0]" }), i4.push({ key: "Size", value: "[" + e2 + "]" }), i4.push({ key: "BitsPerSample", value: "8" }), i4.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i4.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i4, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r2 }), lt2("endobj"), t2.objectNumber = Xt2(), lt2("<< /ShadingType " + t2.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t2.coords[0])) + " " + O2(parseFloat(t2.coords[1])) + " ";
    2 === t2.type ? a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) : a2 += O2(parseFloat(t2.coords[2])) + " " + O2(parseFloat(t2.coords[3])) + " " + O2(parseFloat(t2.coords[4])) + " " + O2(parseFloat(t2.coords[5])), lt2(a2 += "]"), t2.matrix && lt2("/Matrix [" + t2.matrix.toString() + "]"), lt2("/Function " + r2 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t2, e2) {
    var r2 = Kt2(), n2 = Xt2();
    e2.push({ resourcesOid: r2, objectOid: n2 }), t2.objectNumber = n2;
    var i4 = [];
    i4.push({ key: "Type", value: "/Pattern" }), i4.push({ key: "PatternType", value: "1" }), i4.push({ key: "PaintType", value: "1" }), i4.push({ key: "TilingType", value: "1" }), i4.push({ key: "BBox", value: "[" + t2.boundingBox.map(O2).join(" ") + "]" }), i4.push({ key: "XStep", value: O2(t2.xStep) }), i4.push({ key: "YStep", value: O2(t2.yStep) }), i4.push({ key: "Resources", value: r2 + " 0 R" }), t2.matrix && i4.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie2({ data: t2.stream, additionalKeyValues: i4, objectId: t2.objectNumber }), lt2("endobj");
  }, pe2 = function(t2) {
    var e2;
    for (e2 in Ot2)
      Ot2.hasOwnProperty(e2) && (Ot2[e2] instanceof B ? fe2(Ot2[e2]) : Ot2[e2] instanceof M && de2(Ot2[e2], t2));
  }, ge2 = function(t2) {
    for (var e2 in t2.objectNumber = Xt2(), lt2("<<"), t2)
      switch (e2) {
        case "opacity":
          lt2("/ca " + R2(t2[e2]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t2[e2]));
      }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t2;
    for (t2 in Mt2)
      Mt2.hasOwnProperty(t2) && ge2(Mt2[t2]);
  }, ve2 = function() {
    for (var t2 in lt2("/XObject <<"), zt2)
      zt2.hasOwnProperty(t2) && zt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + zt2[t2].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t2 in lt2("/Font <<"), Ft2)
      Ft2.hasOwnProperty(t2) && (false === v2 || true === v2 && b2.hasOwnProperty(t2)) && lt2("/" + t2 + " " + Ft2[t2].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t2 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t2) && Ot2[t2] instanceof B && Ot2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Ot2[t2].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t2) {
    if (Object.keys(Ot2).length > 0) {
      for (var e2 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e2) && Ot2[e2] instanceof y2.TilingPattern && Ot2[e2].objectNumber >= 0 && Ot2[e2].objectNumber < t2 && lt2("/" + e2 + " " + Ot2[e2].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t2;
      for (t2 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t2) && Mt2[t2].objectNumber >= 0 && lt2("/" + t2 + " " + Mt2[t2].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t2) {
    Zt2(t2.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t2.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t2 = [];
    ce2(), me2(), he2(), pe2(t2), Tt2.publish("putResources"), t2.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t2 = 0; t2 < at2.length; t2++) {
      var e2 = at2[t2];
      Zt2(e2.objId, true), lt2(e2.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t2) {
    Ct2[t2.fontName] = Ct2[t2.fontName] || {}, Ct2[t2.fontName][t2.fontStyle] = t2.id;
  }, Pe = function(t2, e2, r2, n2, i4) {
    var a2 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t2, fontName: e2, fontStyle: r2, encoding: n2, isStandardFont: i4 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft2[a2.id] = a2, _e(a2), a2.id;
  }, ke = function(t2) {
    for (var e2 = 0, r2 = pt2.length; e2 < r2; e2++) {
      var n2 = Pe.call(this, t2[e2][0], t2[e2][1], t2[e2][2], pt2[e2][3], true);
      false === v2 && (b2[n2] = true);
      var i4 = t2[e2][0].split("-");
      _e({ id: n2, fontName: i4[0], fontStyle: i4[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t2) {
    return t2.foo = function() {
      try {
        return t2.apply(this, arguments);
      } catch (t3) {
        var e2 = t3.stack || "";
        ~e2.indexOf(" at ") && (e2 = e2.split(" at ")[1]);
        var r2 = "Error in function " + e2.split("\n")[0].split("<")[0] + ": " + t3.message;
        if (!n.console)
          throw new Error(r2);
        n.console.error(r2, t3), n.alert && alert(r2);
      }
    }, t2.foo.bar = t2, t2.foo;
  }, Fe = function(t2, e2) {
    var r2, n2, i4, a2, o3, s3, c3, u3, h2;
    if (i4 = (e2 = e2 || {}).sourceEncoding || "Unicode", o3 = e2.outputEncoding, (e2.autoencode || o3) && Ft2[St2].metadata && Ft2[St2].metadata[i4] && Ft2[St2].metadata[i4].encoding && (a2 = Ft2[St2].metadata[i4].encoding, !o3 && Ft2[St2].encoding && (o3 = Ft2[St2].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), "string" == typeof o3 && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r2 = 0, n2 = t2.length; r2 < n2; r2++)
        (u3 = o3[t2.charCodeAt(r2)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t2[r2]), s3[r2].charCodeAt(0) >> 8 && (c3 = true);
      t2 = s3.join("");
    }
    for (r2 = t2.length; void 0 === c3 && 0 !== r2; )
      t2.charCodeAt(r2 - 1) >> 8 && (c3 = true), r2--;
    if (!c3)
      return t2;
    for (s3 = e2.noBOM ? [] : [254, 255], r2 = 0, n2 = t2.length; r2 < n2; r2++) {
      if ((h2 = (u3 = t2.charCodeAt(r2)) >> 8) >> 8)
        throw new Error("Character at position " + r2 + " of string '" + t2 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h2), s3.push(u3 - (h2 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, Ce = y2.__private__.pdfEscape = y2.pdfEscape = function(t2, e2) {
    return Fe(t2, e2).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y2.__private__.beginPage = function(t2) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t2, e2) {
    var r2, n2, o3;
    switch (i3 = e2 || i3, "string" == typeof t2 && (r2 = A2(t2.toLowerCase()), Array.isArray(r2) && (n2 = r2[0], o3 = r2[1])), Array.isArray(t2) && (n2 = t2[0] * _t2, o3 = t2[1] * _t2), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i3.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je(s2), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t2) {
    t2 > 0 && t2 <= Dt2 && (ot2.splice(t2, 1), Rt2.splice(t2, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t2) {
    t2 > 0 && t2 <= Dt2 && ($2 = t2);
  }, Ee = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = function(t2, e2, r2) {
    var n2, i4 = void 0;
    return r2 = r2 || {}, t2 = void 0 !== t2 ? t2 : Ft2[St2].fontName, e2 = void 0 !== e2 ? e2 : Ft2[St2].fontStyle, n2 = t2.toLowerCase(), void 0 !== Ct2[n2] && void 0 !== Ct2[n2][e2] ? i4 = Ct2[n2][e2] : void 0 !== Ct2[t2] && void 0 !== Ct2[t2][e2] ? i4 = Ct2[t2][e2] : false === r2.disableWarning && a.warn("Unable to look up font label for font '" + t2 + "', '" + e2 + "'. Refer to getFontList() for available fonts."), i4 || r2.noFallback || null == (i4 = Ct2.times[e2]) && (i4 = Ct2.times.normal), i4;
  }, De = y2.__private__.putInfo = function() {
    var t2 = Xt2(), e2 = function(t3) {
      return t3;
    };
    for (var r2 in null !== m2 && (e2 = Ye.encryptor(t2, 0)), lt2("<<"), lt2("/Producer (" + Ce(e2("jsPDF " + E.version)) + ")"), xt2)
      xt2.hasOwnProperty(r2) && xt2[r2] && lt2("/" + r2.substr(0, 1).toUpperCase() + r2.substr(1) + " (" + Ce(e2(xt2[r2])) + ")");
    lt2("/CreationDate (" + Ce(e2(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y2.__private__.putCatalog = function(t2) {
    var e2 = (t2 = t2 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e2 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r2 = "" + mt2;
        "%" === r2.substr(r2.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et3 + 1)), lt2("/Root " + et3 + " 0 R"), lt2("/Info " + (et3 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
  }, ze = y2.__private__.putXRef = function() {
    var t2 = "0000000000";
    lt2("xref"), lt2("0 " + (et3 + 1)), lt2("0000000000 65535 f ");
    for (var e2 = 1; e2 <= et3; e2++) {
      "function" == typeof rt2[e2] ? lt2((t2 + rt2[e2]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e2] ? lt2((t2 + rt2[e2]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue(), oe2(), Se(), xe(), null !== m2 && be2(), De(), Re();
    var t2 = it2;
    return ze(), Te(), lt2("startxref"), lt2("" + t2), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y2.__private__.getBlob = function(t2) {
    return new Blob([dt2(t2)], { type: "application/pdf" });
  }, Ve = y2.output = y2.__private__.output = Ie(function(t2, e2) {
    switch ("string" == typeof (e2 = e2 || {}) ? e2 = { filename: e2 } : e2.filename = e2.filename || "generated.pdf", t2) {
      case void 0:
        return He();
      case "save":
        y2.save(e2.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n.URL && "function" == typeof n.URL.createObjectURL)
          return n.URL && n.URL.createObjectURL(We(He())) || void 0;
        a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r2 = "", i4 = He();
        try {
          r2 = h(i4);
        } catch (t3) {
          r2 = h(unescape(encodeURIComponent(i4)));
        }
        return "data:application/pdf;filename=" + e2.filename + ";base64," + r2;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e2.pdfObjectUrl && (o3 = e2.pdfObjectUrl, s3 = "");
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e2) + ");<\/script></body></html>", u3 = n.open();
          return null !== u3 && u3.document.write(c3), u3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e2.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e2.filename + '" width="500px" height="400px" /></body></html>', f2 = n.open();
          if (null !== f2) {
            f2.document.write(l2);
            var d3 = this;
            f2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f2.document.title = e2.filename, f2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
            };
          }
          return f2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n))
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e2) + '"></iframe></body></html>', g3 = n.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e2.filename), g3 || "undefined" == typeof safari)
          return g3;
        break;
      case "datauri":
      case "dataurl":
        return n.document.location.href = this.output("datauristring", e2);
      default:
        return null;
    }
  }), Ge = function(t2) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t2) > -1;
  };
  switch (o2) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if ("number" != typeof o2)
        throw new Error("Invalid unit: " + o2);
      _t2 = o2;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t2) {
    return null !== m2 ? Ye.encryptor(t2, 0) : function(t3) {
      return t3;
    };
  }, Xe = y2.__private__.getPageInfo = y2.getPageInfo = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t2].objId, pageNumber: t2, pageContext: Rt2[t2] };
  }, Ke = y2.__private__.getPageInfoByObjId = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e2 in Rt2)
      if (Rt2[e2].objId === t2)
        break;
    return Xe(e2);
  }, Ze = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t2) {
    return this.addPage(), this.movePage($2, t2), this;
  }, y2.movePage = function(t2, e2) {
    var r2, n2;
    if (t2 > e2) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var i4 = t2; i4 > e2; i4--)
        ot2[i4] = ot2[i4 - 1], Rt2[i4] = Rt2[i4 - 1];
      ot2[e2] = r2, Rt2[e2] = n2, this.setPage(e2);
    } else if (t2 < e2) {
      r2 = ot2[t2], n2 = Rt2[t2];
      for (var a2 = t2; a2 < e2; a2++)
        ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e2] = r2, Rt2[e2] = n2, this.setPage(e2);
    }
    return this;
  }, y2.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e2, r2, n2, i4, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3 = (i4 = i4 || {}).scope || this;
    if ("number" == typeof e2 && "number" == typeof r2 && ("string" == typeof n2 || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r2, r2 = e2, e2 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], "object" === _typeof(f2 = arguments[3]) && null !== f2 || ("string" == typeof c3 && (u3 = c3, c3 = null), "string" == typeof f2 && (u3 = f2, f2 = null), "number" == typeof f2 && (c3 = f2, f2 = null), i4 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r2) || isNaN(n2) || null == e2)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e2.length)
      return g3;
    var v3 = "", y3 = false, w3 = "number" == typeof i4.lineHeightFactor ? i4.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t2) {
      return t2 = t2.split("	").join(Array(i4.TabLen || 9).join(" ")), Ce(t2, f2);
    }
    function A3(t2) {
      for (var e3, r3 = t2.concat(), n3 = [], i5 = r3.length; i5--; )
        "string" == typeof (e3 = r3.shift()) ? n3.push(e3) : Array.isArray(t2) && (1 === e3.length || void 0 === e3[1] && void 0 === e3[2]) ? n3.push(e3[0]) : n3.push([e3[0], e3[1], e3[2]]);
      return n3;
    }
    function _3(t2, e3) {
      var r3;
      if ("string" == typeof t2)
        r3 = e3(t2)[0];
      else if (Array.isArray(t2)) {
        for (var n3, i5, a3 = t2.concat(), o4 = [], s4 = a3.length; s4--; )
          "string" == typeof (n3 = a3.shift()) ? o4.push(e3(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i5 = e3(n3[0], n3[1], n3[2]), o4.push([i5[0], i5[1], i5[2]]));
        r3 = o4;
      }
      return r3;
    }
    var P3 = false, k3 = true;
    if ("string" == typeof e2)
      P3 = true;
    else if (Array.isArray(e2)) {
      var I2 = e2.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; )
        ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3)
      throw new Error('Type of text must be string or Array. "' + e2 + '" is not recognized.');
    "string" == typeof e2 && (e2 = e2.match(/[\r?\n]/) ? e2.split(/\r\n|\r|\n/g) : [e2]);
    var j2 = gt2 / g3.internal.scaleFactor, B2 = j2 * (w3 - 1);
    switch (i4.baseline) {
      case "bottom":
        n2 -= B2;
        break;
      case "top":
        n2 += j2 - B2;
        break;
      case "hanging":
        n2 += j2 - 2 * B2;
        break;
      case "middle":
        n2 += j2 / 2 - B2;
    }
    if ((l2 = i4.maxWidth || 0) > 0 && ("string" == typeof e2 ? e2 = g3.splitTextToSize(e2, l2) : "[object Array]" === Object.prototype.toString.call(e2) && (e2 = e2.reduce(function(t2, e3) {
      return t2.concat(g3.splitTextToSize(e3, l2));
    }, []))), o3 = { text: e2, x: r2, y: n2, options: i4, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e2 = o3.text, c3 = (i4 = o3.options).angle, p3 instanceof Vt2 == false && c3 && "number" == typeof c3) {
      c3 *= Math.PI / 180, 0 === i4.rotationDirection && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c3 && c3 instanceof Vt2 && (p3 = c3);
    S2 !== x2.ADVANCED || p3 || (p3 = Yt2), void 0 !== (h2 = i4.charSpace || _r) && (v3 += O2(U2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i4.horizontalScale) && (v3 += O2(100 * d3) + " Tz\n");
    i4.lang;
    var D3 = -1, R3 = void 0 !== i4.renderingMode ? i4.renderingMode : i4.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
    -1 !== D3 ? v3 += D3 + " Tr\n" : -1 !== z3 && (v3 += "0 Tr\n"), -1 !== D3 && (T3.usedRenderingMode = D3), u3 = i4.align || "left";
    var H3, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[St2];
    h2 = i4.charSpace || _r, l2 = i4.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i4.flags);
    var Y3 = [];
    if ("[object Array]" === Object.prototype.toString.call(e2)) {
      var J3;
      s3 = A3(e2), "left" !== u3 && (H3 = s3.map(function(t2) {
        return g3.getStringUnitWidth(t2, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
      }));
      var X3, K3 = 0;
      if ("right" === u3) {
        r2 -= H3[0], e2 = [], C2 = s3.length;
        for (var Z3 = 0; Z3 < C2; Z3++)
          0 === Z3 ? (X3 = br(r2), J3 = yr(n2)) : (X3 = U2(K3 - H3[Z3]), J3 = -W3), e2.push([s3[Z3], X3, J3]), K3 = H3[Z3];
      } else if ("center" === u3) {
        r2 -= H3[0] / 2, e2 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++)
          0 === $3 ? (X3 = br(r2), J3 = yr(n2)) : (X3 = U2((K3 - H3[$3]) / 2), J3 = -W3), e2.push([s3[$3], X3, J3]), K3 = H3[$3];
      } else if ("left" === u3) {
        e2 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          e2.push(s3[Q3]);
      } else {
        if ("justify" !== u3)
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e2 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (var tt3 = 0; tt3 < C2; tt3++)
          J3 = 0 === tt3 ? yr(n2) : -W3, X3 = 0 === tt3 ? br(r2) : 0, tt3 < C2 - 1 ? Y3.push(O2(U2((l2 - H3[tt3]) / (s3[tt3].split(" ").length - 1)))) : Y3.push(0), e2.push([s3[tt3], X3, J3]);
      }
    }
    var et4 = "boolean" == typeof i4.R2L ? i4.R2L : bt2;
    true === et4 && (e2 = _3(e2, function(t2, e3, r3) {
      return [t2.split("").reverse().join(""), e3, r3];
    })), o3 = { text: e2, x: r2, y: n2, options: i4, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e2 = o3.text, y3 = o3.mutex.isHex || false;
    var rt3 = Ft2[St2].encoding;
    "WinAnsiEncoding" !== rt3 && "StandardEncoding" !== rt3 || (e2 = _3(e2, function(t2, e3, r3) {
      return [L3(t2), e3, r3];
    })), s3 = A3(e2), e2 = [];
    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = "", ht3 = function(t2, e3, r3) {
      var n3 = "";
      return r3 instanceof Vt2 ? (r3 = "number" == typeof i4.angle ? Gt2(r3, new Vt2(1, 0, 0, 1, t2, e3)) : Gt2(new Vt2(1, 0, 0, 1, t2, e3), r3), S2 === x2.ADVANCED && (r3 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r3)), n3 = r3.join(" ") + " Tm\n") : n3 = O2(t2) + " " + O2(e3) + " Td\n", n3;
    }, ft3 = 0; ft3 < s3.length; ft3++) {
      switch (ut3 = "", ct3) {
        case st3:
          at3 = (y3 ? "<" : "(") + s3[ft3][0] + (y3 ? ">" : ")"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);
          break;
        case ot3:
          at3 = (y3 ? "<" : "(") + s3[ft3] + (y3 ? ">" : ")"), nt3 = br(r2), it3 = yr(n2);
      }
      void 0 !== Y3 && void 0 !== Y3[ft3] && (ut3 = Y3[ft3] + " Tw\n"), 0 === ft3 ? e2.push(ut3 + ht3(nt3, it3, p3) + at3) : ct3 === ot3 ? e2.push(ut3 + at3) : ct3 === st3 && e2.push(ut3 + ht3(nt3, it3, p3) + at3);
    }
    e2 = ct3 === ot3 ? e2.join(" Tj\nT* ") : e2.join(" Tj\n"), e2 += " Tj\n";
    var dt3 = "BT\n/";
    return dt3 += St2 + " " + gt2 + " Tf\n", dt3 += O2(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v3, dt3 += e2, lt2(dt3 += "ET"), b2[St2] = true, g3;
  };
  var $e = y2.__private__.clip = y2.clip = function(t2) {
    return lt2("evenodd" === t2 ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y2.__private__.isValidStyle = function(t2) {
    var e2 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) && (e2 = true), e2;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t2) {
    return Qe(t2) && (g2 = t2), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t2) {
    var e2 = g2;
    switch (t2) {
      case "D":
      case "S":
        e2 = "S";
        break;
      case "F":
        e2 = "f";
        break;
      case "FD":
      case "DF":
        e2 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e2 = t2;
    }
    return e2;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t2) {
    return rr("f", t2), this;
  }, y2.fillEvenOdd = function(t2) {
    return rr("f*", t2), this;
  }, y2.fillStroke = function(t2) {
    return rr("B", t2), this;
  }, y2.fillStrokeEvenOdd = function(t2) {
    return rr("B*", t2), this;
  };
  var rr = function(e2, r2) {
    "object" === _typeof(r2) ? ar(r2, e2) : lt2(e2);
  }, nr = function(t2) {
    null === t2 || S2 === x2.ADVANCED && void 0 === t2 || (t2 = tr(t2), lt2(t2));
  };
  function ir(t2, e2, r2, n2, i4) {
    var a2 = new M(e2 || this.boundingBox, r2 || this.xStep, n2 || this.yStep, this.gState, i4 || this.matrix);
    a2.stream = this.stream;
    var o3 = t2 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  var ar = function(t2, e2) {
    var r2 = Bt2[t2.key], n2 = Ot2[r2];
    if (n2 instanceof B)
      lt2("q"), lt2(or(e2)), n2.gState && y2.setGState(n2.gState), lt2(t2.matrix.toString() + " cm"), lt2("/" + r2 + " sh"), lt2("Q");
    else if (n2 instanceof M) {
      var i4 = new Vt2(1, 0, 0, -1, 0, Rr());
      t2.matrix && (i4 = i4.multiply(t2.matrix || Yt2), r2 = ir.call(n2, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i4).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r2 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e2), lt2("Q");
    }
  }, or = function(t2) {
    switch (t2) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y2.moveTo = function(t2, e2) {
    return lt2(O2(U2(t2)) + " " + O2(H2(e2)) + " m"), this;
  }, cr = y2.lineTo = function(t2, e2) {
    return lt2(O2(U2(t2)) + " " + O2(H2(e2)) + " l"), this;
  }, ur = y2.curveTo = function(t2, e2, r2, n2, i4, a2) {
    return lt2([O2(U2(t2)), O2(H2(e2)), O2(U2(r2)), O2(H2(n2)), O2(U2(i4)), O2(H2(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t2, e2, r2, n2, i4) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i4))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r2 - t2, n2 - e2]], t2, e2, [1, 1], i4 || "S") : this.lines([[r2 - t2, n2 - e2]], t2, e2, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t2, e2, r2, n2, i4, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3, m3, v3;
    if ("number" == typeof t2 && (v3 = r2, r2 = e2, e2 = t2, t2 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e2) || isNaN(r2) || !Array.isArray(t2) || !Array.isArray(n2) || !Qe(i4) || "boolean" != typeof a2)
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e2, r2), o3 = n2[0], s3 = n2[1], u3 = t2.length, g3 = e2, m3 = r2, c3 = 0; c3 < u3; c3++)
      2 === (h2 = t2[c3]).length ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p3 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p3, g3, m3));
    return a2 && er(), nr(i4), this;
  }, y2.path = function(t2) {
    for (var e2 = 0; e2 < t2.length; e2++) {
      var r2 = t2[e2], n2 = r2.c;
      switch (r2.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t2, e2, r2, n2, i4) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i4))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(U2(t2)), O2(H2(e2)), O2(U2(r2)), O2(U2(n2)), "re"].join(" ")), nr(i4), this;
  }, y2.__private__.triangle = y2.triangle = function(t2, e2, r2, n2, i4, a2, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || isNaN(i4) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r2 - t2, n2 - e2], [i4 - r2, a2 - n2], [t2 - i4, e2 - a2]], t2, e2, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t2, e2, r2, n2, i4, a2, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || isNaN(i4) || isNaN(a2) || !Qe(o3))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i4 = Math.min(i4, 0.5 * r2), a2 = Math.min(a2, 0.5 * n2), this.lines([[r2 - 2 * i4, 0], [i4 * s3, 0, i4, a2 - a2 * s3, i4, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i4 * s3, a2, -i4, a2], [2 * i4 - r2, 0], [-i4 * s3, 0, -i4, -a2 * s3, -i4, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i4 * s3, -a2, i4, -a2]], t2 + i4, e2, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t2, e2, r2, n2, i4) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n2) || !Qe(i4))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r2, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t2 + r2, e2), ur(t2 + r2, e2 - o3, t2 + a2, e2 - n2, t2, e2 - n2), ur(t2 - a2, e2 - n2, t2 - r2, e2 - o3, t2 - r2, e2), ur(t2 - r2, e2 + o3, t2 - a2, e2 + n2, t2, e2 + n2), ur(t2 + a2, e2 + n2, t2 + r2, e2 + o3, t2 + r2, e2), nr(i4), this;
  }, y2.__private__.circle = y2.circle = function(t2, e2, r2, n2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || !Qe(n2))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t2, e2, r2, r2, n2);
  }, y2.setFont = function(t2, e2, r2) {
    return r2 && (e2 = k2(e2, r2)), St2 = qe(t2, e2, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[qe.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t2, e2, r2 = {};
    for (t2 in Ct2)
      if (Ct2.hasOwnProperty(t2))
        for (e2 in r2[t2] = [], Ct2[t2])
          Ct2[t2].hasOwnProperty(e2) && r2[t2].push(e2);
    return r2;
  }, y2.addFont = function(t2, e2, r2, n2, i4) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a2.indexOf(arguments[3]) ? i4 = arguments[3] : arguments[3] && -1 == a2.indexOf(arguments[3]) && (r2 = k2(r2, n2)), i4 = i4 || "Identity-H", Pe.call(this, t2, e2, r2, i4);
  };
  var lr, fr = e.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t2) {
    return fr = t2, lt2(O2(U2(t2)) + " w"), this;
  };
  y2.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t2, e2) {
    if (t2 = t2 || [], e2 = e2 || 0, isNaN(e2) || !Array.isArray(t2))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t2 = t2.map(function(t3) {
      return O2(U2(t3));
    }).join(" "), e2 = O2(U2(e2)), lt2("[" + t2 + "] " + e2 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t2) {
    return "number" == typeof (t2 = t2 || 1.15) && (lr = t2), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t2) {
    return U2(t2);
  }, yr = y2.__private__.getVerticalCoordinate = function(t2) {
    return S2 === x2.ADVANCED ? t2 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t2);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t2) {
    return O2(br(t2));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t2) {
    return O2(yr(t2));
  }, Lr = e.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t2, e2, r2, n2) {
    return Lr = re3({ ch1: t2, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t2, e2, r2, n2) {
    return Ar = re3({ ch1: t2, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t2, e2, r2, n2) {
    return xr = re3({ ch1: t2, ch2: e2, ch3: r2, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t2) {
    if (isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t2, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t2) {
    var e2 = y2.CapJoinStyles[t2];
    if (void 0 === e2)
      throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e2, lt2(e2 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t2) {
    var e2 = y2.CapJoinStyles[t2];
    if (void 0 === e2)
      throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e2, lt2(e2 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t2) {
    if (t2 = t2 || 0, isNaN(t2))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(U2(t2)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t2) {
    (t2 = "string" == typeof t2 ? Mt2[Et2[t2]] : Fr(null, t2)).equals(qt2) || (lt2("/" + t2.id + " gs"), qt2 = t2);
  };
  var Fr = function(t2, e2) {
    if (!t2 || !Et2[t2]) {
      var r2 = false;
      for (var n2 in Mt2)
        if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e2)) {
          r2 = true;
          break;
        }
      if (r2)
        e2 = Mt2[n2];
      else {
        var i4 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i4] = e2, e2.id = i4;
      }
      return t2 && (Et2[t2] = e2.id), Tt2.publish("addGState", e2), e2;
    }
  };
  y2.addGState = function(t2, e2) {
    return Fr(t2, e2), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t2 = jt2.pop();
    return St2 = t2.key, gt2 = t2.size, xr = t2.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t2) {
    return lt2(t2.toString() + " cm"), this;
  }, y2.comment = function(t2) {
    return lt2("#" + t2), this;
  };
  var Cr = function(t2, e2) {
    var r2 = t2 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      isNaN(t3) || (r2 = parseFloat(t3));
    } });
    var n2 = e2 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t3) {
      isNaN(t3) || (n2 = parseFloat(t3));
    } });
    var i4 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i4;
    }, set: function(t3) {
      i4 = t3.toString();
    } }), this;
  }, jr = function(t2, e2, r2, n2) {
    Cr.call(this, t2, e2), this.type = "rect";
    var i4 = r2 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i4;
    }, set: function(t3) {
      isNaN(t3) || (i4 = parseFloat(t3));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = parseFloat(t3));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t2, e2, r2, n2, i4) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t2, kt2 = e2, It2 = i4, je([r2, n2]);
  }, Mr = function(t2) {
    if (Ht2[t2])
      Wt2.pop().restore();
    else {
      var e2 = new Or(), r2 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
      e2.id = r2, Ht2[t2] = r2, zt2[r2] = e2, Tt2.publish("addFormObject", e2), Wt2.pop().restore();
    }
  };
  for (var Er in y2.beginFormObject = function(t2, e2, r2, n2, i4) {
    return Br(t2, e2, r2, n2, i4), this;
  }, y2.endFormObject = function(t2) {
    return Mr(t2), this;
  }, y2.doFormObject = function(t2, e2) {
    var r2 = zt2[Ht2[t2]];
    return lt2("q"), lt2(e2.toString() + " cm"), lt2("/" + r2.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t2) {
    var e2 = zt2[Ht2[t2]];
    return { x: e2.x, y: e2.y, width: e2.width, height: e2.height, matrix: e2.matrix };
  }, y2.save = function(t2, e2) {
    return t2 = t2 || "generated.pdf", (e2 = e2 || {}).returnPromise = e2.returnPromise || false, false === e2.returnPromise ? (l(We(He()), t2), "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e3, r2) {
      try {
        var i4 = l(We(He()), t2);
        "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), e3(i4);
      } catch (t3) {
        r2(t3.message);
      }
    });
  }, E.API)
    E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t2, e2) {
      var r2, n2, i4;
      for (i4 = e2.length - 1; -1 !== i4; i4--)
        r2 = e2[i4][0], n2 = e2[i4][1], t2.subscribe.apply(t2, [r2].concat("function" == typeof n2 ? [n2] : n2));
    }(Tt2, E.API.events) : y2[Er] = E.API[Er]);
  var qr = y2.getPageWidth = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightX - Rt2[t2].mediaBox.bottomLeftX) / _t2;
  }, Dr = y2.setPageWidth = function(t2, e2) {
    Rt2[t2].mediaBox.topRightX = e2 * _t2 + Rt2[t2].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t2) {
    return (Rt2[t2 = t2 || $2].mediaBox.topRightY - Rt2[t2].mediaBox.bottomLeftY) / _t2;
  }, Tr = y2.setPageHeight = function(t2, e2) {
    Rt2[t2].mediaBox.topRightY = e2 * _t2 + Rt2[t2].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t2) {
    Dr($2, t2);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t2) {
    Tr($2, t2);
  } }, encryptionOptions: m2, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t2) {
    Dr($2, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t2) {
    Tr($2, t2);
  }, enumerable: true, configurable: true }), ke.call(y2, pt2), St2 = "F1", Oe(s2, i3), Tt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t2) {
  return String.fromCharCode(t2 >> 0 & 255, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
}, I.prototype.toHexString = function(t2) {
  return t2.split("").map(function(t3) {
    return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t2) {
  for (var e = [], r = 0; r < t2.length; r += 2)
    e.push(String.fromCharCode(parseInt(t2.substr(r, 2), 16)));
  return e.join("");
}, I.prototype.processOwnerPassword = function(t2, e) {
  return P(x(e).substr(0, 5), t2);
}, I.prototype.encryptor = function(t2, e) {
  var r = x(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(t3) {
    return P(r, t3);
  };
}, j.prototype.equals = function(e) {
  var r, n2 = "id,objectNumber,equals";
  if (!e || _typeof(e) !== _typeof(this))
    return false;
  var i3 = 0;
  for (r in this)
    if (!(n2.indexOf(r) >= 0)) {
      if (this.hasOwnProperty(r) && !e.hasOwnProperty(r))
        return false;
      if (this[r] !== e[r])
        return false;
      i3++;
    }
  for (r in e)
    e.hasOwnProperty(r) && n2.indexOf(r) < 0 && i3--;
  return 0 === i3;
}, E.API = { events: [] }, E.version = "2.5.1";
var q = E.API;
var D = 1;
var R = function(t2) {
  return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
};
var T = function(t2) {
  return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var U = function(t2) {
  return t2.toFixed(2);
};
var z = function(t2) {
  return t2.toFixed(5);
};
q.__acroform__ = {};
var H = function(t2, e) {
  t2.prototype = Object.create(e.prototype), t2.prototype.constructor = t2;
};
var W = function(t2) {
  return t2 * D;
};
var V = function(t2) {
  var e = new ut(), r = At.internal.getHeight(t2) || 0, n2 = At.internal.getWidth(t2) || 0;
  return e.BBox = [0, 0, Number(U(n2)), Number(U(r))], e;
};
var G = q.__acroform__.setBit = function(t2, e) {
  if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t2 |= 1 << e;
};
var Y = q.__acroform__.clearBit = function(t2, e) {
  if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t2 &= ~(1 << e);
};
var J = q.__acroform__.getBit = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t2 & 1 << e) ? 0 : 1;
};
var X = q.__acroform__.getBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t2, e - 1);
};
var K = q.__acroform__.setBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t2, e - 1);
};
var Z = q.__acroform__.clearBitForPdf = function(t2, e) {
  if (isNaN(t2) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t2, e - 1);
};
var $ = q.__acroform__.calculateCoordinates = function(t2, e) {
  var r = e.internal.getHorizontalCoordinate, n2 = e.internal.getVerticalCoordinate, i3 = t2[0], a2 = t2[1], o2 = t2[2], s2 = t2[3], c2 = {};
  return c2.lowerLeft_X = r(i3) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r(i3 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(U(c2.lowerLeft_X)), Number(U(c2.lowerLeft_Y)), Number(U(c2.upperRight_X)), Number(U(c2.upperRight_Y))];
};
var Q = function(t2) {
  if (t2.appearanceStreamContent)
    return t2.appearanceStreamContent;
  if (t2.V || t2.DV) {
    var e = [], r = t2._V || t2.DV, n2 = tt(t2, r), i3 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(t2.scope.__private__.encodeColorString(t2.color)), e.push("/" + i3 + " " + U(n2.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n2.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var a2 = V(t2);
    return a2.scope = t2.scope, a2.stream = e.join("\n"), a2;
  }
};
var tt = function(t2, e) {
  var r = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, n2 = { text: "", fontSize: "" }, i3 = (e = ")" == (e = "(" == e.substr(0, 1) ? e.substr(1) : e).substr(e.length - 1) ? e.substr(0, e.length - 1) : e).split(" ");
  i3 = t2.multiline ? i3.map(function(t3) {
    return t3.split("\n");
  }) : i3.map(function(t3) {
    return [t3];
  });
  var a2 = r, o2 = At.internal.getHeight(t2) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t2) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = function(e2, r2, n3) {
    if (e2 + 1 < i3.length) {
      var a3 = r2 + " " + i3[e2 + 1][0];
      return et2(a3, t2, n3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t:
    for (; a2 > 0; ) {
      e = "", a2--;
      var u2, h2, l2 = et2("3", t2, a2).height, f2 = t2.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e = "(...) Tj\n", e += "% Width of Text: " + et2(e, t2, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i3.length; y2++)
        if (i3.hasOwnProperty(y2)) {
          var w2 = false;
          if (1 !== i3[y2].length && m2 !== i3[y2].length - 1) {
            if ((l2 + 2) * (b2 + 2) + 2 > o2)
              continue t;
            v2 += i3[y2][m2], w2 = true, g2 = y2, y2--;
          } else {
            v2 = " " == (v2 += i3[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
            var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i3.length - 1;
            if (L2 && !A2) {
              v2 += " ", m2 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N2;
              else if (t2.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
            } else {
              if (!t2.multiline)
                continue t;
              if ((l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
              g2 = N2;
            }
          }
          for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
            var _2 = i3[S2];
            if (t2.multiline) {
              if (S2 === g2) {
                x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
                continue;
              }
              if (S2 === p2) {
                x2 += _2[_2.length - 1] + " ";
                continue;
              }
            }
            x2 += _2[0] + " ";
          }
          switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h2 = et2(x2, t2, a2).width, t2.textAlign) {
            case "right":
              u2 = s2 - h2 - 2;
              break;
            case "center":
              u2 = (s2 - h2) / 2;
              break;
            case "left":
            default:
              u2 = 2;
          }
          e += U(u2) + " " + U(d2) + " Td\n", e += "(" + R(x2) + ") Tj\n", e += -U(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
        } else
          ;
      break;
    }
  return n2.text = e, n2.fontSize = a2, n2;
};
var et2 = function(t2, e, r) {
  var n2 = e.scope.internal.getFont(e.fontName, e.fontStyle), i3 = e.scope.getStringUnitWidth(t2, { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r);
  return { height: e.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r), charSpace: 0 }) * parseFloat(r) * 1.5, width: i3 };
};
var rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
var nt = function(t2, e) {
  var r = { type: "reference", object: t2 };
  void 0 === e.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
    return t3.type === r.type && t3.object === r.object;
  }) && e.internal.getPageInfo(t2.page).pageContext.annotations.push(r);
};
var it = function(e, r) {
  for (var n2 in e)
    if (e.hasOwnProperty(n2)) {
      var i3 = n2, a2 = e[n2];
      r.internal.newObjectDeferredBegin(a2.objId, true), "object" === _typeof(a2) && "function" == typeof a2.putStream && a2.putStream(), delete e[i3];
    }
};
var at = function(e, r) {
  if (r.scope = e, void 0 !== e.internal && (void 0 === e.internal.acroformPlugin || false === e.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
      !function(t2) {
        t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
      }(e);
    }), e.internal.events.subscribe("buildDocument", function() {
      !function(t2) {
        t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e2 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r2 in e2)
          if (e2.hasOwnProperty(r2)) {
            var n2 = e2[r2];
            n2.objId = void 0, n2.hasAnnotation && nt(n2, t2);
          }
      }(e);
    }), e.internal.events.subscribe("putCatalog", function() {
      !function(t2) {
        if (void 0 === t2.internal.acroformPlugin.acroFormDictionaryRoot)
          throw new Error("putCatalogCallback: Root missing.");
        t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e);
    }), e.internal.events.subscribe("postPutPages", function(r2) {
      !function(e2, r3) {
        var n2 = !e2;
        for (var i3 in e2 || (r3.internal.newObjectDeferredBegin(r3.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r3.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e2 = e2 || r3.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e2.hasOwnProperty(i3)) {
            var a2 = e2[i3], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = $(a2.Rect, r3)), r3.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), "object" === _typeof(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var c2 = Q(a2);
              o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r3.internal.acroformPlugin.xForms.push(c2);
            }
            if (a2.appearanceStreamContent) {
              var u2 = "";
              for (var h2 in a2.appearanceStreamContent)
                if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
                  var l2 = a2.appearanceStreamContent[h2];
                  if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                    for (var i3 in l2)
                      if (l2.hasOwnProperty(i3)) {
                        var f2 = l2[i3];
                        "function" == typeof f2 && (f2 = f2.call(r3, a2)), u2 += "/" + i3 + " " + f2 + " ", r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                      }
                  } else
                    "function" == typeof (f2 = l2) && (f2 = f2.call(r3, a2)), u2 += "/" + i3 + " " + f2, r3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r3.internal.acroformPlugin.xForms.push(f2);
                  u2 += ">>";
                }
              o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
            }
            r3.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r3.internal.out("endobj");
          }
        n2 && it(r3.internal.acroformPlugin.xForms, r3);
      }(r2, e);
    }), e.internal.acroformPlugin.isInitialized = true;
  }
};
var ot = q.__acroform__.arrayToPdfArray = function(e, r, n2) {
  var i3 = function(t2) {
    return t2;
  };
  if (Array.isArray(e)) {
    for (var a2 = "[", o2 = 0; o2 < e.length; o2++)
      switch (0 !== o2 && (a2 += " "), _typeof(e[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e[o2].toString();
          break;
        case "string":
          "/" !== e[o2].substr(0, 1) ? (void 0 !== r && n2 && (i3 = n2.internal.getEncryptor(r)), a2 += "(" + R(i3(e[o2].toString())) + ")") : a2 += e[o2].toString();
      }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t2, e, r) {
  var n2 = function(t3) {
    return t3;
  };
  return void 0 !== e && r && (n2 = r.internal.getEncryptor(e)), (t2 = t2 || "").toString(), t2 = "(" + R(n2(t2)) + ")";
};
var ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t2) {
    this._objId = t2;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t2 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t2 = [], e = Object.getOwnPropertyNames(this).filter(function(t3) {
    return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
  });
  for (var r in e)
    if (false === Object.getOwnPropertyDescriptor(this, e[r]).configurable) {
      var n2 = e[r], i3 = this[n2];
      i3 && (Array.isArray(i3) ? t2.push({ key: n2, value: ot(i3, this.objId, this.scope) }) : i3 instanceof ct ? (i3.scope = this.scope, t2.push({ key: n2, value: i3.objId + " 0 R" })) : "function" != typeof i3 && t2.push({ key: n2, value: i3 }));
    }
  return t2;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t2, e = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e;
  }, set: function(t3) {
    e = t3;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e2) {
    t2 = e2.trim();
  }, get: function() {
    return t2 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t2, e = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t2) {
      var e2 = function(t3) {
        return t3;
      };
      return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e2(t2)) + ")";
    }
  }, set: function(e2) {
    t2 = e2;
  } });
};
H(ht, ct);
var lt = function t() {
  ct.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    if (isNaN(t2))
      throw new Error('Invalid value "' + t2 + '" for attribute F supplied.');
    e = t2;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.F = K(e, 3) : this.F = Z(e, 3);
  } });
  var r = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r;
  }, set: function(t2) {
    if (isNaN(t2))
      throw new Error('Invalid value "' + t2 + '" for attribute Ff supplied.');
    r = t2;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n2.length)
      return n2;
  }, set: function(t2) {
    n2 = void 0 !== t2 ? t2 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t2) {
    n2[0] = t2;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t2) {
    n2[1] = t2;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t2) {
    n2[2] = t2;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t2) {
    n2[3] = t2;
  } });
  var i3 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i3;
  }, set: function(t2) {
    switch (t2) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i3 = t2;
        break;
      default:
        throw new Error('Invalid value "' + t2 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt)
        return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e2 = function(t2) {
      return t2;
    };
    return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e2(a2)) + ")";
  }, set: function(t2) {
    a2 = t2.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t2) {
    a2 = t2;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t2) {
    o2 = t2;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t2) {
    s2 = t2;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t2) {
    c2 = t2;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u2 ? 50 / D : u2;
  }, set: function(t2) {
    u2 = t2;
  } });
  var h2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h2;
  }, set: function(t2) {
    h2 = t2;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt))
      return st(l2, this.objId, this.scope);
  }, set: function(t2) {
    t2 = t2.toString(), l2 = t2;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2)
      return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t2) {
    t2 = t2.toString(), f2 = this instanceof mt == true ? "/" + t2 : t2;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t2) {
    this.V = t2;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == false ? "(" === t2.substr(0, 1) ? T(t2.substr(1, t2.length - 2)) : T(t2) : t2;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t2) {
    t2 = t2.toString(), d2 = this instanceof mt == true ? "/" + t2 : t2;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p2, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t2) {
    t2 = Boolean(t2), g2 = t2;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p2)
      return p2;
  }, set: function(t2) {
    p2 = t2;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m2)
      return m2;
  }, set: function(t2) {
    if (-1 === [0, 1, 2].indexOf(t2))
      throw new Error('Invalid value "' + t2 + '" for attribute Q supplied.');
    m2 = t2;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t2;
    switch (m2) {
      case 0:
      default:
        t2 = "left";
        break;
      case 1:
        t2 = "center";
        break;
      case 2:
        t2 = "right";
    }
    return t2;
  }, configurable: true, enumerable: true, set: function(t2) {
    switch (t2) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t2 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e2) {
    t2 = e2;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e2) {
    t2 = e2;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e, this.objId, this.scope);
  }, set: function(t3) {
    var r, n2;
    n2 = [], "string" == typeof (r = t3) && (n2 = function(t4, e2, r2) {
      r2 || (r2 = 1);
      for (var n3, i3 = []; n3 = e2.exec(t4); )
        i3.push(n3[r2]);
      return i3;
    }(r, /\((.*?)\)/g)), e = n2;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t3) {
    e = t3, this.sort && e.sort();
  }, this.addOption = function(t3) {
    t3 = (t3 = t3 || "").toString(), e.push(t3), this.sort && e.sort();
  }, this.removeOption = function(t3, r) {
    for (r = r || false, t3 = (t3 = t3 || "").toString(); -1 !== e.indexOf(t3) && (e.splice(e.indexOf(t3), 1), false !== r); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t3) {
    true === this.combo && (true === Boolean(t3) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t3) {
    true === Boolean(t3) ? (this.Ff = K(this.Ff, 20), e.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e, r = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = function(t3) {
      return t3;
    };
    if (this.scope && (t2 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r).length) {
      var e2, n2 = [];
      for (e2 in n2.push("<<"), r)
        n2.push("/" + e2 + " (" + R(t2(r[e2])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e2) {
    "object" === _typeof(e2) && (r = e2);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (r.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    e = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(t2) {
    e = "/" + t2;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t2 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e) {
    t2 = void 0 !== e ? e : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e, r;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e;
  }, set: function(t2) {
    e = t2;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r;
  }, set: function(t2) {
    r = t2;
  } });
  var n2, i3 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t2 = function(t3) {
      return t3;
    };
    this.scope && (t2 = this.scope.internal.getEncryptor(this.objId));
    var e2, r2 = [];
    for (e2 in r2.push("<<"), i3)
      r2.push("/" + e2 + " (" + R(t2(i3[e2])) + ")");
    return r2.push(">>"), r2.join("\n");
  }, set: function(e2) {
    "object" === _typeof(e2) && (i3 = e2);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i3.CA || "";
  }, set: function(t2) {
    "string" == typeof t2 && (i3.CA = t2);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t2) {
    n2 = t2;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t2) {
    n2 = "/" + t2;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t2) {
  if (!("createAppearanceStream" in t2) || !("getCA" in t2))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids)
    if (this.Kids.hasOwnProperty(e)) {
      var r = this.Kids[e];
      r.appearanceStreamContent = t2.createAppearanceStream(r.optionName), r.caption = t2.getCA();
    }
}, bt.prototype.createOption = function(t2) {
  var e = new yt();
  return e.Parent = this, e.optionName = t2, this.Kids.push(e), xt.call(this.scope, e), e;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t2 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t2;
  }, set: function(e) {
    t2 = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t2;
  }, set: function(e) {
    Number.isInteger(e) && (t2 = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t2) {
    true === Boolean(t2) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i3 = t2.scope.__private__.encodeColorString(t2.color), a2 = tt(t2, t2.caption);
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), r.push("BMC"), r.push("q"), r.push("0 0 1 rg"), r.push("/" + n2 + " " + U(a2.fontSize) + " Tf " + i3), r.push("BT"), r.push(a2.text), r.push("ET"), r.push("Q"), r.push("EMC"), e.stream = r.join("\n"), e;
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n2 = t2.scope.__private__.encodeColorString(t2.color), i3 = [], a2 = At.internal.getHeight(t2), o2 = At.internal.getWidth(t2), s2 = tt(t2, t2.caption);
  return i3.push("1 g"), i3.push("0 0 " + U(o2) + " " + U(a2) + " re"), i3.push("f"), i3.push("q"), i3.push("0 0 1 rg"), i3.push("0 0 " + U(o2 - 1) + " " + U(a2 - 1) + " re"), i3.push("W"), i3.push("n"), i3.push("0 g"), i3.push("BT"), i3.push("/" + r + " " + U(s2.fontSize) + " Tf " + n2), i3.push(s2.text), i3.push("ET"), i3.push("Q"), e.stream = i3.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
  var e = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[t2] = At.RadioButton.Circle.YesNormal, e.D[t2] = At.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i3 = At.internal.Bezier_C, a2 = Number((n2 * i3).toFixed(5));
  return r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i3 = Number((2 * n2).toFixed(5)), a2 = Number((i3 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(i3 + " 0 m"), r.push(i3 + " " + a2 + " " + a2 + " " + i3 + " 0 " + i3 + " c"), r.push("-" + a2 + " " + i3 + " -" + i3 + " " + a2 + " -" + i3 + " 0 c"), r.push("-" + i3 + " -" + a2 + " -" + a2 + " -" + i3 + " 0 -" + i3 + " c"), r.push(a2 + " -" + i3 + " " + i3 + " -" + a2 + " " + i3 + " 0 c"), r.push("f"), r.push("Q"), r.push("0 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(n2 + " 0 m"), r.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.getWidth(t2) <= At.internal.getHeight(t2) ? At.internal.getWidth(t2) / 4 : At.internal.getHeight(t2) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i3 = Number((2 * n2).toFixed(5)), a2 = Number((i3 * At.internal.Bezier_C).toFixed(5));
  return r.push("0.749023 g"), r.push("q"), r.push("1 0 0 1 " + z(At.internal.getWidth(t2) / 2) + " " + z(At.internal.getHeight(t2) / 2) + " cm"), r.push(i3 + " 0 m"), r.push(i3 + " " + a2 + " " + a2 + " " + i3 + " 0 " + i3 + " c"), r.push("-" + a2 + " " + i3 + " -" + i3 + " " + a2 + " -" + i3 + " 0 c"), r.push("-" + i3 + " -" + a2 + " -" + a2 + " -" + i3 + " 0 -" + i3 + " c"), r.push(a2 + " -" + i3 + " " + i3 + " -" + a2 + " " + i3 + " 0 c"), r.push("f"), r.push("Q"), e.stream = r.join("\n"), e;
} }, Cross: { createAppearanceStream: function(t2) {
  var e = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[t2] = At.RadioButton.Cross.YesNormal, e.D[t2] = At.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [], n2 = At.internal.calculateCross(t2);
  return r.push("q"), r.push("1 1 " + U(At.internal.getWidth(t2) - 2) + " " + U(At.internal.getHeight(t2) - 2) + " re"), r.push("W"), r.push("n"), r.push(U(n2.x1.x) + " " + U(n2.x1.y) + " m"), r.push(U(n2.x2.x) + " " + U(n2.x2.y) + " l"), r.push(U(n2.x4.x) + " " + U(n2.x4.y) + " m"), r.push(U(n2.x3.x) + " " + U(n2.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
}, YesPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = At.internal.calculateCross(t2), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + U(At.internal.getWidth(t2) - 2) + " " + U(At.internal.getHeight(t2) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U(r.x1.x) + " " + U(r.x1.y) + " m"), n2.push(U(r.x2.x) + " " + U(r.x2.y) + " l"), n2.push(U(r.x4.x) + " " + U(r.x4.y) + " m"), n2.push(U(r.x3.x) + " " + U(r.x3.y) + " l"), n2.push("s"), n2.push("Q"), e.stream = n2.join("\n"), e;
}, OffPushDown: function(t2) {
  var e = V(t2);
  e.scope = t2.scope;
  var r = [];
  return r.push("0.749023 g"), r.push("0 0 " + U(At.internal.getWidth(t2)) + " " + U(At.internal.getHeight(t2)) + " re"), r.push("f"), e.stream = r.join("\n"), e;
} } }, createDefaultAppearanceStream: function(t2) {
  var e = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r = t2.scope.__private__.encodeColorString(t2.color);
  return "/" + e + " " + t2.fontSize + " Tf " + r;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
  var e = At.internal.getWidth(t2), r = At.internal.getHeight(t2), n2 = Math.min(e, r);
  return { x1: { x: (e - n2) / 2, y: (r - n2) / 2 + n2 }, x2: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 }, x3: { x: (e - n2) / 2, y: (r - n2) / 2 }, x4: { x: (e - n2) / 2 + n2, y: (r - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e) {
  var r = 0;
  return "object" === _typeof(e) && (r = W(e.Rect[2])), r;
}, At.internal.getHeight = function(e) {
  var r = 0;
  return "object" === _typeof(e) && (r = W(e.Rect[3])), r;
};
var xt = q.addField = function(t2) {
  if (at(this, t2), !(t2 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = t2).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = false, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
var St = E.AcroForm;
function _t(t2) {
  return t2.reduce(function(t3, e, r) {
    return t3[e] = r, t3;
  }, {});
}
!function(e) {
  e.__addimage__ = {};
  var r = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i3 = e.__addimage__.getImageFileTypeByImageData = function(t2, e2) {
    var i4, a3, o3, s3, c3, u2 = r;
    if ("RGBA" === (e2 = e2 || r) || void 0 !== t2.data && t2.data instanceof Uint8ClampedArray && "height" in t2 && "width" in t2)
      return "RGBA";
    if (x2(t2))
      for (c3 in n2)
        for (o3 = n2[c3], i4 = 0; i4 < o3.length; i4 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i4].length; a3 += 1)
            if (void 0 !== o3[i4][a3] && o3[i4][a3] !== t2[a3]) {
              s3 = false;
              break;
            }
          if (true === s3) {
            u2 = c3;
            break;
          }
        }
    else
      for (c3 in n2)
        for (o3 = n2[c3], i4 = 0; i4 < o3.length; i4 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i4].length; a3 += 1)
            if (void 0 !== o3[i4][a3] && o3[i4][a3] !== t2.charCodeAt(a3)) {
              s3 = false;
              break;
            }
          if (true === s3) {
            u2 = c3;
            break;
          }
        }
    return u2 === r && e2 !== r && (u2 = e2), u2;
  }, a2 = function t2(e2) {
    for (var r2 = this.internal.write, n3 = this.internal.putStream, i4 = (0, this.internal.getFilters)(); -1 !== i4.indexOf("FlateEncode"); )
      i4.splice(i4.indexOf("FlateEncode"), 1);
    e2.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e2.width }), a3.push({ key: "Height", value: e2.height }), e2.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e2.palette.length / 3 - 1) + " " + ("sMask" in e2 && void 0 !== e2.sMask ? e2.objectId + 2 : e2.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e2.colorSpace }), e2.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e2.bitsPerComponent }), "decodeParameters" in e2 && void 0 !== e2.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e2.decodeParameters + ">>" }), "transparency" in e2 && Array.isArray(e2.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e2.transparency.length; s3 < c3; s3++)
        o3 += e2.transparency[s3] + " " + e2.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    void 0 !== e2.sMask && a3.push({ key: "SMask", value: e2.objectId + 1 + " 0 R" });
    var u2 = void 0 !== e2.filter ? ["/" + e2.filter] : void 0;
    if (n3({ data: e2.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e2.objectId }), r2("endobj"), "sMask" in e2 && void 0 !== e2.sMask) {
      var h3 = "/Predictor " + e2.predictor + " /Colors 1 /BitsPerComponent " + e2.bitsPerComponent + " /Columns " + e2.width, l3 = { width: e2.width, height: e2.height, colorSpace: "DeviceGray", bitsPerComponent: e2.bitsPerComponent, decodeParameters: h3, data: e2.sMask };
      "filter" in e2 && (l3.filter = e2.filter), t2.call(this, l3);
    }
    if (e2.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e2.palette)), objectId: f3 }), r2("endobj");
    }
  }, o2 = function() {
    var t2 = this.internal.collections.addImage_images;
    for (var e2 in t2)
      a2.call(this, t2[e2]);
  }, s2 = function() {
    var t2, e2 = this.internal.collections.addImage_images, r2 = this.internal.write;
    for (var n3 in e2)
      r2("/I" + (t2 = e2[n3]).index, t2.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, h2 = function() {
    var t2 = this.internal.collections.addImage_images;
    return c2.call(this), t2;
  }, l2 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f2 = function(t2) {
    return "function" == typeof e["process" + t2.toUpperCase()];
  }, d2 = function(e2) {
    return "object" === _typeof(e2) && 1 === e2.nodeType;
  }, p2 = function(t2, r2) {
    if ("IMG" === t2.nodeName && t2.hasAttribute("src")) {
      var n3 = "" + t2.getAttribute("src");
      if (0 === n3.indexOf("data:image/"))
        return u(unescape(n3).split("base64,").pop());
      var i4 = e.loadFile(n3, true);
      if (void 0 !== i4)
        return i4;
    }
    if ("CANVAS" === t2.nodeName) {
      if (0 === t2.width || 0 === t2.height)
        throw new Error("Given canvas must have data. Canvas width: " + t2.width + ", height: " + t2.height);
      var a3;
      switch (r2) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u(t2.toDataURL(a3, 1).split("base64,").pop());
    }
  }, g2 = function(t2) {
    var e2 = this.internal.collections.addImage_images;
    if (e2) {
      for (var r2 in e2)
        if (t2 === e2[r2].alias)
          return e2[r2];
    }
  }, m2 = function(t2, e2, r2) {
    return t2 || e2 || (t2 = -96, e2 = -96), t2 < 0 && (t2 = -1 * r2.width * 72 / t2 / this.internal.scaleFactor), e2 < 0 && (e2 = -1 * r2.height * 72 / e2 / this.internal.scaleFactor), 0 === t2 && (t2 = e2 * r2.width / r2.height), 0 === e2 && (e2 = t2 * r2.height / r2.width), [t2, e2];
  }, v2 = function(t2, e2, r2, n3, i4, a3) {
    var o3 = m2.call(this, r2, n3, i4), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
    if (r2 = o3[0], n3 = o3[1], u2[i4.index] = i4, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t3) {
        return t3.toFixed(4);
      }, p3 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t2), c3(e2 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r2), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r2), "0", "0", s3(n3), s3(t2), c3(e2 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i4.index + " Do"), this.internal.write("Q");
  }, b2 = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e.__addimage__.sHashCode = function(t2) {
    var e2, r2, n3 = 0;
    if ("string" == typeof t2)
      for (r2 = t2.length, e2 = 0; e2 < r2; e2++)
        n3 = (n3 << 5) - n3 + t2.charCodeAt(e2), n3 |= 0;
    else if (x2(t2))
      for (r2 = t2.byteLength / 2, e2 = 0; e2 < r2; e2++)
        n3 = (n3 << 5) - n3 + t2[e2], n3 |= 0;
    return n3;
  }, N2 = e.__addimage__.validateStringAsBase64 = function(t2) {
    (t2 = t2 || "").toString().trim();
    var e2 = true;
    return 0 === t2.length && (e2 = false), t2.length % 4 != 0 && (e2 = false), false === /^[A-Za-z0-9+/]+$/.test(t2.substr(0, t2.length - 2)) && (e2 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t2.substr(-2)) && (e2 = false), e2;
  }, L2 = e.__addimage__.extractImageFromDataUrl = function(t2) {
    var e2 = (t2 = t2 || "").split("base64,"), r2 = null;
    if (2 === e2.length) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e2[0]);
      Array.isArray(n3) && (r2 = { mimeType: n3[1], charset: n3[2], data: e2[1] });
    }
    return r2;
  }, A2 = e.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e.__addimage__.isArrayBuffer = function(t2) {
    return A2() && t2 instanceof ArrayBuffer;
  };
  var x2 = e.__addimage__.isArrayBufferView = function(t2) {
    return A2() && "undefined" != typeof Uint32Array && (t2 instanceof Int8Array || t2 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t2 instanceof Uint8ClampedArray || t2 instanceof Int16Array || t2 instanceof Uint16Array || t2 instanceof Int32Array || t2 instanceof Uint32Array || t2 instanceof Float32Array || t2 instanceof Float64Array);
  }, S2 = e.__addimage__.binaryStringToUint8Array = function(t2) {
    for (var e2 = t2.length, r2 = new Uint8Array(e2), n3 = 0; n3 < e2; n3++)
      r2[n3] = t2.charCodeAt(n3);
    return r2;
  }, _2 = e.__addimage__.arrayBufferToBinaryString = function(t2) {
    for (var e2 = "", r2 = x2(t2) ? t2 : new Uint8Array(t2), n3 = 0; n3 < r2.length; n3 += 8192)
      e2 += String.fromCharCode.apply(null, r2.subarray(n3, n3 + 8192));
    return e2;
  };
  e.addImage = function() {
    var e2, n3, i4, a3, o3, s3, u2, h3, l3;
    if ("number" == typeof arguments[1] ? (n3 = r, i4 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i4 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), "object" === _typeof(e2 = arguments[0]) && !d2(e2) && "imageData" in e2) {
      var f3 = e2;
      e2 = f3.imageData, n3 = f3.format || n3 || r, i4 = f3.x || i4 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
    }
    var p3 = this.internal.getFilters();
    if (void 0 === h3 && -1 !== p3.indexOf("FlateEncode") && (h3 = "SLOW"), isNaN(i4) || isNaN(a3))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e2, n3, u2, h3);
    return v2.call(this, i4, a3, o3, s3, g3, l3), this;
  };
  var P2 = function(t2, n3, a3, o3) {
    var s3, c3, u2;
    if ("string" == typeof t2 && i3(t2) === r) {
      t2 = unescape(t2);
      var h3 = k2(t2, false);
      ("" !== h3 || void 0 !== (h3 = e.loadFile(t2, true))) && (t2 = h3);
    }
    if (d2(t2) && (t2 = p2(t2, n3)), n3 = i3(t2, n3), !f2(n3))
      throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if ((null == (u2 = a3) || 0 === u2.length) && (a3 = function(t3) {
      return "string" == typeof t3 || x2(t3) ? w2(t3) : x2(t3.data) ? w2(t3.data) : null;
    }(t2)), (s3 = g2.call(this, a3)) || (A2() && (t2 instanceof Uint8Array || "RGBA" === n3 || (c3 = t2, t2 = S2(t2))), s3 = this["process" + n3.toUpperCase()](t2, l2.call(this), a3, function(t3) {
      return t3 && "string" == typeof t3 && (t3 = t3.toUpperCase()), t3 in e.image_compression ? t3 : y2.NONE;
    }(o3), c3)), !s3)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e.__addimage__.convertBase64ToBinaryString = function(t2, e2) {
    var r2;
    e2 = "boolean" != typeof e2 || e2;
    var n3, i4 = "";
    if ("string" == typeof t2) {
      n3 = null !== (r2 = L2(t2)) ? r2.data : t2;
      try {
        i4 = u(n3);
      } catch (t3) {
        if (e2)
          throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i4;
  };
  e.getImageProperties = function(t2) {
    var n3, a3, o3 = "";
    if (d2(t2) && (t2 = p2(t2)), "string" == typeof t2 && i3(t2) === r && ("" === (o3 = k2(t2, false)) && (o3 = e.loadFile(t2) || ""), t2 = o3), a3 = i3(t2), !f2(a3))
      throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t2 instanceof Uint8Array || (t2 = S2(t2)), !(n3 = this["process" + a3.toUpperCase()](t2)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function(t3) {
    if (void 0 !== t3 && "" != t3)
      return true;
  };
  E.API.events.push(["addPage", function(t3) {
    this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
  }]), t2.events.push(["putPage", function(t3) {
    for (var r, n2, i3, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), c2 = t3.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++)
      switch ((r = c2[h2]).type) {
        case "link":
          (e(r.options.url) || e(r.options.pageNumber)) && (u2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u2 = true;
      }
    if (0 != u2) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t3.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r.title || "Note";
            i3 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y) + "] ") + "/Contents (" + f2(m2(r.contents)) + ")", i3 += " /Popup " + g2.objId + " 0 R", i3 += " /P " + s2.objId + " 0 R", i3 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i3;
            var b2 = p2.objId + " 0 R";
            i3 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r.bounds.x + 30) + " " + o2(r.bounds.y + r.bounds.h) + " " + a2(r.bounds.x + r.bounds.w + 30) + " " + o2(r.bounds.y) + "] ") + " /Parent " + b2, r.open && (i3 += " /Open true"), i3 += " >>", g2.content = i3, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r.bounds.x) + " " + o2(r.bounds.y) + " " + a2(r.bounds.x + r.bounds.w) + " " + o2(r.bounds.y + r.bounds.h) + "] ";
            var y2 = r.color || "#000000";
            i3 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r.contents)) + ")", i3 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i3 += " /Border [0 0 0]", i3 += " >>", this.internal.write(i3);
            break;
          case "link":
            if (r.options.name) {
              var w2 = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = w2.page, r.options.top = w2.y;
            } else
              r.options.top || (r.options.top = 0);
            if (n2 = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", i3 = "", r.options.url)
              i3 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r.options.url)) + ") >>";
            else if (r.options.pageNumber) {
              switch (i3 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
                case "Fit":
                  i3 += " /Fit]";
                  break;
                case "FitH":
                  i3 += " /FitH " + r.options.top + "]";
                  break;
                case "FitV":
                  r.options.left = r.options.left || 0, i3 += " /FitV " + r.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r.options.top);
                  r.options.left = r.options.left || 0, void 0 === r.options.zoom && (r.options.zoom = 0), i3 += " /XYZ " + r.options.left + " " + N2 + " " + r.options.zoom + "]";
              }
            }
            "" != i3 && (i3 += " >>", this.internal.write(i3));
        }
      }
      this.internal.write("]");
    }
  }]), t2.createAnnotation = function(t3) {
    var e2 = this.internal.getCurrentPageInfo();
    switch (t3.type) {
      case "link":
        this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
        break;
      case "text":
      case "freetext":
        e2.pageContext.annotations.push(t3);
    }
  }, t2.link = function(t3, e2, r, n2, i3) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e2), w: o2(t3 + r), h: s2(e2 + n2) }, options: i3, type: "link" });
  }, t2.textWithLink = function(t3, e2, r, n2) {
    var i3, a2, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n2.maxWidth) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t3, a2).length;
      i3 = Math.ceil(s2 * c2);
    } else
      a2 = o2, i3 = s2;
    return this.text(t3, e2, r, n2), r += 0.2 * s2, "center" === n2.align && (e2 -= o2 / 2), "right" === n2.align && (e2 -= o2), this.link(e2, r - s2, a2, i3, n2), o2;
  }, t2.getTextWidth = function(t3) {
    var e2 = this.internal.getFontSize();
    return this.getStringUnitWidth(t3) * e2 / this.internal.scaleFactor;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i3 = [1570, 1571, 1573, 1575];
  t2.__arabicParser__ = {};
  var a2 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
    return void 0 !== e[t3.charCodeAt(0)];
  }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
    return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
  }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length <= 2;
  }, c2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
    return o2(t3) && i3.indexOf(t3.charCodeAt(0)) >= 0;
  };
  t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 1;
  };
  var u2 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 2;
  };
  t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
    return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 3;
  };
  var h2 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
    return o2(t3) && a2(t3) && 4 == e[t3.charCodeAt(0)].length;
  }, l2 = t2.__arabicParser__.resolveLigatures = function(t3) {
    var e2 = 0, n3 = r, i4 = "", a3 = 0;
    for (e2 = 0; e2 < t3.length; e2 += 1)
      void 0 !== n3[t3.charCodeAt(e2)] ? (a3++, "number" == typeof (n3 = n3[t3.charCodeAt(e2)]) && (i4 += String.fromCharCode(n3), n3 = r, a3 = 0), e2 === t3.length - 1 && (n3 = r, i4 += t3.charAt(e2 - (a3 - 1)), e2 -= a3 - 1, a3 = 0)) : (n3 = r, i4 += t3.charAt(e2 - a3), e2 -= a3, a3 = 0);
    return i4;
  };
  t2.__arabicParser__.isArabicDiacritic = function(t3) {
    return void 0 !== t3 && void 0 !== n2[t3.charCodeAt(0)];
  };
  var f2 = t2.__arabicParser__.getCorrectForm = function(t3, e2, r2) {
    return o2(t3) ? false === a2(t3) ? -1 : !u2(t3) || !o2(e2) && !o2(r2) || !o2(r2) && s2(e2) || s2(t3) && !o2(e2) || s2(t3) && c2(e2) || s2(t3) && s2(e2) ? 0 : h2(t3) && o2(e2) && !s2(e2) && o2(r2) && u2(r2) ? 3 : s2(t3) || !o2(r2) ? 1 : 2 : -1;
  }, d2 = function(t3) {
    var r2 = 0, n3 = 0, i4 = 0, a3 = "", s3 = "", c3 = "", u3 = (t3 = t3 || "").split("\\s+"), h3 = [];
    for (r2 = 0; r2 < u3.length; r2 += 1) {
      for (h3.push(""), n3 = 0; n3 < u3[r2].length; n3 += 1)
        a3 = u3[r2][n3], s3 = u3[r2][n3 - 1], c3 = u3[r2][n3 + 1], o2(a3) ? (i4 = f2(a3, s3, c3), h3[r2] += -1 !== i4 ? String.fromCharCode(e[a3.charCodeAt(0)][i4]) : a3) : h3[r2] += a3;
      h3[r2] = l2(h3[r2]);
    }
    return h3.join(" ");
  }, p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
    var t3, e2 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r2 = [];
    if (Array.isArray(e2)) {
      var n3 = 0;
      for (r2 = [], n3 = 0; n3 < e2.length; n3 += 1)
        Array.isArray(e2[n3]) ? r2.push([d2(e2[n3][0]), e2[n3][1], e2[n3][2]]) : r2.push([d2(e2[n3])]);
      t3 = r2;
    } else
      t3 = d2(e2);
    return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
  };
  t2.events.push(["preProcessText", p2]);
}(E.API), E.API.autoPrint = function(t2) {
  var e;
  switch ((t2 = t2 || {}).variant = t2.variant || "non-conform", t2.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function() {
    var t3 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t3;
    }, set: function(e3) {
      t3 = e3;
    } });
    var e2 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e2;
    }, set: function(t4) {
      e2 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e2 + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(t4) {
      r = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t4) {
      n2 = t4;
    } });
    var i3 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t3, e2) {
    var r;
    if ("2d" !== (t3 = t3 || "2d"))
      return null;
    for (r in e2)
      this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = e2[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t2.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(E.API), function(e) {
  var r = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i3 = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t2 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t2;
    }, set: function(e3) {
      t2 = e3;
    } });
    var e2 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e2;
    }, set: function(t3) {
      e2 = t3;
    } });
    var r2 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      r2 = t3;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t3) {
      n3 = t3;
    } });
    var i4 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i4;
    }, set: function(t3) {
      i4 = t3;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t3) {
      a3 = t3;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e.setHeaderFunction = function(t2) {
    return i3.call(this), this.internal.__cell__.headerFunction = "function" == typeof t2 ? t2 : void 0, this;
  }, e.getTextDimensions = function(t2, e2) {
    i3.call(this);
    var r2 = (e2 = e2 || {}).fontSize || this.getFontSize(), n3 = e2.font || this.getFont(), a3 = e2.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t2) && "string" != typeof t2) {
      if ("number" != typeof t2)
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t2 = String(t2);
    }
    var h2 = e2.maxWidth;
    h2 > 0 ? "string" == typeof t2 ? t2 = this.splitTextToSize(t2, h2) : "[object Array]" === Object.prototype.toString.call(t2) && (t2 = t2.reduce(function(t3, e3) {
      return t3.concat(u2.splitTextToSize(e3, h2));
    }, [])) : t2 = Array.isArray(t2) ? t2 : [t2];
    for (var l2 = 0; l2 < t2.length; l2++)
      o3 < (c3 = this.getStringUnitWidth(t2[l2], { font: n3 }) * r2) && (o3 = c3);
    return 0 !== o3 && (s3 = t2.length), { w: o3 /= a3, h: Math.max((s3 * r2 * this.getLineHeightFactor() - r2 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e.cellAddPage = function() {
    i3.call(this), this.addPage();
    var t2 = this.internal.__cell__.margins || r;
    return this.internal.__cell__.lastCell = new o2(t2.left, t2.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e.cell = function() {
    var t2;
    t2 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i3.call(this);
    var e2 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return void 0 !== e2.lineNumber && (e2.lineNumber === t2.lineNumber ? (t2.x = (e2.x || 0) + (e2.width || 0), t2.y = e2.y || 0) : e2.y + e2.height + t2.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t2.y = s3.top, u2 && c3 && (this.printHeaderRow(t2.lineNumber, true), t2.y += c3[0].height)) : t2.y = e2.y + e2.height || t2.y), void 0 !== t2.text[0] && (this.rect(t2.x, t2.y, t2.width, t2.height, true === n2 ? "FD" : void 0), "right" === t2.align ? this.text(t2.text, t2.x + t2.width - a3, t2.y + a3, { align: "right", baseline: "top" }) : "center" === t2.align ? this.text(t2.text, t2.x + t2.width / 2, t2.y + a3, { align: "center", baseline: "top", maxWidth: t2.width - a3 - a3 }) : this.text(t2.text, t2.x + a3, t2.y + a3, { align: "left", baseline: "top", maxWidth: t2.width - a3 - a3 })), this.internal.__cell__.lastCell = t2, this;
  };
  e.table = function(e2, n3, u2, h2, l2) {
    if (i3.call(this), !u2)
      throw new Error("No data for PDF table.");
    var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, S2 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r), P2 = "number" == typeof l2.padding ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h2)
      v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
        return "left";
      });
    else if (Array.isArray(h2) && "object" === _typeof(h2[0]))
      for (m2 = h2.map(function(t2) {
        return t2.name;
      }), v2 = h2.map(function(t2) {
        return t2.prompt || t2.name || "";
      }), b2 = h2.map(function(t2) {
        return t2.align || "left";
      }), f2 = 0; f2 < h2.length; f2 += 1)
        w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
    else
      Array.isArray(h2) && "string" == typeof h2[0] && (v2 = m2 = h2, b2 = m2.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h2) && "string" == typeof h2[0])
      for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = u2.map(function(t2) {
          return t2[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1)
          N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1)
        F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t2) {
        return new o2(e2, n3, w2[t2], C2, F2[t2].text, void 0, F2[t2].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h2.reduce(function(t2, e3) {
      return t2[e3.name] = e3.align, t2;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p2 = 0; p2 < m2.length; p2 += 1) {
        var B2 = u2[f2][m2[p2]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p2, data: B2 }, this), s2.call(this, new o2(e2, n3, w2[m2[p2]], O2, B2, f2 + 2, j2[m2[p2]]));
      }
    }
    return this.internal.__cell__.table_x = e2, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = function(t2, e2) {
    var r2 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i4 = this.internal.scaleFactor;
    return Object.keys(t2).map(function(n4) {
      var i5 = t2[n4];
      return this.splitTextToSize(i5.hasOwnProperty("text") ? i5.text : i5, e2[n4] - r2 - r2);
    }, this).map(function(t3) {
      return this.getLineHeightFactor() * t3.length * n3 / i4 + r2 + r2;
    }, this).reduce(function(t3, e3) {
      return Math.max(t3, e3);
    }, 0);
  };
  e.setTableHeaderRow = function(t2) {
    i3.call(this), this.internal.__cell__.tableHeaderRow = t2;
  }, e.printHeaderRow = function(t2, e2) {
    if (i3.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r2;
    if (n2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r2 = this.internal.__cell__.tableHeaderRow[u2].clone(), e2 && (r2.y = this.internal.__cell__.margins.top || 0, c3.push(r2)), r2.lineNumber = t2;
      var h2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r2), this.setTextColor(h2);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
var kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
var It = _t(kt);
var Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900];
var Ct = _t(Ft);
function jt(t2) {
  var e = t2.family.replace(/"|'/g, "").toLowerCase(), r = function(t3) {
    return Pt[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.style), n2 = function(t3) {
    if (!t3)
      return 400;
    if ("number" == typeof t3)
      return t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400;
    if (/^\d00$/.test(t3))
      return parseInt(t3);
    switch (t3) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t2.weight), i3 = function(t3) {
    return "number" == typeof It[t3 = t3 || "normal"] ? t3 : "normal";
  }(t2.stretch);
  return { family: e, style: r, weight: n2, stretch: i3, src: t2.src || [], ref: t2.ref || { name: e, style: [i3, r, n2].join(" ") } };
}
function Ot(t2, e, r, n2) {
  var i3;
  for (i3 = r; i3 >= 0 && i3 < e.length; i3 += n2)
    if (t2[e[i3]])
      return t2[e[i3]];
  for (i3 = r; i3 >= 0 && i3 < e.length; i3 -= n2)
    if (t2[e[i3]])
      return t2[e[i3]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
var Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t2) {
  return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
}
function qt(t2, e, r) {
  for (var n2 = (r = r || {}).defaultFontFamily || "times", i3 = Object.assign({}, Bt, r.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e.length; ++s2)
    if (i3[(a2 = jt(e[s2])).family] && (a2.family = i3[a2.family]), t2.hasOwnProperty(a2.family)) {
      o2 = t2[a2.family];
      break;
    }
  if (!(o2 = o2 || t2[n2]))
    throw new Error("Could not find a font-family for the rule '" + Et(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t3, e2) {
    if (e2[t3])
      return e2[t3];
    var r2 = It[t3], n3 = r2 <= It.normal ? -1 : 1, i4 = Ot(e2, kt, r2, n3);
    if (!i4)
      throw new Error("Could not find a matching font-stretch value for " + t3);
    return i4;
  }(a2.stretch, o2), o2 = function(t3, e2) {
    if (e2[t3])
      return e2[t3];
    for (var r2 = Pt[t3], n3 = 0; n3 < r2.length; ++n3)
      if (e2[r2[n3]])
        return e2[r2[n3]];
    throw new Error("Could not find a matching font-style for " + t3);
  }(a2.style, o2), !(o2 = function(t3, e2) {
    if (e2[t3])
      return e2[t3];
    if (400 === t3 && e2[500])
      return e2[500];
    if (500 === t3 && e2[400])
      return e2[400];
    var r2 = Ct[t3], n3 = Ot(e2, Ft, r2, t3 < 400 ? -1 : 1);
    if (!n3)
      throw new Error("Could not find a matching font-weight for value " + t3);
    return n3;
  }(a2.weight, o2)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a2) + "'.");
  return o2;
}
function Dt(t2) {
  return t2.trimLeft();
}
function Rt(t2, e) {
  for (var r = 0; r < t2.length; ) {
    if (t2.charAt(r) === e)
      return [t2.substring(0, r), t2.substring(r + 1)];
    r += 1;
  }
  return null;
}
function Tt(t2) {
  var e = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e ? null : [e[0], t2.substring(e[0].length)];
}
var Ut;
var zt;
var Ht;
var Wt = ["times"];
!function(e) {
  var r, n2, i3, o2, s2, c2, u2, h2, l2, d2 = function(t2) {
    return t2 = t2 || {}, this.isStrokeTransparent = t2.isStrokeTransparent || false, this.strokeOpacity = t2.strokeOpacity || 1, this.strokeStyle = t2.strokeStyle || "#000000", this.fillStyle = t2.fillStyle || "#000000", this.isFillTransparent = t2.isFillTransparent || false, this.fillOpacity = t2.fillOpacity || 1, this.font = t2.font || "10px sans-serif", this.textBaseline = t2.textBaseline || "alphabetic", this.textAlign = t2.textAlign || "left", this.lineWidth = t2.lineWidth || 1, this.lineJoin = t2.lineJoin || "miter", this.lineCap = t2.lineCap || "butt", this.path = t2.path || [], this.transform = void 0 !== t2.transform ? t2.transform.clone() : new h2(), this.globalCompositeOperation = t2.globalCompositeOperation || "normal", this.globalAlpha = t2.globalAlpha || 1, this.clip_path = t2.clip_path || [], this.currentPoint = t2.currentPoint || new c2(), this.miterLimit = t2.miterLimit || 10, this.lastPoint = t2.lastPoint || new c2(), this.lineDashOffset = t2.lineDashOffset || 0, this.lineDash = t2.lineDash || [], this.margin = t2.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t2.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t2.ignoreClearRect || t2.ignoreClearRect, this;
  };
  e.events.push(["initialized", function() {
    this.context2d = new p2(this), r = this.internal.f2, n2 = this.internal.getCoordinateString, i3 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
  }]);
  var p2 = function(t2) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e2 = t2;
    Object.defineProperty(this, "pdf", { get: function() {
      return e2;
    } });
    var r2 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r2;
    }, set: function(t3) {
      r2 = Boolean(t3);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t3) {
      n3 = Boolean(t3);
    } });
    var i4 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i4;
    }, set: function(t3) {
      isNaN(t3) || (i4 = t3);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t3) {
      isNaN(t3) || (a2 = t3);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t3) {
      var e3;
      "number" == typeof t3 ? e3 = [t3, t3, t3, t3] : ((e3 = new Array(4))[0] = t3[0], e3[1] = t3.length >= 2 ? t3[1] : e3[0], e3[2] = t3.length >= 3 ? t3[2] : e3[0], e3[3] = t3.length >= 4 ? t3[3] : e3[1]), l2.margin = e3;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t3) {
      o3 = t3;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t3) {
      s3 = t3;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t3) {
      c3 = t3;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t3) {
      t3 instanceof d2 && (l2 = t3);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t3) {
      l2.path = t3;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t3) {
      u3 = t3;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t3) {
      var e3;
      e3 = g2(t3), this.ctx.fillStyle = e3.style, this.ctx.isFillTransparent = 0 === e3.a, this.ctx.fillOpacity = e3.a, this.pdf.setFillColor(e3.r, e3.g, e3.b, { a: e3.a }), this.pdf.setTextColor(e3.r, e3.g, e3.b, { a: e3.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t3) {
      var e3 = g2(t3);
      this.ctx.strokeStyle = e3.style, this.ctx.isStrokeTransparent = 0 === e3.a, this.ctx.strokeOpacity = e3.a, 0 === e3.a ? this.pdf.setDrawColor(255, 255, 255) : (e3.a, this.pdf.setDrawColor(e3.r, e3.g, e3.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t3) {
      -1 !== ["butt", "round", "square"].indexOf(t3) && (this.ctx.lineCap = t3, this.pdf.setLineCap(t3));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.lineWidth = t3, this.pdf.setLineWidth(t3));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t3) {
      -1 !== ["bevel", "round", "miter"].indexOf(t3) && (this.ctx.lineJoin = t3, this.pdf.setLineJoin(t3));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t3) {
      isNaN(t3) || (this.ctx.miterLimit = t3, this.pdf.setMiterLimit(t3));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t3) {
      this.ctx.textBaseline = t3;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t3) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t3) && (this.ctx.textAlign = t3);
    } });
    var h3 = null;
    function f2(t3, e3) {
      if (null === h3) {
        var r3 = function(t4) {
          var e4 = [];
          return Object.keys(t4).forEach(function(r4) {
            t4[r4].forEach(function(t5) {
              var n4 = null;
              switch (t5) {
                case "bold":
                  n4 = { family: r4, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r4, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r4, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r4 };
              }
              null !== n4 && (n4.ref = { name: r4, style: t5 }, e4.push(n4));
            });
          }), e4;
        }(t3.getFontList());
        h3 = function(t4) {
          for (var e4 = {}, r4 = 0; r4 < t4.length; ++r4) {
            var n4 = jt(t4[r4]), i5 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e4[i5] = e4[i5] || {}, e4[i5][a3] = e4[i5][a3] || {}, e4[i5][a3][o4] = e4[i5][a3][o4] || {}, e4[i5][a3][o4][s4] = n4;
          }
          return e4;
        }(r3.concat(e3));
      }
      return h3;
    }
    var p3 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p3;
    }, set: function(t3) {
      h3 = null, p3 = t3;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t3) {
      var e3;
      if (this.ctx.font = t3, null !== (e3 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t3))) {
        var r3 = e3[1], n4 = (e3[2], e3[3]), i5 = e3[4], a3 = (e3[5], e3[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i5)[2];
        i5 = "px" === o4 ? Math.floor(parseFloat(i5) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i5) * this.pdf.getFontSize()) : Math.floor(parseFloat(i5) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i5);
        var s4 = function(t4) {
          var e4, r4, n5 = [], i6 = t4.trim();
          if ("" === i6)
            return Wt;
          if (i6 in Mt)
            return [Mt[i6]];
          for (; "" !== i6; ) {
            switch (r4 = null, e4 = (i6 = Dt(i6)).charAt(0)) {
              case '"':
              case "'":
                r4 = Rt(i6.substring(1), e4);
                break;
              default:
                r4 = Tt(i6);
            }
            if (null === r4)
              return Wt;
            if (n5.push(r4[0]), "" !== (i6 = Dt(r4[1])) && "," !== i6.charAt(0))
              return Wt;
            i6 = i6.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t4) {
            return { family: t4, stretch: "normal", weight: n4, style: r3 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          ("bold" === n4 || parseInt(n4, 10) >= 700 || "bold" === r3) && (u4 = "bold"), "italic" === r3 && (u4 += "italic"), 0 === u4.length && (u4 = "normal");
          for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
            if (void 0 !== this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true })) {
              h4 = s4[d3];
              break;
            }
            if ("bolditalic" === u4 && void 0 !== this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true }))
              h4 = s4[d3], u4 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true })) {
              h4 = s4[d3], u4 = "normal";
              break;
            }
          }
          if ("" === h4) {
            for (var p4 = 0; p4 < s4.length; p4++)
              if (l3[s4[p4]]) {
                h4 = l3[s4[p4]];
                break;
              }
          }
          h4 = "" === h4 ? "Times" : h4, this.pdf.setFont(h4, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t3) {
      this.ctx.globalCompositeOperation = t3;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t3) {
      this.ctx.globalAlpha = t3;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t3) {
      this.ctx.lineDashOffset = t3, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t3) {
      this.ctx.lineDash = t3, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t3) {
      this.ctx.ignoreClearRect = Boolean(t3);
    } });
  };
  p2.prototype.setLineDash = function(t2) {
    this.lineDash = t2;
  }, p2.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p2.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p2.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p2.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p2.prototype.moveTo = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e2));
    this.path.push({ type: "mt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(t2, e2);
  }, p2.prototype.closePath = function() {
    var e2 = new c2(0, 0), r2 = 0;
    for (r2 = this.path.length - 1; -1 !== r2; r2--)
      if ("begin" === this.path[r2].type && "object" === _typeof(this.path[r2 + 1]) && "number" == typeof this.path[r2 + 1].x) {
        e2 = new c2(this.path[r2 + 1].x, this.path[r2 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e2.x, e2.y);
  }, p2.prototype.lineTo = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r2 = this.ctx.transform.applyToPoint(new c2(t2, e2));
    this.path.push({ type: "lt", x: r2.x, y: r2.y }), this.ctx.lastPoint = new c2(r2.x, r2.y);
  }, p2.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p2.prototype.quadraticCurveTo = function(t2, e2, r2, n3) {
    if (isNaN(r2) || isNaN(n3) || isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i4 = this.ctx.transform.applyToPoint(new c2(r2, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t2, e2));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i4.x, y: i4.y }), this.ctx.lastPoint = new c2(i4.x, i4.y);
  }, p2.prototype.bezierCurveTo = function(t2, e2, r2, n3, i4, o3) {
    if (isNaN(i4) || isNaN(o3) || isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i4, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t2, e2)), h3 = this.ctx.transform.applyToPoint(new c2(r2, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p2.prototype.arc = function(t2, e2, r2, n3, i4, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3) || isNaN(i4))
      throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t2, e2));
      t2 = s3.x, e2 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r2)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r2 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
    }
    Math.abs(i4 - n3) >= 2 * Math.PI && (n3 = 0, i4 = 2 * Math.PI), this.path.push({ type: "arc", x: t2, y: e2, radius: r2, startAngle: n3, endAngle: i4, counterclockwise: o3 });
  }, p2.prototype.arcTo = function(t2, e2, r2, n3, i4) {
    throw new Error("arcTo not implemented.");
  }, p2.prototype.rect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t2, e2), this.lineTo(t2 + r2, e2), this.lineTo(t2 + r2, e2 + n3), this.lineTo(t2, e2 + n3), this.lineTo(t2, e2), this.lineTo(t2 + r2, e2), this.lineTo(t2, e2);
  }, p2.prototype.fillRect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i4 = {};
      "butt" !== this.lineCap && (i4.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i4.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t2, e2, r2, n3), this.fill(), i4.hasOwnProperty("lineCap") && (this.lineCap = i4.lineCap), i4.hasOwnProperty("lineJoin") && (this.lineJoin = i4.lineJoin);
    }
  }, p2.prototype.strokeRect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t2, e2, r2, n3), this.stroke());
  }, p2.prototype.clearRect = function(t2, e2, r2, n3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3))
      throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t2, e2, r2, n3));
  }, p2.prototype.save = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++)
      this.pdf.setPage(r2 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e2), t2) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p2.prototype.restore = function(t2) {
    t2 = "boolean" != typeof t2 || t2;
    for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, r2 = 0; r2 < this.pdf.internal.getNumberOfPages(); r2++)
      this.pdf.setPage(r2 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e2), t2 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p2.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t2) {
    var e2, r2, n3, i4;
    if (true === t2.isCanvasGradient && (t2 = t2.getColor()), !t2)
      return { r: 0, g: 0, b: 0, a: 0, style: t2 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t2))
      e2 = 0, r2 = 0, n3 = 0, i4 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t2);
      if (null !== a2)
        e2 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i4 = 1;
      else if (null !== (a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t2)))
        e2 = parseInt(a2[1]), r2 = parseInt(a2[2]), n3 = parseInt(a2[3]), i4 = parseFloat(a2[4]);
      else {
        if (i4 = 1, "string" == typeof t2 && "#" !== t2.charAt(0)) {
          var o3 = new f(t2);
          t2 = o3.ok ? o3.toHex() : "#000000";
        }
        4 === t2.length ? (e2 = t2.substring(1, 2), e2 += e2, r2 = t2.substring(2, 3), r2 += r2, n3 = t2.substring(3, 4), n3 += n3) : (e2 = t2.substring(1, 3), r2 = t2.substring(3, 5), n3 = t2.substring(5, 7)), e2 = parseInt(e2, 16), r2 = parseInt(r2, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e2, g: r2, b: n3, a: i4, style: t2 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p2.prototype.fillText = function(t2, e2, r2, n3) {
    if (isNaN(e2) || isNaN(r2) || "string" != typeof t2)
      throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i4 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e2, y: r2, scale: o3, angle: i4, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.strokeText = function(t2, e2, r2, n3) {
    if (isNaN(e2) || isNaN(r2) || "string" != typeof t2)
      throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i4 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t2, x: e2, y: r2, scale: o3, renderingMode: "stroke", angle: i4, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.measureText = function(t2) {
    if ("string" != typeof t2)
      throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e2 = this.pdf, r2 = this.pdf.internal.scaleFactor, n3 = e2.internal.getFontSize(), i4 = e2.getStringUnitWidth(t2) * n3 / e2.internal.scaleFactor, o3 = function(t3) {
      var e3 = (t3 = t3 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e3;
      } }), this;
    };
    return new o3({ width: i4 *= Math.round(96 * r2 / 72 * 1e4) / 1e4 });
  }, p2.prototype.scale = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r2 = new h2(t2, 0, 0, e2, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.rotate = function(t2) {
    if (isNaN(t2))
      throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e2 = new h2(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e2);
  }, p2.prototype.translate = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2))
      throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r2 = new h2(1, 0, 0, 1, t2, e2);
    this.ctx.transform = this.ctx.transform.multiply(r2);
  }, p2.prototype.transform = function(t2, e2, r2, n3, i4, o3) {
    if (isNaN(t2) || isNaN(e2) || isNaN(r2) || isNaN(n3) || isNaN(i4) || isNaN(o3))
      throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h2(t2, e2, r2, n3, i4, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p2.prototype.setTransform = function(t2, e2, r2, n3, i4, a2) {
    t2 = isNaN(t2) ? 1 : t2, e2 = isNaN(e2) ? 0 : e2, r2 = isNaN(r2) ? 0 : r2, n3 = isNaN(n3) ? 1 : n3, i4 = isNaN(i4) ? 0 : i4, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t2, e2, r2, n3, i4, a2);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p2.prototype.drawImage = function(t2, e2, r2, n3, i4, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t2), f2 = 1, d3 = 1, p3 = 1, g3 = 1;
    void 0 !== n3 && void 0 !== s3 && (p3 = s3 / n3, g3 = c3 / i4, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i4 * c3 / i4), void 0 === a2 && (a2 = e2, o3 = r2, e2 = 0, r2 = 0), void 0 !== n3 && void 0 === s3 && (s3 = n3, c3 = i4), void 0 === n3 && void 0 === s3 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e2 * p3, o3 - r2 * g3, n3 * f2, i4 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)
      -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B3 + (C3 - 2) * M3;
        if (0 !== this.ctx.clip_path.length) {
          var D3 = this.path;
          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t2, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t2, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t2, e2, r2) {
    var n3 = [];
    e2 = e2 || this.pdf.internal.pageSize.width, r2 = r2 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i4 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t2.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t2.y + i4) / r2) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t2.y + i4 - t2.radius) / r2) + 1), n3.push(Math.floor((t2.y + i4 + t2.radius) / r2) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x, t2.y);
        n3.push(Math.floor((a2.y + i4) / r2) + 1), n3.push(Math.floor((a2.y + a2.h + i4) / r2) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x2, t2.y2, t2.x, t2.y);
        n3.push(Math.floor((o3.y + i4) / r2) + 1), n3.push(Math.floor((o3.y + o3.h + i4) / r2) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t2.y + i4) / r2) + 1), n3.push(Math.floor((t2.y + t2.h + i4) / r2) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )
        w2.call(this);
    return n3;
  }, w2 = function() {
    var t2 = this.fillStyle, e2 = this.strokeStyle, r2 = this.font, n3 = this.lineCap, i4 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t2, this.strokeStyle = e2, this.font = r2, this.lineCap = n3, this.lineWidth = i4, this.lineJoin = a2;
  }, N2 = function(t2, e2, r2) {
    for (var n3 = 0; n3 < t2.length; n3++)
      switch (t2[n3].type) {
        case "bct":
          t2[n3].x2 += e2, t2[n3].y2 += r2;
        case "qct":
          t2[n3].x1 += e2, t2[n3].y1 += r2;
        case "mt":
        case "lt":
        case "arc":
        default:
          t2[n3].x += e2, t2[n3].y += r2;
      }
    return t2;
  }, L2 = function(t2) {
    return t2.sort(function(t3, e2) {
      return t3 - e2;
    });
  }, A2 = function(t2, e2) {
    for (var r2, n3, i4 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)
      if (void 0 !== l3[d3].x)
        for (var p3 = y2.call(this, l3[d3]), g3 = 0; g3 < p3.length; g3 += 1)
          -1 === f2.indexOf(p3[g3]) && f2.push(p3[g3]);
    for (var m3 = 0; m3 < f2.length; m3++)
      for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )
        w2.call(this);
    if (L2(f2), this.autoPaging)
      for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i4, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
        if (0 !== this.ctx.clip_path.length) {
          var C3 = this.path;
          r2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r2, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t2, true), this.path = C3;
        }
        if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e2 || 0 === S3) {
          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t2, e2), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s3;
      }
    else
      this.lineWidth = c3, x2.call(this, t2, e2), this.lineWidth = s3;
    this.path = h3;
  }, x2 = function(t2, e2) {
    if (("stroke" !== t2 || e2 || !v2.call(this)) && ("stroke" === t2 || e2 || !m2.call(this))) {
      for (var r2, n3, i4 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i4.push({ begin: true });
            break;
          case "close":
            i4.push({ close: true });
            break;
          case "mt":
            i4.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i4.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r2 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--)
                if (true !== i4[c3 - 1].close && true !== i4[c3 - 1].begin) {
                  i4[c3 - 1].deltas.push(r2), i4[c3 - 1].abs.push(s3);
                  break;
                }
            }
            break;
          case "bct":
            r2 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i4[i4.length - 1].deltas.push(r2);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
            r2 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i4[i4.length - 1].deltas.push(r2);
            break;
          case "arc":
            i4.push({ deltas: [], abs: [], arc: true }), Array.isArray(i4[i4.length - 1].abs) && i4[i4.length - 1].abs.push(s3);
        }
      }
      n3 = e2 ? null : "stroke" === t2 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i4.length; b3++)
        if (i4[b3].arc)
          for (var y3 = i4[b3].abs, w3 = 0; w3 < y3.length; w3++) {
            var N3 = y3[w3];
            "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e2, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
          }
        else if (true === i4[b3].close)
          this.pdf.internal.out("h"), g3 = false;
        else if (true !== i4[b3].begin) {
          var L3 = i4[b3].start.x, A3 = i4[b3].start.y;
          O2.call(this, i4[b3].deltas, L3, A3), g3 = true;
        }
      n3 && k2.call(this, n3), e2 && I2.call(this);
    }
  }, S2 = function(t2) {
    var e2 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r2 = e2 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t2 - r2;
      case "top":
        return t2 + e2 - r2;
      case "hanging":
        return t2 + e2 - 2 * r2;
      case "middle":
        return t2 + e2 / 2 - r2;
      case "ideographic":
        return t2;
      case "alphabetic":
      default:
        return t2;
    }
  }, _2 = function(t2) {
    return t2 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p2.prototype.createLinearGradient = function() {
    var t2 = function() {
    };
    return t2.colorStops = [], t2.addColorStop = function(t3, e2) {
      this.colorStops.push([t3, e2]);
    }, t2.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t2.isCanvasGradient = true, t2;
  }, p2.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p2.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t2, e2, r2, n3, i4, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r2, n3, i4, a2), h3 = 0; h3 < u3.length; h3++) {
      var l3 = u3[h3];
      0 === h3 && (c3 ? F2.call(this, l3.x1 + t2, l3.y1 + e2) : j2.call(this, l3.x1 + t2, l3.y1 + e2)), B2.call(this, t2, e2, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, k2 = function(t2) {
    switch (t2) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t2, e2) {
    this.pdf.internal.out(n2(t2) + " " + i3(e2) + " m");
  }, C2 = function(t2) {
    var e2;
    switch (t2.align) {
      case "right":
      case "end":
        e2 = "right";
        break;
      case "center":
        e2 = "center";
        break;
      case "left":
      case "start":
      default:
        e2 = "left";
    }
    var r2 = this.pdf.getTextDimensions(t2.text), n3 = S2.call(this, t2.y), i4 = _2.call(this, n3) - r2.h, a2 = this.ctx.transform.applyToPoint(new c2(t2.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d3, p3 = this.ctx.transform.applyToRectangle(new u2(t2.x, n3, r2.w, r2.h)), g3 = s3.applyToRectangle(new u2(t2.x, i4, r2.w, r2.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)
      -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging)
      for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
        if (0 !== this.ctx.clip_path.length) {
          var E3 = this.path;
          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d3 = this.lineWidth, this.lineWidth = d3 * t2.scale);
        var D3 = "text" !== this.autoPaging;
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O3) {
            var R3 = D3 ? t2.text : this.pdf.splitTextToSize(t2.text, t2.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t2.angle, align: e2, renderingMode: t2.renderingMode }), U2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
      }
    else
      t2.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t2.scale), d3 = this.lineWidth, this.lineWidth = d3 * t2.scale), this.pdf.text(t2.text, a2.x + this.posX, a2.y + this.posY, { angle: t2.angle, align: e2, renderingMode: t2.renderingMode, maxWidth: t2.maxWidth }), t2.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
  }, j2 = function(t2, e2, r2, a2) {
    r2 = r2 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t2 + r2) + " " + i3(e2 + a2) + " l");
  }, O2 = function(t2, e2, r2) {
    return this.pdf.lines(t2, e2, r2, null, null);
  }, B2 = function(t2, e2, n3, i4, a2, c3, u3, h3) {
    this.pdf.internal.out([r(o2(n3 + t2)), r(s2(i4 + e2)), r(o2(a2 + t2)), r(s2(c3 + e2)), r(o2(u3 + t2)), r(s2(h3 + e2)), "c"].join(" "));
  }, M2 = function(t2, e2, r2, n3) {
    for (var i4 = 2 * Math.PI, a2 = Math.PI / 2; e2 > r2; )
      e2 -= i4;
    var o3 = Math.abs(r2 - e2);
    o3 < i4 && n3 && (o3 = i4 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e2; o3 > 1e-5; ) {
      var h3 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t2, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
    }
    return s3;
  }, E2 = function(t2, e2, r2) {
    var n3 = (r2 - e2) / 2, i4 = t2 * Math.cos(n3), a2 = t2 * Math.sin(n3), o3 = i4, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i4 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i4), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p3 = -f2, g3 = n3 + e2, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t2 * Math.cos(e2), y1: t2 * Math.sin(e2), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t2 * Math.cos(r2), y4: t2 * Math.sin(r2) };
  }, q2 = function(t2) {
    return 180 * t2 / Math.PI;
  }, D2 = function(t2, e2, r2, n3, i4, a2) {
    var o3 = t2 + 0.5 * (r2 - t2), s3 = e2 + 0.5 * (n3 - e2), c3 = i4 + 0.5 * (r2 - i4), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t2, i4, o3, c3), f2 = Math.max(t2, i4, o3, c3), d3 = Math.min(e2, a2, s3, h3), p3 = Math.max(e2, a2, s3, h3);
    return new u2(l3, d3, f2 - l3, p3 - d3);
  }, R2 = function(t2, e2, r2, n3, i4, a2, o3, s3) {
    var c3, h3, l3, f2, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r2 - t2, x3 = n3 - e2, S3 = i4 - r2, _3 = a2 - n3, P3 = o3 - i4, k3 = s3 - a2;
    for (h3 = 0; h3 < 41; h3++)
      v3 = (g3 = (l3 = t2 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r2 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i4 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e2 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), 0 == h3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t2, e2, r2 = (t2 = this.ctx.lineDash, e2 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t2, lineDashOffset: e2 }));
      this.prevLineDash !== r2 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r2);
    }
  };
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var r = function(t3) {
    var e, r2, n3, i4, a3, o2, s2, c2, u2, h2;
    for (/[^\x00-\xFF]/.test(t3), r2 = [], n3 = 0, i4 = (t3 += e = "\0\0\0\0".slice(t3.length % 4 || 4)).length; i4 > n3; n3 += 4)
      0 !== (a3 = (t3.charCodeAt(n3) << 24) + (t3.charCodeAt(n3 + 1) << 16) + (t3.charCodeAt(n3 + 2) << 8) + t3.charCodeAt(n3 + 3)) ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r2.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r2.push(122);
    return function(t4, e2) {
      for (var r3 = e2; r3 > 0; r3--)
        t4.pop();
    }(r2, e.length), String.fromCharCode.apply(String, r2) + "~>";
  }, n2 = function(t3) {
    var e, r2, n3, i4, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
    for (t3[h2](-2), t3 = t3[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i4 = 0, a3 = (t3 += e = "uuuuu"[h2](t3[s2] % 5 || 5))[s2]; a3 > i4; i4 += 5)
      r2 = 52200625 * (t3[u2](i4) - 33) + 614125 * (t3[u2](i4 + 1) - 33) + 7225 * (t3[u2](i4 + 2) - 33) + 85 * (t3[u2](i4 + 3) - 33) + (t3[u2](i4 + 4) - 33), n3.push(c2 & r2 >> 24, c2 & r2 >> 16, c2 & r2 >> 8, c2 & r2);
    return function(t4, e2) {
      for (var r3 = e2; r3 > 0; r3--)
        t4.pop();
    }(n3, e[s2]), o2.fromCharCode.apply(o2, n3);
  }, i3 = function(t3) {
    var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t3 = t3.replace(/\s/g, "")).indexOf(">") && (t3 = t3.substr(0, t3.indexOf(">"))), t3.length % 2 && (t3 += "0"), false === e.test(t3))
      return "";
    for (var r2 = "", n3 = 0; n3 < t3.length; n3 += 2)
      r2 += String.fromCharCode("0x" + (t3[n3] + t3[n3 + 1]));
    return r2;
  }, a2 = function(t3) {
    for (var r2 = new Uint8Array(t3.length), n3 = t3.length; n3--; )
      r2[n3] = t3.charCodeAt(n3);
    return t3 = (r2 = zlibSync(r2)).reduce(function(t4, e) {
      return t4 + String.fromCharCode(e);
    }, "");
  };
  t2.processDataByFilters = function(t3, e) {
    var o2 = 0, s2 = t3 || "", c2 = [];
    for ("string" == typeof (e = e || []) && (e = [e]), o2 = 0; o2 < e.length; o2 += 1)
      switch (e[o2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s2 = n2(s2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s2 = r(s2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s2 = i3(s2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s2 = s2.split("").map(function(t4) {
            return ("0" + t4.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s2 = a2(s2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e[o2] + '" is not implemented');
      }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.loadFile = function(t3, e, r) {
    return function(t4, e2, r2) {
      e2 = false !== e2, r2 = "function" == typeof r2 ? r2 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t5, e3, r3) {
          var n3 = new XMLHttpRequest(), i3 = 0, a2 = function(t6) {
            var e4 = t6.length, r4 = [], n4 = String.fromCharCode;
            for (i3 = 0; i3 < e4; i3 += 1)
              r4.push(n4(255 & t6.charCodeAt(i3)));
            return r4.join("");
          };
          if (n3.open("GET", t5, !e3), n3.overrideMimeType("text/plain; charset=x-user-defined"), false === e3 && (n3.onload = function() {
            200 === n3.status ? r3(a2(this.responseText)) : r3(void 0);
          }), n3.send(null), e3 && 200 === n3.status)
            return a2(n3.responseText);
        }(t4, e2, r2);
      } catch (t5) {
      }
      return n2;
    }(t3, e, r);
  }, t2.loadImageFile = t2.loadFile;
}(E.API), function(e) {
  function r() {
    return (n.html2canvas ? Promise.resolve(n.html2canvas) : import("./chunk-C44CKN2E.js")).catch(function(t2) {
      return Promise.reject(new Error("Could not load html2canvas: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  function i3() {
    return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : import("./chunk-2DV5SC6J.js")).catch(function(t2) {
      return Promise.reject(new Error("Could not load dompurify: " + t2));
    }).then(function(t2) {
      return t2.default ? t2.default : t2;
    });
  }
  var a2 = function(e2) {
    var r2 = _typeof(e2);
    return "undefined" === r2 ? "undefined" : "string" === r2 || e2 instanceof String ? "string" : "number" === r2 || e2 instanceof Number ? "number" : "function" === r2 || e2 instanceof Function ? "function" : e2 && e2.constructor === Array ? "array" : e2 && 1 === e2.nodeType ? "element" : "object" === r2 ? "object" : "unknown";
  }, o2 = function(t2, e2) {
    var r2 = document.createElement(t2);
    for (var n2 in e2.className && (r2.className = e2.className), e2.innerHTML && e2.dompurify && (r2.innerHTML = e2.dompurify.sanitize(e2.innerHTML)), e2.style)
      r2.style[n2] = e2.style[n2];
    return r2;
  }, s2 = function t2(e2) {
    var r2 = Object.assign(t2.convert(Promise.resolve()), JSON.parse(JSON.stringify(t2.template))), n2 = t2.convert(Promise.resolve(), r2);
    return n2 = (n2 = n2.setProgress(1, t2, 1, [t2])).set(e2);
  };
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t2, e2) {
    return t2.__proto__ = e2 || s2.prototype, t2;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t2, e2) {
    return this.then(function() {
      switch (e2 = e2 || function(t3) {
        switch (a2(t3)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t3.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t2)) {
        case "string":
          return this.then(i3).then(function(e3) {
            return this.set({ src: o2("div", { innerHTML: t2, dompurify: e3 }) });
          });
        case "element":
          return this.set({ src: t2 });
        case "canvas":
          return this.set({ canvas: t2 });
        case "img":
          return this.set({ img: t2 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t2) {
    switch (t2) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t2 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e2 = function t3(e3, r2) {
        for (var n2 = 3 === e3.nodeType ? document.createTextNode(e3.nodeValue) : e3.cloneNode(false), i4 = e3.firstChild; i4; i4 = i4.nextSibling)
          true !== r2 && 1 === i4.nodeType && "SCRIPT" === i4.nodeName || n2.appendChild(t3(i4, r2));
        return 1 === e3.nodeType && ("CANVAS" === e3.nodeName ? (n2.width = e3.width, n2.height = e3.height, n2.getContext("2d").drawImage(e3, 0, 0)) : "TEXTAREA" !== e3.nodeName && "SELECT" !== e3.nodeName || (n2.value = e3.value), n2.addEventListener("load", function() {
          n2.scrollTop = e3.scrollTop, n2.scrollLeft = e3.scrollLeft;
        }, true)), n2;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e2.tagName && (t2.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t2 }), this.prop.container.appendChild(e2), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e2 = Object.assign({}, this.opt.html2canvas);
      return delete e2.onrendered, t3(this.prop.container, e2);
    }).then(function(t3) {
      (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t2 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t2).then(r).then(function(t3) {
      var e2 = this.opt.jsPDF, r2 = this.opt.fontFaces, n2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i4 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i4.onrendered, e2.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e2.context2d.posX = this.opt.x, e2.context2d.posY = this.opt.y, e2.context2d.margin = this.opt.margin, e2.context2d.fontFaces = r2, r2)
        for (var a3 = 0; a3 < r2.length; ++a3) {
          var o3 = r2[a3], s3 = o3.src.find(function(t4) {
            return "truetype" === t4.format;
          });
          s3 && e2.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
      return i4.windowHeight = i4.windowHeight || 0, i4.windowHeight = 0 == i4.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i4.windowHeight, e2.context2d.save(true), t3(this.prop.container, i4);
    }).then(function(t3) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t2 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t2;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t2, e2, r2) {
    return "img" === (r2 = r2 || "pdf").toLowerCase() || "image" === r2.toLowerCase() ? this.outputImg(t2, e2) : this.outputPdf(t2, e2);
  }, s2.prototype.outputPdf = function(t2, e2) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t2, e2);
    });
  }, s2.prototype.outputImg = function(t2) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t2) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t2 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t2) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t2 ? { filename: t2 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t2) {
    if ("object" !== a2(t2))
      return this;
    var e2 = Object.keys(t2 || {}).map(function(e3) {
      if (e3 in s2.template.prop)
        return function() {
          this.prop[e3] = t2[e3];
        };
      switch (e3) {
        case "margin":
          return this.setMargin.bind(this, t2.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t2.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t2.pageSize);
        default:
          return function() {
            this.opt[e3] = t2[e3];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e2);
    });
  }, s2.prototype.get = function(t2, e2) {
    return this.then(function() {
      var r2 = t2 in s2.template.prop ? this.prop[t2] : this.opt[t2];
      return e2 ? e2(r2) : r2;
    });
  }, s2.prototype.setMargin = function(t2) {
    return this.then(function() {
      switch (a2(t2)) {
        case "number":
          t2 = [t2, t2, t2, t2];
        case "array":
          if (2 === t2.length && (t2 = [t2[0], t2[1], t2[0], t2[1]]), 4 === t2.length)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t2;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t2) {
    function e2(t3, e3) {
      return Math.floor(t3 * e3 / 72 * 96);
    }
    return this.then(function() {
      (t2 = t2 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t2.inner = { width: t2.width - this.opt.margin[1] - this.opt.margin[3], height: t2.height - this.opt.margin[0] - this.opt.margin[2] }, t2.inner.px = { width: e2(t2.inner.width, t2.k), height: e2(t2.inner.height, t2.k) }, t2.inner.ratio = t2.inner.height / t2.inner.width), this.prop.pageSize = t2;
    });
  }, s2.prototype.setProgress = function(t2, e2, r2, n2) {
    return null != t2 && (this.progress.val = t2), null != e2 && (this.progress.state = e2), null != r2 && (this.progress.n = r2), null != n2 && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t2, e2, r2, n2) {
    return this.setProgress(t2 ? this.progress.val + t2 : null, e2 || null, r2 ? this.progress.n + r2 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t2, e2) {
    var r2 = this;
    return this.thenCore(t2, e2, function(t3, e3) {
      return r2.updateProgress(null, null, 1, [t3]), Promise.prototype.then.call(this, function(e4) {
        return r2.updateProgress(null, t3), e4;
      }).then(t3, e3).then(function(t4) {
        return r2.updateProgress(1), t4;
      });
    });
  }, s2.prototype.thenCore = function(t2, e2, r2) {
    r2 = r2 || Promise.prototype.then;
    t2 && (t2 = t2.bind(this)), e2 && (e2 = e2.bind(this));
    var n2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s2.convert(Object.assign({}, this), Promise.prototype), i4 = r2.call(n2, t2, e2);
    return s2.convert(i4, this.__proto__);
  }, s2.prototype.thenExternal = function(t2, e2) {
    return Promise.prototype.then.call(this, t2, e2);
  }, s2.prototype.thenList = function(t2) {
    var e2 = this;
    return t2.forEach(function(t3) {
      e2 = e2.thenCore(t3);
    }), e2;
  }, s2.prototype.catch = function(t2) {
    t2 && (t2 = t2.bind(this));
    var e2 = Promise.prototype.catch.call(this, t2);
    return s2.convert(e2, this);
  }, s2.prototype.catchExternal = function(t2) {
    return Promise.prototype.catch.call(this, t2);
  }, s2.prototype.error = function(t2) {
    return this.then(function() {
      throw new Error(t2);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E.getPageSize = function(e2, r2, n2) {
    if ("object" === _typeof(e2)) {
      var i4 = e2;
      e2 = i4.orientation, r2 = i4.unit || r2, n2 = i4.format || n2;
    }
    r2 = r2 || "mm", n2 = n2 || "a4", e2 = ("" + (e2 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r2) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r2;
    }
    var c2, u2 = 0, h2 = 0;
    if (s3.hasOwnProperty(o3))
      u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
    else
      try {
        u2 = n2[1], h2 = n2[0];
      } catch (t2) {
        throw new Error("Invalid format: " + n2);
      }
    if ("p" === e2 || "portrait" === e2)
      e2 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
    else {
      if ("l" !== e2 && "landscape" !== e2)
        throw "Invalid orientation: " + e2;
      e2 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
    }
    return { width: h2, height: u2, unit: r2, k: a3, orientation: e2 };
  }, e.html = function(t2, e2) {
    (e2 = e2 || {}).callback = e2.callback || function() {
    }, e2.html2canvas = e2.html2canvas || {}, e2.html2canvas.canvas = e2.html2canvas.canvas || this.canvas, e2.jsPDF = e2.jsPDF || this, e2.fontFaces = e2.fontFaces ? e2.fontFaces.map(jt) : null;
    var r2 = new s2(e2);
    return e2.worker ? r2 : r2.from(t2).doCallback();
  };
}(E.API), E.API.addJS = function(t2) {
  return Ht = t2, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e;
  t2.events.push(["postPutResources", function() {
    var t3 = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n2 = t3.outline.render().split(/\r\n/), i3 = 0; i3 < n2.length; i3++) {
        var a2 = n2[i3], o2 = r.exec(a2);
        if (null != o2) {
          var s2 = o2[1];
          t3.internal.newObjectDeferredBegin(s2, false);
        }
        t3.internal.write(a2);
      }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i3 = 0; i3 < c2; i3++) {
        var h2 = t3.internal.newObject();
        u2.push(h2);
        var l2 = t3.internal.getPageInfo(i3 + 1);
        t3.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t3.internal.newObject();
      t3.internal.write("<< /Names [ ");
      for (i3 = 0; i3 < u2.length; i3++)
        t3.internal.write("(page_" + (i3 + 1) + ")" + u2[i3] + " 0 R");
      t3.internal.write(" ] >>", "endobj"), e = t3.internal.newObject(), t3.internal.write("<< /Dests " + f2 + " 0 R"), t3.internal.write(">>", "endobj");
    }
  }]), t2.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), t2.events.push(["initialized", function() {
    var t3 = this;
    t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e2, r) {
      var n2 = { title: e2, options: r, children: [] };
      return null == t4 && (t4 = this.root), t4.children.push(n2), n2;
    }, t3.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t3.outline.genIds_r = function(e2) {
      e2.id = t3.internal.newObjectDeferred();
      for (var r = 0; r < e2.children.length; r++)
        this.genIds_r(e2.children[r]);
    }, t3.outline.renderRoot = function(t4) {
      this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
    }, t3.outline.renderItems = function(e2) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e2.children.length; n2++) {
        var i3 = e2.children[n2];
        this.objStart(i3), this.line("/Title " + this.makeString(i3.title)), this.line("/Parent " + this.makeRef(e2)), n2 > 0 && this.line("/Prev " + this.makeRef(e2.children[n2 - 1])), n2 < e2.children.length - 1 && this.line("/Next " + this.makeRef(e2.children[n2 + 1])), i3.children.length > 0 && (this.line("/First " + this.makeRef(i3.children[0])), this.line("/Last " + this.makeRef(i3.children[i3.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i3);
        if (a2 > 0 && this.line("/Count " + a2), i3.options && i3.options.pageNumber) {
          var o2 = t3.internal.getPageInfo(i3.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e2.children.length; s2++)
        this.renderItems(e2.children[s2]);
    }, t3.outline.line = function(t4) {
      this.ctx.val += t4 + "\r\n";
    }, t3.outline.makeRef = function(t4) {
      return t4.id + " 0 R";
    }, t3.outline.makeString = function(e2) {
      return "(" + t3.internal.pdfEscape(e2) + ")";
    }, t3.outline.objStart = function(t4) {
      this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
    }, t3.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t3.outline.count_r = function(t4, e2) {
      for (var r = 0; r < e2.children.length; r++)
        t4.count++, this.count_r(t4, e2.children[r]);
      return t4.count;
    };
  }]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  t2.processJPEG = function(t3, r, n2, i3, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
      switch (t3 = a2 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, (s2 = function(t4) {
        for (var r2, n3 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i4 = t4.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i4; o3 += 2) {
          if (o3 += n3, -1 !== e.indexOf(t4.charCodeAt(o3 + 1))) {
            r2 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a3 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: r2, numcomponents: t4.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
        }
        return a3;
      }(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r, alias: n2 };
    }
    return u2;
  };
}(E.API);
var Vt;
var Gt;
var Yt;
var Jt;
var Xt;
var Kt = function() {
  var t2, e, i3;
  function a2(t3) {
    var e2, r, n2, i4, a3, o3, s2, c2, u2, h2, l2, f2, d2, p2;
    for (this.data = t3, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e2 = this.readUInt32(), u2 = (function() {
        var t4, e3;
        for (e3 = [], t4 = 0; t4 < 4; ++t4)
          e3.push(String.fromCharCode(this.data[this.pos++]));
        return e3;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e2);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i4 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i4, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u2 && (this.pos += 4, e2 -= 4), t3 = (null != o3 ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e2 ? f2 < e2 : f2 > e2; 0 <= e2 ? ++f2 : --f2)
            t3.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e2), this.transparency.indexed.length > n2)
                throw new Error("More transparent colors than palette size");
              if ((h2 = n2 - this.transparency.indexed.length) > 0)
                for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e2)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e2);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e2)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (p2 = this.colorType) || 6 === p2, r = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e2;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a2.prototype.read = function(t3) {
    var e2, r;
    for (r = [], e2 = 0; 0 <= t3 ? e2 < t3 : e2 > t3; 0 <= t3 ? ++e2 : --e2)
      r.push(this.data[this.pos++]);
    return r;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t3) {
    var e2 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e2), i4 = 0, a3 = this;
    if (null == t3 && (t3 = this.imgData), 0 === t3.length)
      return new Uint8Array(0);
    function o3(r, o4, s2, c2) {
      var u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e2 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t3.length, N2 = 0, h2 = 0; N2 < C2 && i4 < p2; ) {
        switch (t3[i4++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)
              w2[h2++] = t3[i4++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)
              u2 = t3[i4++], d2 = f2 < e2 ? 0 : w2[h2 - e2], w2[h2++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)
              u2 = t3[i4++], l2 = (f2 - f2 % e2) / e2, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], w2[h2++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)
              u2 = t3[i4++], l2 = (f2 - f2 % e2) / e2, d2 = f2 < e2 ? 0 : w2[h2 - e2], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)
              u2 = t3[i4++], l2 = (f2 - f2 % e2) / e2, d2 = f2 < e2 ? 0 : w2[h2 - e2], 0 === N2 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e2 + f2 % e2], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e2 + f2 % e2]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t3[i4 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r) * e2, B2 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e2; M2 += 1)
              n2[O2++] = w2[B2++];
            O2 += (s2 - 1) * e2;
          }
        }
        N2++;
      }
    }
    return t3 = unzlibSync(t3), 1 == a3.interlaceMethod ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t3, e2, r, n2, i4, a3, o3, s2, c2;
    for (r = this.palette, a3 = this.transparency.indexed || [], i4 = new Uint8Array((a3.length || 0) + r.length), n2 = 0, t3 = 0, e2 = o3 = 0, s2 = r.length; o3 < s2; e2 = o3 += 3)
      i4[n2++] = r[e2], i4[n2++] = r[e2 + 1], i4[n2++] = r[e2 + 2], i4[n2++] = null != (c2 = a3[t3++]) ? c2 : 255;
    return i4;
  }, a2.prototype.copyToImageData = function(t3, e2) {
    var r, n2, i4, a3, o3, s2, c2, u2, h2, l2, f2;
    if (n2 = this.colors, h2 = null, r = this.hasAlphaChannel, this.palette.length && (h2 = null != (f2 = this._decodedPalette) ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r = true), u2 = (i4 = t3.data || t3).length, o3 = h2 || e2, a3 = s2 = 0, 1 === n2)
      for (; a3 < u2; )
        c2 = h2 ? 4 * e2[a3 / 4] : s2, l2 = o3[c2++], i4[a3++] = l2, i4[a3++] = l2, i4[a3++] = l2, i4[a3++] = r ? o3[c2++] : 255, s2 = c2;
    else
      for (; a3 < u2; )
        c2 = h2 ? 4 * e2[a3 / 4] : s2, i4[a3++] = o3[c2++], i4[a3++] = o3[c2++], i4[a3++] = o3[c2++], i4[a3++] = r ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t3;
    return t3 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t3, this.decodePixels()), t3;
  };
  var o2 = function() {
    if ("[object Window]" === Object.prototype.toString.call(n)) {
      try {
        e = n.document.createElement("canvas"), i3 = e.getContext("2d");
      } catch (t3) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o2(), t2 = function(t3) {
    var r;
    if (true === o2())
      return i3.width = t3.width, i3.height = t3.height, i3.clearRect(0, 0, t3.width, t3.height), i3.putImageData(t3, 0, 0), (r = new Image()).src = e.toDataURL(), r;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a2.prototype.decodeFrames = function(e2) {
    var r, n2, i4, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)
        r = c2[n2], i4 = e2.createImageData(r.width, r.height), a3 = this.decodePixels(new Uint8Array(r.data)), this.copyToImageData(i4, a3), r.imageData = i4, u2.push(r.image = t2(i4));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t3, e2) {
    var r, n2, i4;
    return r = (n2 = this.animation.frames)[e2], i4 = n2[e2 - 1], 0 === e2 && t3.clearRect(0, 0, this.width, this.height), 1 === (null != i4 ? i4.disposeOp : void 0) ? t3.clearRect(i4.xOffset, i4.yOffset, i4.width, i4.height) : 2 === (null != i4 ? i4.disposeOp : void 0) && t3.putImageData(i4.imageData, i4.xOffset, i4.yOffset), 0 === r.blendOp && t3.clearRect(r.xOffset, r.yOffset, r.width, r.height), t3.drawImage(r.image, r.xOffset, r.yOffset);
  }, a2.prototype.animate = function(t3) {
    var e2, r, n2, i4, a3, o3, s2 = this;
    return r = 0, o3 = this.animation, i4 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e2 = function() {
      var o4, c2;
      if (o4 = r++ % i4, c2 = n2[o4], s2.renderFrame(t3, o4), i4 > 1 && r / i4 < a3)
        return s2.animation._timeout = setTimeout(e2, c2.delay);
    })();
  }, a2.prototype.stopAnimation = function() {
    var t3;
    return clearTimeout(null != (t3 = this.animation) ? t3._timeout : void 0);
  }, a2.prototype.render = function(t3) {
    var e2, r;
    return t3._png && t3._png.stopAnimation(), t3._png = this, t3.width = this.width, t3.height = this.height, e2 = t3.getContext("2d"), this.animation ? (this.decodeFrames(e2), this.animate(e2)) : (r = e2.createImageData(this.width, this.height), this.copyToImageData(r, this.decodePixels()), e2.putImageData(r, 0, 0));
  }, a2;
}();
function Zt(t2) {
  var e = 0;
  if (71 !== t2[e++] || 73 !== t2[e++] || 70 !== t2[e++] || 56 !== t2[e++] || 56 != (t2[e++] + 1 & 253) || 97 !== t2[e++])
    throw new Error("Invalid GIF 87a/89a header.");
  var r = t2[e++] | t2[e++] << 8, n2 = t2[e++] | t2[e++] << 8, i3 = t2[e++], a2 = i3 >> 7, o2 = 1 << (7 & i3) + 1;
  t2[e++];
  t2[e++];
  var s2 = null, c2 = null;
  a2 && (s2 = e, c2 = o2, e += 3 * o2);
  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
  for (this.width = r, this.height = n2; u2 && e < t2.length; )
    switch (t2[e++]) {
      case 33:
        switch (t2[e++]) {
          case 255:
            if (11 !== t2[e] || 78 == t2[e + 1] && 69 == t2[e + 2] && 84 == t2[e + 3] && 83 == t2[e + 4] && 67 == t2[e + 5] && 65 == t2[e + 6] && 80 == t2[e + 7] && 69 == t2[e + 8] && 50 == t2[e + 9] && 46 == t2[e + 10] && 48 == t2[e + 11] && 3 == t2[e + 12] && 1 == t2[e + 13] && 0 == t2[e + 16])
              e += 14, p2 = t2[e++] | t2[e++] << 8, e++;
            else
              for (e += 12; ; ) {
                if (!((P2 = t2[e++]) >= 0))
                  throw Error("Invalid block size");
                if (0 === P2)
                  break;
                e += P2;
              }
            break;
          case 249:
            if (4 !== t2[e++] || 0 !== t2[e + 4])
              throw new Error("Invalid graphics extension block.");
            var g2 = t2[e++];
            l2 = t2[e++] | t2[e++] << 8, f2 = t2[e++], 0 == (1 & g2) && (f2 = null), d2 = g2 >> 2 & 7, e++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t2[e++]) >= 0))
                throw Error("Invalid block size");
              if (0 === P2)
                break;
              e += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t2[e - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t2[e++] | t2[e++] << 8, v2 = t2[e++] | t2[e++] << 8, b2 = t2[e++] | t2[e++] << 8, y2 = t2[e++] | t2[e++] << 8, w2 = t2[e++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e, x2 = L2, e += 3 * L2;
        }
        var _2 = e;
        for (e++; ; ) {
          var P2;
          if (!((P2 = t2[e++]) >= 0))
            throw Error("Invalid block size");
          if (0 === P2)
            break;
          e += P2;
        }
        h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t2[e - 1].toString(16));
    }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t3) {
    if (t3 < 0 || t3 >= h2.length)
      throw new Error("Frame index out of range.");
    return h2[t3];
  }, this.decodeAndBlitFrameBGRA = function(e2, n3) {
    var i4 = this.frameInfo(e2), a3 = i4.width * i4.height, o3 = new Uint8Array(a3);
    $t(t2, i4.data_offset, o3, a3);
    var s3 = i4.palette_offset, c3 = i4.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i4.width, h3 = r - u3, l3 = u3, f3 = 4 * (i4.y * r + i4.x), d3 = 4 * ((i4.y + i4.height) * r + i4.x), p3 = f3, g3 = 4 * h3;
    true === i4.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e2, n3) {
    var i4 = this.frameInfo(e2), a3 = i4.width * i4.height, o3 = new Uint8Array(a3);
    $t(t2, i4.data_offset, o3, a3);
    var s3 = i4.palette_offset, c3 = i4.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i4.width, h3 = r - u3, l3 = u3, f3 = 4 * (i4.y * r + i4.x), d3 = 4 * ((i4.y + i4.height) * r + i4.x), p3 = f3, g3 = 4 * h3;
    true === i4.interlaced && (g3 += 4 * r * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p3 += 4;
      else {
        var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
        n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
      }
      --l3;
    }
  };
}
function $t(t2, e, r, n2) {
  for (var i3 = t2[e++], o2 = 1 << i3, s2 = o2 + 1, c2 = s2 + 1, u2 = i3 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t2[e++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && 0 !== p2; )
      f2 |= t2[e++] << l2, l2 += 8, 1 === p2 ? p2 = t2[e++] : --p2;
    if (l2 < u2)
      break;
    var v2 = f2 & h2;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2)
        break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )
        w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)
        return void a.log("Warning, gif stream longer than expected.");
      r[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r[d2++] = N2), w2 = b2; y2--; )
        w2 = g2[w2], r[--L2] = 255 & w2, w2 >>= 8;
      null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
    } else
      c2 = s2 + 1, h2 = (1 << (u2 = i3 + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a.log("Warning, gif stream shorter than expected."), r;
}
function Qt(t2) {
  var e, r, n2, i3, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t3, e2) {
    for (var r2 = 0, n3 = 0, i4 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t3[a3]; o3++)
        i4[e2[n3]] = [], i4[e2[n3]][0] = r2, i4[e2[n3]][1] = a3, n3++, r2++;
      r2 *= 2;
    }
    return i4;
  }
  function O2(t3) {
    for (var e2 = t3[0], r2 = t3[1] - 1; r2 >= 0; )
      e2 & 1 << r2 && (m2 |= 1 << v2), r2--, --v2 < 0 && (255 == m2 ? (B2(255), B2(0)) : B2(m2), v2 = 7, m2 = 0);
  }
  function B2(t3) {
    g2.push(t3);
  }
  function M2(t3) {
    B2(t3 >> 8 & 255), B2(255 & t3);
  }
  function E2(t3, e2, r2, n3, i4) {
    for (var a3, o3 = i4[0], s3 = i4[240], c3 = function(t4, e3) {
      var r3, n4, i5, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
      for (h4 = 0; h4 < 8; ++h4) {
        r3 = t4[f3], n4 = t4[f3 + 1], i5 = t4[f3 + 2], a4 = t4[f3 + 3], o4 = t4[f3 + 4], s4 = t4[f3 + 5], c4 = t4[f3 + 6];
        var p3 = r3 + (u4 = t4[f3 + 7]), g4 = r3 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i5 + s4, y4 = i5 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t4[f3] = L3 + x3, t4[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t4[f3 + 2] = A3 + _3, t4[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
        t4[f3 + 5] = j3 + k3, t4[f3 + 3] = j3 - k3, t4[f3 + 1] = C3 + I3, t4[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
        r3 = t4[f3], n4 = t4[f3 + 8], i5 = t4[f3 + 16], a4 = t4[f3 + 24], o4 = t4[f3 + 32], s4 = t4[f3 + 40], c4 = t4[f3 + 48];
        var O3 = r3 + (u4 = t4[f3 + 56]), B3 = r3 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i5 + s4, D2 = i5 - s4, R2 = a4 + o4, T2 = a4 - o4, U2 = O3 + R2, z2 = O3 - R2, H2 = M3 + q3, W2 = M3 - q3;
        t4[f3] = U2 + H2, t4[f3 + 32] = U2 - H2;
        var V2 = 0.707106781 * (W2 + z2);
        t4[f3 + 16] = z2 + V2, t4[f3 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T2 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
        t4[f3 + 40] = Z2 + Y2, t4[f3 + 24] = Z2 - Y2, t4[f3 + 8] = K2 + J2, t4[f3 + 56] = K2 - J2, f3++;
      }
      for (h4 = 0; h4 < 64; ++h4)
        l3 = t4[h4] * e3[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t3, e2), u3 = 0; u3 < 64; ++u3)
      p2[A2[u3]] = c3[u3];
    var h3 = p2[0] - r2;
    r2 = p2[0], 0 == h3 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; )
      g3--;
    if (0 == g3)
      return O2(o3), r2;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; 0 == p2[v3] && v3 <= g3; )
        ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3)
          O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p2[v3], O2(i4[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return 63 != g3 && O2(o3), r2;
  }
  function q2(t3) {
    (t3 = Math.min(Math.max(t3, 1), 100), a2 != t3) && (!function(t4) {
      for (var e2 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r2 = 0; r2 < 64; r2++) {
        var n3 = o2((e2[r2] * t4 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r2]] = n3;
      }
      for (var i4 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i4[a3] * t4 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++)
        for (var g3 = 0; g3 < 8; g3++)
          u2[d3] = 1 / (s2[A2[d3]] * f3[p3] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p3] * f3[g3] * 8), d3++;
    }(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a2 = t3);
  }
  this.encode = function(t3, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
      M2(65499), M2(132), B2(0);
      for (var t4 = 0; t4 < 64; t4++)
        B2(s2[t4]);
      B2(1);
      for (var e2 = 0; e2 < 64; e2++)
        B2(c2[e2]);
    }(), function(t4, e2) {
      M2(65472), M2(17), B2(8), M2(e2), M2(t4), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
    }(t3.width, t3.height), function() {
      M2(65476), M2(418), B2(0);
      for (var t4 = 0; t4 < 16; t4++)
        B2(x2[t4 + 1]);
      for (var e2 = 0; e2 <= 11; e2++)
        B2(S2[e2]);
      B2(16);
      for (var r2 = 0; r2 < 16; r2++)
        B2(_2[r2 + 1]);
      for (var n3 = 0; n3 <= 161; n3++)
        B2(P2[n3]);
      B2(1);
      for (var i4 = 0; i4 < 16; i4++)
        B2(k2[i4 + 1]);
      for (var a4 = 0; a4 <= 11; a4++)
        B2(I2[a4]);
      B2(17);
      for (var o4 = 0; o4 < 16; o4++)
        B2(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++)
        B2(C2[s3]);
    }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p3, N3, A3, j3, D2, R2, T2, U2, z2 = t3.data, H2 = t3.width, W2 = t3.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, U2 = 0; U2 < 64; U2++)
          D2 = j3 + (T2 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p3 = z2[D2++], N3 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[U2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e, n2), l3 = E2(y2, h2, l3, r, i3), f3 = E2(w2, h2, f3, r, i3), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t2 = t2 || 50, function() {
    for (var t3 = String.fromCharCode, e2 = 0; e2 < 256; e2++)
      N2[e2] = t3(e2);
  }(), e = j2(x2, S2), r = j2(k2, I2), n2 = j2(_2, P2), i3 = j2(F2, C2), function() {
    for (var t3 = 1, e2 = 2, r2 = 1; r2 <= 15; r2++) {
      for (var n3 = t3; n3 < e2; n3++)
        f2[32767 + n3] = r2, l2[32767 + n3] = [], l2[32767 + n3][1] = r2, l2[32767 + n3][0] = n3;
      for (var i4 = -(e2 - 1); i4 <= -t3; i4++)
        f2[32767 + i4] = r2, l2[32767 + i4] = [], l2[32767 + i4][1] = r2, l2[32767 + i4][0] = e2 - 1 + i4;
      t3 <<= 1, e2 <<= 1;
    }
  }(), function() {
    for (var t3 = 0; t3 < 256; t3++)
      L2[t3] = 19595 * t3, L2[t3 + 256 >> 0] = 38470 * t3, L2[t3 + 512 >> 0] = 7471 * t3 + 32768, L2[t3 + 768 >> 0] = -11059 * t3, L2[t3 + 1024 >> 0] = -21709 * t3, L2[t3 + 1280 >> 0] = 32768 * t3 + 8421375, L2[t3 + 1536 >> 0] = -27439 * t3, L2[t3 + 1792 >> 0] = -5329 * t3;
  }(), q2(t2);
}
function te(t2, e) {
  if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag))
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t2) {
  function e(t3) {
    if (!t3)
      throw Error("assert :P");
  }
  function r(t3, e2, r2) {
    for (var n3 = 0; 4 > n3; n3++)
      if (t3[e2 + n3] != r2.charCodeAt(n3))
        return true;
    return false;
  }
  function n2(t3, e2, r2, n3, i4) {
    for (var a3 = 0; a3 < i4; a3++)
      t3[e2 + a3] = r2[n3 + a3];
  }
  function i3(t3, e2, r2, n3) {
    for (var i4 = 0; i4 < n3; i4++)
      t3[e2 + i4] = r2;
  }
  function a2(t3) {
    return new Int32Array(t3);
  }
  function o2(t3, e2) {
    for (var r2 = [], n3 = 0; n3 < t3; n3++)
      r2.push(new e2());
    return r2;
  }
  function s2(t3, e2) {
    var r2 = [];
    return function t4(r3, n3, i4) {
      for (var a3 = i4[n3], o3 = 0; o3 < a3 && (r3.push(i4.length > n3 + 1 ? [] : new e2()), !(i4.length < n3 + 1)); o3++)
        t4(r3[o3], n3 + 1, i4);
    }(r2, 0, t3), r2;
  }
  var c2 = function() {
    var t3 = this;
    function c3(t4, e2) {
      for (var r2 = 1 << e2 - 1 >>> 0; t4 & r2; )
        r2 >>>= 1;
      return r2 ? (t4 & r2 - 1) + r2 : t4;
    }
    function u3(t4, r2, n3, i4, a3) {
      e(!(i4 % n3));
      do {
        t4[r2 + (i4 -= n3)] = a3;
      } while (0 < i4);
    }
    function h3(t4, r2, n3, i4, o3) {
      if (e(2328 >= o3), 512 >= o3)
        var s3 = a2(512);
      else if (null == (s3 = a2(o3)))
        return 0;
      return function(t5, r3, n4, i5, o4, s4) {
        var h4, f4, d4 = r3, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e(0 != o4), e(null != i5), e(null != t5), e(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i5[f4])
            return 0;
          ++g4[i5[f4]];
        }
        if (g4[0] == o4)
          return 0;
        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
          if (g4[h4] > 1 << h4)
            return 0;
          m4[h4 + 1] = m4[h4] + g4[h4];
        }
        for (f4 = 0; f4 < o4; ++f4)
          h4 = i5[f4], 0 < i5[f4] && (s4[m4[h4]++] = f4);
        if (1 == m4[15])
          return (i5 = new l3()).g = 0, i5.value = s4[0], u3(t5, d4, 1, p4, i5), p4;
        var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4])
            (i5 = new l3()).g = h4, i5.value = s4[f4++], u3(t5, d4 + w4, o4, A4, i5), w4 = c3(w4, h4);
        }
        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4]) {
            if (i5 = new l3(), (w4 & y4) != b4) {
              for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )
                ++b4, v4 <<= 1;
              p4 += A4 = 1 << (v4 = b4 - n4), t5[r3 + (b4 = w4 & y4)].g = v4 + n4, t5[r3 + b4].value = d4 - r3 - b4;
            }
            i5.g = h4 - n4, i5.value = s4[f4++], u3(t5, d4 + (w4 >> n4), o4, A4, i5), w4 = c3(w4, h4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p4;
      }(t4, r2, n3, i4, o3, s3);
    }
    function l3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    function p3(t4, r2, n3, i4) {
      e(null != t4), e(null != r2), e(2147483648 > i4), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = r2, t4.pa = n3, t4.Jd = r2, t4.Yc = n3 + i4, t4.Zc = 4 <= i4 ? n3 + i4 - 4 + 1 : n3, _2(t4);
    }
    function g3(t4, e2) {
      for (var r2 = 0; 0 < e2--; )
        r2 |= k2(t4, 128) << e2;
      return r2;
    }
    function m3(t4, e2) {
      var r2 = g3(t4, e2);
      return P2(t4) ? -r2 : r2;
    }
    function v3(t4, r2, n3, i4) {
      var a3, o3 = 0;
      for (e(null != t4), e(null != r2), e(4294967288 > i4), t4.Sb = i4, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i4 && (i4 = 4), a3 = 0; a3 < i4; ++a3)
        o3 += r2[n3 + a3] << 8 * a3;
      t4.Ra = o3, t4.bb = i4, t4.oa = r2, t4.pa = n3;
    }
    function b3(t4) {
      for (; 8 <= t4.u && t4.bb < t4.Sb; )
        t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << Ur - 8 >>> 0, ++t4.bb, t4.u -= 8;
      A3(t4) && (t4.h = 1, t4.u = 0);
    }
    function y3(t4, r2) {
      if (e(0 <= r2), !t4.h && r2 <= Tr) {
        var n3 = L3(t4) & Rr[r2];
        return t4.u += r2, b3(t4), n3;
      }
      return t4.h = 1, t4.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t4) {
      return t4.Ra >>> (t4.u & Ur - 1) >>> 0;
    }
    function A3(t4) {
      return e(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > Ur;
    }
    function x2(t4, e2) {
      t4.u = e2, t4.h = A3(t4);
    }
    function S2(t4) {
      t4.u >= zr && (e(t4.u >= zr), b3(t4));
    }
    function _2(t4) {
      e(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
    }
    function P2(t4) {
      return g3(t4, 1);
    }
    function k2(t4, e2) {
      var r2 = t4.Ca;
      0 > t4.b && _2(t4);
      var n3 = t4.b, i4 = r2 * e2 >>> 8, a3 = (t4.I >>> n3 > i4) + 0;
      for (a3 ? (r2 -= i4, t4.I -= i4 + 1 << n3 >>> 0) : r2 = i4 + 1, n3 = r2, i4 = 0; 256 <= n3; )
        i4 += 8, n3 >>= 8;
      return n3 = 7 ^ i4 + Hr[n3], t4.b -= n3, t4.Ca = (r2 << n3) - 1, a3;
    }
    function I2(t4, e2, r2) {
      t4[e2 + 0] = r2 >> 24 & 255, t4[e2 + 1] = r2 >> 16 & 255, t4[e2 + 2] = r2 >> 8 & 255, t4[e2 + 3] = r2 >> 0 & 255;
    }
    function F2(t4, e2) {
      return t4[e2 + 0] << 0 | t4[e2 + 1] << 8;
    }
    function C2(t4, e2) {
      return F2(t4, e2) | t4[e2 + 2] << 16;
    }
    function j2(t4, e2) {
      return F2(t4, e2) | F2(t4, e2 + 2) << 16;
    }
    function O2(t4, r2) {
      var n3 = 1 << r2;
      return e(null != t4), e(0 < r2), t4.X = a2(n3), null == t4.X ? 0 : (t4.Mb = 32 - r2, t4.Xa = r2, 1);
    }
    function B2(t4, r2) {
      e(null != t4), e(null != r2), e(t4.Xa == r2.Xa), n2(r2.X, 0, t4.X, 0, 1 << r2.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t4, r2, n3, i4) {
      e(null != n3), e(null != i4);
      var a3 = n3[0], o3 = i4[0];
      return 0 == a3 && (a3 = (t4 * o3 + r2 / 2) / r2), 0 == o3 && (o3 = (r2 * a3 + t4 / 2) / t4), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i4[0] = o3, 1);
    }
    function q2(t4, e2) {
      return t4 + (1 << e2) - 1 >>> e2;
    }
    function D2(t4, e2) {
      return ((4278255360 & t4) + (4278255360 & e2) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e2) >>> 0 & 16711935) >>> 0;
    }
    function R2(e2, r2) {
      t3[r2] = function(r3, n3, i4, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h4 = t3[e2](s3[c4 + u4 - 1], i4, a3 + u4);
          s3[c4 + u4] = D2(r3[n3 + u4], h4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t4, e2) {
      return ((4278124286 & (t4 ^ e2)) >>> 1) + (t4 & e2) >>> 0;
    }
    function z2(t4) {
      return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
    }
    function H2(t4, e2) {
      return z2(t4 + (t4 - e2 + 0.5 >> 1));
    }
    function W2(t4, e2, r2) {
      return Math.abs(e2 - r2) - Math.abs(t4 - r2);
    }
    function V2(t4, e2, r2, n3, i4, a3, o3) {
      for (n3 = a3[o3 - 1], r2 = 0; r2 < i4; ++r2)
        a3[o3 + r2] = n3 = D2(t4[e2 + r2], n3);
    }
    function G2(t4, e2, r2, n3, i4) {
      var a3;
      for (a3 = 0; a3 < r2; ++a3) {
        var o3 = t4[e2 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i4 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    function Y2(t4, e2) {
      e2.jd = t4 >> 0 & 255, e2.hd = t4 >> 8 & 255, e2.ud = t4 >> 16 & 255;
    }
    function J2(t4, e2, r2, n3, i4, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e2[r2 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t4.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t4.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
        i4[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
      }
    }
    function X2(e2, r2, n3, i4, a3) {
      t3[r2] = function(t4, e3, r3, n4, o3, s3, c4, u4, h4) {
        for (n4 = c4; n4 < u4; ++n4)
          for (c4 = 0; c4 < h4; ++c4)
            o3[s3++] = a3(r3[i4(t4[e3++])]);
      }, t3[e2] = function(e3, r3, o3, s3, c4, u4, h4) {
        var l4 = 8 >> e3.b, f4 = e3.Ea, d4 = e3.K[0], p4 = e3.w;
        if (8 > l4)
          for (e3 = (1 << e3.b) - 1, p4 = (1 << l4) - 1; r3 < o3; ++r3) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4)
              g4 & e3 || (m4 = i4(s3[c4++])), u4[h4++] = a3(d4[m4 & p4]), m4 >>= l4;
          }
        else
          t3["VP8LMapColor" + n3](s3, c4, d4, p4, u4, h4, r3, o3, f4);
      };
    }
    function K2(t4, e2, r2, n3, i4) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = t4[e2++];
        n3[i4++] = a3 >> 16 & 255, n3[i4++] = a3 >> 8 & 255, n3[i4++] = a3 >> 0 & 255;
      }
    }
    function Z2(t4, e2, r2, n3, i4) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = t4[e2++];
        n3[i4++] = a3 >> 16 & 255, n3[i4++] = a3 >> 8 & 255, n3[i4++] = a3 >> 0 & 255, n3[i4++] = a3 >> 24 & 255;
      }
    }
    function $2(t4, e2, r2, n3, i4) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = (o3 = t4[e2++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i4++] = a3, n3[i4++] = o3;
      }
    }
    function Q2(t4, e2, r2, n3, i4) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = (o3 = t4[e2++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i4++] = a3, n3[i4++] = o3;
      }
    }
    function tt2(t4, e2, r2, n3, i4) {
      for (r2 = e2 + r2; e2 < r2; ) {
        var a3 = t4[e2++];
        n3[i4++] = a3 >> 0 & 255, n3[i4++] = a3 >> 8 & 255, n3[i4++] = a3 >> 16 & 255;
      }
    }
    function et3(t4, e2, r2, i4, a3, o3) {
      if (0 == o3)
        for (r2 = e2 + r2; e2 < r2; )
          I2(i4, ((o3 = t4[e2++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else
        n2(i4, a3, t4, e2, r2);
    }
    function rt2(e2, r2) {
      t3[r2][0] = t3[e2 + "0"], t3[r2][1] = t3[e2 + "1"], t3[r2][2] = t3[e2 + "2"], t3[r2][3] = t3[e2 + "3"], t3[r2][4] = t3[e2 + "4"], t3[r2][5] = t3[e2 + "5"], t3[r2][6] = t3[e2 + "6"], t3[r2][7] = t3[e2 + "7"], t3[r2][8] = t3[e2 + "8"], t3[r2][9] = t3[e2 + "9"], t3[r2][10] = t3[e2 + "10"], t3[r2][11] = t3[e2 + "11"], t3[r2][12] = t3[e2 + "12"], t3[r2][13] = t3[e2 + "13"], t3[r2][14] = t3[e2 + "0"], t3[r2][15] = t3[e2 + "0"];
    }
    function nt2(t4) {
      return t4 == Hn || t4 == Wn || t4 == Vn || t4 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t4) {
      return alert("todo:WebPSamplerProcessPlane"), t4.T;
    }
    function ht2(t4, e2) {
      var r2 = t4.T, i4 = e2.ba.f.RGBA, a3 = i4.eb, o3 = i4.fb + t4.ka * i4.A, s3 = vi[e2.ba.S], c4 = t4.y, u4 = t4.O, h4 = t4.f, l4 = t4.N, f4 = t4.ea, d4 = t4.W, p4 = e2.cc, g4 = e2.dc, m4 = e2.Mc, v4 = e2.Nc, b4 = t4.ka, y4 = t4.ka + t4.T, w4 = t4.U, N4 = w4 + 1 >> 1;
      for (0 == b4 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e2.ec, e2.fc, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i4.A, a3, o3, w4), ++r2); b4 + 2 < y4; b4 += 2)
        p4 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t4.Rc, d4 += t4.Rc, o3 += 2 * i4.A, s3(c4, (u4 += 2 * t4.fa) - t4.fa, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i4.A, a3, o3, w4);
      return u4 += t4.fa, t4.j + y4 < t4.o ? (n2(e2.ec, e2.fc, c4, u4, w4), n2(e2.cc, e2.dc, h4, l4, N4), n2(e2.Mc, e2.Nc, f4, d4, N4), r2--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i4.A, null, null, w4), r2;
    }
    function lt2(t4, r2, n3) {
      var i4 = t4.F, a3 = [t4.J];
      if (null != i4) {
        var o3 = t4.U, s3 = r2.ba.S, c4 = s3 == Tn || s3 == Vn;
        r2 = r2.ba.f.RGBA;
        var u4 = [0], h4 = t4.ka;
        u4[0] = t4.T, t4.Kb && (0 == h4 ? --u4[0] : (--h4, a3[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (u4[0] = t4.o - t4.j - h4));
        var l4 = r2.eb;
        h4 = r2.fb + h4 * r2.A;
        t4 = Sn(i4, a3[0], t4.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r2.A), e(n3 == u4), t4 && nt2(s3) && An(l4, h4, c4, o3, u4, r2.A);
      }
      return 0;
    }
    function ft2(t4) {
      var e2 = t4.ma, r2 = e2.ba.S, n3 = 11 > r2, i4 = r2 == qn || r2 == Rn || r2 == Tn || r2 == Un || 12 == r2 || nt2(r2);
      if (e2.memory = null, e2.Ib = null, e2.Jb = null, e2.Nd = null, !Mr(e2.Oa, t4, i4 ? 11 : 12))
        return 0;
      if (i4 && nt2(r2) && br(), t4.da)
        alert("todo:use_scaling");
      else {
        if (n3) {
          if (e2.Ib = ut2, t4.Kb) {
            if (r2 = t4.U + 1 >> 1, e2.memory = a2(t4.U + 2 * r2), null == e2.memory)
              return 0;
            e2.ec = e2.memory, e2.fc = 0, e2.cc = e2.ec, e2.dc = e2.fc + t4.U, e2.Mc = e2.cc, e2.Nc = e2.dc + r2, e2.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i4 && (e2.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci) {
        for (t4 = 0; 256 > t4; ++t4)
          ji[t4] = 89858 * (t4 - 128) + _i >> Si, Mi[t4] = -22014 * (t4 - 128) + _i, Bi[t4] = -45773 * (t4 - 128), Oi[t4] = 113618 * (t4 - 128) + _i >> Si;
        for (t4 = Pi; t4 < ki; ++t4)
          e2 = 76283 * (t4 - 16) + _i >> Si, Ei[t4 - Pi] = Vt2(e2, 255), qi[t4 - Pi] = Vt2(e2 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t4) {
      var r2 = t4.ma, n3 = t4.U, i4 = t4.T;
      return e(!(1 & t4.ka)), 0 >= n3 || 0 >= i4 ? 0 : (n3 = r2.Ib(t4, r2), null != r2.Jb && r2.Jb(t4, r2, n3), r2.Dc += n3, 1);
    }
    function pt2(t4) {
      t4.ma.memory = null;
    }
    function gt2(t4, e2, r2, n3) {
      return 47 != y3(t4, 8) ? 0 : (e2[0] = y3(t4, 14) + 1, r2[0] = y3(t4, 14) + 1, n3[0] = y3(t4, 1), 0 != y3(t4, 3) ? 0 : !t4.h);
    }
    function mt2(t4, e2) {
      if (4 > t4)
        return t4 + 1;
      var r2 = t4 - 2 >> 1;
      return (2 + (1 & t4) << r2) + y3(e2, r2) + 1;
    }
    function vt2(t4, e2) {
      return 120 < e2 ? e2 - 120 : 1 <= (r2 = ((r2 = $n[e2 - 1]) >> 4) * t4 + (8 - (15 & r2))) ? r2 : 1;
      var r2;
    }
    function bt2(t4, e2, r2) {
      var n3 = L3(r2), i4 = t4[e2 += 255 & n3].g - 8;
      return 0 < i4 && (x2(r2, r2.u + 8), n3 = L3(r2), e2 += t4[e2].value, e2 += n3 & (1 << i4) - 1), x2(r2, r2.u + t4[e2].g), t4[e2].value;
    }
    function yt2(t4, r2, n3) {
      return n3.g += t4.g, n3.value += t4.value << r2 >>> 0, e(8 >= n3.g), t4.g;
    }
    function wt2(t4, r2, n3) {
      var i4 = t4.xc;
      return e((r2 = 0 == i4 ? 0 : t4.vc[t4.md * (n3 >> i4) + (r2 >> i4)]) < t4.Wb), t4.Ya[r2];
    }
    function Nt2(t4, r2, i4, a3) {
      var o3 = t4.ab, s3 = t4.c * r2, c4 = t4.C;
      r2 = c4 + r2;
      var u4 = i4, h4 = a3;
      for (a3 = t4.Ta, i4 = t4.Ua; 0 < o3--; ) {
        var l4 = t4.gc[o3], f4 = c4, d4 = r2, p4 = u4, g4 = h4, m4 = (h4 = a3, u4 = i4, l4.Ea);
        switch (e(f4 < d4), e(d4 <= l4.nc), l4.hc) {
          case 2:
            Gr(p4, g4, (d4 - f4) * m4, h4, u4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
            0 == v4 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
            }
            d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; )
                Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
            }
            break;
          case 3:
            if (p4 == h4 && g4 == u4 && 0 < l4.b) {
              for (b4 = h4, p4 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)
                v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4)
                b4[p4 + w4] = v4[w4];
              Yr(l4, f4, d4, h4, m4, h4, u4);
            } else
              Yr(l4, f4, d4, p4, g4, h4, u4);
        }
        u4 = a3, h4 = i4;
      }
      h4 != i4 && n2(a3, i4, u4, h4, s3);
    }
    function Lt2(t4, r2) {
      var n3 = t4.V, i4 = t4.Ba + t4.c * t4.C, a3 = r2 - t4.C;
      if (e(r2 <= t4.l.o), e(16 >= a3), 0 < a3) {
        var o3 = t4.l, s3 = t4.Ta, c4 = t4.Ua, u4 = o3.width;
        if (Nt2(t4, a3, n3, i4), a3 = c4 = [c4], e((n3 = t4.C) < (i4 = r2)), e(o3.v < o3.va), i4 > o3.o && (i4 = o3.o), n3 < o3.j) {
          var h4 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h4 * u4;
        }
        if (n3 >= i4 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i4 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t4.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i4 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
            for (l4 = l4.fb + t4.Ma * l4.A; 0 < d4--; ) {
              var p4 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
              switch (i4) {
                case En:
                  Qr(p4, g4, m4, v4, b4);
                  break;
                case qn:
                  tn(p4, g4, m4, v4, b4);
                  break;
                case Hn:
                  tn(p4, g4, m4, v4, b4), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Dn:
                  nn(p4, g4, m4, v4, b4);
                  break;
                case Rn:
                  et3(p4, g4, m4, v4, b4, 1);
                  break;
                case Wn:
                  et3(p4, g4, m4, v4, b4, 1), An(v4, b4, 0, m4, 1, 0);
                  break;
                case Tn:
                  et3(p4, g4, m4, v4, b4, 0);
                  break;
                case Vn:
                  et3(p4, g4, m4, v4, b4, 0), An(v4, b4, 1, m4, 1, 0);
                  break;
                case Un:
                  en(p4, g4, m4, v4, b4);
                  break;
                case Gn:
                  en(p4, g4, m4, v4, b4), xn(v4, b4, m4, 1, 0);
                  break;
                case zn:
                  rn(p4, g4, m4, v4, b4);
                  break;
                default:
                  e(0);
              }
              c4 += u4, l4 += f4;
            }
            t4.Ma += o3;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e(t4.Ma <= n3.height);
        }
      }
      t4.C = r2, e(t4.C <= t4.i);
    }
    function At2(t4) {
      var e2;
      if (0 < t4.ua)
        return 0;
      for (e2 = 0; e2 < t4.Wb; ++e2) {
        var r2 = t4.Ya[e2].G, n3 = t4.Ya[e2].H;
        if (0 < r2[1][n3[1] + 0].g || 0 < r2[2][n3[2] + 0].g || 0 < r2[3][n3[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t4, r2, n3, i4, a3, o3) {
      if (0 != t4.Z) {
        var s3 = t4.qd, c4 = t4.rd;
        for (e(null != mi[t4.Z]); r2 < n3; ++r2)
          mi[t4.Z](s3, c4, i4, a3, i4, a3, o3), s3 = i4, c4 = a3, a3 += o3;
        t4.qd = s3, t4.rd = c4;
      }
    }
    function St2(t4, r2) {
      var n3 = t4.l.ma, i4 = 0 == n3.Z || 1 == n3.Z ? t4.l.j : t4.C;
      i4 = t4.C < i4 ? i4 : t4.C;
      if (e(r2 <= t4.l.o), r2 > i4) {
        var a3 = t4.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i4, c4 = t4.V, u4 = t4.Ba + t4.c * i4, h4 = t4.gc;
        e(1 == t4.ab), e(3 == h4[0].hc), Xr(h4[0], i4, r2, c4, u4, o3, s3), xt2(n3, i4, r2, o3, s3, a3);
      }
      t4.C = t4.Ma = r2;
    }
    function _t2(t4, r2, n3, i4, a3, o3, s3) {
      var c4 = t4.$ / i4, u4 = t4.$ % i4, h4 = t4.m, l4 = t4.s, f4 = n3 + t4.$, d4 = f4;
      a3 = n3 + i4 * a3;
      var p4 = n3 + i4 * o3, g4 = 280 + l4.ua, m4 = t4.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
      e(t4.C < o3), e(p4 <= a3);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f4 < p4; ) {
            var N4 = 0;
            if (c4 >= m4) {
              var _3 = f4 - n3;
              e((m4 = t4).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B2(m4.s.Wa, m4.s.vb), m4 = c4 + ti;
            }
            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e(null != y4), y4.Qb && (r2[f4] = y4.qb, w4 = true), !w4)
              if (S2(h4), y4.jc) {
                N4 = h4, _3 = r2;
                var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
                e(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
              } else
                N4 = bt2(y4.G[0], y4.H[0], h4);
            if (h4.h)
              break;
            if (w4 || 256 > N4) {
              if (!w4)
                if (y4.nd)
                  r2[f4] = (y4.qb | N4 << 8) >>> 0;
                else {
                  if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h)
                    break;
                  r2[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                }
              if (w4 = false, ++f4, ++u4 >= i4 && (u4 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4), null != v4))
                for (; d4 < f4; )
                  N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i4, _3 = mt2(_3, h4)), h4.h)
                break;
              if (f4 - n3 < _3 || a3 - f4 < N4)
                break t;
              for (P3 = 0; P3 < N4; ++P3)
                r2[f4 + P3] = r2[f4 + P3 - _3];
              for (f4 += N4, u4 += N4; u4 >= i4; )
                u4 -= i4, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t4, c4);
              if (e(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), null != v4)
                for (; d4 < f4; )
                  N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4))
                break t;
              for (w4 = N4 - 280, e(null != v4); d4 < f4; )
                N4 = r2[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e(!(w4 >>> (_3 = v4).Xa)), r2[N4] = _3.X[w4], w4 = true;
            }
            w4 || e(h4.h == A3(h4));
          }
          if (t4.Pb && h4.h && f4 < a3)
            e(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B2(t4.s.vb, t4.s.Wa);
          else {
            if (h4.h)
              break t;
            null != s3 && s3(t4, c4 > o3 ? o3 : c4), t4.a = 0, t4.$ = f4 - n3;
          }
          return 1;
        }
      return t4.a = 3, 0;
    }
    function Pt2(t4) {
      e(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
      var r2 = t4.Wa;
      null != r2 && (r2.X = null), t4.vb = null, e(null != t4);
    }
    function kt2() {
      var e2 = new or();
      return null == e2 ? null : (e2.a = 0, e2.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn = tt2, t3.VP8LMapColor32b = Jr, t3.VP8LMapColor8b = Kr, e2);
    }
    function It2(t4, r2, n3, s3, c4) {
      var u4 = 1, f4 = [t4], p4 = [r2], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n3)
            for (; u4 && y3(g4, 1); ) {
              var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
              if (A4.Oc & 1 << I3)
                u4 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                      var B3, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                      if (null == T3)
                        F3 = 0;
                      else {
                        var U3 = E3.K[0], z3 = E3.w;
                        for (T3[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3)
                          T3[B3] = D2(U3[z3 + B3], T3[B3 - 1]);
                        for (; B3 < 4 * R3; ++B3)
                          T3[B3] = 0;
                        E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                      }
                    }
                    _3 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e(0);
                }
                u4 = _3;
              }
            }
          if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H3;
          if (H3 = u4)
            e: {
              var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et4 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (; ; ) {
                  if (Z3 && y3($3, 1)) {
                    var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et4 && (et4 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o2(et4 * nt3, l3), lt3 = et4, ft3 = o2(lt3, d3);
                  if (null == ft3)
                    var dt3 = null;
                  else
                    e(65536 >= lt3), dt3 = ft3;
                  var pt3 = a2(rt3);
                  if (null == dt3 || null == pt3 || null == ht3) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et4; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                        if (i3(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y3(Ot3, 1) + 1, Et3 = y3(Ot3, 1), qt3 = y3(Ot3, 0 == Et3 ? 1 : 8);
                          kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St3.a = 3;
                            var Ut3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y3(Ot3, 3);
                          var zt3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                          i:
                            for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                              if (y3(Xt3, 1)) {
                                var $t3 = 2 + 2 * y3(Xt3, 3);
                                if ((zt3 = 2 + y3(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                zt3 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x2(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                                else {
                                  var ee3 = 16 == te3, re4 = te3 - 16, ne3 = Jn[re4], ie3 = y3(Xt3, Yn[re4]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                      }
                      if (0 == Ut3)
                        break r;
                      if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et4, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
                  break e;
                }
              H3 = 0;
            }
          if (!(u4 = H3)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, u4 = 0;
              break t;
            }
          } else
            m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
            s3.xb = pi;
            break t;
          }
          if (null == (v4 = a2(f4 * p4))) {
            s3.a = 1, u4 = 0;
            break t;
          }
          u4 = (u4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
          break t;
        }
      return u4 ? (null != c4 ? c4[0] = v4 : (e(null == v4), e(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    function Ft2(t4, r2) {
      var n3 = t4.c * t4.i, i4 = n3 + r2 + 16 * r2;
      return e(t4.c <= r2), t4.V = a2(i4), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + n3 + r2, 1);
    }
    function Ct2(t4, r2) {
      var n3 = t4.C, i4 = r2 - n3, a3 = t4.V, o3 = t4.Ba + t4.c * n3;
      for (e(r2 <= t4.l.o); 0 < i4; ) {
        var s3 = 16 < i4 ? 16 : i4, c4 = t4.l.ma, u4 = t4.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t4.Ta, p4 = t4.Ua;
        Nt2(t4, s3, a3, o3), _n(d4, p4, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i4 -= s3, a3 += s3 * t4.c, n3 += s3;
      }
      e(n3 == r2), t4.C = t4.Ma = r2;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t4 = [];
        return function t5(e2, r2, n3) {
          for (var i4 = n3[r2], a3 = 0; a3 < i4 && (e2.push(n3.length > r2 + 1 ? [] : 0), !(n3.length < r2 + 1)); a3++)
            t5(e2[a3], r2 + 1, n3);
        }(t4, 0, [3, 11]), t4;
      }();
    }
    function Et2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t4, e2) {
      return 0 > t4 ? 0 : t4 > e2 ? e2 : t4;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t4 = new Wt2();
      return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ni || (ni = Zt2)), t4;
    }
    function Jt2(t4, e2, r2) {
      return 0 == t4.a && (t4.a = e2, t4.sc = r2, t4.cb = 0), 0;
    }
    function Xt2(t4, e2, r2) {
      return 3 <= r2 && 157 == t4[e2 + 0] && 1 == t4[e2 + 1] && 42 == t4[e2 + 2];
    }
    function Kt2(t4, r2) {
      if (null == t4)
        return 0;
      if (t4.a = 0, t4.sc = "OK", null == r2)
        return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r2.data, a3 = r2.w, o3 = r2.ha;
      if (4 > o3)
        return Jt2(t4, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t4.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)
        return Jt2(t4, 3, "Incorrect keyframe parameters.");
      if (!c4.yd)
        return Jt2(t4, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t4.Kc;
      if (c4.Rb) {
        if (7 > o3)
          return Jt2(t4, 7, "cannot parse picture header");
        if (!Xt2(n3, a3, o3))
          return Jt2(t4, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t4.za = u4.c + 15 >> 4, t4.Ub = u4.i + 15 >> 4, r2.width = u4.c, r2.height = u4.i, r2.Da = 0, r2.j = 0, r2.v = 0, r2.va = r2.width, r2.o = r2.height, r2.da = 0, r2.ib = r2.width, r2.hb = r2.height, r2.U = r2.width, r2.T = r2.height, i3((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i3(s3.Zb, 0, 0, s3.Zb.length), i3(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3)
        return Jt2(t4, 7, "bad partition length");
      p3(s3 = t4.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t4.Qa;
      var h4, l4 = t4.Pa;
      if (e(null != s3), e(null != u4), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4)
            u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
          for (h4 = 0; 4 > h4; ++h4)
            u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb)
          for (h4 = 0; 3 > h4; ++h4)
            l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
      } else
        u4.Bb = 0;
      if (s3.Ka)
        return Jt2(t4, 3, "cannot parse segment header");
      if ((u4 = t4.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t4.L = 0 == u4.Tb ? 0 : u4.zd ? 1 : 2, s3.Ka)
        return Jt2(t4, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t4.Xb = (1 << g3(t4.m, 2)) - 1, f4 < 3 * (l4 = t4.Xb))
        n3 = 7;
      else {
        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d4 > u4 && (d4 = u4), p3(t4.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
        }
        p3(t4.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
      }
      if (0 != n3)
        return Jt2(t4, n3, "cannot parse partitions");
      for (n3 = g3(h4 = t4.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t4.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += n3);
        } else {
          if (0 < d4) {
            t4.pb[d4] = t4.pb[0];
            continue;
          }
          v4 = n3;
        }
        var b4 = t4.pb[d4];
        b4.Sc[0] = ei[Vt2(v4 + o3, 127)], b4.Sc[1] = ri[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v4 + l4, 117)], b4.Qc[1] = ri[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
      }
      if (!c4.Rb)
        return Jt2(t4, 4, "Not a key frame.");
      for (P2(s3), c4 = t4.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3)
          for (a3 = 0; 3 > a3; ++a3)
            for (u4 = 0; 11 > u4; ++u4)
              l4 = k2(s3, ui[n3][o3][a3][u4]) ? g3(s3, 8) : si[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3)
          c4.Xc[n3][o3] = c4.Wc[n3][hi[o3]];
      }
      return t4.kc = P2(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
    }
    function Zt2(t4, e2, r2, n3, i4, a3, o3) {
      var s3 = e2[i4].Yb[r2];
      for (r2 = 0; 16 > i4; ++i4) {
        if (!k2(t4, s3[r2 + 0]))
          return i4;
        for (; !k2(t4, s3[r2 + 1]); )
          if (s3 = e2[++i4].Yb[0], r2 = 0, 16 == i4)
            return 16;
        var c4 = e2[i4 + 1].Yb;
        if (k2(t4, s3[r2 + 2])) {
          var u4 = t4, h4 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r2) + 3]))
            if (k2(u4, f4[l4 + 6])) {
              for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii[l4]; f4[s3]; ++s3)
                h4 += h4 + k2(u4, f4[s3]);
              h4 += 3 + (8 << l4);
            } else
              k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
          else
            h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else
          h4 = 1, s3 = c4[1];
        c4 = o3 + ai[i4], 0 > (u4 = t4).b && _2(u4);
        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i4) + 0];
      }
      return 16;
    }
    function $t2(t4) {
      var e2 = t4.rb[t4.sb - 1];
      e2.la = 0, e2.Na = 0, i3(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
    }
    function Qt2(t4, r2) {
      if (null == t4)
        return 0;
      if (null == r2)
        return Jt2(t4, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t4.cb && !Kt2(t4, r2))
        return 0;
      if (e(t4.cb), null == r2.ac || r2.ac(r2)) {
        r2.ob && (t4.L = 0);
        var s3 = Ri[t4.L];
        if (2 == t4.L ? (t4.yb = 0, t4.zb = 0) : (t4.yb = r2.v - s3 >> 4, t4.zb = r2.j - s3 >> 4, 0 > t4.yb && (t4.yb = 0), 0 > t4.zb && (t4.zb = 0)), t4.Va = r2.o + 15 + s3 >> 4, t4.Hb = r2.va + 15 + s3 >> 4, t4.Hb > t4.za && (t4.Hb = t4.za), t4.Va > t4.Ub && (t4.Va = t4.Ub), 0 < t4.L) {
          var c4 = t4.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t4.Qa.Cb) {
              var h4 = t4.Qa.Lb[s3];
              t4.Qa.Fb || (h4 += c4.Tb);
            } else
              h4 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t4.gd[s3][u4], f4 = h4;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d4 = f4;
                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else
                l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else
        Jt2(t4, 6, "Frame setup failed"), s3 = t4.a;
      if (s3 = 0 == s3) {
        if (s3) {
          t4.$c = 0, 0 < t4.Aa || (t4.Ic = Ui);
          t: {
            s3 = t4.Ic;
            c4 = 4 * (d4 = t4.za);
            var p4 = 32 * d4, g4 = d4 + 1, m4 = 0 < t4.L ? d4 * (0 < t4.Aa ? 2 : 1) : 0, v4 = (2 == t4.Aa ? 2 : 1) * d4;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri[t4.L]) / 2 * p4) + (h4 = null != t4.Fa && 0 < t4.Fa.length ? t4.Kc.c * t4.Kc.i : 0)) != l4)
              s3 = 0;
            else {
              if (l4 > t4.Vb) {
                if (t4.Vb = 0, t4.Ec = a2(l4), t4.Fc = 0, null == t4.Ec) {
                  s3 = Jt2(t4, 1, "no memory during frame initialization.");
                  break t;
                }
                t4.Vb = l4;
              }
              l4 = t4.Ec, f4 = t4.Fc, t4.Ac = l4, t4.Bc = f4, f4 += c4, t4.Gd = o2(p4, Ht2), t4.Hd = 0, t4.rb = o2(g4 + 1, Rt2), t4.sb = 1, t4.wa = m4 ? o2(m4, Dt2) : null, t4.Y = 0, t4.D.Nb = 0, t4.D.wa = t4.wa, t4.D.Y = t4.Y, 0 < t4.Aa && (t4.D.Y += d4), e(true), t4.oc = l4, t4.pc = f4, f4 += 832, t4.ya = o2(v4, Ut2), t4.aa = 0, t4.D.ya = t4.ya, t4.D.aa = t4.aa, 2 == t4.Aa && (t4.D.aa += d4), t4.R = 16 * d4, t4.B = 8 * d4, d4 = (p4 = Ri[t4.L]) * t4.R, p4 = p4 / 2 * t4.B, t4.sa = l4, t4.ta = f4 + d4, t4.qa = t4.sa, t4.ra = t4.ta + 16 * s3 * t4.R + p4, t4.Ha = t4.qa, t4.Ia = t4.ra + 8 * s3 * t4.B + p4, t4.$c = 0, f4 += u4, t4.mb = h4 ? l4 : null, t4.nb = h4 ? f4 : null, e(f4 + h4 <= t4.Fc + t4.Vb), $t2(t4), i3(t4.Ac, t4.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r2.ka = 0, r2.y = t4.sa, r2.O = t4.ta, r2.f = t4.qa, r2.N = t4.ra, r2.ea = t4.Ha, r2.Vd = t4.Ia, r2.fa = t4.R, r2.Rc = t4.B, r2.F = null, r2.J = 0, !Cn) {
              for (s3 = -255; 255 >= s3; ++s3)
                Pn[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3)
                kn[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3)
                In[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3)
                Fn[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn = 1;
            }
            an = ue2, on2 = ae2, cn = oe2, un = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s3 = 1;
          } else
            s3 = 0;
        }
        s3 && (s3 = function(t5, r3) {
          for (t5.M = 0; t5.M < t5.Va; ++t5.M) {
            var o3, s4 = t5.Jc[t5.M & t5.Xb], c5 = t5.m, u5 = t5;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v5 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p5[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci[f5[d5 + b4]][y4];
                    for (var w4 = oi[k2(h5, y4[0])]; 0 < w4; )
                      w4 = oi[2 * w4 + k2(h5, y4[w4])];
                    y4 = -w4, f5[d5 + b4] = y4;
                  }
                  n2(m5, v5, f5, d5, 4), v5 += 4, p5[0 + l5] = y4;
                }
              } else
                y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i3(f5, d5, y4, 4), i3(p5, 0, y4, 4);
              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka)
              return Jt2(t5, 7, "Premature end-of-partition0 encountered.");
            for (; t5.ja < t5.za; ++t5.ja) {
              if (u5 = s4, h5 = (c5 = t5).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)
                h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                if (l5 = p5.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i3(l5, m5, 0, 384), p5.Za)
                  var A4 = 0, x3 = d5[3];
                else {
                  w4 = a2(16);
                  var S3 = h5.Na + v5.Na;
                  if (S3 = ni(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h5.la, I3 = 15 & v5.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h5.la = x3, v5.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)
                return Jt2(t5, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t5), c5 = r3, u5 = 1, o3 = (s4 = t5).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, 0 == s4.Aa)
              t: {
                if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p5 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = 0 == (P3 = L4.M), b4 = P3 >= s4.Va - 1, 2 == s4.Aa && Or(s4, L4), L4.uc)
                  for (F3 = (S3 = s4).D.M, e(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j3 = (U3 = S3).D).Nb;
                    N4 = U3.R;
                    var j3 = j3.wa[j3.Y + A4], O3 = U3.sa, B3 = U3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (0 != E3)
                      if (e(3 <= E3), 1 == U3.L)
                        0 < A4 && wn(O3, B3, N4, E3 + 4), j3.La && Ln(O3, B3, N4, E3), 0 < x3 && yn(O3, B3, N4, E3 + 4), j3.La && Nn(O3, B3, N4, E3);
                      else {
                        var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T3 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn(O3, B3, N4, E3 + 4, M3, C3), pn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (mn(O3, B3, N4, E3, M3, C3), bn(D3, R3, T3, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B3, N4, E3 + 4, M3, C3), dn(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (gn(O3, B3, N4, E3, M3, C3), vn(D3, R3, T3, U3, q3, E3, M3, C3));
                      }
                  }
                if (s4.ia && alert("todo:DitherRow"), null != c5.put) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, null != s4.Fa && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, null == c5.F && 0 == c5.F.length)) {
                    u5 = Jt2(s4, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), null != c5.F && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, null != c5.F && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                }
                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p5 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
              }
            if (!u5)
              return Jt2(t5, 6, "Output aborted.");
          }
          return 1;
        }(t4, r2)), null != r2.bc && r2.bc(r2), s3 &= 1;
      }
      return s3 ? (t4.cb = 0, s3) : 0;
    }
    function te2(t4, e2, r2, n3, i4) {
      i4 = t4[e2 + r2 + 32 * n3] + (i4 >> 3), t4[e2 + r2 + 32 * n3] = -256 & i4 ? 0 > i4 ? 0 : 255 : i4;
    }
    function ee2(t4, e2, r2, n3, i4, a3) {
      te2(t4, e2, 0, r2, n3 + i4), te2(t4, e2, 1, r2, n3 + a3), te2(t4, e2, 2, r2, n3 - a3), te2(t4, e2, 3, r2, n3 - i4);
    }
    function re3(t4) {
      return (20091 * t4 >> 16) + t4;
    }
    function ne2(t4, e2, r2, n3) {
      var i4, o3 = 0, s3 = a2(16);
      for (i4 = 0; 4 > i4; ++i4) {
        var c4 = t4[e2 + 0] + t4[e2 + 8], u4 = t4[e2 + 0] - t4[e2 + 8], h4 = (35468 * t4[e2 + 4] >> 16) - re3(t4[e2 + 12]), l4 = re3(t4[e2 + 4]) + (35468 * t4[e2 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e2++;
      }
      for (i4 = o3 = 0; 4 > i4; ++i4)
        c4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t4 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re3(s3[o3 + 12]), te2(r2, n3, 0, 0, c4 + (l4 = re3(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r2, n3, 1, 0, u4 + h4), te2(r2, n3, 2, 0, u4 - h4), te2(r2, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    function ie2(t4, e2, r2, n3) {
      var i4 = t4[e2 + 0] + 4, a3 = 35468 * t4[e2 + 4] >> 16, o3 = re3(t4[e2 + 4]), s3 = 35468 * t4[e2 + 1] >> 16;
      ee2(r2, n3, 0, i4 + o3, t4 = re3(t4[e2 + 1]), s3), ee2(r2, n3, 1, i4 + a3, t4, s3), ee2(r2, n3, 2, i4 - a3, t4, s3), ee2(r2, n3, 3, i4 - o3, t4, s3);
    }
    function ae2(t4, e2, r2, n3, i4) {
      ne2(t4, e2, r2, n3), i4 && ne2(t4, e2 + 16, r2, n3 + 4);
    }
    function oe2(t4, e2, r2, n3) {
      on2(t4, e2 + 0, r2, n3, 1), on2(t4, e2 + 32, r2, n3 + 128, 1);
    }
    function se2(t4, e2, r2, n3) {
      var i4;
      for (t4 = t4[e2 + 0] + 4, i4 = 0; 4 > i4; ++i4)
        for (e2 = 0; 4 > e2; ++e2)
          te2(r2, n3, e2, i4, t4);
    }
    function ce2(t4, e2, r2, n3) {
      t4[e2 + 0] && un(t4, e2 + 0, r2, n3), t4[e2 + 16] && un(t4, e2 + 16, r2, n3 + 4), t4[e2 + 32] && un(t4, e2 + 32, r2, n3 + 128), t4[e2 + 48] && un(t4, e2 + 48, r2, n3 + 128 + 4);
    }
    function ue2(t4, e2, r2, n3) {
      var i4, o3 = a2(16);
      for (i4 = 0; 4 > i4; ++i4) {
        var s3 = t4[e2 + 0 + i4] + t4[e2 + 12 + i4], c4 = t4[e2 + 4 + i4] + t4[e2 + 8 + i4], u4 = t4[e2 + 4 + i4] - t4[e2 + 8 + i4], h4 = t4[e2 + 0 + i4] - t4[e2 + 12 + i4];
        o3[0 + i4] = s3 + c4, o3[8 + i4] = s3 - c4, o3[4 + i4] = h4 + u4, o3[12 + i4] = h4 - u4;
      }
      for (i4 = 0; 4 > i4; ++i4)
        s3 = (t4 = o3[0 + 4 * i4] + 3) + o3[3 + 4 * i4], c4 = o3[1 + 4 * i4] + o3[2 + 4 * i4], u4 = o3[1 + 4 * i4] - o3[2 + 4 * i4], h4 = t4 - o3[3 + 4 * i4], r2[n3 + 0] = s3 + c4 >> 3, r2[n3 + 16] = h4 + u4 >> 3, r2[n3 + 32] = s3 - c4 >> 3, r2[n3 + 48] = h4 - u4 >> 3, n3 += 64;
    }
    function he2(t4, e2, r2) {
      var n3, i4 = e2 - 32, a3 = Bn, o3 = 255 - t4[i4 - 1];
      for (n3 = 0; n3 < r2; ++n3) {
        var s3, c4 = a3, u4 = o3 + t4[e2 - 1];
        for (s3 = 0; s3 < r2; ++s3)
          t4[e2 + s3] = c4[u4 + t4[i4 + s3]];
        e2 += 32;
      }
    }
    function le2(t4, e2) {
      he2(t4, e2, 4);
    }
    function fe2(t4, e2) {
      he2(t4, e2, 8);
    }
    function de2(t4, e2) {
      he2(t4, e2, 16);
    }
    function pe2(t4, e2) {
      var r2;
      for (r2 = 0; 16 > r2; ++r2)
        n2(t4, e2 + 32 * r2, t4, e2 - 32, 16);
    }
    function ge2(t4, e2) {
      var r2;
      for (r2 = 16; 0 < r2; --r2)
        i3(t4, e2, t4[e2 - 1], 16), e2 += 32;
    }
    function me2(t4, e2, r2) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3)
        i3(e2, r2 + 32 * n3, t4, 16);
    }
    function ve2(t4, e2) {
      var r2, n3 = 16;
      for (r2 = 0; 16 > r2; ++r2)
        n3 += t4[e2 - 1 + 32 * r2] + t4[e2 + r2 - 32];
      me2(n3 >> 5, t4, e2);
    }
    function be2(t4, e2) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2)
        n3 += t4[e2 - 1 + 32 * r2];
      me2(n3 >> 4, t4, e2);
    }
    function ye2(t4, e2) {
      var r2, n3 = 8;
      for (r2 = 0; 16 > r2; ++r2)
        n3 += t4[e2 + r2 - 32];
      me2(n3 >> 4, t4, e2);
    }
    function we2(t4, e2) {
      me2(128, t4, e2);
    }
    function Ne2(t4, e2, r2) {
      return t4 + 2 * e2 + r2 + 2 >> 2;
    }
    function Le2(t4, e2) {
      var r2, i4 = e2 - 32;
      i4 = new Uint8Array([Ne2(t4[i4 - 1], t4[i4 + 0], t4[i4 + 1]), Ne2(t4[i4 + 0], t4[i4 + 1], t4[i4 + 2]), Ne2(t4[i4 + 1], t4[i4 + 2], t4[i4 + 3]), Ne2(t4[i4 + 2], t4[i4 + 3], t4[i4 + 4])]);
      for (r2 = 0; 4 > r2; ++r2)
        n2(t4, e2 + 32 * r2, i4, 0, i4.length);
    }
    function Ae(t4, e2) {
      var r2 = t4[e2 - 1], n3 = t4[e2 - 1 + 32], i4 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96];
      I2(t4, e2 + 0, 16843009 * Ne2(t4[e2 - 1 - 32], r2, n3)), I2(t4, e2 + 32, 16843009 * Ne2(r2, n3, i4)), I2(t4, e2 + 64, 16843009 * Ne2(n3, i4, a3)), I2(t4, e2 + 96, 16843009 * Ne2(i4, a3, a3));
    }
    function xe(t4, e2) {
      var r2, n3 = 4;
      for (r2 = 0; 4 > r2; ++r2)
        n3 += t4[e2 + r2 - 32] + t4[e2 - 1 + 32 * r2];
      for (n3 >>= 3, r2 = 0; 4 > r2; ++r2)
        i3(t4, e2 + 32 * r2, n3, 4);
    }
    function Se(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i4 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 - 32], o3 = t4[e2 + 0 - 32], s3 = t4[e2 + 1 - 32], c4 = t4[e2 + 2 - 32], u4 = t4[e2 + 3 - 32];
      t4[e2 + 0 + 96] = Ne2(n3, i4, t4[e2 - 1 + 96]), t4[e2 + 1 + 96] = t4[e2 + 0 + 64] = Ne2(r2, n3, i4), t4[e2 + 2 + 96] = t4[e2 + 1 + 64] = t4[e2 + 0 + 32] = Ne2(a3, r2, n3), t4[e2 + 3 + 96] = t4[e2 + 2 + 64] = t4[e2 + 1 + 32] = t4[e2 + 0 + 0] = Ne2(o3, a3, r2), t4[e2 + 3 + 64] = t4[e2 + 2 + 32] = t4[e2 + 1 + 0] = Ne2(s3, o3, a3), t4[e2 + 3 + 32] = t4[e2 + 2 + 0] = Ne2(c4, s3, o3), t4[e2 + 3 + 0] = Ne2(u4, c4, s3);
    }
    function _e(t4, e2) {
      var r2 = t4[e2 + 1 - 32], n3 = t4[e2 + 2 - 32], i4 = t4[e2 + 3 - 32], a3 = t4[e2 + 4 - 32], o3 = t4[e2 + 5 - 32], s3 = t4[e2 + 6 - 32], c4 = t4[e2 + 7 - 32];
      t4[e2 + 0 + 0] = Ne2(t4[e2 + 0 - 32], r2, n3), t4[e2 + 1 + 0] = t4[e2 + 0 + 32] = Ne2(r2, n3, i4), t4[e2 + 2 + 0] = t4[e2 + 1 + 32] = t4[e2 + 0 + 64] = Ne2(n3, i4, a3), t4[e2 + 3 + 0] = t4[e2 + 2 + 32] = t4[e2 + 1 + 64] = t4[e2 + 0 + 96] = Ne2(i4, a3, o3), t4[e2 + 3 + 32] = t4[e2 + 2 + 64] = t4[e2 + 1 + 96] = Ne2(a3, o3, s3), t4[e2 + 3 + 64] = t4[e2 + 2 + 96] = Ne2(o3, s3, c4), t4[e2 + 3 + 96] = Ne2(s3, c4, c4);
    }
    function Pe(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i4 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 - 32], o3 = t4[e2 + 0 - 32], s3 = t4[e2 + 1 - 32], c4 = t4[e2 + 2 - 32], u4 = t4[e2 + 3 - 32];
      t4[e2 + 0 + 0] = t4[e2 + 1 + 64] = a3 + o3 + 1 >> 1, t4[e2 + 1 + 0] = t4[e2 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 3 + 64] = s3 + c4 + 1 >> 1, t4[e2 + 3 + 0] = c4 + u4 + 1 >> 1, t4[e2 + 0 + 96] = Ne2(i4, n3, r2), t4[e2 + 0 + 64] = Ne2(n3, r2, a3), t4[e2 + 0 + 32] = t4[e2 + 1 + 96] = Ne2(r2, a3, o3), t4[e2 + 1 + 32] = t4[e2 + 2 + 96] = Ne2(a3, o3, s3), t4[e2 + 2 + 32] = t4[e2 + 3 + 96] = Ne2(o3, s3, c4), t4[e2 + 3 + 32] = Ne2(s3, c4, u4);
    }
    function ke(t4, e2) {
      var r2 = t4[e2 + 0 - 32], n3 = t4[e2 + 1 - 32], i4 = t4[e2 + 2 - 32], a3 = t4[e2 + 3 - 32], o3 = t4[e2 + 4 - 32], s3 = t4[e2 + 5 - 32], c4 = t4[e2 + 6 - 32], u4 = t4[e2 + 7 - 32];
      t4[e2 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e2 + 1 + 0] = t4[e2 + 0 + 64] = n3 + i4 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 1 + 64] = i4 + a3 + 1 >> 1, t4[e2 + 3 + 0] = t4[e2 + 2 + 64] = a3 + o3 + 1 >> 1, t4[e2 + 0 + 32] = Ne2(r2, n3, i4), t4[e2 + 1 + 32] = t4[e2 + 0 + 96] = Ne2(n3, i4, a3), t4[e2 + 2 + 32] = t4[e2 + 1 + 96] = Ne2(i4, a3, o3), t4[e2 + 3 + 32] = t4[e2 + 2 + 96] = Ne2(a3, o3, s3), t4[e2 + 3 + 64] = Ne2(o3, s3, c4), t4[e2 + 3 + 96] = Ne2(s3, c4, u4);
    }
    function Ie(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i4 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96];
      t4[e2 + 0 + 0] = r2 + n3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 0 + 32] = n3 + i4 + 1 >> 1, t4[e2 + 2 + 32] = t4[e2 + 0 + 64] = i4 + a3 + 1 >> 1, t4[e2 + 1 + 0] = Ne2(r2, n3, i4), t4[e2 + 3 + 0] = t4[e2 + 1 + 32] = Ne2(n3, i4, a3), t4[e2 + 3 + 32] = t4[e2 + 1 + 64] = Ne2(i4, a3, a3), t4[e2 + 3 + 64] = t4[e2 + 2 + 64] = t4[e2 + 0 + 96] = t4[e2 + 1 + 96] = t4[e2 + 2 + 96] = t4[e2 + 3 + 96] = a3;
    }
    function Fe(t4, e2) {
      var r2 = t4[e2 - 1 + 0], n3 = t4[e2 - 1 + 32], i4 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96], o3 = t4[e2 - 1 - 32], s3 = t4[e2 + 0 - 32], c4 = t4[e2 + 1 - 32], u4 = t4[e2 + 2 - 32];
      t4[e2 + 0 + 0] = t4[e2 + 2 + 32] = r2 + o3 + 1 >> 1, t4[e2 + 0 + 32] = t4[e2 + 2 + 64] = n3 + r2 + 1 >> 1, t4[e2 + 0 + 64] = t4[e2 + 2 + 96] = i4 + n3 + 1 >> 1, t4[e2 + 0 + 96] = a3 + i4 + 1 >> 1, t4[e2 + 3 + 0] = Ne2(s3, c4, u4), t4[e2 + 2 + 0] = Ne2(o3, s3, c4), t4[e2 + 1 + 0] = t4[e2 + 3 + 32] = Ne2(r2, o3, s3), t4[e2 + 1 + 32] = t4[e2 + 3 + 64] = Ne2(n3, r2, o3), t4[e2 + 1 + 64] = t4[e2 + 3 + 96] = Ne2(i4, n3, r2), t4[e2 + 1 + 96] = Ne2(a3, i4, n3);
    }
    function Ce(t4, e2) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2)
        n2(t4, e2 + 32 * r2, t4, e2 - 32, 8);
    }
    function je(t4, e2) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2)
        i3(t4, e2, t4[e2 - 1], 8), e2 += 32;
    }
    function Oe(t4, e2, r2) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3)
        i3(e2, r2 + 32 * n3, t4, 8);
    }
    function Be(t4, e2) {
      var r2, n3 = 8;
      for (r2 = 0; 8 > r2; ++r2)
        n3 += t4[e2 + r2 - 32] + t4[e2 - 1 + 32 * r2];
      Oe(n3 >> 4, t4, e2);
    }
    function Me(t4, e2) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2)
        n3 += t4[e2 + r2 - 32];
      Oe(n3 >> 3, t4, e2);
    }
    function Ee(t4, e2) {
      var r2, n3 = 4;
      for (r2 = 0; 8 > r2; ++r2)
        n3 += t4[e2 - 1 + 32 * r2];
      Oe(n3 >> 3, t4, e2);
    }
    function qe(t4, e2) {
      Oe(128, t4, e2);
    }
    function De(t4, e2, r2) {
      var n3 = t4[e2 - r2], i4 = t4[e2 + 0], a3 = 3 * (i4 - n3) + jn[1020 + t4[e2 - 2 * r2] - t4[e2 + r2]], o3 = On[112 + (a3 + 4 >> 3)];
      t4[e2 - r2] = Bn[255 + n3 + On[112 + (a3 + 3 >> 3)]], t4[e2 + 0] = Bn[255 + i4 - o3];
    }
    function Re(t4, e2, r2, n3) {
      var i4 = t4[e2 + 0], a3 = t4[e2 + r2];
      return Mn[255 + t4[e2 - 2 * r2] - t4[e2 - r2]] > n3 || Mn[255 + a3 - i4] > n3;
    }
    function Te(t4, e2, r2, n3) {
      return 4 * Mn[255 + t4[e2 - r2] - t4[e2 + 0]] + Mn[255 + t4[e2 - 2 * r2] - t4[e2 + r2]] <= n3;
    }
    function Ue(t4, e2, r2, n3, i4) {
      var a3 = t4[e2 - 3 * r2], o3 = t4[e2 - 2 * r2], s3 = t4[e2 - r2], c4 = t4[e2 + 0], u4 = t4[e2 + r2], h4 = t4[e2 + 2 * r2], l4 = t4[e2 + 3 * r2];
      return 4 * Mn[255 + s3 - c4] + Mn[255 + o3 - u4] > n3 ? 0 : Mn[255 + t4[e2 - 4 * r2] - a3] <= i4 && Mn[255 + a3 - o3] <= i4 && Mn[255 + o3 - s3] <= i4 && Mn[255 + l4 - h4] <= i4 && Mn[255 + h4 - u4] <= i4 && Mn[255 + u4 - c4] <= i4;
    }
    function ze(t4, e2, r2, n3) {
      var i4 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t4, e2 + n3, r2, i4) && De(t4, e2 + n3, r2);
    }
    function He(t4, e2, r2, n3) {
      var i4 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te(t4, e2 + n3 * r2, 1, i4) && De(t4, e2 + n3 * r2, 1);
    }
    function We(t4, e2, r2, n3) {
      var i4;
      for (i4 = 3; 0 < i4; --i4)
        ze(t4, e2 += 4 * r2, r2, n3);
    }
    function Ve(t4, e2, r2, n3) {
      var i4;
      for (i4 = 3; 0 < i4; --i4)
        He(t4, e2 += 4, r2, n3);
    }
    function Ge(t4, e2, r2, n3, i4, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i4--; ) {
        if (Ue(t4, e2, r2, a3, o3))
          if (Re(t4, e2, r2, s3))
            De(t4, e2, r2);
          else {
            var c4 = t4, u4 = e2, h4 = r2, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p4 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn[1020 + 3 * (d4 - f4) + jn[1020 + l4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c4[u4 - 3 * h4] = Bn[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn[255 + l4 + v4], c4[u4 - h4] = Bn[255 + f4 + m4], c4[u4 + 0] = Bn[255 + d4 - m4], c4[u4 + h4] = Bn[255 + p4 - v4], c4[u4 + 2 * h4] = Bn[255 + g4 - b4];
          }
        e2 += n3;
      }
    }
    function Ye(t4, e2, r2, n3, i4, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i4--; ) {
        if (Ue(t4, e2, r2, a3, o3))
          if (Re(t4, e2, r2, s3))
            De(t4, e2, r2);
          else {
            var c4 = t4, u4 = e2, h4 = r2, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p4 = On[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
            c4[u4 - 2 * h4] = Bn[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn[255 + l4 + g4], c4[u4 + 0] = Bn[255 + f4 - p4], c4[u4 + h4] = Bn[255 + d4 - m4];
          }
        e2 += n3;
      }
    }
    function Je(t4, e2, r2, n3, i4, a3) {
      Ge(t4, e2, r2, 1, 16, n3, i4, a3);
    }
    function Xe(t4, e2, r2, n3, i4, a3) {
      Ge(t4, e2, 1, r2, 16, n3, i4, a3);
    }
    function Ke(t4, e2, r2, n3, i4, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t4, e2 += 4 * r2, r2, 1, 16, n3, i4, a3);
    }
    function Ze(t4, e2, r2, n3, i4, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye(t4, e2 += 4, 1, r2, 16, n3, i4, a3);
    }
    function $e(t4, e2, r2, n3, i4, a3, o3, s3) {
      Ge(t4, e2, i4, 1, 8, a3, o3, s3), Ge(r2, n3, i4, 1, 8, a3, o3, s3);
    }
    function Qe(t4, e2, r2, n3, i4, a3, o3, s3) {
      Ge(t4, e2, 1, i4, 8, a3, o3, s3), Ge(r2, n3, 1, i4, 8, a3, o3, s3);
    }
    function tr(t4, e2, r2, n3, i4, a3, o3, s3) {
      Ye(t4, e2 + 4 * i4, i4, 1, 8, a3, o3, s3), Ye(r2, n3 + 4 * i4, i4, 1, 8, a3, o3, s3);
    }
    function er(t4, e2, r2, n3, i4, a3, o3, s3) {
      Ye(t4, e2 + 4, 1, i4, 8, a3, o3, s3), Ye(r2, n3 + 4, 1, i4, 8, a3, o3, s3);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t4, e2, r2, n3, i4, a3, o3) {
      for (t4 = null == t4 ? 0 : t4[e2 + 0], e2 = 0; e2 < o3; ++e2)
        i4[a3 + e2] = t4 + r2[n3 + e2] & 255, t4 = i4[a3 + e2];
    }
    function ur(t4, e2, r2, n3, i4, a3, o3) {
      var s3;
      if (null == t4)
        cr(null, null, r2, n3, i4, a3, o3);
      else
        for (s3 = 0; s3 < o3; ++s3)
          i4[a3 + s3] = t4[e2 + s3] + r2[n3 + s3] & 255;
    }
    function hr(t4, e2, r2, n3, i4, a3, o3) {
      if (null == t4)
        cr(null, null, r2, n3, i4, a3, o3);
      else {
        var s3, c4 = t4[e2 + 0], u4 = c4, h4 = c4;
        for (s3 = 0; s3 < o3; ++s3)
          u4 = h4 + (c4 = t4[e2 + s3]) - u4, h4 = r2[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i4[a3 + s3] = h4;
      }
    }
    function lr(t4, r2, i4, o3) {
      var s3 = r2.width, c4 = r2.o;
      if (e(null != t4 && null != r2), 0 > i4 || 0 >= o3 || i4 + o3 > c4)
        return null;
      if (!t4.Cc) {
        if (null == t4.ga) {
          var u4;
          if (t4.ga = new sr(), (u4 = null == t4.ga) || (u4 = r2.width * r2.o, e(0 == t4.Gb.length), t4.Gb = a2(u4), t4.Uc = 0, null == t4.Gb ? u4 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t4.ga;
            var h4 = t4.Fa, l4 = t4.P, f4 = t4.qc, d4 = t4.mb, p4 = t4.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e(null != h4 && null != d4 && null != r2), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr, u4.ca = d4, u4.tb = p4, u4.c = r2.width, u4.i = r2.height, e(0 < u4.c && 0 < u4.i), 1 >= f4)
              r2 = 0;
            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)
              r2 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r2.width, b4.height = r2.height, b4.Da = r2.Da, b4.v = r2.v, b4.va = r2.va, b4.j = r2.j, b4.o = r2.o, u4.$a)
              t: {
                e(1 == u4.$a), r2 = kt2();
                e:
                  for (; ; ) {
                    if (null == r2) {
                      r2 = 0;
                      break t;
                    }
                    if (e(null != u4), u4.mc = r2, r2.c = u4.c, r2.i = u4.i, r2.l = u4.l, r2.l.ma = u4, r2.l.width = u4.c, r2.l.height = u4.i, r2.a = 0, v3(r2.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r2, null))
                      break e;
                    if (1 == r2.ab && 3 == r2.gc[0].hc && At2(r2.s) ? (u4.ic = 1, h4 = r2.c * r2.i, r2.Ta = null, r2.Ua = 0, r2.V = a2(h4), r2.Ba = 0, null == r2.V ? (r2.a = 1, r2 = 0) : r2 = 1) : (u4.ic = 0, r2 = Ft2(r2, u4.c)), !r2)
                      break e;
                    r2 = 1;
                    break t;
                  }
                u4.mc = null, r2 = 0;
              }
            else
              r2 = m4 >= u4.c * u4.i;
            u4 = !r2;
          }
          if (u4)
            return null;
          1 != t4.ga.Lc ? t4.Ga = 0 : o3 = c4 - i4;
        }
        e(null != t4.ga), e(i4 + o3 <= c4);
        t: {
          if (r2 = (h4 = t4.ga).c, c4 = h4.l.o, 0 == h4.$a) {
            if (g4 = t4.rc, m4 = t4.Vc, b4 = t4.Fa, l4 = t4.P + 1 + i4 * r2, f4 = t4.mb, d4 = t4.nb + i4 * r2, e(l4 <= t4.P + t4.qc), 0 != h4.Z)
              for (e(null != mi[h4.Z]), u4 = 0; u4 < o3; ++u4)
                mi[h4.Z](g4, m4, b4, l4, f4, d4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
            else
              for (u4 = 0; u4 < o3; ++u4)
                n2(f4, d4, b4, l4, r2), g4 = f4, m4 = d4, d4 += r2, l4 += r2;
            t4.rc = g4, t4.Vc = m4;
          } else {
            if (e(null != h4.mc), r2 = i4 + o3, e(null != (u4 = h4.mc)), e(r2 <= u4.i), u4.C >= r2)
              r2 = 1;
            else if (h4.ic || mr(), h4.ic) {
              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r2, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
              e(w4 <= N4), e(r2 <= y4), e(At2(p4));
              e:
                for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))
                      h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3)
                        h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; )
                        f4 -= m4, ++l4 <= r2 && !(l4 % 16) && St2(u4, l4);
                      w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                    }
                    e(d4.h == A3(d4));
                  }
                  St2(u4, l4 > r2 ? r2 : l4);
                  break e;
                }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r2 = b4;
            } else
              r2 = _t2(u4, u4.V, u4.Ba, u4.c, u4.i, r2, Ct2);
            if (!r2) {
              o3 = 0;
              break t;
            }
          }
          i4 + o3 >= c4 && (t4.Cc = 1), o3 = 1;
        }
        if (!o3)
          return null;
        if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t4.nb + i4 * s3;
    }
    function fr(t4, e2, r2, n3, i4, a3) {
      for (; 0 < i4--; ) {
        var o3, s3 = t4, c4 = e2 + (r2 ? 1 : 0), u4 = t4, h4 = e2 + (r2 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h4 + 4 * o3];
          255 != l4 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e2 += a3;
      }
    }
    function dr(t4, e2, r2, n3, i4) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r2; ++a3) {
          var o3 = t4[e2 + 2 * a3 + 0], s3 = 15 & (u4 = t4[e2 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t4[e2 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t4[e2 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e2 += i4;
      }
    }
    function pr(t4, e2, r2, n3, i4, a3, o3, s3) {
      var c4, u4, h4 = 255;
      for (u4 = 0; u4 < i4; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t4[e2 + c4];
          a3[o3 + 4 * c4] = l4, h4 &= l4;
        }
        e2 += r2, o3 += s3;
      }
      return 255 != h4;
    }
    function gr(t4, e2, r2, n3, i4) {
      var a3;
      for (a3 = 0; a3 < i4; ++a3)
        r2[n3 + a3] = t4[e2 + a3] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r2, n3, i4) {
      t3[r2] = function(t4, r3, a3, o3, s3, c4, u4, h4, l4, f4, d4, p4, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p4 + 0] << 16;
        e(null != t4);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t4[r3 + 0], 255 & x3, x3 >> 16, g4, m4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t4[r3 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i4), n3(t4[r3 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i4), null != a3 && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i4), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i4)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t4[r3 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i4)));
      };
    }
    function br() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t4) {
      return t4 & ~Fi ? 0 > t4 ? 0 : 255 : t4 >> Ii;
    }
    function wr(t4, e2) {
      return yr((19077 * t4 >> 8) + (26149 * e2 >> 8) - 14234);
    }
    function Nr(t4, e2, r2) {
      return yr((19077 * t4 >> 8) - (6419 * e2 >> 8) - (13320 * r2 >> 8) + 8708);
    }
    function Lr(t4, e2) {
      return yr((19077 * t4 >> 8) + (33050 * e2 >> 8) - 17685);
    }
    function Ar(t4, e2, r2, n3, i4) {
      n3[i4 + 0] = wr(t4, r2), n3[i4 + 1] = Nr(t4, e2, r2), n3[i4 + 2] = Lr(t4, e2);
    }
    function xr(t4, e2, r2, n3, i4) {
      n3[i4 + 0] = Lr(t4, e2), n3[i4 + 1] = Nr(t4, e2, r2), n3[i4 + 2] = wr(t4, r2);
    }
    function Sr(t4, e2, r2, n3, i4) {
      var a3 = Nr(t4, e2, r2);
      e2 = a3 << 3 & 224 | Lr(t4, e2) >> 3, n3[i4 + 0] = 248 & wr(t4, r2) | a3 >> 5, n3[i4 + 1] = e2;
    }
    function _r(t4, e2, r2, n3, i4) {
      var a3 = 240 & Lr(t4, e2) | 15;
      n3[i4 + 0] = 240 & wr(t4, r2) | Nr(t4, e2, r2) >> 4, n3[i4 + 1] = a3;
    }
    function Pr(t4, e2, r2, n3, i4) {
      n3[i4 + 0] = 255, Ar(t4, e2, r2, n3, i4 + 1);
    }
    function kr(t4, e2, r2, n3, i4) {
      xr(t4, e2, r2, n3, i4), n3[i4 + 3] = 255;
    }
    function Ir(t4, e2, r2, n3, i4) {
      Ar(t4, e2, r2, n3, i4), n3[i4 + 3] = 255;
    }
    function Vt2(t4, e2) {
      return 0 > t4 ? 0 : t4 > e2 ? e2 : t4;
    }
    function Fr(e2, r2, n3) {
      t3[e2] = function(t4, e3, i4, a3, o3, s3, c4, u4, h4) {
        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; )
          r2(t4[e3 + 0], i4[a3 + 0], o3[s3 + 0], c4, u4), r2(t4[e3 + 1], i4[a3 + 0], o3[s3 + 0], c4, u4 + n3), e3 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h4 && r2(t4[e3 + 0], i4[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    function Cr(t4, e2, r2) {
      return 0 == r2 ? 0 == t4 ? 0 == e2 ? 6 : 5 : 0 == e2 ? 4 : 0 : r2;
    }
    function jr(t4, e2, r2, n3, i4) {
      switch (t4 >>> 30) {
        case 3:
          on2(e2, r2, n3, i4, 0);
          break;
        case 2:
          sn(e2, r2, n3, i4);
          break;
        case 1:
          un(e2, r2, n3, i4);
      }
    }
    function Or(t4, e2) {
      var r2, a3, o3 = e2.M, s3 = e2.Nb, c4 = t4.oc, u4 = t4.pc + 40, h4 = t4.oc, l4 = t4.pc + 584, f4 = t4.oc, d4 = t4.pc + 600;
      for (r2 = 0; 16 > r2; ++r2)
        c4[u4 + 32 * r2 - 1] = 129;
      for (r2 = 0; 8 > r2; ++r2)
        h4[l4 + 32 * r2 - 1] = 129, f4[d4 + 32 * r2 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i3(c4, u4 - 32 - 1, 127, 21), i3(h4, l4 - 32 - 1, 127, 9), i3(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t4.za; ++a3) {
        var p4 = e2.ya[e2.aa + a3];
        if (0 < a3) {
          for (r2 = -1; 16 > r2; ++r2)
            n2(c4, u4 + 32 * r2 - 4, c4, u4 + 32 * r2 + 12, 4);
          for (r2 = -1; 8 > r2; ++r2)
            n2(h4, l4 + 32 * r2 - 4, h4, l4 + 32 * r2 + 4, 4), n2(f4, d4 + 32 * r2 - 4, f4, d4 + 32 * r2 + 4, 4);
        }
        var g4 = t4.Gd, m4 = t4.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t4.za - 1 ? i3(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r2 = 0; 4 > r2; r2++)
            y4[w4 + 128 + r2] = y4[w4 + 256 + r2] = y4[w4 + 384 + r2] = y4[w4 + 0 + r2];
          for (r2 = 0; 16 > r2; ++r2, b4 <<= 2)
            y4 = c4, w4 = u4 + Di[r2], fi[p4.Ob[r2]](y4, w4), jr(b4, v4, 16 * +r2, y4, w4);
        } else if (y4 = Cr(a3, o3, p4.Ob[0]), li[y4](c4, u4), 0 != b4)
          for (r2 = 0; 16 > r2; ++r2, b4 <<= 2)
            jr(b4, v4, 16 * +r2, c4, u4 + Di[r2]);
        for (r2 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di[y4](h4, l4), di[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p4 = r2 >> 0) && (170 & p4 ? cn(b4, 256, y4, w4) : hn(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (r2 >>= 8) && (170 & r2 ? cn(v4, 320, p4, b4) : hn(v4, 320, p4, b4)), o3 < t4.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r2 = 8 * s3 * t4.B, g4 = t4.sa, m4 = t4.ta + 16 * a3 + 16 * s3 * t4.R, v4 = t4.qa, p4 = t4.ra + 8 * a3 + r2, b4 = t4.Ha, y4 = t4.Ia + 8 * a3 + r2, r2 = 0; 16 > r2; ++r2)
          n2(g4, m4 + r2 * t4.R, c4, u4 + 32 * r2, 16);
        for (r2 = 0; 8 > r2; ++r2)
          n2(v4, p4 + r2 * t4.B, h4, l4 + 32 * r2, 8), n2(b4, y4 + r2 * t4.B, f4, d4 + 32 * r2, 8);
      }
    }
    function Br(t4, n3, i4, a3, o3, s3, c4, u4, h4) {
      var l4 = [0], f4 = [0], d4 = 0, p4 = null != h4 ? h4.kd : 0, g4 = null != h4 ? h4 : new nr();
      if (null == t4 || 12 > i4)
        return 7;
      g4.data = t4, g4.w = n3, g4.ha = i4, n3 = [n3], i4 = [i4], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i4, y4 = g4.gb;
        if (e(null != t4), e(null != b4), e(null != y4), y4[0] = 0, 12 <= b4[0] && !r(t4, m4[0], "RIFF")) {
          if (r(t4, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t4, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p4 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (0 != y4)
        return y4;
      for (w4 = 0 < g4.gb[0], i4 = i4[0]; ; ) {
        t: {
          var L4 = t4;
          b4 = n3, y4 = i4;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])
            y4 = 7;
          else {
            if (!r(L4, b4[0], "VP8X")) {
              if (10 != j2(L4, b4[0] + 4)) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              null != S3 && (S3[0] = _3), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], 0 != y4)
          return y4;
        if (b4 = !!(2 & m4), !w4 && d4)
          return 3;
        if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u4 && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && null == h4) {
          y4 = 0;
          break;
        }
        if (4 > i4) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r(t4, n3[0], "ALPH")) {
          i4 = [i4], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t4, y4 = n3, w4 = i4;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e(null != _3), e(null != w4), L4 = y4[0];
            var I3 = w4[0];
            for (e(null != A4), e(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r(_3, L4, "VP8 ") || !r(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i4 = i4[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4)
            break;
        }
        i4 = [i4], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t4, y4 = n3, w4 = i4, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r(k3, _3, "VP8 "), P3 = !r(k3, _3, "VP8L"), e(null != k3), e(null != w4), e(null != x3), e(null != S3), 8 > w4[0])
            y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                y4 = 3;
                break t;
              }
              if (p4 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
            y4 = 0;
          }
        if (i4 = i4[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (null == u4 || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i4) {
            y4 = 7;
            break;
          }
          u4 = c4, p4 = m4, b4 = s3, null == t4 || 5 > i4 ? t4 = 0 : 5 <= i4 && 47 == t4[n3 + 0] && !(t4[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t4, n3, i4), gt2(x3, w4, k3, A4) ? (null != u4 && (u4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t4 = 1) : t4 = 0) : t4 = 0;
        } else {
          if (10 > i4) {
            y4 = 7;
            break;
          }
          u4 = m4, null == t4 || 10 > i4 || !Xt2(t4, n3 + 3, i4 - 3) ? t4 = 0 : (p4 = t4[n3 + 0] | t4[n3 + 1] << 8 | t4[n3 + 2] << 16, b4 = 16383 & (t4[n3 + 7] << 8 | t4[n3 + 6]), t4 = 16383 & (t4[n3 + 9] << 8 | t4[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t4 ? t4 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t4), t4 = 1));
        }
        if (!t4)
          return 3;
        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))
          return 3;
        null != h4 && (h4[0] = g4, h4.offset = n3 - h4.w, e(4294967286 > n3 - h4.w), e(h4.offset == h4.ha - i4));
        break;
      }
      return 0 == y4 || 7 == y4 && d4 && null == h4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
    }
    function Mr(t4, e2, r2) {
      var n3 = e2.width, i4 = e2.height, a3 = 0, o3 = 0, s3 = n3, c4 = i4;
      if (e2.Da = null != t4 && 0 < t4.Da, e2.Da && (s3 = t4.cd, c4 = t4.bd, a3 = t4.v, o3 = t4.j, 11 > r2 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i4))
        return 0;
      if (e2.v = a3, e2.j = o3, e2.va = a3 + s3, e2.o = o3 + c4, e2.U = s3, e2.T = c4, e2.da = null != t4 && 0 < t4.da, e2.da) {
        if (!E2(s3, c4, r2 = [t4.ib], a3 = [t4.hb]))
          return 0;
        e2.ib = r2[0], e2.hb = a3[0];
      }
      return e2.ob = null != t4 && t4.ob, e2.Kb = null == t4 || !t4.Sd, e2.da && (e2.ob = e2.ib < 3 * n3 / 4 && e2.hb < 3 * i4 / 4, e2.Kb = 0), 1;
    }
    function Er(t4) {
      if (null == t4)
        return 2;
      if (11 > t4.S) {
        var e2 = t4.f.RGBA;
        e2.fb += (t4.height - 1) * e2.A, e2.A = -e2.A;
      } else
        e2 = t4.f.kb, t4 = t4.height, e2.O += (t4 - 1) * e2.fa, e2.fa = -e2.fa, e2.N += (t4 - 1 >> 1) * e2.Ab, e2.Ab = -e2.Ab, e2.W += (t4 - 1 >> 1) * e2.Db, e2.Db = -e2.Db, null != e2.F && (e2.J += (t4 - 1) * e2.lb, e2.lb = -e2.lb);
      return 0;
    }
    function qr(t4, e2, r2, n3) {
      if (null == n3 || 0 >= t4 || 0 >= e2)
        return 2;
      if (null != r2) {
        if (r2.Da) {
          var i4 = r2.cd, o3 = r2.bd, s3 = -2 & r2.v, c4 = -2 & r2.j;
          if (0 > s3 || 0 > c4 || 0 >= i4 || 0 >= o3 || s3 + i4 > t4 || c4 + o3 > e2)
            return 2;
          t4 = i4, e2 = o3;
        }
        if (r2.da) {
          if (!E2(t4, e2, i4 = [r2.ib], o3 = [r2.hb]))
            return 2;
          t4 = i4[0], e2 = o3[0];
        }
      }
      n3.width = t4, n3.height = e2;
      t: {
        var u4 = n3.width, h4 = n3.height;
        if (t4 = n3.S, 0 >= u4 || 0 >= h4 || !(t4 >= En && 13 > t4))
          t4 = 2;
        else {
          if (0 >= n3.Rd && null == n3.sd) {
            s3 = o3 = i4 = e2 = 0;
            var l4 = (c4 = u4 * zi[t4]) * h4;
            if (11 > t4 || (o3 = (h4 + 1) / 2 * (e2 = (u4 + 1) / 2), 12 == t4 && (s3 = (i4 = u4) * h4)), null == (h4 = a2(l4 + 2 * o3 + s3))) {
              t4 = 1;
              break t;
            }
            n3.sd = h4, 11 > t4 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e2, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e2, u4.Ed = o3, 12 == t4 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i4);
          }
          if (e2 = 1, i4 = n3.S, o3 = n3.width, s3 = n3.height, i4 >= En && 13 > i4)
            if (11 > i4)
              t4 = n3.f.RGBA, e2 &= (c4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e2 &= c4 >= o3 * zi[i4], e2 &= null != t4.eb;
            else {
              t4 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t4.fa);
              h4 = Math.abs(t4.Ab);
              var f4 = Math.abs(t4.Db), d4 = Math.abs(t4.lb), p4 = d4 * (s3 - 1) + o3;
              e2 &= u4 * (s3 - 1) + o3 <= t4.Fd, e2 &= h4 * (l4 - 1) + c4 <= t4.Cd, e2 = (e2 &= f4 * (l4 - 1) + c4 <= t4.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e2 &= null != t4.y, e2 &= null != t4.f, e2 &= null != t4.ea, 12 == i4 && (e2 &= d4 >= o3, e2 &= p4 <= t4.Tc, e2 &= null != t4.F);
            }
          else
            e2 = 0;
          t4 = e2 ? 0 : 2;
        }
      }
      return 0 != t4 || null != r2 && r2.fd && (t4 = Er(n3)), t4;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
      return 4278190080;
    }, t3.Predictor1 = function(t4) {
      return t4;
    }, t3.Predictor2 = function(t4, e2, r2) {
      return e2[r2 + 0];
    }, t3.Predictor3 = function(t4, e2, r2) {
      return e2[r2 + 1];
    }, t3.Predictor4 = function(t4, e2, r2) {
      return e2[r2 - 1];
    }, t3.Predictor5 = function(t4, e2, r2) {
      return U2(U2(t4, e2[r2 + 1]), e2[r2 + 0]);
    }, t3.Predictor6 = function(t4, e2, r2) {
      return U2(t4, e2[r2 - 1]);
    }, t3.Predictor7 = function(t4, e2, r2) {
      return U2(t4, e2[r2 + 0]);
    }, t3.Predictor8 = function(t4, e2, r2) {
      return U2(e2[r2 - 1], e2[r2 + 0]);
    }, t3.Predictor9 = function(t4, e2, r2) {
      return U2(e2[r2 + 0], e2[r2 + 1]);
    }, t3.Predictor10 = function(t4, e2, r2) {
      return U2(U2(t4, e2[r2 - 1]), U2(e2[r2 + 0], e2[r2 + 1]));
    }, t3.Predictor11 = function(t4, e2, r2) {
      var n3 = e2[r2 + 0];
      return 0 >= W2(n3 >> 24 & 255, t4 >> 24 & 255, (e2 = e2[r2 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t4 >> 16 & 255, e2 >> 16 & 255) + W2(n3 >> 8 & 255, t4 >> 8 & 255, e2 >> 8 & 255) + W2(255 & n3, 255 & t4, 255 & e2) ? n3 : t4;
    }, t3.Predictor12 = function(t4, e2, r2) {
      var n3 = e2[r2 + 0];
      return (z2((t4 >> 24 & 255) + (n3 >> 24 & 255) - ((e2 = e2[r2 - 1]) >> 24 & 255)) << 24 | z2((t4 >> 16 & 255) + (n3 >> 16 & 255) - (e2 >> 16 & 255)) << 16 | z2((t4 >> 8 & 255) + (n3 >> 8 & 255) - (e2 >> 8 & 255)) << 8 | z2((255 & t4) + (255 & n3) - (255 & e2))) >>> 0;
    }, t3.Predictor13 = function(t4, e2, r2) {
      var n3 = e2[r2 - 1];
      return (H2((t4 = U2(t4, e2[r2 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H2(t4 >> 16 & 255, n3 >> 16 & 255) << 16 | H2(t4 >> 8 & 255, n3 >> 8 & 255) << 8 | H2(t4 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t3.PredictorAdd0;
    t3.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t3.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
      return t4 >> 8 & 255;
    }, function(t4) {
      return t4;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
      return t4;
    }, function(t4) {
      return t4 >> 8 & 255;
    });
    var Gr, Yr = t3.ColorIndexInverseTransform, Jr = t3.MapARGB, Xr = t3.VP8LColorIndexInverseTransformAlpha, Kr = t3.MapAlpha, Zr = t3.VP8LPredictorsAdd = [];
    Zr.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn, an, on2, sn, cn, un, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a2(511), kn = a2(2041), In = a2(225), Fn = a2(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t3.UpsampleRgbLinePair, yi = t3.UpsampleBgrLinePair, wi = t3.UpsampleRgbaLinePair, Ni = t3.UpsampleBgraLinePair, Li = t3.UpsampleArgbLinePair, Ai = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(256), Ei = a2(ki - Pi), qi = a2(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t4, r2, n3, i4, a3) {
      var o3 = qn, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h4 = c4.height, l4 = new st2();
      if (null == l4 || null == t4)
        var f4 = 2;
      else
        e(null != l4), f4 = Br(t4, r2, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (0 != f4 ? u4 = 0 : (null != u4 && (u4[0] = l4.width[0]), null != h4 && (h4[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], null != i4 && (i4[0] = c4.width), null != a3 && (a3[0] = c4.height);
        t: {
          if (i4 = new Gt2(), (a3 = new nr()).data = t4, a3.w = r2, a3.ha = n3, a3.kd = 1, r2 = [0], e(null != a3), (0 == (t4 = Br(a3.data, a3.w, a3.ha, null, null, null, r2, null, a3)) || 7 == t4) && r2[0] && (t4 = 4), 0 == (r2 = t4)) {
            if (e(null != s3), i4.data = a3.data, i4.w = a3.w + a3.offset, i4.ha = a3.ha - a3.offset, i4.put = dt2, i4.ac = ft2, i4.bc = pt2, i4.ma = s3, a3.xa) {
              if (null == (t4 = kt2())) {
                s3 = 1;
                break t;
              }
              if (function(t5, r3) {
                var n4 = [0], i5 = [0], a4 = [0];
                e:
                  for (; ; ) {
                    if (null == t5)
                      return 0;
                    if (null == r3)
                      return t5.a = 2, 0;
                    if (t5.l = r3, t5.a = 0, v3(t5.m, r3.data, r3.w, r3.ha), !gt2(t5.m, n4, i5, a4)) {
                      t5.a = 3;
                      break e;
                    }
                    if (t5.xb = gi, r3.width = n4[0], r3.height = i5[0], !It2(n4[0], i5[0], 1, t5, null))
                      break e;
                    return 1;
                  }
                return e(0 != t5.a), 0;
              }(t4, i4)) {
                if (i4 = 0 == (r2 = qr(i4.width, i4.height, s3.Oa, s3.ba))) {
                  e: {
                    i4 = t4;
                    r:
                      for (; ; ) {
                        if (null == i4) {
                          i4 = 0;
                          break e;
                        }
                        if (e(null != i4.s.yc), e(null != i4.s.Ya), e(0 < i4.s.Wb), e(null != (n3 = i4.l)), e(null != (a3 = n3.ma)), 0 != i4.xb) {
                          if (i4.ca = a3.ba, i4.tb = a3.tb, e(null != i4.ca), !Mr(a3.Oa, n3, Rn)) {
                            i4.a = 2;
                            break r;
                          }
                          if (!Ft2(i4, n3.width))
                            break r;
                          if (n3.da)
                            break r;
                          if ((n3.da || nt2(i4.ca.S)) && mr(), 11 > i4.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i4.ca.f.kb.F && mr()), i4.Pb && 0 < i4.s.ua && null == i4.s.vb.X && !O2(i4.s.vb, i4.s.Wa.Xa)) {
                            i4.a = 1;
                            break r;
                          }
                          i4.xb = 0;
                        }
                        if (!_t2(i4, i4.V, i4.Ba, i4.c, i4.i, n3.o, Lt2))
                          break r;
                        a3.Dc = i4.Ma, i4 = 1;
                        break e;
                      }
                    e(0 != i4.a), i4 = 0;
                  }
                  i4 = !i4;
                }
                i4 && (r2 = t4.a);
              } else
                r2 = t4.a;
            } else {
              if (null == (t4 = new Yt2())) {
                s3 = 1;
                break t;
              }
              if (t4.Fa = a3.na, t4.P = a3.P, t4.qc = a3.Sa, Kt2(t4, i4)) {
                if (0 == (r2 = qr(i4.width, i4.height, s3.Oa, s3.ba))) {
                  if (t4.Aa = 0, n3 = s3.Oa, e(null != (a3 = t4)), null != n3) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h4 = l4 = 0; 4 > h4; ++h4)
                        12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t4, i4) || (r2 = t4.a);
                }
              } else
                r2 = t4.a;
            }
            0 == r2 && null != s3.Oa && s3.Oa.fd && (r2 = Er(s3.ba));
          }
          s3 = r2;
        }
        o3 = 0 != s3 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else
        o3 = null;
      return o3;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u2(t3, e2) {
    for (var r2 = "", n3 = 0; n3 < 4; n3++)
      r2 += String.fromCharCode(t3[e2++]);
    return r2;
  }
  function h2(t3, e2) {
    return (t3[e2 + 0] << 0 | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) >>> 0;
  }
  function l2(t3, e2) {
    return (t3[e2 + 0] << 0 | t3[e2 + 1] << 8 | t3[e2 + 2] << 16 | t3[e2 + 3] << 24) >>> 0;
  }
  new c2();
  var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t2, v2 = function(t3, e2) {
    var r2 = {}, n3 = 0, i4 = false, a3 = 0, o3 = 0;
    if (r2.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t4, e3, r3, n4) {
      for (var i5 = 0; i5 < n4; i5++)
        if (t4[e3 + i5] != r3.charCodeAt(i5))
          return true;
      return false;
    }(t3, e2, "RIFF", 4)) {
      var s3, c3;
      l2(t3, e2 += 4);
      for (e2 += 8; e2 < t3.length; ) {
        var f3 = u2(t3, e2), d3 = l2(t3, e2 += 4);
        e2 += 4;
        var p3 = d3 + (1 & d3);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            void 0 === r2.frames[n3] && (r2.frames[n3] = {});
            (v3 = r2.frames[n3]).src_off = i4 ? o3 : e2 - 8, v3.src_size = a3 + d3 + 8, n3++, i4 && (i4 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r2.header = {}).feature_flags = t3[e2];
            var g3 = e2 + 4;
            v3.canvas_width = 1 + h2(t3, g3);
            g3 += 3;
            v3.canvas_height = 1 + h2(t3, g3);
            g3 += 3;
            break;
          case "ALPH":
            i4 = true, a3 = p3 + 8, o3 = e2 - 8;
            break;
          case "ANIM":
            (v3 = r2.header).bgcolor = l2(t3, e2);
            g3 = e2 + 4;
            v3.loop_count = (s3 = t3)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r2.frames[n3] = {}).offset_x = 2 * h2(t3, e2), e2 += 3, v3.offset_y = 2 * h2(t3, e2), e2 += 3, v3.width = 1 + h2(t3, e2), e2 += 3, v3.height = 1 + h2(t3, e2), e2 += 3, v3.duration = h2(t3, e2), e2 += 3, m3 = t3[e2++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        "ANMF" != f3 && (e2 += p3);
      }
      return r2;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && 0 != y2[w2].blend; w2++)
      ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)
    p2[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p2, this;
}
!function(t2) {
  var r = function() {
    return "function" == typeof zlibSync;
  }, n2 = function(r2, n3, a3, h3) {
    var l3 = 4, f3 = s2;
    switch (h3) {
      case t2.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t2.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t2.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r2 = i3(r2, n3, a3, f3);
    var d2 = zlibSync(r2, { level: l3 });
    return t2.__addimage__.arrayBufferToBinaryString(d2);
  }, i3 = function(t3, e, r2, n3) {
    for (var i4, a3, o3, s3 = t3.length / e, c3 = new Uint8Array(t3.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
      if (o3 = h3 * e, i4 = t3.subarray(o3, o3 + e), n3)
        c3.set(n3(i4, r2, a3), o3 + h3);
      else {
        for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1)
          g2[d2] = u3[d2](i4, r2, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h3);
      }
      a3 = i4;
    }
    return c3;
  }, a2 = function(t3) {
    var e = Array.apply([], t3);
    return e.unshift(0), e;
  }, o2 = function(t3, e) {
    var r2, n3 = [], i4 = t3.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i4; a3 += 1)
      r2 = t3[a3 - e] || 0, n3[a3 + 1] = t3[a3] - r2 + 256 & 255;
    return n3;
  }, s2 = function(t3, e, r2) {
    var n3, i4 = [], a3 = t3.length;
    i4[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1)
      n3 = r2 && r2[o3] || 0, i4[o3 + 1] = t3[o3] - n3 + 256 & 255;
    return i4;
  }, c2 = function(t3, e, r2) {
    var n3, i4, a3 = [], o3 = t3.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1)
      n3 = t3[s3 - e] || 0, i4 = r2 && r2[s3] || 0, a3[s3 + 1] = t3[s3] + 256 - (n3 + i4 >>> 1) & 255;
    return a3;
  }, u2 = function(t3, e, r2) {
    var n3, i4, a3, o3, s3 = [], c3 = t3.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1)
      n3 = t3[u3 - e] || 0, i4 = r2 && r2[u3] || 0, a3 = r2 && r2[u3 - e] || 0, o3 = h2(n3, i4, a3), s3[u3 + 1] = t3[u3] - o3 + 256 & 255;
    return s3;
  }, h2 = function(t3, e, r2) {
    if (t3 === e && e === r2)
      return t3;
    var n3 = Math.abs(e - r2), i4 = Math.abs(t3 - r2), a3 = Math.abs(t3 + e - r2 - r2);
    return n3 <= i4 && n3 <= a3 ? t3 : i4 <= a3 ? e : r2;
  }, l2 = function() {
    return [a2, o2, s2, c2, u2];
  }, f2 = function(t3) {
    var e = t3.map(function(t4) {
      return t4.reduce(function(t5, e2) {
        return t5 + Math.abs(e2);
      }, 0);
    });
    return e.indexOf(Math.min.apply(null, e));
  };
  t2.processPNG = function(e, i4, a3, o3) {
    var s3, c3, u3, h3, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e) && (e = new Uint8Array(e)), this.__addimage__.isArrayBufferView(e)) {
      if (e = (u3 = new Kt(e)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, -1 !== [4, 6].indexOf(u3.colorType)) {
        if (8 === u3.bits) {
          g2 = (p2 = 32 == u3.pixelBitlength ? new Uint32Array(u3.decodePixels().buffer) : 16 == u3.pixelBitlength ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p2[w2], x2 = 0; x2 < S2; )
              v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (16 === u3.bits) {
          g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; )
            y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t2.image_compression.NONE && r() ? (e = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e = v2, d2 = m2, L2 = void 0);
      }
      if (3 === u3.colorType && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
          k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0))
          h3 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++)
            m2[w2] = P2[p2[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e2) {
        var r2;
        switch (e2) {
          case t2.image_compression.FAST:
            r2 = 11;
            break;
          case t2.image_compression.MEDIUM:
            r2 = 13;
            break;
          case t2.image_compression.SLOW:
            r2 = 14;
            break;
          default:
            r2 = 12;
        }
        return r2;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) && (e = this.__addimage__.arrayBufferToBinaryString(e)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e, index: i4, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E.API), function(t2) {
  t2.processGIF89A = function(e, r, n2, i3) {
    var a2 = new Zt(e), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
    return t2.processJPEG.call(this, h2, r, n2, i3);
  }, t2.processGIF87A = t2.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t2);
    for (var e = 0; e < t2; e++) {
      var r = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i3 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e] = { red: i3, green: n2, blue: r, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t2 = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[t2]();
  } catch (t3) {
    a.log("bit decode error:" + t3);
  }
}, te.prototype.bit1 = function() {
  var t2, e = Math.ceil(this.width / 8), r = e % 4;
  for (t2 = this.height - 1; t2 >= 0; t2--) {
    for (var n2 = this.bottom_up ? t2 : this.height - 1 - t2, i3 = 0; i3 < e; i3++)
      for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i3 * 4, s2 = 0; s2 < 8 && 8 * i3 + s2 < this.width; s2++) {
        var c2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
    0 !== r && (this.pos += 4 - r);
  }
}, te.prototype.bit4 = function() {
  for (var t2 = Math.ceil(this.width / 2), e = t2 % 4, r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i3 = 0; i3 < t2; i3++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i3 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i3 + 1 >= this.width)
        break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    0 !== e && (this.pos += 4 - e);
  }
}, te.prototype.bit8 = function() {
  for (var t2 = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var r = this.bottom_up ? e : this.height - 1 - e, n2 = 0; n2 < this.width; n2++) {
      var i3 = this.datav.getUint8(this.pos++, true), a2 = r * this.width * 4 + 4 * n2;
      if (i3 < this.palette.length) {
        var o2 = this.palette[i3];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else
        this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    0 !== t2 && (this.pos += 4 - t2);
  }
}, te.prototype.bit15 = function() {
  for (var t2 = this.width % 3, e = parseInt("11111", 2), r = this.height - 1; r >= 0; r--) {
    for (var n2 = this.bottom_up ? r : this.height - 1 - r, i3 = 0; i3 < this.width; i3++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e) / e * 255 | 0, s2 = (a2 >> 5 & e) / e * 255 | 0, c2 = (a2 >> 10 & e) / e * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i3;
      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
    }
    this.pos += t2;
  }
}, te.prototype.bit16 = function() {
  for (var t2 = this.width % 3, e = parseInt("11111", 2), r = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i3 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e) / e * 255 | 0, c2 = (o2 >> 5 & r) / r * 255 | 0, u2 = (o2 >> 11) / e * 255 | 0, h2 = i3 * this.width * 4 + 4 * a2;
      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
    }
    this.pos += t2;
  }
}, te.prototype.bit24 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--) {
    for (var e = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
      var n2 = this.datav.getUint8(this.pos++, true), i3 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e * this.width * 4 + 4 * r;
      this.data[o2] = a2, this.data[o2 + 1] = i3, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t2 = this.height - 1; t2 >= 0; t2--)
    for (var e = this.bottom_up ? t2 : this.height - 1 - t2, r = 0; r < this.width; r++) {
      var n2 = this.datav.getUint8(this.pos++, true), i3 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e * this.width * 4 + 4 * r;
      this.data[s2] = a2, this.data[s2 + 1] = i3, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
    }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processBMP = function(e, r, n2, i3) {
    var a2 = new te(e, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i3);
  };
}(E.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  t2.processWEBP = function(e, r, n2, i3) {
    var a2 = new ee(e, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t2.processJPEG.call(this, u2, r, n2, i3);
  };
}(E.API), E.API.processRGBA = function(t2, e, r) {
  for (var n2 = t2.data, i3 = n2.length, a2 = new Uint8Array(i3 / 4 * 3), o2 = new Uint8Array(i3 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i3; u2 += 4) {
    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e, alias: r, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
}, E.API.setLanguage = function(t2) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e, r) {
  var n2, i3, a2 = (r = r || {}).font || this.internal.getFont(), o2 = r.fontSize || this.internal.getFontSize(), s2 = r.charSpace || this.internal.getCharSpace(), c2 = r.widths ? r.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r.kerning ? r.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = false !== r.doKerning, d2 = 0, p2 = e.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p2; n2++)
    i3 = e.charCodeAt(n2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i3)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof(h2[i3]) && !isNaN(parseInt(h2[i3][g2], 10)) ? h2[i3][g2] / l2 : 0, v2.push((c2[i3] || m2) / u2 + d2)), g2 = i3;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t2, e) {
  var r = (e = e || {}).fontSize || this.internal.getFontSize(), n2 = e.font || this.internal.getFont(), i3 = e.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t2 = Vt.processArabic(t2)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t2, r, i3) / r : Gt.apply(this, arguments).reduce(function(t3, e2) {
    return t3 + e2;
  }, 0);
}, Jt = function(t2, e, r, n2) {
  for (var i3 = [], a2 = 0, o2 = t2.length, s2 = 0; a2 !== o2 && s2 + e[a2] < r; )
    s2 += e[a2], a2++;
  i3.push(t2.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; )
    s2 + e[a2] > n2 && (i3.push(t2.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e[a2], a2++;
  return c2 !== a2 && i3.push(t2.slice(c2, a2)), i3;
}, Xt = function(t2, e, r) {
  r || (r = {});
  var n2, i3, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r.textIndent || 0, d2 = 0, p2 = 0, g2 = t2.split(" "), m2 = Gt.apply(this, [" ", r])[0];
  if (c2 = -1 === r.lineIndent ? g2[0].length + 2 : r.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t3) {
      (t3 = t3.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t3.map(function(t4, e2) {
        return (e2 && t4.length ? "\n" : "") + t4;
      })) : b2.push(t3[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i3 = Gt.apply(this, [n2, r])).reduce(function(t3, e2) {
      return t3 + e2;
    }, 0)) > e || y2) {
      if (p2 > e) {
        for (s2 = Jt.apply(this, [n2, i3, e - (f2 + d2), e]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; )
          l2.push([s2.shift()]);
        p2 = i3.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t3, e2) {
          return t3 + e2;
        }, 0);
      } else
        h2 = [n2];
      l2.push(h2), f2 = p2 + c2, d2 = m2;
    } else
      h2.push(n2), f2 += d2 + p2, d2 = m2;
  }
  return u2 = c2 ? function(t3, e2) {
    return (e2 ? v2 : "") + t3.join(" ");
  } : function(t3) {
    return t3.join(" ");
  }, l2.map(u2);
}, Vt.splitTextToSize = function(t2, e, r) {
  var n2, i3 = (r = r || {}).fontSize || this.internal.getFontSize(), a2 = (function(t3) {
    if (t3.widths && t3.kerning)
      return { widths: t3.widths, kerning: t3.kerning };
    var e2 = this.internal.getFont(t3.fontName, t3.fontStyle);
    return e2.metadata.Unicode ? { widths: e2.metadata.Unicode.widths || { 0: 1 }, kerning: e2.metadata.Unicode.kerning || {} } : { font: e2.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, r);
  n2 = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e / i3;
  a2.textIndent = r.textIndent ? 1 * r.textIndent * this.internal.scaleFactor / i3 : 0, a2.lineIndent = r.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++)
    u2 = u2.concat(Xt.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e) {
  e.__fontmetrics__ = e.__fontmetrics__ || {};
  for (var r = "klmnopqrstuvwxyz", n2 = {}, i3 = {}, a2 = 0; a2 < r.length; a2++)
    n2[r[a2]] = "0123456789abcdef"[a2], i3["0123456789abcdef"[a2]] = r[a2];
  var o2 = function(t2) {
    return "0x" + parseInt(t2, 10).toString(16);
  }, s2 = e.__fontmetrics__.compress = function(e2) {
    var r2, n3, a3, c3, u3 = ["{"];
    for (var h3 in e2) {
      if (r2 = e2[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i3[n3.slice(-1)]), "number" == typeof r2)
        r2 < 0 ? (a3 = o2(r2).slice(3), c3 = "-") : (a3 = o2(r2).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i3[a3.slice(-1)];
      else {
        if ("object" !== _typeof(r2))
          throw new Error("Don't know what to do with value type " + _typeof(r2) + ".");
        a3 = s2(r2);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e.__fontmetrics__.uncompress = function(t2) {
    if ("string" != typeof t2)
      throw new Error("Invalid argument passed to uncompress.");
    for (var e2, r2, i4, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t2.length - 1, d2 = 1; d2 < f2; d2 += 1)
      "'" == (a3 = t2[d2]) ? e2 ? (i4 = e2.join(""), e2 = void 0) : e2 = [] : e2 ? e2.push(a3) : "{" == a3 ? (u3.push([c3, i4]), c3 = {}, i4 = void 0) : "}" == a3 ? ((r2 = u3.pop())[0][r2[1]] = c3, i4 = void 0, c3 = r2[0]) : "-" == a3 ? s3 = -1 : void 0 === i4 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i4 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i4] = parseInt(l3, 16) * s3, s3 = 1, i4 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e.events.push(["addFont", function(t2) {
    var e2 = t2.font, r2 = l2.Unicode[e2.postScriptName];
    r2 && (e2.metadata.Unicode = {}, e2.metadata.Unicode.widths = r2.widths, e2.metadata.Unicode.kerning = r2.kerning);
    var n3 = h2.Unicode[e2.postScriptName];
    n3 && (e2.metadata.Unicode.encoding = n3, e2.encoding = n3.codePages[0]);
  }]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function(t3) {
    for (var e2 = t3.length, r = new Uint8Array(e2), n2 = 0; n2 < e2; n2++)
      r[n2] = t3.charCodeAt(n2);
    return r;
  };
  t2.API.events.push(["addFont", function(r) {
    var n2 = void 0, i3 = r.font, a2 = r.instance;
    if (!i3.isStandardFont) {
      if (void 0 === a2)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i3.postScriptName + "').");
      if ("string" != typeof (n2 = false === a2.existsFileInVFS(i3.postScriptName) ? a2.loadFile(i3.postScriptName) : a2.getFileFromVFS(i3.postScriptName)))
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i3.postScriptName + "').");
      !function(r2, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e(n3) : e(u(n3)), r2.metadata = t2.API.TTFFont.open(n3), r2.metadata.Unicode = r2.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r2.metadata.glyIdsUsed = [0];
      }(i3, n2);
    }
  }]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  function e() {
    return (n.canvg ? Promise.resolve(n.canvg) : import("./chunk-CIH2GXSZ.js")).catch(function(t3) {
      return Promise.reject(new Error("Could not load canvg: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  E.API.addSvgAsImage = function(t3, r, n2, i3, o2, s2, c2, u2) {
    if (isNaN(r) || isNaN(n2))
      throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i3) || isNaN(o2))
      throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h2 = document.createElement("canvas");
    h2.width = i3, h2.height = o2;
    var l2 = h2.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e().then(function(e2) {
      return e2.fromString(l2, t3, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t4) {
      return t4.render(f2);
    }).then(function() {
      d2.addImage(h2.toDataURL("image/jpeg", 1), r, n2, i3, o2, c2, u2);
    });
  };
}(), E.API.putTotalPages = function(t2) {
  var e, r = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t2, "g"), r = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), r = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)
    for (var i3 = 0; i3 < this.internal.pages[n2].length; i3++)
      this.internal.pages[n2][i3] = this.internal.pages[n2][i3].replace(e, r);
  return this;
}, E.API.viewerPreferences = function(e, r) {
  var n2;
  e = e || {}, r = r || false;
  var i3, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
  function d2(t2, e2) {
    var r2, n3 = false;
    for (r2 = 0; r2 < t2.length; r2 += 1)
      t2[r2] === e2 && (n3 = true);
    return n3;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, "reset" === e || true === r) {
    var p2 = c2.length;
    for (f2 = 0; f2 < p2; f2 += 1)
      n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if ("object" === _typeof(e)) {
    for (a2 in e)
      if (o2 = e[a2], d2(c2, a2) && void 0 !== o2) {
        if ("boolean" === n2[a2].type && "boolean" == typeof o2)
          n2[a2].value = o2;
        else if ("name" === n2[a2].type && d2(n2[a2].valueSet, o2))
          n2[a2].value = o2;
        else if ("integer" === n2[a2].type && Number.isInteger(o2))
          n2[a2].value = o2;
        else if ("array" === n2[a2].type) {
          for (h2 = 0; h2 < o2.length; h2 += 1)
            if (i3 = true, 1 === o2[h2].length && "number" == typeof o2[h2][0])
              u2.push(String(o2[h2] - 1));
            else if (o2[h2].length > 1) {
              for (l2 = 0; l2 < o2[h2].length; l2 += 1)
                "number" != typeof o2[h2][l2] && (i3 = false);
              true === i3 && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
            }
          n2[a2].value = "[" + u2.join(" ") + "]";
        } else
          n2[a2].value = n2[a2].defaultValue;
        n2[a2].explicitSet = true;
      }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t2, e2 = [];
    for (t2 in n2)
      true === n2[t2].explicitSet && ("name" === n2[t2].type ? e2.push("/" + t2 + " /" + n2[t2].value) : e2.push("/" + t2 + " " + n2[t2].value));
    0 !== e2.length && this.internal.write("/ViewerPreferences\n<<\n" + e2.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t2) {
  var e = function() {
    var t3 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e2 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r2 = unescape(encodeURIComponent(t3)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i3 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r2.length + n2.length + i3.length + e2.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e2 + r2 + n2 + i3 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, r = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t2.addMetadata = function(t3, n2) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t3, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(E.API), function(t2) {
  var e = t2.API, r = e.pdfEscape16 = function(t3, e2) {
    for (var r2, n3 = e2.metadata.Unicode.widths, i4 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
      if (r2 = e2.metadata.characterToGlyph(t3.charCodeAt(o2)), e2.metadata.glyIdsUsed.push(r2), e2.metadata.toUnicode[r2] = t3.charCodeAt(o2), -1 == n3.indexOf(r2) && (n3.push(r2), n3.push([parseInt(e2.metadata.widthOfGlyph(r2), 10)])), "0" == r2)
        return a2.join("");
      r2 = r2.toString(16), a2.push(i4[4 - r2.length], r2);
    }
    return a2.join("");
  }, n2 = function(t3) {
    var e2, r2, n3, i4, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r2 = Object.keys(t3).sort(function(t4, e3) {
      return t4 - e3;
    })).length; o2 < s2; o2++)
      e2 = r2[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t3[e2] && null !== t3[e2] && "function" == typeof t3[e2].toString && (i4 = ("0000" + t3[e2].toString(16)).slice(-4), e2 = ("0000" + (+e2).toString(16)).slice(-4), n3.push("<" + e2 + "><" + i4 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e.events.push(["putFont", function(e2) {
    !function(e3) {
      var r2 = e3.font, i4 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "Identity-H" === r2.encoding) {
        for (var s2 = r2.metadata.Unicode.widths, c2 = r2.metadata.subset.encode(r2.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++)
          u2 += String.fromCharCode(c2[h2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i4("endobj");
        var f2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: f2 }), i4("endobj");
        var d2 = a2();
        i4("<<"), i4("/Type /FontDescriptor"), i4("/FontName /" + F(r2.fontName)), i4("/FontFile2 " + l2 + " 0 R"), i4("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i4("/Flags " + r2.metadata.flags), i4("/StemV " + r2.metadata.stemV), i4("/ItalicAngle " + r2.metadata.italicAngle), i4("/Ascent " + r2.metadata.ascender), i4("/Descent " + r2.metadata.decender), i4("/CapHeight " + r2.metadata.capHeight), i4(">>"), i4("endobj");
        var p2 = a2();
        i4("<<"), i4("/Type /Font"), i4("/BaseFont /" + F(r2.fontName)), i4("/FontDescriptor " + d2 + " 0 R"), i4("/W " + t2.API.PDFObject.convert(s2)), i4("/CIDToGIDMap /Identity"), i4("/DW 1000"), i4("/Subtype /CIDFontType2"), i4("/CIDSystemInfo"), i4("<<"), i4("/Supplement 0"), i4("/Registry (Adobe)"), i4("/Ordering (" + r2.encoding + ")"), i4(">>"), i4(">>"), i4("endobj"), r2.objectNumber = a2(), i4("<<"), i4("/Type /Font"), i4("/Subtype /Type0"), i4("/ToUnicode " + f2 + " 0 R"), i4("/BaseFont /" + F(r2.fontName)), i4("/Encoding /" + r2.encoding), i4("/DescendantFonts [" + p2 + " 0 R]"), i4(">>"), i4("endobj"), r2.isAlreadyPutted = true;
      }
    }(e2);
  }]);
  e.events.push(["putFont", function(e2) {
    !function(e3) {
      var r2 = e3.font, i4 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
      if (r2.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === r2.encoding) {
        for (var s2 = r2.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++)
          c2 += String.fromCharCode(s2[u2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i4("endobj");
        var l2 = a2();
        o2({ data: n2(r2.metadata.toUnicode), addLength1: true, objectId: l2 }), i4("endobj");
        var f2 = a2();
        i4("<<"), i4("/Descent " + r2.metadata.decender), i4("/CapHeight " + r2.metadata.capHeight), i4("/StemV " + r2.metadata.stemV), i4("/Type /FontDescriptor"), i4("/FontFile2 " + h2 + " 0 R"), i4("/Flags 96"), i4("/FontBBox " + t2.API.PDFObject.convert(r2.metadata.bbox)), i4("/FontName /" + F(r2.fontName)), i4("/ItalicAngle " + r2.metadata.italicAngle), i4("/Ascent " + r2.metadata.ascender), i4(">>"), i4("endobj"), r2.objectNumber = a2();
        for (var d2 = 0; d2 < r2.metadata.hmtx.widths.length; d2++)
          r2.metadata.hmtx.widths[d2] = parseInt(r2.metadata.hmtx.widths[d2] * (1e3 / r2.metadata.head.unitsPerEm));
        i4("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F(r2.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r2.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(r2.metadata.hmtx.widths) + ">>"), i4("endobj"), r2.isAlreadyPutted = true;
      }
    }(e2);
  }]);
  var i3 = function(t3) {
    var e2, n3 = t3.text || "", i4 = t3.x, a2 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h2[l2].encoding;
    if ("Identity-H" !== h2[l2].encoding)
      return { text: n3, x: i4, y: a2, options: o2, mutex: s2 };
    for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1)
      h2[l2].metadata.hasOwnProperty("cmap") && (e2 = h2[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e2 || p2[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f2, l2).split("").map(function(t4) {
      return t4.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m2 = r(f2, h2[l2])), s2.isHex = true, { text: m2, x: i4, y: a2, options: o2, mutex: s2 };
  };
  e.events.push(["postProcessText", function(t3) {
    var e2 = t3.text || "", r2 = [], n3 = { text: e2, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
    if (Array.isArray(e2)) {
      var a2 = 0;
      for (a2 = 0; a2 < e2.length; a2 += 1)
        Array.isArray(e2[a2]) && 3 === e2[a2].length ? r2.push([i3(Object.assign({}, n3, { text: e2[a2][0] })).text, e2[a2][1], e2[a2][2]]) : r2.push(i3(Object.assign({}, n3, { text: e2[a2] })).text);
      t3.text = r2;
    } else
      t3.text = i3(Object.assign({}, n3, { text: e2 })).text;
  }]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t2) {
  var e = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t2.existsFileInVFS = function(t3) {
    return e.call(this), void 0 !== this.internal.vFS[t3];
  }, t2.addFileToVFS = function(t3, r) {
    return e.call(this), this.internal.vFS[t3] = r, this;
  }, t2.getFileFromVFS = function(t3) {
    return e.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
  };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t2) {
  t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
    var r2, n2, i3, a2, o2, s2, c2, u2 = e, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t4) {
      var e2 = t4.charCodeAt(), r3 = e2 >> 8, n3 = d2[r3];
      return void 0 !== n3 ? u2[256 * n3 + (255 & e2)] : 252 === r3 || 253 === r3 ? "AL" : g2.test(r3) ? "L" : 8 === r3 ? "R" : "N";
    }, y2 = function(t4) {
      for (var e2, r3 = 0; r3 < t4.length; r3++) {
        if ("L" === (e2 = b2(t4.charAt(r3))))
          return false;
        if ("R" === e2)
          return true;
      }
      return false;
    }, w2 = function(t4, e2, o3, s3) {
      var c3, u3, h3, l3, f3 = e2[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e2.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u3 = e2[s3 + 1]) && "AN" !== u3 ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e2.length && "EN" === e2[s3 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && "EN" === o3[s3 - 1]) {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h3 = s3 + 1, l3 = e2.length; h3 < l3 && "ET" === e2[h3]; )
            h3++;
          f3 = h3 < l3 && "EN" === e2[h3] ? "EN" : "N";
          break;
        case "NSM":
          if (i3 && !a2) {
            for (l3 = e2.length, h3 = s3 + 1; h3 < l3 && "NSM" === e2[h3]; )
              h3++;
            if (h3 < l3) {
              var d3 = t4[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
              if (c3 = e2[h3], p3 && ("R" === c3 || "AL" === c3)) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || "B" === (c3 = e2[s3 - 1]) ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r2 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, N2 = function(t4, e2, r3) {
      var n3 = t4.split("");
      return r3 && L2(n3, r3, { hiLevel: v2 }), n3.reverse(), e2 && e2.reverse(), n3.join("");
    }, L2 = function(t4, e2, i4) {
      var a3, o3, s3, c3, u3, d3 = -1, p3 = t4.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
      for (m2 = false, r2 = false, n2 = false, o3 = 0; o3 < p3; o3++)
        L3[o3] = b2(t4[o3]);
      for (s3 = 0; s3 < p3; s3++) {
        if (u3 = g3, y3[s3] = w2(t4, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e2[s3] = c3 = N3[g3][5], a3 > 0)
          if (16 === a3) {
            for (o3 = d3; o3 < s3; o3++)
              e2[o3] = 1;
            d3 = -1;
          } else
            d3 = -1;
        if (N3[g3][6])
          -1 === d3 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++)
            e2[o3] = c3;
          d3 = -1;
        }
        "B" === L3[s3] && (e2[s3] = 0), i4.hiLevel |= c3;
      }
      n2 && function(t5, e3, r3) {
        for (var n3 = 0; n3 < r3; n3++)
          if ("S" === t5[n3]) {
            e3[n3] = v2;
            for (var i5 = n3 - 1; i5 >= 0 && "WS" === t5[i5]; i5--)
              e3[i5] = v2;
          }
      }(L3, e2, p3);
    }, A2 = function(t4, e2, n3, i4, a3) {
      if (!(a3.hiLevel < t4)) {
        if (1 === t4 && 1 === v2 && !r2)
          return e2.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h3 = e2.length, l3 = 0; l3 < h3; ) {
          if (i4[l3] >= t4) {
            for (c3 = l3 + 1; c3 < h3 && i4[c3] >= t4; )
              c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)
              o3 = e2[u3], e2[u3] = e2[s3], e2[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, x2 = function(t4, e2, r3) {
      var n3 = t4.split(""), i4 = { hiLevel: v2 };
      return r3 || (r3 = []), L2(n3, r3, i4), function(t5, e3, r4) {
        if (0 !== r4.hiLevel && c2)
          for (var n4, i5 = 0; i5 < t5.length; i5++)
            1 === e3[i5] && (n4 = p2.indexOf(t5[i5])) >= 0 && (t5[i5] = p2[n4 + 1]);
      }(n3, r3, i4), A2(2, n3, e2, r3, i4), A2(1, n3, e2, r3, i4), n3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t4, e2, r3) {
      if (function(t5, e3) {
        if (e3)
          for (var r4 = 0; r4 < t5.length; r4++)
            e3[r4] = r4;
        void 0 === a2 && (a2 = y2(t5)), void 0 === s2 && (s2 = y2(t5));
      }(t4, e2), i3 || !o2 || s2)
        if (i3 && o2 && a2 ^ s2)
          v2 = a2 ? 1 : 0, t4 = N2(t4, e2, r3);
        else if (!i3 && o2 && s2)
          v2 = a2 ? 1 : 0, t4 = x2(t4, e2, r3), t4 = N2(t4, e2);
        else if (!i3 || a2 || o2 || s2) {
          if (i3 && !o2 && a2 ^ s2)
            t4 = N2(t4, e2), a2 ? (v2 = 0, t4 = x2(t4, e2, r3)) : (v2 = 1, t4 = x2(t4, e2, r3), t4 = N2(t4, e2));
          else if (i3 && a2 && !o2 && s2)
            v2 = 1, t4 = x2(t4, e2, r3), t4 = N2(t4, e2);
          else if (!i3 && !o2 && a2 ^ s2) {
            var n3 = c2;
            a2 ? (v2 = 1, t4 = x2(t4, e2, r3), v2 = 0, c2 = false, t4 = x2(t4, e2, r3), c2 = n3) : (v2 = 0, t4 = x2(t4, e2, r3), t4 = N2(t4, e2), v2 = 1, c2 = false, t4 = x2(t4, e2, r3), c2 = n3, t4 = N2(t4, e2));
          }
        } else
          v2 = 0, t4 = x2(t4, e2, r3);
      else
        v2 = a2 ? 1 : 0, t4 = x2(t4, e2, r3);
      return t4;
    }, this.__bidiEngine__.setOptions = function(t4) {
      t4 && (i3 = t4.isInputVisual, o2 = t4.isOutputVisual, a2 = t4.isInputRtl, s2 = t4.isOutputRtl, c2 = t4.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r = new t2.__bidiEngine__({ isInputVisual: true });
  t2.API.events.push(["postProcessText", function(t3) {
    var e2 = t3.text, n2 = (t3.x, t3.y, t3.options || {}), i3 = (t3.mutex, n2.lang, []);
    if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e2)) {
      var a2 = 0;
      for (i3 = [], a2 = 0; a2 < e2.length; a2 += 1)
        "[object Array]" === Object.prototype.toString.call(e2[a2]) ? i3.push([r.doBidiReorder(e2[a2][0]), e2[a2][1], e2[a2][2]]) : i3.push([r.doBidiReorder(e2[a2])]);
      t3.text = i3;
    } else
      t3.text = r.doBidiReorder(e2);
    r.setOptions({ isInputVisual: true });
  }]);
}(E), E.API.TTFFont = function() {
  function t2(t3) {
    var e;
    if (this.rawData = t3, e = this.contents = new ne(t3), this.contents.pos = 4, "ttcf" === e.readString(4))
      throw new Error("TTCF not supported.");
    e.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t2.open = function(e) {
    return new t2(e);
  }, t2.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t2.prototype.registerTTF = function() {
    var t3, e, r, n2, i3;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var e2, r2, n3, i4;
      for (i4 = [], e2 = 0, r2 = (n3 = this.bbox).length; e2 < r2; e2++)
        t3 = n3[e2], i4.push(Math.round(t3 * this.scaleFactor));
      return i4;
    }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n2 = this.post.italic_angle), 0 != (32768 & (e = n2 >> 16)) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i3 = this.familyClass) || 2 === i3 || 3 === i3 || 4 === i3 || 5 === i3 || 7 === i3, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t2.prototype.characterToGlyph = function(t3) {
    var e;
    return (null != (e = this.cmap.unicode) ? e.codeMap[t3] : void 0) || 0;
  }, t2.prototype.widthOfGlyph = function(t3) {
    var e;
    return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e;
  }, t2.prototype.widthOfString = function(t3, e, r) {
    var n2, i3, a2, o2;
    for (a2 = 0, i3 = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i3 < o2 : i3 > o2; i3 = 0 <= o2 ? ++i3 : --i3)
      n2 = t3.charCodeAt(i3), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r * (1e3 / e) || 0;
    return a2 * (e / 1e3);
  }, t2.prototype.lineHeight = function(t3, e) {
    var r;
    return null == e && (e = false), r = e ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t3;
  }, t2;
}();
var re2;
var ne = function() {
  function t2(t3) {
    this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
  }
  return t2.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t2.prototype.writeByte = function(t3) {
    return this.data[this.pos++] = t3;
  }, t2.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t2.prototype.writeUInt32 = function(t3) {
    return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt32 = function() {
    var t3;
    return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
  }, t2.prototype.writeInt32 = function(t3) {
    return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
  }, t2.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t2.prototype.writeUInt16 = function(t3) {
    return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
  }, t2.prototype.readInt16 = function() {
    var t3;
    return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
  }, t2.prototype.writeInt16 = function(t3) {
    return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
  }, t2.prototype.readString = function(t3) {
    var e, r;
    for (r = [], e = 0; 0 <= t3 ? e < t3 : e > t3; e = 0 <= t3 ? ++e : --e)
      r[e] = String.fromCharCode(this.readByte());
    return r.join("");
  }, t2.prototype.writeString = function(t3) {
    var e, r, n2;
    for (n2 = [], e = 0, r = t3.length; 0 <= r ? e < r : e > r; e = 0 <= r ? ++e : --e)
      n2.push(this.writeByte(t3.charCodeAt(e)));
    return n2;
  }, t2.prototype.readShort = function() {
    return this.readInt16();
  }, t2.prototype.writeShort = function(t3) {
    return this.writeInt16(t3);
  }, t2.prototype.readLongLong = function() {
    var t3, e, r, n2, i3, a2, o2, s2;
    return t3 = this.readByte(), e = this.readByte(), r = this.readByte(), n2 = this.readByte(), i3 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i3) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e + 1099511627776 * r + 4294967296 * n2 + 16777216 * i3 + 65536 * a2 + 256 * o2 + s2;
  }, t2.prototype.writeLongLong = function(t3) {
    var e, r;
    return e = Math.floor(t3 / 4294967296), r = 4294967295 & t3, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, t2.prototype.readInt = function() {
    return this.readInt32();
  }, t2.prototype.writeInt = function(t3) {
    return this.writeInt32(t3);
  }, t2.prototype.read = function(t3) {
    var e, r;
    for (e = [], r = 0; 0 <= t3 ? r < t3 : r > t3; r = 0 <= t3 ? ++r : --r)
      e.push(this.readByte());
    return e;
  }, t2.prototype.write = function(t3) {
    var e, r, n2, i3;
    for (i3 = [], r = 0, n2 = t3.length; r < n2; r++)
      e = t3[r], i3.push(this.writeByte(e));
    return i3;
  }, t2;
}();
var ie = function() {
  var t2;
  function e(t3) {
    var e2, r, n2;
    for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, r = 0, n2 = this.tableCount; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r)
      e2 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e2.tag] = e2;
  }
  return e.prototype.encode = function(e2) {
    var r, n2, i3, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2;
    for (p2 in f2 = Object.keys(e2).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i3 = 16 * f2, c2 = n2.pos + i3, o2 = null, d2 = [], e2)
      for (l2 = e2[p2], n2.writeString(p2), n2.writeInt(t2(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), "head" === p2 && (o2 = c2), c2 += l2.length; c2 % 4; )
        d2.push(0), c2++;
    return n2.write(d2), r = 2981146554 - t2(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r), n2.data;
  }, t2 = function(t3) {
    var e2, r, n2, i3;
    for (t3 = ve.call(t3); t3.length % 4; )
      t3.push(0);
    for (n2 = new ne(t3), r = 0, e2 = 0, i3 = t3.length; e2 < i3; e2 = e2 += 4)
      r += n2.readUInt32();
    return 4294967295 & r;
  }, e;
}();
var ae = {}.hasOwnProperty;
var oe = function(t2, e) {
  for (var r in e)
    ae.call(e, r) && (t2[r] = e[r]);
  function n2() {
    this.constructor = t2;
  }
  return n2.prototype = e.prototype, t2.prototype = new n2(), t2.__super__ = e.prototype, t2;
};
re2 = function() {
  function t2(t3) {
    var e;
    this.file = t3, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
  }
  return t2.prototype.parse = function() {
  }, t2.prototype.encode = function() {
  }, t2.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t2;
}();
var se = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "head", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
  }, e.prototype.encode = function(t3) {
    var e2;
    return (e2 = new ne()).writeInt(this.version), e2.writeInt(this.revision), e2.writeInt(this.checkSumAdjustment), e2.writeInt(this.magicNumber), e2.writeShort(this.flags), e2.writeShort(this.unitsPerEm), e2.writeLongLong(this.created), e2.writeLongLong(this.modified), e2.writeShort(this.xMin), e2.writeShort(this.yMin), e2.writeShort(this.xMax), e2.writeShort(this.yMax), e2.writeShort(this.macStyle), e2.writeShort(this.lowestRecPPEM), e2.writeShort(this.fontDirectionHint), e2.writeShort(t3), e2.writeShort(this.glyphDataFormat), e2.data;
  }, e;
}();
var ce = function() {
  function t2(t3, e) {
    var r, n2, i3, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2;
    switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e + t3.readInt(), h2 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2)
          this.codeMap[s2] = t3.readByte();
        break;
      case 4:
        for (f2 = t3.readUInt16(), l2 = f2 / 2, t3.pos += 6, i3 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), t3.pos += 2, p2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), c2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), u2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= l2 ? e2 < l2 : e2 > l2; s2 = 0 <= l2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), n2 = (this.length - t3.pos + this.offset) / 2, o2 = function() {
          var e2, r2;
          for (r2 = [], s2 = e2 = 0; 0 <= n2 ? e2 < n2 : e2 > n2; s2 = 0 <= n2 ? ++e2 : --e2)
            r2.push(t3.readUInt16());
          return r2;
        }(), s2 = m2 = 0, b2 = i3.length; m2 < b2; s2 = ++m2)
          for (g2 = i3[s2], r = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r = d2 <= g2 ? ++v2 : --v2)
            0 === u2[s2] ? a2 = r + c2[s2] : 0 !== (a2 = o2[u2[s2] / 2 + (r - d2) - (l2 - s2)] || 0) && (a2 += c2[s2]), this.codeMap[r] = 65535 & a2;
    }
    t3.pos = h2;
  }
  return t2.encode = function(t3, e) {
    var r, n2, i3, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B2, M2, E2, q2, D2, R2, T2, U2, z2, H2, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t3).sort(function(t4, e2) {
      return t4 - e2;
    }), e) {
      case "macroman":
        for (p2 = 0, g2 = function() {
          var t4 = [];
          for (d2 = 0; d2 < 256; ++d2)
            t4.push(0);
          return t4;
        }(), v2 = { 0: 0 }, i3 = {}, F2 = 0, B2 = a2.length; F2 < B2; F2++)
          null == v2[W2 = t3[n2 = a2[F2]]] && (v2[W2] = ++p2), i3[n2] = { old: t3[n2], new: v2[t3[n2]] }, g2[n2] = v2[t3[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i3, subtable: I2.data, maxGlyphID: p2 + 1 };
      case "unicode":
        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)
          null == v2[w2 = t3[n2 = a2[C2]]] && (v2[w2] = ++b2), r[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h2[d2], 65535 === _2) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r[_2].new) >= 32768)
            for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)
              f2.push(r[n2].new);
          else
            s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), z2 = 0, q2 = h2.length; z2 < q2; z2++)
          n2 = h2[z2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++)
          n2 = P2[H2], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++)
          o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++)
          y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, U2 = f2.length; Y2 < U2; Y2++)
          p2 = f2[Y2], I2.writeUInt16(p2);
        return { charMap: r, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t2;
}();
var ue = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "cmap", e.prototype.parse = function(t3) {
    var e2, r, n2;
    for (t3.pos = this.offset, this.version = t3.readUInt16(), n2 = t3.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= n2 ? r < n2 : r > n2; r = 0 <= n2 ? ++r : --r)
      e2 = new ce(t3, this.offset), this.tables.push(e2), e2.isUnicode && null == this.unicode && (this.unicode = e2);
    return true;
  }, e.encode = function(t3, e2) {
    var r, n2;
    return null == e2 && (e2 = "macroman"), r = ce.encode(t3, e2), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r.table = n2.data.concat(r.subtable), r;
  }, e;
}();
var he = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "hhea", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
  }, e;
}();
var le = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "OS/2", e.prototype.parse = function(t3) {
    if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = function() {
      var e2, r;
      for (r = [], e2 = 0; e2 < 10; ++e2)
        r.push(t3.readByte());
      return r;
    }(), this.charRange = function() {
      var e2, r;
      for (r = [], e2 = 0; e2 < 4; ++e2)
        r.push(t3.readInt());
      return r;
    }(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = function() {
      var e2, r;
      for (r = [], e2 = 0; e2 < 2; e2 = ++e2)
        r.push(t3.readInt());
      return r;
    }(), this.version > 1))
      return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
  }, e;
}();
var fe = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "post", e.prototype.parse = function(t3) {
    var e2, r, n2;
    switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i3;
        for (r = t3.readUInt16(), this.glyphNameIndex = [], i3 = 0; 0 <= r ? i3 < r : i3 > r; i3 = 0 <= r ? ++i3 : --i3)
          this.glyphNameIndex.push(t3.readUInt16());
        for (this.names = [], n2 = []; t3.pos < this.offset + this.length; )
          e2 = t3.readByte(), n2.push(this.names.push(t3.readString(e2)));
        return n2;
      case 151552:
        return r = t3.readUInt16(), this.offsets = t3.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var e3, r2, n3;
          for (n3 = [], i3 = e3 = 0, r2 = this.file.maxp.numGlyphs; 0 <= r2 ? e3 < r2 : e3 > r2; i3 = 0 <= r2 ? ++e3 : --e3)
            n3.push(t3.readUInt32());
          return n3;
        }).call(this);
    }
  }, e;
}();
var de = function(t2, e) {
  this.raw = t2, this.length = t2.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
};
var pe = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "name", e.prototype.parse = function(t3) {
    var e2, r, n2, i3, a2, o2, s2, c2, u2, h2, l2;
    for (t3.pos = this.offset, t3.readShort(), e2 = t3.readShort(), o2 = t3.readShort(), r = [], i3 = 0; 0 <= e2 ? i3 < e2 : i3 > e2; i3 = 0 <= e2 ? ++i3 : --i3)
      r.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
    for (s2 = {}, i3 = u2 = 0, h2 = r.length; u2 < h2; i3 = ++u2)
      n2 = r[i3], t3.pos = n2.offset, c2 = t3.readString(n2.length), a2 = new de(c2, n2), null == s2[l2 = n2.nameID] && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t4) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e;
}();
var ge = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "maxp", e.prototype.parse = function(t3) {
    return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
  }, e;
}();
var me = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "hmtx", e.prototype.parse = function(t3) {
    var e2, r, n2, i3, a2, o2, s2;
    for (t3.pos = this.offset, this.metrics = [], e2 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e2 < o2 : e2 > o2; e2 = 0 <= o2 ? ++e2 : --e2)
      this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r2, i4;
      for (i4 = [], e2 = r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; e2 = 0 <= n2 ? ++r2 : --r2)
        i4.push(t3.readInt16());
      return i4;
    }(), this.widths = (function() {
      var t4, e3, r2, n3;
      for (n3 = [], t4 = 0, e3 = (r2 = this.metrics).length; t4 < e3; t4++)
        i3 = r2[t4], n3.push(i3.advance);
      return n3;
    }).call(this), r = this.widths[this.widths.length - 1], s2 = [], e2 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e2 = 0 <= n2 ? ++a2 : --a2)
      s2.push(this.widths.push(r));
    return s2;
  }, e.prototype.forGlyph = function(t3) {
    return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
  }, e;
}();
var ve = [].slice;
var be = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t3) {
    var e2, r, n2, i3, a2, o2, s2, c2, u2, h2;
    return t3 in this.cache ? this.cache[t3] : (i3 = this.file.loca, e2 = this.file.contents, r = i3.indexOf(t3), 0 === (n2 = i3.lengthOf(t3)) ? this.cache[t3] = null : (e2.pos = this.offset + r, a2 = (o2 = new ne(e2.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t3] = -1 === a2 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t3]));
  }, e.prototype.encode = function(t3, e2, r) {
    var n2, i3, a2, o2, s2;
    for (a2 = [], i3 = [], o2 = 0, s2 = e2.length; o2 < s2; o2++)
      n2 = t3[e2[o2]], i3.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r)));
    return i3.push(a2.length), { table: a2, offsets: i3 };
  }, e;
}();
var ye = function() {
  function t2(t3, e, r, n2, i3, a2) {
    this.raw = t3, this.numberOfContours = e, this.xMin = r, this.yMin = n2, this.xMax = i3, this.yMax = a2, this.compound = false;
  }
  return t2.prototype.encode = function() {
    return this.raw.data;
  }, t2;
}();
var we = function() {
  function t2(t3, e, r, n2, i3) {
    var a2, o2;
    for (this.raw = t3, this.xMin = e, this.yMin = r, this.xMax = n2, this.yMax = i3, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )
      a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return 1, 8, 32, 64, 128, t2.prototype.encode = function() {
    var t3, e, r;
    for (e = new ne(ve.call(this.raw.data)), t3 = 0, r = this.glyphIDs.length; t3 < r; ++t3)
      e.pos = this.glyphOffsets[t3];
    return e.data;
  }, t2;
}();
var Ne = function(t2) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return oe(e, re2), e.prototype.tag = "loca", e.prototype.parse = function(t3) {
    var e2, r;
    return t3.pos = this.offset, e2 = this.file.head.indexToLocFormat, this.offsets = 0 === e2 ? (function() {
      var e3, n2;
      for (n2 = [], r = 0, e3 = this.length; r < e3; r += 2)
        n2.push(2 * t3.readUInt16());
      return n2;
    }).call(this) : (function() {
      var e3, n2;
      for (n2 = [], r = 0, e3 = this.length; r < e3; r += 4)
        n2.push(t3.readUInt32());
      return n2;
    }).call(this);
  }, e.prototype.indexOf = function(t3) {
    return this.offsets[t3];
  }, e.prototype.lengthOf = function(t3) {
    return this.offsets[t3 + 1] - this.offsets[t3];
  }, e.prototype.encode = function(t3, e2) {
    for (var r = new Uint32Array(this.offsets.length), n2 = 0, i3 = 0, a2 = 0; a2 < r.length; ++a2)
      if (r[a2] = n2, i3 < e2.length && e2[i3] == a2) {
        ++i3, r[a2] = n2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (n2 += s2);
      }
    for (var c2 = new Array(4 * r.length), u2 = 0; u2 < r.length; ++u2)
      c2[4 * u2 + 3] = 255 & r[u2], c2[4 * u2 + 2] = (65280 & r[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r[u2]) >> 16, c2[4 * u2] = (4278190080 & r[u2]) >> 24;
    return c2;
  }, e;
}();
var Le = function() {
  function t2(t3) {
    this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t2.prototype.generateCmap = function() {
    var t3, e, r, n2, i3;
    for (e in n2 = this.font.cmap.tables[0].codeMap, t3 = {}, i3 = this.subset)
      r = i3[e], t3[e] = n2[r];
    return t3;
  }, t2.prototype.glyphsFor = function(t3) {
    var e, r, n2, i3, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t3.length; a2 < o2; a2++)
      n2[i3 = t3[a2]] = this.font.glyf.glyphFor(i3);
    for (i3 in e = [], n2)
      (null != (r = n2[i3]) ? r.compound : void 0) && e.push.apply(e, r.glyphIDs);
    if (e.length > 0)
      for (i3 in s2 = this.glyphsFor(e))
        r = s2[i3], n2[i3] = r;
    return n2;
  }, t2.prototype.encode = function(t3, e) {
    var r, n2, i3, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2;
    for (n2 in r = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t3), f2 = { 0: 0 }, m2 = r.charMap)
      f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r.maxGlyphID, a2)
      d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t4) {
      var e2, r2;
      for (e2 in r2 = {}, t4)
        r2[t4[e2]] = e2;
      return r2;
    }(f2), h2 = Object.keys(u2).sort(function(t4, e2) {
      return t4 - e2;
    }), p2 = function() {
      var t4, e2, r2;
      for (r2 = [], t4 = 0, e2 = h2.length; t4 < e2; t4++)
        o2 = h2[t4], r2.push(u2[o2]);
      return r2;
    }(), i3 = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i3.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i3.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t2;
}();
E.API.PDFObject = function() {
  var t2;
  function e() {
  }
  return t2 = function(t3, e2) {
    return (Array(e2 + 1).join("0") + t3).slice(-e2);
  }, e.convert = function(r) {
    var n2, i3, a2, o2;
    if (Array.isArray(r))
      return "[" + function() {
        var t3, i4, a3;
        for (a3 = [], t3 = 0, i4 = r.length; t3 < i4; t3++)
          n2 = r[t3], a3.push(e.convert(n2));
        return a3;
      }().join(" ") + "]";
    if ("string" == typeof r)
      return "/" + r;
    if (null != r ? r.isString : void 0)
      return "(" + r + ")";
    if (r instanceof Date)
      return "(D:" + t2(r.getUTCFullYear(), 4) + t2(r.getUTCMonth(), 2) + t2(r.getUTCDate(), 2) + t2(r.getUTCHours(), 2) + t2(r.getUTCMinutes(), 2) + t2(r.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r)) {
      for (i3 in a2 = ["<<"], r)
        o2 = r[i3], a2.push("/" + i3 + " " + e.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r;
  }, e;
}();
var jspdf_es_min_default = E;

// node_modules/ngx-barcode6/fesm2022/ngx-barcode6.mjs
var import_jsbarcode = __toESM(require_JsBarcode(), 1);
var _c017 = ["bcElement"];
var _NgxBarcode6Component = class _NgxBarcode6Component {
  get options() {
    return {
      format: this.format,
      lineColor: this.lineColor,
      width: this.width,
      height: this.height,
      displayValue: this.displayValue,
      fontOptions: this.fontOptions,
      font: this.font,
      textAlign: this.textAlign,
      textPosition: this.textPosition,
      textMargin: this.textMargin,
      fontSize: this.fontSize,
      background: this.background,
      margin: this.margin,
      marginTop: this.marginTop,
      marginBottom: this.marginBottom,
      marginLeft: this.marginLeft,
      marginRight: this.marginRight,
      valid: this.valid
    };
  }
  constructor(renderer) {
    this.renderer = renderer;
    this.elementType = "svg";
    this.cssClass = "barcode";
    this.format = "CODE128";
    this.lineColor = "#000000";
    this.width = 2;
    this.height = 100;
    this.displayValue = false;
    this.fontOptions = "";
    this.font = "monospace";
    this.textAlign = "center";
    this.textPosition = "bottom";
    this.textMargin = 2;
    this.fontSize = 20;
    this.background = "#ffffff";
    this.margin = 10;
    this.marginTop = 10;
    this.marginBottom = 10;
    this.marginLeft = 10;
    this.marginRight = 10;
    this.value = "";
    this.valid = () => true;
  }
  ngAfterViewInit() {
    this.createBarcode();
  }
  ngOnChanges() {
    if (this.bcElement) {
      this.createBarcode();
    }
  }
  createBarcode() {
    if (!this.value) {
      return;
    }
    let element;
    switch (this.elementType) {
      case "img":
        element = this.renderer.createElement("img");
        break;
      case "canvas":
        element = this.renderer.createElement("canvas");
        break;
      case "svg":
      default:
        element = this.renderer.createElement("svg", "svg");
    }
    (0, import_jsbarcode.default)(element, this.value, this.options);
    for (const node of this.bcElement.nativeElement.childNodes) {
      this.renderer.removeChild(this.bcElement.nativeElement, node);
    }
    this.renderer.appendChild(this.bcElement.nativeElement, element);
  }
};
_NgxBarcode6Component.\u0275fac = function NgxBarcode6Component_Factory(t2) {
  return new (t2 || _NgxBarcode6Component)(\u0275\u0275directiveInject(Renderer2));
};
_NgxBarcode6Component.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NgxBarcode6Component,
  selectors: [["ngx-barcode6"]],
  viewQuery: function NgxBarcode6Component_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c017, 5);
    }
    if (rf & 2) {
      let _t2;
      \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.bcElement = _t2.first);
    }
  },
  inputs: {
    elementType: [InputFlags.None, "bc-element-type", "elementType"],
    cssClass: [InputFlags.None, "bc-class", "cssClass"],
    format: [InputFlags.None, "bc-format", "format"],
    lineColor: [InputFlags.None, "bc-line-color", "lineColor"],
    width: [InputFlags.None, "bc-width", "width"],
    height: [InputFlags.None, "bc-height", "height"],
    displayValue: [InputFlags.None, "bc-display-value", "displayValue"],
    fontOptions: [InputFlags.None, "bc-font-options", "fontOptions"],
    font: [InputFlags.None, "bc-font", "font"],
    textAlign: [InputFlags.None, "bc-text-align", "textAlign"],
    textPosition: [InputFlags.None, "bc-text-position", "textPosition"],
    textMargin: [InputFlags.None, "bc-text-margin", "textMargin"],
    fontSize: [InputFlags.None, "bc-font-size", "fontSize"],
    background: [InputFlags.None, "bc-background", "background"],
    margin: [InputFlags.None, "bc-margin", "margin"],
    marginTop: [InputFlags.None, "bc-margin-top", "marginTop"],
    marginBottom: [InputFlags.None, "bc-margin-bottom", "marginBottom"],
    marginLeft: [InputFlags.None, "bc-margin-left", "marginLeft"],
    marginRight: [InputFlags.None, "bc-margin-right", "marginRight"],
    value: [InputFlags.None, "bc-value", "value"],
    valid: [InputFlags.None, "bc-valid", "valid"]
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 2,
  vars: 2,
  consts: [["bcElement", ""]],
  template: function NgxBarcode6Component_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "div", null, 0);
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.cssClass);
    }
  },
  encapsulation: 2
});
var NgxBarcode6Component = _NgxBarcode6Component;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxBarcode6Component, [{
    type: Component,
    args: [{
      selector: "ngx-barcode6",
      template: `<div #bcElement [class]="cssClass"></div>`
    }]
  }], () => [{
    type: Renderer2
  }], {
    elementType: [{
      type: Input,
      args: ["bc-element-type"]
    }],
    cssClass: [{
      type: Input,
      args: ["bc-class"]
    }],
    format: [{
      type: Input,
      args: ["bc-format"]
    }],
    lineColor: [{
      type: Input,
      args: ["bc-line-color"]
    }],
    width: [{
      type: Input,
      args: ["bc-width"]
    }],
    height: [{
      type: Input,
      args: ["bc-height"]
    }],
    displayValue: [{
      type: Input,
      args: ["bc-display-value"]
    }],
    fontOptions: [{
      type: Input,
      args: ["bc-font-options"]
    }],
    font: [{
      type: Input,
      args: ["bc-font"]
    }],
    textAlign: [{
      type: Input,
      args: ["bc-text-align"]
    }],
    textPosition: [{
      type: Input,
      args: ["bc-text-position"]
    }],
    textMargin: [{
      type: Input,
      args: ["bc-text-margin"]
    }],
    fontSize: [{
      type: Input,
      args: ["bc-font-size"]
    }],
    background: [{
      type: Input,
      args: ["bc-background"]
    }],
    margin: [{
      type: Input,
      args: ["bc-margin"]
    }],
    marginTop: [{
      type: Input,
      args: ["bc-margin-top"]
    }],
    marginBottom: [{
      type: Input,
      args: ["bc-margin-bottom"]
    }],
    marginLeft: [{
      type: Input,
      args: ["bc-margin-left"]
    }],
    marginRight: [{
      type: Input,
      args: ["bc-margin-right"]
    }],
    value: [{
      type: Input,
      args: ["bc-value"]
    }],
    valid: [{
      type: Input,
      args: ["bc-valid"]
    }],
    bcElement: [{
      type: ViewChild,
      args: ["bcElement"]
    }]
  });
})();
var _NgxBarcode6Module = class _NgxBarcode6Module {
};
_NgxBarcode6Module.\u0275fac = function NgxBarcode6Module_Factory(t2) {
  return new (t2 || _NgxBarcode6Module)();
};
_NgxBarcode6Module.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NgxBarcode6Module
});
_NgxBarcode6Module.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var NgxBarcode6Module = _NgxBarcode6Module;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxBarcode6Module, [{
    type: NgModule,
    args: [{
      declarations: [NgxBarcode6Component],
      imports: [],
      exports: [NgxBarcode6Component]
    }]
  }], null, null);
})();

// node_modules/angularx-qrcode/fesm2022/angularx-qrcode.mjs
var import_qrcode = __toESM(require_browser(), 1);
var _c018 = ["qrcElement"];
var _QRCodeComponent = class _QRCodeComponent {
  constructor(renderer, sanitizer) {
    this.renderer = renderer;
    this.sanitizer = sanitizer;
    this.allowEmptyString = false;
    this.colorDark = "#000000ff";
    this.colorLight = "#ffffffff";
    this.cssClass = "qrcode";
    this.elementType = "canvas";
    this.errorCorrectionLevel = "M";
    this.margin = 4;
    this.qrdata = "";
    this.scale = 4;
    this.width = 10;
    this.qrCodeURL = new EventEmitter();
    this.context = null;
  }
  ngOnChanges() {
    return __async(this, null, function* () {
      yield this.createQRCode();
    });
  }
  isValidQrCodeText(data) {
    if (this.allowEmptyString === false) {
      return !(typeof data === "undefined" || data === "" || data === "null" || data === null);
    }
    return !(typeof data === "undefined");
  }
  toDataURL(qrCodeConfig) {
    return new Promise((resolve, reject) => {
      (0, import_qrcode.toDataURL)(this.qrdata, qrCodeConfig, (err, url2) => {
        if (err) {
          reject(err);
        } else {
          resolve(url2);
        }
      });
    });
  }
  toCanvas(canvas, qrCodeConfig) {
    return new Promise((resolve, reject) => {
      (0, import_qrcode.toCanvas)(canvas, this.qrdata, qrCodeConfig, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve("success");
        }
      });
    });
  }
  toSVG(qrCodeConfig) {
    return new Promise((resolve, reject) => {
      (0, import_qrcode.toString)(this.qrdata, qrCodeConfig, (err, url2) => {
        if (err) {
          reject(err);
        } else {
          resolve(url2);
        }
      });
    });
  }
  renderElement(element) {
    for (const node of this.qrcElement.nativeElement.childNodes) {
      this.renderer.removeChild(this.qrcElement.nativeElement, node);
    }
    this.renderer.appendChild(this.qrcElement.nativeElement, element);
  }
  createQRCode() {
    return __async(this, null, function* () {
      if (this.version && this.version > 40) {
        console.warn("[angularx-qrcode] max value for `version` is 40");
        this.version = 40;
      } else if (this.version && this.version < 1) {
        console.warn("[angularx-qrcode]`min value for `version` is 1");
        this.version = 1;
      } else if (this.version !== void 0 && isNaN(this.version)) {
        console.warn("[angularx-qrcode] version should be a number, defaulting to auto.");
        this.version = void 0;
      }
      try {
        if (!this.isValidQrCodeText(this.qrdata)) {
          throw new Error("[angularx-qrcode] Field `qrdata` is empty, set 'allowEmptyString=\"true\"' to overwrite this behaviour.");
        }
        if (this.isValidQrCodeText(this.qrdata) && this.qrdata === "") {
          this.qrdata = " ";
        }
        const config = {
          color: {
            dark: this.colorDark,
            light: this.colorLight
          },
          errorCorrectionLevel: this.errorCorrectionLevel,
          margin: this.margin,
          scale: this.scale,
          version: this.version,
          width: this.width
        };
        const centerImageSrc = this.imageSrc;
        const centerImageHeight = this.imageHeight || 40;
        const centerImageWidth = this.imageWidth || 40;
        switch (this.elementType) {
          case "canvas": {
            const canvasElement = this.renderer.createElement("canvas");
            this.context = canvasElement.getContext("2d");
            this.toCanvas(canvasElement, config).then(() => {
              if (this.ariaLabel) {
                this.renderer.setAttribute(canvasElement, "aria-label", `${this.ariaLabel}`);
              }
              if (this.title) {
                this.renderer.setAttribute(canvasElement, "title", `${this.title}`);
              }
              if (centerImageSrc && this.context) {
                this.centerImage = new Image(centerImageWidth, centerImageHeight);
                if (centerImageSrc !== this.centerImage.src) {
                  this.centerImage.src = centerImageSrc;
                }
                if (centerImageHeight !== this.centerImage.height) {
                  this.centerImage.height = centerImageHeight;
                }
                if (centerImageWidth !== this.centerImage.width) {
                  this.centerImage.width = centerImageWidth;
                }
                const centerImage = this.centerImage;
                if (centerImage) {
                  centerImage.onload = () => {
                    this.context?.drawImage(centerImage, canvasElement.width / 2 - centerImageWidth / 2, canvasElement.height / 2 - centerImageHeight / 2, centerImageWidth, centerImageHeight);
                  };
                }
              }
              this.renderElement(canvasElement);
              this.emitQRCodeURL(canvasElement);
            }).catch((e) => {
              console.error("[angularx-qrcode] canvas error:", e);
            });
            break;
          }
          case "svg": {
            const svgParentElement = this.renderer.createElement("div");
            this.toSVG(config).then((svgString) => {
              this.renderer.setProperty(svgParentElement, "innerHTML", svgString);
              const svgElement = svgParentElement.firstChild;
              this.renderer.setAttribute(svgElement, "height", `${this.width}`);
              this.renderer.setAttribute(svgElement, "width", `${this.width}`);
              this.renderElement(svgElement);
              this.emitQRCodeURL(svgElement);
            }).catch((e) => {
              console.error("[angularx-qrcode] svg error:", e);
            });
            break;
          }
          case "url":
          case "img":
          default: {
            const imgElement = this.renderer.createElement("img");
            this.toDataURL(config).then((dataUrl) => {
              if (this.alt) {
                imgElement.setAttribute("alt", this.alt);
              }
              if (this.ariaLabel) {
                imgElement.setAttribute("aria-label", this.ariaLabel);
              }
              imgElement.setAttribute("src", dataUrl);
              if (this.title) {
                imgElement.setAttribute("title", this.title);
              }
              this.renderElement(imgElement);
              this.emitQRCodeURL(imgElement);
            }).catch((e) => {
              console.error("[angularx-qrcode] img/url error:", e);
            });
          }
        }
      } catch (e) {
        console.error("[angularx-qrcode] Error generating QR Code:", e.message);
      }
    });
  }
  emitQRCodeURL(element) {
    const className = element.constructor.name;
    if (className === SVGSVGElement.name) {
      const svgHTML = element.outerHTML;
      const blob = new Blob([svgHTML], {
        type: "image/svg+xml"
      });
      const urlSvg = URL.createObjectURL(blob);
      const urlSanitized = this.sanitizer.bypassSecurityTrustUrl(urlSvg);
      this.qrCodeURL.emit(urlSanitized);
      return;
    }
    let urlImage = "";
    if (className === HTMLCanvasElement.name) {
      urlImage = element.toDataURL("image/png");
    }
    if (className === HTMLImageElement.name) {
      urlImage = element.src;
    }
    fetch(urlImage).then((urlResponse) => urlResponse.blob()).then((blob) => URL.createObjectURL(blob)).then((url2) => this.sanitizer.bypassSecurityTrustUrl(url2)).then((urlSanitized) => {
      this.qrCodeURL.emit(urlSanitized);
    }).catch((error) => {
      console.error("[angularx-qrcode] Error when fetching image/png URL: " + error);
    });
  }
};
_QRCodeComponent.\u0275fac = function QRCodeComponent_Factory(t2) {
  return new (t2 || _QRCodeComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(DomSanitizer));
};
_QRCodeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _QRCodeComponent,
  selectors: [["qrcode"]],
  viewQuery: function QRCodeComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c018, 7);
    }
    if (rf & 2) {
      let _t2;
      \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.qrcElement = _t2.first);
    }
  },
  inputs: {
    allowEmptyString: "allowEmptyString",
    colorDark: "colorDark",
    colorLight: "colorLight",
    cssClass: "cssClass",
    elementType: "elementType",
    errorCorrectionLevel: "errorCorrectionLevel",
    imageSrc: "imageSrc",
    imageHeight: "imageHeight",
    imageWidth: "imageWidth",
    margin: "margin",
    qrdata: "qrdata",
    scale: "scale",
    version: "version",
    width: "width",
    alt: "alt",
    ariaLabel: "ariaLabel",
    title: "title"
  },
  outputs: {
    qrCodeURL: "qrCodeURL"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 2,
  vars: 2,
  consts: [["qrcElement", ""]],
  template: function QRCodeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "div", null, 0);
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.cssClass);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var QRCodeComponent = _QRCodeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QRCodeComponent, [{
    type: Component,
    args: [{
      selector: "qrcode",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div #qrcElement [class]="cssClass"></div>`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: DomSanitizer
  }], {
    allowEmptyString: [{
      type: Input
    }],
    colorDark: [{
      type: Input
    }],
    colorLight: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    elementType: [{
      type: Input
    }],
    errorCorrectionLevel: [{
      type: Input
    }],
    imageSrc: [{
      type: Input
    }],
    imageHeight: [{
      type: Input
    }],
    imageWidth: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    qrdata: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    version: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    alt: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    qrCodeURL: [{
      type: Output
    }],
    qrcElement: [{
      type: ViewChild,
      args: ["qrcElement", {
        static: true
      }]
    }]
  });
})();
var _QRCodeModule = class _QRCodeModule {
};
_QRCodeModule.\u0275fac = function QRCodeModule_Factory(t2) {
  return new (t2 || _QRCodeModule)();
};
_QRCodeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _QRCodeModule
});
_QRCodeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var QRCodeModule = _QRCodeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QRCodeModule, [{
    type: NgModule,
    args: [{
      providers: [],
      declarations: [QRCodeComponent],
      exports: [QRCodeComponent]
    }]
  }], null, null);
})();

// src/app/modules/dashboard/components/print/print-process/print-process.component.ts
var _c019 = ["canvasElement"];
var _c111 = ["downloadElement"];
function PrintProcessComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 3);
    \u0275\u0275text(1, " \u0E44\u0E21\u0E48\u0E1E\u0E1A\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E1E\u0E34\u0E21\u0E1E\u0E4C\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C\n");
    \u0275\u0275elementEnd();
  }
}
function PrintProcessComponent_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "h3");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\u0E1B\u0E23\u0E30\u0E21\u0E27\u0E25\u0E1C\u0E25 ", ctx_r1.percentComplete.toFixed(2), "%");
  }
}
function PrintProcessComponent_Conditional_1_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("value", ctx_r1.percentComplete);
  }
}
function PrintProcessComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card")(1, "mat-card-content", 5)(2, "button", 6);
    \u0275\u0275listener("click", function PrintProcessComponent_Conditional_1_Template_button_click_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClickDownload());
    });
    \u0275\u0275text(3, " \u0E14\u0E32\u0E27\u0E19\u0E4C\u0E42\u0E2B\u0E25\u0E14\u0E44\u0E1F\u0E25\u0E4C ");
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, PrintProcessComponent_Conditional_1_Conditional_4_Template, 2, 1, "h3");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "mat-card-footer");
    \u0275\u0275template(6, PrintProcessComponent_Conditional_1_Conditional_6_Template, 1, 1, "mat-progress-bar", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx_r1.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(4, ctx_r1.isLoading ? 4 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(6, ctx_r1.isLoading ? 6 : -1);
  }
}
function PrintProcessComponent_ng_container_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "qrcode", 9, 1);
  }
  if (rf & 2) {
    const inventory_r3 = ctx.$implicit;
    \u0275\u0275property("qrdata", inventory_r3.code)("width", 128);
  }
}
function PrintProcessComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 8);
    \u0275\u0275repeaterCreate(2, PrintProcessComponent_ng_container_2_For_3_Template, 2, 2, "qrcode", 9, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275element(4, "a", 10, 0);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r1.inventories);
    \u0275\u0275advance(2);
    \u0275\u0275property("download", ctx_r1.fileName);
  }
}
function PrintProcessComponent_ng_container_3_For_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "ngx-barcode6", 11, 2);
  }
  if (rf & 2) {
    const inventory_r4 = ctx.$implicit;
    \u0275\u0275property("bc-format", "CODE39")("bc-value", inventory_r4.track);
  }
}
function PrintProcessComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 8);
    \u0275\u0275repeaterCreate(2, PrintProcessComponent_ng_container_3_For_3_Template, 2, 2, "ngx-barcode6", 11, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275element(4, "canvas", null, 1)(6, "a", 10, 0);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r1.inventories);
    \u0275\u0275advance(4);
    \u0275\u0275property("download", ctx_r1.fileName);
  }
}
var Process;
(function(Process2) {
  Process2[Process2["QRCode"] = 1] = "QRCode";
  Process2[Process2["BarCode"] = 2] = "BarCode";
})(Process || (Process = {}));
var _PrintProcessComponent = class _PrintProcessComponent {
  constructor() {
    this.route = inject(ActivatedRoute);
    this.subscription = new Subscription();
    this.printService = inject(PrintService);
    this.validationService = inject(ValidationService);
    this.print = +this.route.snapshot.params["print"];
    this.percentComplete = 0;
    this.isMissing = false;
    this.isLoading = false;
    this.isProcess = false;
    this.inventories = [];
  }
  ngOnInit() {
    if (this.print !== Process.QRCode && this.print !== Process.BarCode) {
      this.isMissing = true;
      return;
    }
    this.inventories = this.printService.getAll();
    if (this.validationService.isEmpty(this.inventories)) {
      this.isMissing = true;
      return;
    }
    this.isLoading = true;
    this.isProcess = true;
    defer(() => this.canvasElement ? of(null) : interval(300).pipe(filter(() => !!this.canvasElement), take(1))).subscribe(() => {
      if (this.print === Process.QRCode) {
        this.fileName = "qrcode.pdf";
        this.processPrintQRCode();
      }
      if (this.print === Process.BarCode) {
        this.fileName = "barcode.pdf";
        this.processPrintBarCode();
      }
    });
  }
  ngOnDestroy() {
    this.isProcess = false;
    this.subscription.unsubscribe();
  }
  onClickDownload() {
    if (!this.fileUrl)
      return;
    this.downloadElement.nativeElement.href = this.fileUrl;
    this.downloadElement.nativeElement.click();
  }
  processPrintQRCode() {
    const canvas = document.querySelectorAll("canvas");
    for (let i3 = 0; i3 < canvas.length; i3++) {
      this.inventories[i3].fileUrl = canvas[i3].toDataURL();
    }
    const doc = new jspdf_es_min_default("p", "px", "a4");
    const startX = 15;
    const startY = 10;
    const columnWidth = 71.292;
    const columnHeight = 71.292;
    const columnGap = 15;
    const columnDash = 5;
    const rowGap = 15;
    const rowDash = 20;
    const rowCountThreshold = 6;
    const lineText1 = 3;
    const lineText2 = 12;
    const delayTime = 10;
    const totalInventories = this.inventories.reduce((acc, inventory) => acc + inventory.printCount, 0);
    let currentX = startX;
    let currentY = startY;
    let rowCount = 0;
    let columnCount = 0;
    let processedInventories = 0;
    doc.setFontSize(9);
    this.subscription = from(this.inventories).pipe(concatMap((inventory) => from(Array(inventory.printCount)).pipe(concatMap(() => of(inventory).pipe(delay(delayTime))))), finalize(() => timer(500).pipe(takeWhile(() => this.isProcess)).subscribe(() => {
      doc.save(this.fileName);
      this.fileUrl = doc.output("datauristring");
      this.isLoading = false;
      this.percentComplete = 0;
      this.printService.reset();
    }))).subscribe((inventory) => {
      processedInventories++;
      this.percentComplete = processedInventories / totalInventories * 100;
      if (!inventory.fileUrl)
        return;
      const line1 = inventory.code.substring(0, 13);
      const line2 = inventory.code.substring(13, inventory.code.length);
      doc.addImage(inventory.fileUrl, currentX, currentY, columnWidth, columnHeight);
      doc.text(line1, currentX + columnGap - 5, currentY + columnHeight + lineText1);
      doc.text(line2, currentX + columnGap - 5, currentY + columnHeight + lineText2);
      currentX += columnWidth + columnGap;
      if (currentX + columnWidth <= doc.internal.pageSize.getWidth()) {
        doc.setLineDashPattern([3, 3], 0);
        doc.line(currentX - columnGap / 2, currentY + rowGap - columnDash, currentX - columnGap / 2, currentY + columnHeight + rowGap);
        columnCount++;
        if (columnCount === 1) {
          const dashedX = startX;
          const dashedY = currentY + rowGap + columnHeight + rowDash / 2;
          doc.setLineDashPattern([3, 3], 0);
          doc.line(dashedX, dashedY, doc.internal.pageSize.getWidth() - startX, dashedY);
        }
      }
      if (currentX + columnWidth > doc.internal.pageSize.getWidth()) {
        currentX = startX;
        currentY += columnHeight + columnGap + rowGap;
        rowCount++;
        columnCount = 0;
      }
      if (rowCount >= rowCountThreshold) {
        doc.addPage();
        currentX = startX;
        currentY = startY;
        rowCount = 0;
      }
    });
  }
  processPrintBarCode() {
    return __async(this, null, function* () {
      const svg = document.querySelectorAll("svg");
      for (let i3 = 1; i3 < svg.length; i3++) {
        this.inventories[i3 - 1].fileUrl = yield this.convertSvgToJpg(svg[i3]);
      }
      const doc = new jspdf_es_min_default("p", "px", "a4");
      const startX = 15;
      const startY = 15;
      const columnWidth = 128.82;
      const columnHeight = 40;
      const columnGap = 15;
      const rowGap = 20;
      const rowDash = 25;
      const rowCountThreshold = 10;
      const delayTime = 10;
      const totalInventories = this.inventories.reduce((acc, inventory) => acc + inventory.printCount, 0);
      let currentX = startX;
      let currentY = startY;
      let rowCount = 0;
      let columnCount = 0;
      let processedInventories = 0;
      doc.setFontSize(9);
      this.subscription = from(this.inventories).pipe(concatMap((inventory) => from(Array(inventory.printCount)).pipe(concatMap(() => of(inventory).pipe(delay(delayTime))))), finalize(() => timer(500).pipe(takeWhile(() => this.isProcess)).subscribe(() => {
        doc.save(this.fileName);
        this.fileUrl = doc.output("datauristring");
        this.isLoading = false;
        this.percentComplete = 0;
        this.printService.reset();
      }))).subscribe((inventory) => {
        processedInventories++;
        this.percentComplete = processedInventories / totalInventories * 100;
        if (!inventory.fileUrl)
          return;
        doc.addImage(inventory.fileUrl, currentX, currentY, columnWidth, columnHeight);
        doc.text(inventory.code, currentX + columnGap + 2, currentY + columnHeight + 4);
        currentX += columnWidth + columnGap;
        if (currentX + columnWidth <= doc.internal.pageSize.getWidth()) {
          doc.setLineDashPattern([3, 3], 0);
          doc.line(currentX - columnGap / 2, currentY - rowGap, currentX - columnGap / 2, currentY + columnHeight + columnGap - 3);
          columnCount++;
          if (columnCount === 1) {
            const dashedX = startX;
            const dashedY = currentY + columnHeight + rowDash / 2;
            doc.setLineDashPattern([3, 3], 0);
            doc.line(dashedX, dashedY, doc.internal.pageSize.getWidth() - startX, dashedY);
          }
        }
        if (currentX + columnWidth > doc.internal.pageSize.getWidth()) {
          currentX = startX;
          currentY += columnHeight + rowGap;
          rowCount++;
          columnCount = 0;
        }
        if (rowCount >= rowCountThreshold) {
          doc.addPage();
          currentX = startX;
          currentY = startY;
          rowCount = 0;
        }
      });
    });
  }
  convertSvgToJpg(svg) {
    return __async(this, null, function* () {
      const canvas = this.canvasElement.nativeElement;
      const context = canvas.getContext("2d");
      const svgRect = svg.getBoundingClientRect();
      canvas.width = svgRect.width;
      canvas.height = svgRect.height;
      try {
        const image64 = this.convertSvgToBase64(svg);
        const image = yield this.loadImage(image64);
        context.drawImage(image, 0, 0);
        return canvas.toDataURL("image/jpeg");
      } catch (error) {
        return null;
      }
    });
  }
  convertSvgToBase64(svg) {
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = btoa(xml);
    const b64Start = "data:image/svg+xml;base64,";
    const image64 = b64Start + svg64;
    return image64;
  }
  loadImage(image64) {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.src = image64;
      image.addEventListener("load", (e) => resolve(image));
      image.addEventListener("error", () => {
        reject(new Error(`Failed to load image's URL: ${image64}`));
      });
    });
  }
};
_PrintProcessComponent.\u0275fac = function PrintProcessComponent_Factory(t2) {
  return new (t2 || _PrintProcessComponent)();
};
_PrintProcessComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PrintProcessComponent, selectors: [["app-print-process"]], viewQuery: function PrintProcessComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c019, 5);
    \u0275\u0275viewQuery(_c111, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.canvasElement = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.downloadElement = _t2.first);
  }
}, decls: 4, vars: 3, consts: [["downloadElement", ""], ["canvasElement", ""], ["svgElement", ""], ["mat-flat-button", "", "color", "warn", 1, "w-100"], [4, "ngIf"], [1, "mb-16"], ["mat-flat-button", "", "color", "primary", 1, "mb-20", 3, "click", "disabled"], ["mode", "buffer", "color", "accent", 3, "value"], [1, "d-flex", "flex-wrap", "gap-10", "visibility-hidden"], [3, "qrdata", "width"], [3, "download"], [3, "bc-format", "bc-value"]], template: function PrintProcessComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, PrintProcessComponent_Conditional_0_Template, 2, 0, "button", 3)(1, PrintProcessComponent_Conditional_1_Template, 7, 3)(2, PrintProcessComponent_ng_container_2_Template, 6, 1, "ng-container", 4)(3, PrintProcessComponent_ng_container_3_Template, 8, 1, "ng-container", 4);
  }
  if (rf & 2) {
    \u0275\u0275conditional(0, ctx.isMissing ? 0 : 1);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.print === 1);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.print === 2);
  }
}, dependencies: [NgIf, MatButton, MatCard, MatCardContent, MatCardFooter, MatProgressBar, NgxBarcode6Component, QRCodeComponent] });
var PrintProcessComponent = _PrintProcessComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PrintProcessComponent, { className: "PrintProcessComponent", filePath: "src\\app\\modules\\dashboard\\components\\print\\print-process\\print-process.component.ts", lineNumber: 39 });
})();

// src/app/modules/dashboard/components/inventory-check/inventory-check.component.ts
var _c020 = ["filterInput"];
var _c112 = () => [10, 25, 50, 100];
var _c26 = (a0) => ["/inventory/view", a0];
function InventoryCheckComponent_For_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-option", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const year_r2 = ctx.$implicit;
    \u0275\u0275property("value", year_r2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(year_r2);
  }
}
function InventoryCheckComponent_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 24);
    \u0275\u0275listener("click", function InventoryCheckComponent_button_12_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.selectYear.setValue(""));
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "close");
    \u0275\u0275elementEnd()();
  }
}
function InventoryCheckComponent_Conditional_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 12);
  }
}
function InventoryCheckComponent_Conditional_36_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r3.category.value == null ? null : ctx_r3.category.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function InventoryCheckComponent_For_38_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 25);
    \u0275\u0275listener("click", function InventoryCheckComponent_For_38_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r6 = ctx.$implicit;
    \u0275\u0275property("value", category_r6);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(category_r6);
  }
}
function InventoryCheckComponent_Conditional_45_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" (+", ((ctx_r3.status.value == null ? null : ctx_r3.status.value.length) || 0) - 1, " \u0E2D\u0E37\u0E48\u0E19 \u0E46 ) ");
  }
}
function InventoryCheckComponent_For_47_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-option", 25);
    \u0275\u0275listener("click", function InventoryCheckComponent_For_47_Template_mat_option_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onFilter());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const status_r8 = ctx.$implicit;
    \u0275\u0275property("value", status_r8);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(status_r8);
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r9 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r9.no, " ");
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E23\u0E39\u0E1B");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell")(1, "a", 40);
    \u0275\u0275element(2, "img", 41);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const element_r10 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(3, _c26, element_r10.inventoryId));
    \u0275\u0275advance();
    \u0275\u0275property("defaultImage", "assets/images/no-image.jpg")("lazyLoad", ctx_r3.imageUrl + element_r10.image);
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r11 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r11.code, " ");
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E1B\u0E35");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r12 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r12.year, " ");
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r13 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r13.category, " ");
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r14 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r14.status, " ");
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E2B\u0E49\u0E2D\u0E07");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r15 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r15.location, " ");
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 39);
    \u0275\u0275text(1, "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C");
    \u0275\u0275elementEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_cell_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "cutDetail");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r16 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(2, 1, element_r16.description), " ");
  }
}
function InventoryCheckComponent_Conditional_53_Conditional_26_mat_header_cell_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function InventoryCheckComponent_Conditional_53_Conditional_26_mat_cell_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell")(1, "button", 43);
    \u0275\u0275listener("click", function InventoryCheckComponent_Conditional_53_Conditional_26_mat_cell_2_Template_button_click_1_listener() {
      const element_r18 = \u0275\u0275restoreView(_r17).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.onConfirm(element_r18.id, element_r18.code));
    });
    \u0275\u0275elementStart(2, "mat-icon");
    \u0275\u0275text(3, "delete");
    \u0275\u0275elementEnd()()();
  }
}
function InventoryCheckComponent_Conditional_53_Conditional_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 36);
    \u0275\u0275template(1, InventoryCheckComponent_Conditional_53_Conditional_26_mat_header_cell_1_Template, 1, 0, "mat-header-cell", 42)(2, InventoryCheckComponent_Conditional_53_Conditional_26_mat_cell_2_Template, 4, 0, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
  }
}
function InventoryCheckComponent_Conditional_53_mat_header_row_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function InventoryCheckComponent_Conditional_53_mat_row_28_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function InventoryCheckComponent_Conditional_53_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-table", 21);
    \u0275\u0275elementContainerStart(1, 26);
    \u0275\u0275template(2, InventoryCheckComponent_Conditional_53_mat_header_cell_2_Template, 2, 0, "mat-header-cell", 27)(3, InventoryCheckComponent_Conditional_53_mat_cell_3_Template, 2, 1, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(4, 29);
    \u0275\u0275template(5, InventoryCheckComponent_Conditional_53_mat_header_cell_5_Template, 2, 0, "mat-header-cell", 27)(6, InventoryCheckComponent_Conditional_53_mat_cell_6_Template, 3, 5, "mat-cell", 28);
    \u0275\u0275text(7, " \u0E23\u0E2B\u0E31\u0E2A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C ");
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(8, 30);
    \u0275\u0275template(9, InventoryCheckComponent_Conditional_53_mat_header_cell_9_Template, 2, 0, "mat-header-cell", 27)(10, InventoryCheckComponent_Conditional_53_mat_cell_10_Template, 2, 1, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(11, 31);
    \u0275\u0275template(12, InventoryCheckComponent_Conditional_53_mat_header_cell_12_Template, 2, 0, "mat-header-cell", 27)(13, InventoryCheckComponent_Conditional_53_mat_cell_13_Template, 2, 1, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(14, 32);
    \u0275\u0275template(15, InventoryCheckComponent_Conditional_53_mat_header_cell_15_Template, 2, 0, "mat-header-cell", 27)(16, InventoryCheckComponent_Conditional_53_mat_cell_16_Template, 2, 1, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(17, 33);
    \u0275\u0275template(18, InventoryCheckComponent_Conditional_53_mat_header_cell_18_Template, 2, 0, "mat-header-cell", 27)(19, InventoryCheckComponent_Conditional_53_mat_cell_19_Template, 2, 1, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(20, 34);
    \u0275\u0275template(21, InventoryCheckComponent_Conditional_53_mat_header_cell_21_Template, 2, 0, "mat-header-cell", 27)(22, InventoryCheckComponent_Conditional_53_mat_cell_22_Template, 2, 1, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(23, 35);
    \u0275\u0275template(24, InventoryCheckComponent_Conditional_53_mat_header_cell_24_Template, 2, 0, "mat-header-cell", 27)(25, InventoryCheckComponent_Conditional_53_mat_cell_25_Template, 3, 3, "mat-cell", 28);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(26, InventoryCheckComponent_Conditional_53_Conditional_26_Template, 3, 0, "ng-container", 36)(27, InventoryCheckComponent_Conditional_53_mat_header_row_27_Template, 1, 0, "mat-header-row", 37)(28, InventoryCheckComponent_Conditional_53_mat_row_28_Template, 1, 0, "mat-row", 38);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("dataSource", ctx_r3.dataSource);
    \u0275\u0275advance(26);
    \u0275\u0275conditional(26, ctx_r3.isAdmin ? 26 : -1);
    \u0275\u0275advance();
    \u0275\u0275property("matHeaderRowDef", ctx_r3.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r3.displayedColumns);
  }
}
function InventoryCheckComponent_Conditional_54_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 44);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "list");
  }
}
var _InventoryCheckComponent = class _InventoryCheckComponent {
  constructor() {
    this.formBuilder = inject(FormBuilder);
    this.inventoryCheckService = inject(InventoryCheckService);
    this.inventoryCheckApiService = inject(InventoryCheckApiService);
    this.categoryService = inject(CategoryService);
    this.statusService = inject(StatusService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.profileService = inject(ProfileService);
    this.subscription = new Subscription();
    this.datePipe = inject(DatePipe);
    this.imageUrl = environment.imageUrl;
    this.isAdmin = this.profileService.isAdmin();
    this.filter = {
      categories: this.categoryService.getActiveNames(),
      statuses: this.statusService.getActiveNames()
    };
    this.form = this.initForm();
    this.title = "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23 \u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C";
    this.sweetAlertTitle = "";
    this.years = [];
    this.selectYear = new FormControl(null);
    this.isLoading = false;
    this.displayedColumns = [
      "no",
      "image",
      "code",
      "year",
      "category",
      "status",
      "location",
      "description"
    ];
    this.dataSource = new MatTableDataSource([]);
  }
  ngOnInit() {
    if (this.isAdmin)
      this.displayedColumns.push("action");
    this.initDataSource();
    this.initSubscriptions();
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onSearch() {
    const isYear = this.years.includes(this.selectYear.value);
    if (!isYear)
      return;
    const year = +this.selectYear.value - 543;
    this.isLoading = true;
    this.inventoryCheckApiService.getByYear(year).pipe(finalize(() => this.isLoading = false)).subscribe();
  }
  setFilter() {
    this.form.setValue({ category: [], status: [] });
  }
  onFilter() {
    const inventories = this.inventoryCheckService.getTableData();
    const filters = this.form.value;
    this.dataSource.data = Object.keys(filters).reduce((result, keyName) => result.filter((item) => {
      if (filters[keyName].length === 0)
        return result;
      return filters[keyName].includes(item[keyName]);
    }), inventories).map((inventory, i3) => __spreadProps(__spreadValues({}, inventory), { no: i3 + 1 }));
  }
  onResetFilter() {
    this.filterInput.nativeElement.value = "";
    this.dataSource.filter = "";
    this.setFilter();
    this.onFilter();
  }
  onConfirm(id, title) {
    this.id = id;
    this.sweetAlertTitle = `\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E1A\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E23\u0E38\u0E20\u0E31\u0E13\u0E11\u0E4C
${title}?`;
    this.sweetAlert.alert(this.sweetAlertTitle);
  }
  onDelete(confirm2) {
    if (!confirm2)
      return;
    this.inventoryCheckApiService.delete(this.id).subscribe((res) => this.toastService.info("Info", res.message));
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  get category() {
    return this.form.controls["category"];
  }
  get status() {
    return this.form.controls["status"];
  }
  initForm() {
    return this.formBuilder.group({
      category: this.formBuilder.control([]),
      status: this.formBuilder.control([])
    });
  }
  _filter(value2) {
    const filterValue = value2.toLowerCase();
    return this.years.filter((option) => option.toLowerCase().includes(filterValue));
  }
  initDataSource() {
    const startYear = 2567;
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear() + 543;
    const futureYear = currentYear + 20;
    for (let i3 = startYear; i3 <= futureYear; i3++) {
      this.years.push(i3.toString());
    }
    this.filteredOptions = this.selectYear.valueChanges.pipe(startWith(""), map((value2) => this._filter(value2 || "")));
    this.dataSource.data = this.inventoryCheckService.getTableData();
    if (!this.validationService.isEmpty(this.dataSource.data)) {
      this.initPaginatorAndSort();
    }
  }
  initPaginatorAndSort() {
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
      this.dataSource.sort.sort({
        id: "no",
        start: "desc",
        disableClear: true
      });
    });
  }
  initSubscriptions() {
    this.subscription.add(this.inventoryCheckService.onListener().subscribe(() => {
      this.dataSource.data = this.inventoryCheckService.getTableData();
      this.initPaginatorAndSort();
    }));
    this.subscription.add(this.categoryService.onListener().subscribe(() => {
      this.filter.categories = this.categoryService.getActiveNames();
    }));
    this.subscription.add(this.statusService.onListener().subscribe(() => {
      this.filter.statuses = this.statusService.getActiveNames();
    }));
  }
};
_InventoryCheckComponent.\u0275fac = function InventoryCheckComponent_Factory(t2) {
  return new (t2 || _InventoryCheckComponent)();
};
_InventoryCheckComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InventoryCheckComponent, selectors: [["app-inventory-check"]], viewQuery: function InventoryCheckComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(SweetAlertComponent, 5);
    \u0275\u0275viewQuery(_c020, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sweetAlert = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.filterInput = _t2.first);
  }
}, decls: 57, vars: 17, consts: [["auto", "matAutocomplete"], ["filterInput", ""], [1, "mb-20", "mat-elevation-z8"], [3, "ngSubmit"], [1, "w-100"], ["type", "text", "matInput", "", 3, "formControl", "matAutocomplete"], ["autoActiveFirstOption", ""], [3, "value"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click", 4, "ngIf"], ["type", "submit", "matSuffix", "", "mat-icon-button", ""], ["matSuffix", "", "fontIcon", "search"], ["type", "button", "mat-raised-button", "", "color", "primary", 3, "click", "disabled"], ["mode", "indeterminate"], [1, "mat-elevation-z8"], [1, "mb-16", "d-flex", "justify-between", "align-center"], ["type", "button", "mat-button", "", "color", "warn", 3, "click"], [1, "filter-box", 3, "formGroup"], ["formControlName", "category", "multiple", ""], [1, "additional-selection"], ["formControlName", "status", "multiple", ""], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], [3, "confirm", "icon"], ["type", "button", "matSuffix", "", "mat-icon-button", "", "color", "primary", 3, "click"], [3, "click", "value"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "image"], ["matColumnDef", "code"], ["matColumnDef", "year"], ["matColumnDef", "category"], ["matColumnDef", "status"], ["matColumnDef", "location"], ["matColumnDef", "description"], ["matColumnDef", "action"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["mat-sort-header", ""], [1, "blurred-img", 3, "routerLink"], [3, "defaultImage", "lazyLoad"], [4, "matHeaderCellDef"], ["mat-icon-button", "", "color", "warn", 3, "click"], [3, "form"]], template: function InventoryCheckComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 2)(1, "mat-card-content")(2, "form", 3);
    \u0275\u0275listener("ngSubmit", function InventoryCheckComponent_Template_form_ngSubmit_2_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearch());
    });
    \u0275\u0275elementStart(3, "mat-form-field", 4)(4, "mat-label");
    \u0275\u0275text(5, "\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E1B\u0E35");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "input", 5);
    \u0275\u0275elementStart(7, "mat-autocomplete", 6, 0);
    \u0275\u0275repeaterCreate(9, InventoryCheckComponent_For_10_Template, 2, 2, "mat-option", 7, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275pipe(11, "async");
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, InventoryCheckComponent_button_12_Template, 3, 0, "button", 8);
    \u0275\u0275elementStart(13, "button", 9);
    \u0275\u0275element(14, "mat-icon", 10);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(15, "mat-card-actions")(16, "button", 11);
    \u0275\u0275listener("click", function InventoryCheckComponent_Template_button_click_16_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSearch());
    });
    \u0275\u0275elementStart(17, "mat-icon");
    \u0275\u0275text(18, "search");
    \u0275\u0275elementEnd();
    \u0275\u0275text(19, " \u0E04\u0E49\u0E19\u0E2B\u0E32 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "mat-card-footer");
    \u0275\u0275template(21, InventoryCheckComponent_Conditional_21_Template, 1, 0, "mat-progress-bar", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "mat-card", 13)(23, "mat-card-header", 14)(24, "mat-card-title");
    \u0275\u0275text(25);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "button", 15);
    \u0275\u0275listener("click", function InventoryCheckComponent_Template_button_click_26_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onResetFilter());
    });
    \u0275\u0275text(27, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "mat-card-content")(29, "form", 16)(30, "mat-form-field")(31, "mat-label");
    \u0275\u0275text(32, "\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "mat-select", 17)(34, "mat-select-trigger");
    \u0275\u0275text(35);
    \u0275\u0275template(36, InventoryCheckComponent_Conditional_36_Template, 2, 1, "span", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(37, InventoryCheckComponent_For_38_Template, 2, 2, "mat-option", 7, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(39, "mat-form-field")(40, "mat-label");
    \u0275\u0275text(41, "\u0E2A\u0E16\u0E32\u0E19\u0E30");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(42, "mat-select", 19)(43, "mat-select-trigger");
    \u0275\u0275text(44);
    \u0275\u0275template(45, InventoryCheckComponent_Conditional_45_Template, 2, 1, "span", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(46, InventoryCheckComponent_For_47_Template, 2, 2, "mat-option", 7, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(48, "mat-form-field")(49, "mat-label");
    \u0275\u0275text(50, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(51, "input", 20, 1);
    \u0275\u0275listener("keyup", function InventoryCheckComponent_Template_input_keyup_51_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.applyFilter($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(53, InventoryCheckComponent_Conditional_53_Template, 29, 4, "mat-table", 21)(54, InventoryCheckComponent_Conditional_54_Template, 1, 1);
    \u0275\u0275element(55, "mat-paginator", 22);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(56, "app-sweet-alert", 23);
    \u0275\u0275listener("confirm", function InventoryCheckComponent_Template_app_sweet_alert_confirm_56_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onDelete($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const auto_r19 = \u0275\u0275reference(8);
    \u0275\u0275advance(6);
    \u0275\u0275property("formControl", ctx.selectYear)("matAutocomplete", auto_r19);
    \u0275\u0275advance(3);
    \u0275\u0275repeater(\u0275\u0275pipeBind1(11, 14, ctx.filteredOptions));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.selectYear.value);
    \u0275\u0275advance(4);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(5);
    \u0275\u0275conditional(21, ctx.isLoading ? 21 : -1);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1(" ", (ctx.category.value == null ? null : ctx.category.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(36, ((ctx.category.value == null ? null : ctx.category.value.length) || 0) > 1 ? 36 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx.filter.categories);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1(" ", (ctx.status.value == null ? null : ctx.status.value[0]) || "", " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(45, ((ctx.status.value == null ? null : ctx.status.value.length) || 0) > 1 ? 45 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx.filter.statuses);
    \u0275\u0275advance(7);
    \u0275\u0275conditional(53, !ctx.isLoading ? 53 : 54);
    \u0275\u0275advance(2);
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(16, _c112));
    \u0275\u0275advance();
    \u0275\u0275property("icon", "error");
  }
}, dependencies: [RouterLink, NgIf, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormControlDirective, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatCard, MatCardActions, MatCardContent, MatCardFooter, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatSuffix, MatProgressBar, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader, MatSelect, MatSelectTrigger, MatOption, MatAutocomplete, MatAutocompleteTrigger, LazyLoadImageDirective, LoadingDataComponent, SweetAlertComponent, NgForm, AsyncPipe, CutDetailPipe], styles: ["\n\n.search[_ngcontent-%COMP%] {\n  margin: 10px 0;\n}\n.search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n  padding: 16px;\n  font-size: 16px;\n  line-height: 20px;\n  color: #000;\n  box-sizing: border-box;\n  border-bottom: 1px solid #ff9800;\n}\n.dark-theme[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .dark-theme   [_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n  padding: 8px 10px;\n  color: #fff;\n  box-sizing: border-box;\n}\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-image[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  padding-block: 8px;\n}\n.mat-column-code[_ngcontent-%COMP%] {\n  flex: 0 0 140px;\n}\n.mat-column-year[_ngcontent-%COMP%] {\n  flex: 0 0 100px;\n}\n.mat-column-category[_ngcontent-%COMP%] {\n  flex: 0 0 150px;\n}\n.mat-column-status[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-location[_ngcontent-%COMP%] {\n  flex: 0 0 100px;\n}\n.mat-column-description[_ngcontent-%COMP%] {\n  min-width: 200px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  flex: 0 0 100px;\n}\nimg[_ngcontent-%COMP%] {\n  width: 100%;\n  height: 100%;\n}\nmat-row[_ngcontent-%COMP%]:hover {\n  background-color: #f5f5f5;\n  transition: 0.2s;\n}\n.dark-theme[_nghost-%COMP%]   mat-row[_ngcontent-%COMP%]:hover, .dark-theme   [_nghost-%COMP%]   mat-row[_ngcontent-%COMP%]:hover {\n  background-color: #343434;\n}\n.filter-box[_ngcontent-%COMP%] {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-between;\n  gap: 10px;\n}\n.filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n  flex: 1 1 calc(25% - 10px);\n  min-width: 150px;\n}\n.filter-box[_ngcontent-%COMP%]   .additional-selection[_ngcontent-%COMP%] {\n  opacity: 0.75;\n  font-size: 0.75em;\n}\n@media (max-width: 968px) {\n  .filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n    flex: 1 1 calc(50% - 10px);\n  }\n}\n@media (min-width: 599px) {\n  .filter-box[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%] {\n    flex: 1 1 calc(25% - 10px);\n  }\n}\n/*# sourceMappingURL=inventory-check.component.css.map */"] });
var InventoryCheckComponent = _InventoryCheckComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InventoryCheckComponent, { className: "InventoryCheckComponent", filePath: "src\\app\\modules\\dashboard\\components\\inventory-check\\inventory-check.component.ts", lineNumber: 46 });
})();

// src/app/modules/dashboard/constants/location.constant.ts
var LOCATION = {
  validationField: {
    name: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E17\u0E35\u0E48" },
    active: { required: "\u0E01\u0E23\u0E38\u0E13\u0E32\u0E23\u0E30\u0E1A\u0E38 \u0E2A\u0E16\u0E32\u0E19\u0E30\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19" }
  }
};

// src/app/modules/dashboard/components/location/location-edit/location-edit.component.ts
var _c021 = ["formDirec"];
var _c113 = ["nameInput"];
function LocationEditComponent_Conditional_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-progress-bar", 15);
  }
}
var _LocationEditComponent = class _LocationEditComponent {
  constructor() {
    this.data = inject(MAT_DIALOG_DATA);
    this.formBuilder = inject(FormBuilder);
    this.dialogRef = inject(MatDialogRef);
    this.locationApiService = inject(LocationApiService);
    this.toastService = inject(ToastNotificationService);
    this.title = "\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E2B\u0E49\u0E2D\u0E07";
    this.isEdit = false;
    this.isLoading = false;
    this.validationField = LOCATION.validationField;
    this.form = this.initForm();
  }
  ngOnInit() {
    if (this.data) {
      this.title = "\u0E41\u0E01\u0E49\u0E44\u0E02\u0E2B\u0E49\u0E2D\u0E07";
      this.isEdit = true;
      this.form.patchValue(this.data);
    }
    this.dialogRef.keydownEvents().subscribe((event) => event.key === "Escape" && this.onCloseDialog());
    this.dialogRef.backdropClick().subscribe(() => this.onCloseDialog());
  }
  onSubmit() {
    if (this.form.invalid)
      return;
    if (JSON.stringify(this.data) === JSON.stringify(this.form.value))
      return;
    const _a2 = __spreadValues({}, this.form.getRawValue()), { id } = _a2, payload = __objRest(_a2, ["id"]);
    this.isLoading = true;
    this.operation$ = this.isEdit ? this.locationApiService.update(id, payload) : this.locationApiService.create(payload);
    this.operation$.pipe(catchError((error) => {
      if (error.status === 0)
        this.dialogRef.close();
      return throwError(() => error);
    }), finalize(() => this.isLoading = false)).subscribe((res) => {
      if (this.isEdit)
        this.dialogRef.close();
      else
        this.onReset();
      this.toastService.success("Success", res.message);
    });
  }
  onReset() {
    if (this.isEdit)
      this.form.patchValue(this.data);
    else
      this.formDirec.resetForm();
    this.nameInput.nativeElement.focus();
  }
  newDialogBackdropHandler() {
    const isChange = this.name.value !== "" || this.remark.value !== "";
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  editDialogBackdropHandler() {
    const isChange = this.name.value !== this.data.name || this.active.value !== this.data.active || this.remark.value !== this.data.remark;
    if (isChange)
      return this.confirmDialogBackdropHandler();
    this.dialogRef.close();
  }
  confirmDialogBackdropHandler() {
    const confirmation = confirm("\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E22\u0E01\u0E40\u0E25\u0E34\u0E01\u0E01\u0E32\u0E23\u0E41\u0E01\u0E49\u0E44\u0E02\u0E41\u0E25\u0E30\u0E2D\u0E2D\u0E01\u0E08\u0E32\u0E01\u0E1F\u0E2D\u0E23\u0E4C\u0E21\u0E2B\u0E23\u0E37\u0E2D\u0E44\u0E21\u0E48?");
    if (confirmation)
      this.dialogRef.close();
  }
  onCloseDialog() {
    if (this.isEdit)
      this.editDialogBackdropHandler();
    else
      this.newDialogBackdropHandler();
  }
  get name() {
    return this.form.controls["name"];
  }
  get active() {
    return this.form.controls["active"];
  }
  get remark() {
    return this.form.controls["remark"];
  }
  initForm() {
    return this.formBuilder.nonNullable.group({
      id: [null],
      name: ["", [Validators.required]],
      active: [true, [Validators.required]],
      remark: [""]
    });
  }
};
_LocationEditComponent.\u0275fac = function LocationEditComponent_Factory(t2) {
  return new (t2 || _LocationEditComponent)();
};
_LocationEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LocationEditComponent, selectors: [["app-location-edit"]], viewQuery: function LocationEditComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(_c021, 5);
    \u0275\u0275viewQuery(_c113, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.formDirec = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.nameInput = _t2.first);
  }
}, decls: 33, vars: 7, consts: [["formDirec", "ngForm"], ["nameInput", ""], [1, "d-flex", "justify-between", "align-center"], ["mat-dialog-title", ""], ["mat-icon-button", "", "tabindex", "-1", 1, "btn-close", 3, "click"], [3, "ngSubmit", "formGroup"], [1, "form-container"], [1, "box"], ["type", "text", "matInput", "", "formControlName", "name"], [3, "control", "errorMessage"], ["type", "text", "matInput", "", "formControlName", "remark"], [1, "d-flex", "gap-10"], ["formControlName", "active"], ["type", "submit", "mat-raised-button", "", "color", "primary", 3, "disabled"], ["type", "button", "mat-button", "", "color", "warn", 3, "click", "disabled"], ["mode", "indeterminate"]], template: function LocationEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "h2", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "button", 4);
    \u0275\u0275listener("click", function LocationEditComponent_Template_button_click_3_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onCloseDialog());
    });
    \u0275\u0275elementStart(4, "mat-icon");
    \u0275\u0275text(5, "close");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(6, "form", 5, 0);
    \u0275\u0275listener("ngSubmit", function LocationEditComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onSubmit());
    });
    \u0275\u0275element(8, "mat-divider");
    \u0275\u0275elementStart(9, "mat-dialog-content", 6)(10, "div", 7)(11, "mat-form-field")(12, "mat-label");
    \u0275\u0275text(13, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "input", 8, 1);
    \u0275\u0275elementStart(16, "mat-error");
    \u0275\u0275element(17, "app-error-field", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "mat-form-field")(19, "mat-label");
    \u0275\u0275text(20, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
    \u0275\u0275element(21, "input", 10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 11);
    \u0275\u0275element(23, "mat-slide-toggle", 12);
    \u0275\u0275elementStart(24, "span");
    \u0275\u0275text(25, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E0A\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(26, "mat-divider");
    \u0275\u0275elementStart(27, "mat-dialog-actions")(28, "button", 13);
    \u0275\u0275text(29, " \u0E15\u0E01\u0E25\u0E07 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "button", 14);
    \u0275\u0275listener("click", function LocationEditComponent_Template_button_click_30_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.onReset());
    });
    \u0275\u0275text(31, " \u0E23\u0E35\u0E40\u0E0B\u0E47\u0E15 ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(32, LocationEditComponent_Conditional_32_Template, 1, 0, "mat-progress-bar", 15);
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.title);
    \u0275\u0275advance(4);
    \u0275\u0275property("formGroup", ctx.form);
    \u0275\u0275advance(11);
    \u0275\u0275property("control", ctx.name)("errorMessage", ctx.validationField.name);
    \u0275\u0275advance(11);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", ctx.isLoading);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(32, ctx.isLoading ? 32 : -1);
  }
}, dependencies: [\u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, FormGroupDirective, FormControlName, MatButton, MatIconButton, MatIcon, MatDivider, MatInput, MatFormField, MatLabel, MatError, MatProgressBar, MatSlideToggle, MatDialogTitle, MatDialogActions, MatDialogContent, ErrorFieldComponent] });
var LocationEditComponent = _LocationEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LocationEditComponent, { className: "LocationEditComponent", filePath: "src\\app\\modules\\dashboard\\components\\location\\location-edit\\location-edit.component.ts", lineNumber: 27 });
})();

// src/app/modules/dashboard/components/location/location.component.ts
var LocationComponent_Defer_5_DepsFn = () => [MatIconButton, MatIcon, MatCard, MatCardContent, MatCardHeader, MatCardTitle, MatInput, MatFormField, MatLabel, MatTable, MatHeaderCellDef, MatHeaderRowDef, MatColumnDef, MatCellDef, MatRowDef, MatHeaderCell, MatCell, MatHeaderRow, MatRow, MatPaginator, MatSort, MatSortHeader];
var _c022 = () => [10, 25, 50, 100];
function LocationComponent_Defer_3_mat_header_cell_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "No.");
    \u0275\u0275elementEnd();
  }
}
function LocationComponent_Defer_3_mat_cell_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r3.no, " ");
  }
}
function LocationComponent_Defer_3_mat_header_cell_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E0A\u0E37\u0E48\u0E2D");
    \u0275\u0275elementEnd();
  }
}
function LocationComponent_Defer_3_mat_cell_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r4.name, " ");
  }
}
function LocationComponent_Defer_3_mat_header_cell_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E40\u0E1B\u0E34\u0E14\u0E43\u0E02\u0E49\u0E07\u0E32\u0E19");
    \u0275\u0275elementEnd();
  }
}
function LocationComponent_Defer_3_mat_cell_18_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 20);
    \u0275\u0275text(1, "toggle_on");
    \u0275\u0275elementEnd();
  }
}
function LocationComponent_Defer_3_mat_cell_18_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 21);
    \u0275\u0275text(1, "toggle_off");
    \u0275\u0275elementEnd();
  }
}
function LocationComponent_Defer_3_mat_cell_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275template(1, LocationComponent_Defer_3_mat_cell_18_Conditional_1_Template, 2, 0, "mat-icon", 20)(2, LocationComponent_Defer_3_mat_cell_18_Conditional_2_Template, 2, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(1, element_r5.active ? 1 : 2);
  }
}
function LocationComponent_Defer_3_mat_header_cell_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-header-cell", 19);
    \u0275\u0275text(1, "\u0E2B\u0E21\u0E32\u0E22\u0E40\u0E2B\u0E15\u0E38");
    \u0275\u0275elementEnd();
  }
}
function LocationComponent_Defer_3_mat_cell_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-cell");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const element_r6 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", element_r6.remark, " ");
  }
}
function LocationComponent_Defer_3_mat_header_cell_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-cell");
  }
}
function LocationComponent_Defer_3_mat_cell_24_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-cell")(1, "button", 22);
    \u0275\u0275listener("click", function LocationComponent_Defer_3_mat_cell_24_Template_button_click_1_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onUpdate(element_r8));
    });
    \u0275\u0275elementStart(2, "mat-icon", 23);
    \u0275\u0275text(3, "edit");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "button", 24);
    \u0275\u0275listener("click", function LocationComponent_Defer_3_mat_cell_24_Template_button_click_4_listener() {
      const element_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onConfirm(element_r8.id, element_r8.name));
    });
    \u0275\u0275elementStart(5, "mat-icon");
    \u0275\u0275text(6, "delete");
    \u0275\u0275elementEnd()()();
  }
}
function LocationComponent_Defer_3_mat_header_row_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-header-row");
  }
}
function LocationComponent_Defer_3_mat_row_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "mat-row");
  }
}
function LocationComponent_Defer_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "mat-card", 3)(1, "mat-card-header", 4)(2, "mat-card-title");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "mat-card-content")(5, "mat-form-field", 5)(6, "mat-label");
    \u0275\u0275text(7, "\u0E01\u0E23\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "input", 6);
    \u0275\u0275listener("keyup", function LocationComponent_Defer_3_Template_input_keyup_8_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.applyFilter($event));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "mat-table", 7);
    \u0275\u0275elementContainerStart(10, 8);
    \u0275\u0275template(11, LocationComponent_Defer_3_mat_header_cell_11_Template, 2, 0, "mat-header-cell", 9)(12, LocationComponent_Defer_3_mat_cell_12_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(13, 11);
    \u0275\u0275template(14, LocationComponent_Defer_3_mat_header_cell_14_Template, 2, 0, "mat-header-cell", 9)(15, LocationComponent_Defer_3_mat_cell_15_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(16, 12);
    \u0275\u0275template(17, LocationComponent_Defer_3_mat_header_cell_17_Template, 2, 0, "mat-header-cell", 9)(18, LocationComponent_Defer_3_mat_cell_18_Template, 3, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(19, 13);
    \u0275\u0275template(20, LocationComponent_Defer_3_mat_header_cell_20_Template, 2, 0, "mat-header-cell", 9)(21, LocationComponent_Defer_3_mat_cell_21_Template, 2, 1, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementContainerStart(22, 14);
    \u0275\u0275template(23, LocationComponent_Defer_3_mat_header_cell_23_Template, 1, 0, "mat-header-cell", 15)(24, LocationComponent_Defer_3_mat_cell_24_Template, 7, 0, "mat-cell", 10);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275template(25, LocationComponent_Defer_3_mat_header_row_25_Template, 1, 0, "mat-header-row", 16)(26, LocationComponent_Defer_3_mat_row_26_Template, 1, 0, "mat-row", 17);
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "mat-paginator", 18);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.title);
    \u0275\u0275advance(6);
    \u0275\u0275property("dataSource", ctx_r1.dataSource);
    \u0275\u0275advance(16);
    \u0275\u0275property("matHeaderRowDef", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("matRowDefColumns", ctx_r1.displayedColumns);
    \u0275\u0275advance();
    \u0275\u0275property("pageSizeOptions", \u0275\u0275pureFunction0(5, _c022));
  }
}
function LocationComponent_DeferPlaceholder_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-loading-data", 25);
  }
  if (rf & 2) {
    \u0275\u0275property("form", "card");
  }
}
var _LocationComponent = class _LocationComponent {
  constructor() {
    this.locationService = inject(LocationService);
    this.locationApiService = inject(LocationApiService);
    this.validationService = inject(ValidationService);
    this.toastService = inject(ToastNotificationService);
    this.dialog = inject(MatDialog);
    this.subscription = new Subscription();
    this.title = "\u0E23\u0E32\u0E22\u0E0A\u0E37\u0E48\u0E2D\u0E2B\u0E49\u0E2D\u0E07";
    this.displayedColumns = ["no", "name", "active", "remark", "action"];
    this.dataSource = new MatTableDataSource([]);
    this.isFirstLoading = false;
  }
  ngOnInit() {
    this.initDataSource();
    this.subscription = this.locationService.onListener().subscribe(() => this.dataSource.data = this.locationService.getTableData());
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onCreate() {
    this.dialog.open(LocationEditComponent, {
      width: "500px",
      disableClose: true
    });
  }
  onUpdate(item) {
    this.dialog.open(LocationEditComponent, {
      data: item,
      width: "500px",
      disableClose: true
    });
  }
  onConfirm(id, title) {
    this.id = id;
    this.sweetAlertTitle = `\u0E22\u0E37\u0E19\u0E22\u0E31\u0E19\u0E01\u0E32\u0E23\u0E25\u0E1A ${title}?`;
    this.sweetAlert.alert(this.sweetAlertTitle);
  }
  onDelete(confirm2) {
    if (!confirm2)
      return;
    this.locationApiService.delete(this.id).subscribe((res) => this.toastService.info("Info", res.message));
  }
  applyFilter(event) {
    const filterValue = event.target.value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }
  initDataSource() {
    this.dataSource.data = this.locationService.getTableData();
    if (this.validationService.isEmpty(this.dataSource.data))
      this.locationApiService.getAll().pipe(finalize(() => this.isFirstLoading = true)).subscribe();
    defer(() => this.paginator && this.sort ? of(null) : interval(300).pipe(filter(() => !!this.paginator && !!this.sort), take(1))).subscribe(() => {
      this.dataSource.paginator = this.paginator;
      this.dataSource.sort = this.sort;
    });
  }
};
_LocationComponent.\u0275fac = function LocationComponent_Factory(t2) {
  return new (t2 || _LocationComponent)();
};
_LocationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LocationComponent, selectors: [["app-location"]], viewQuery: function LocationComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuery(MatPaginator, 5);
    \u0275\u0275viewQuery(MatSort, 5);
    \u0275\u0275viewQuery(SweetAlertComponent, 5);
  }
  if (rf & 2) {
    let _t2;
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.paginator = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sort = _t2.first);
    \u0275\u0275queryRefresh(_t2 = \u0275\u0275loadQuery()) && (ctx.sweetAlert = _t2.first);
  }
}, decls: 8, vars: 2, consts: [[300], ["mat-fab", "", "color", "primary", 1, "mb-20", 3, "click"], [3, "confirm", "icon"], [1, "mat-elevation-z8"], [1, "mb-16"], [1, "w-100"], ["matInput", "", 3, "keyup"], ["matSort", "", 3, "dataSource"], ["matColumnDef", "no"], ["mat-sort-header", "", 4, "matHeaderCellDef"], [4, "matCellDef"], ["matColumnDef", "name"], ["matColumnDef", "active"], ["matColumnDef", "remark"], ["matColumnDef", "action"], [4, "matHeaderCellDef"], [4, "matHeaderRowDef"], [4, "matRowDef", "matRowDefColumns"], ["showFirstLastButtons", "", 3, "pageSizeOptions"], ["mat-sort-header", ""], [1, "toggle-on"], [1, "toggle-off"], ["mat-icon-button", "", 3, "click"], ["color", "accent"], ["mat-icon-button", "", "color", "warn", 3, "click"], [3, "form"]], template: function LocationComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 1);
    \u0275\u0275listener("click", function LocationComponent_Template_button_click_0_listener() {
      return ctx.onCreate();
    });
    \u0275\u0275elementStart(1, "mat-icon");
    \u0275\u0275text(2, "add");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(3, LocationComponent_Defer_3_Template, 28, 6)(4, LocationComponent_DeferPlaceholder_4_Template, 1, 1);
    \u0275\u0275defer(5, 3, LocationComponent_Defer_5_DepsFn, null, 4, null, null, 0, \u0275\u0275deferEnableTimerScheduling);
    \u0275\u0275elementStart(7, "app-sweet-alert", 2);
    \u0275\u0275listener("confirm", function LocationComponent_Template_app_sweet_alert_confirm_7_listener($event) {
      return ctx.onDelete($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(5);
    \u0275\u0275deferWhen(ctx.dataSource.data.length > 0 || ctx.isFirstLoading);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", "error");
  }
}, dependencies: [MatFabButton, MatIcon, LoadingDataComponent, SweetAlertComponent], styles: ["\n\n.mat-column-no[_ngcontent-%COMP%] {\n  flex: 0 0 70px;\n}\n.mat-column-name[_ngcontent-%COMP%] {\n  min-width: 120px;\n}\n.mat-column-active[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n}\n.mat-column-remark[_ngcontent-%COMP%] {\n  min-width: 150px;\n}\n.mat-column-action[_ngcontent-%COMP%] {\n  flex: 0 0 120px;\n  justify-content: center;\n}\n/*# sourceMappingURL=table-styles.css.map */"] });
var LocationComponent = _LocationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LocationComponent, { className: "LocationComponent", filePath: "src\\app\\modules\\dashboard\\components\\location\\location.component.ts", lineNumber: 31 });
})();

// src/app/modules/dashboard/dashboard.routes.ts
var routes = [
  {
    path: "",
    component: DashboardComponent,
    canActivateChild: [dashboardGuard],
    resolve: [dashboardResolver],
    children: [
      { path: "", redirectTo: "scan", pathMatch: "full" },
      { path: "scan", component: ScanComponent },
      {
        path: "inventory",
        component: InventoryComponent,
        children: [
          { path: "", component: InventoryListComponent },
          { path: "new", component: InventoryNewComponent },
          { path: "view/:id", component: InventoryViewComponent },
          { path: "edit/:id", component: InventoryEditComponent }
        ]
      },
      {
        path: "print",
        component: PrintComponent,
        children: [
          { path: "", component: PrintListComponent },
          { path: "process/:print", component: PrintProcessComponent }
        ]
      },
      {
        path: "log",
        component: LogComponent,
        children: [
          { path: "", component: LogListComponent },
          { path: "view/:id", component: LogViewComponent }
        ]
      },
      {
        path: "inventory-check",
        component: InventoryCheckComponent
      },
      { path: "profile", component: ProfileComponent },
      { path: "password", component: PasswordComponent },
      {
        path: "setting",
        canActivateChild: [adminGuard],
        children: [
          { path: "", redirectTo: "user", pathMatch: "full" },
          { path: "user", component: UserComponent },
          { path: "category", component: CategoryComponent },
          { path: "status", component: StatusComponent },
          { path: "fund", component: FundComponent },
          { path: "location", component: LocationComponent }
        ]
      }
    ]
  }
];
var _DashboardRoutingModule = class _DashboardRoutingModule {
};
_DashboardRoutingModule.\u0275fac = function DashboardRoutingModule_Factory(t2) {
  return new (t2 || _DashboardRoutingModule)();
};
_DashboardRoutingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _DashboardRoutingModule });
_DashboardRoutingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [RouterModule.forChild(routes), RouterModule] });
var DashboardRoutingModule = _DashboardRoutingModule;

// src/app/modules/dashboard/pipes/search.pipe.ts
var _SearchPipe = class _SearchPipe {
  transform(value2, searchText) {
    if (!value2 || !value2.length)
      return value2;
    if (!searchText || !searchText.length)
      return value2;
    return value2.filter((item) => {
      return item.toString().toLowerCase().indexOf(searchText.toLowerCase()) > -1;
    });
  }
};
_SearchPipe.\u0275fac = function SearchPipe_Factory(t2) {
  return new (t2 || _SearchPipe)();
};
_SearchPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "search", type: _SearchPipe, pure: true });
var SearchPipe = _SearchPipe;

// src/app/modules/dashboard/dashboard.module.ts
var _DashboardModule = class _DashboardModule {
};
_DashboardModule.\u0275fac = function DashboardModule_Factory(t2) {
  return new (t2 || _DashboardModule)();
};
_DashboardModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _DashboardModule });
_DashboardModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  DashboardRoutingModule,
  CoreModule,
  SharedModule,
  FormsModule,
  NgxBarcode6Module,
  QRCodeModule
] });
var DashboardModule = _DashboardModule;
export {
  DashboardModule
};
/*! Bundled license information:

jspdf/dist/jspdf.es.min.js:
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   *)
  (**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=chunk-J4U3D3YN.js.map
